on:
  pull_request:
  push:
    branches:
      - master
  merge_group:
  workflow_dispatch:
    inputs:
      pr_number:
        description: "Pull Request Number"
        required: false
        default: ""

name: CI

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.event.inputs.pr_number || format('sha-{0}', github.sha) }}
  cancel-in-progress: true

jobs:
  internal-tests:
    name: Internal Tests
    # Skip if not a PR or a push to master
    # Skip if this is an external contribution. GitHub secrets will be empty, so the step would fail anyway.
    if: ${{ (github.event_name == 'pull_request' || (github.event_name == 'push' && github.ref == 'refs/heads/master'))
      && (github.event_name != 'pull_request' || !github.event.pull_request.head.repo.fork) }}
    permissions:
      contents: read
    runs-on: ubuntu-latest
    env:
      TARGET_OWNER: clockworklabs
      TARGET_REPO: SpacetimeDBPrivate
    steps:
      - id: dispatch
        name: Trigger tests
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SPACETIMEDB_PRIVATE_TOKEN }}
          script: |
            const workflowId = 'ci.yml';
            const targetRef = 'bfops/smarter-internal-tests';
            const targetOwner = process.env.TARGET_OWNER;
            const targetRepo = process.env.TARGET_REPO;
            // Use the ref for pull requests because the head sha is brittle (github does some extra dance where it merges in master).
            const publicRef = (context.eventName === 'pull_request') ? context.payload.pull_request.head.ref : context.sha;
            const publicPrNumber = context.payload.pull_request?.number ?? context.payload.inputs?.pr_number;
            const preDispatch = new Date().toISOString();

            // Dispatch the workflow in the target repository
            await github.rest.actions.createWorkflowDispatch({
              owner: targetOwner,
              repo: targetRepo,
              workflow_id: workflowId,
              ref: targetRef,
              inputs: { public_ref: publicRef, public_pr_number: String(publicPrNumber) }
            });
  
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  
            // Find the dispatched run by name
            let runId = null;
            for (let attempt = 0; attempt < 20 && !runId; attempt++) { // up to ~10 minutes to locate the run
              await sleep(5000);
              const runsResp = await github.rest.actions.listWorkflowRuns({
                owner: targetOwner,
                repo: targetRepo,
                workflow_id: workflowId,
                event: 'workflow_dispatch',
                branch: targetRef,
                per_page: 50,
              });
  
              const expectedName = `CI [public_ref=${publicRef}]`;
              const candidates = runsResp.data.workflow_runs
                .filter(r => r.name === expectedName && new Date(r.created_at) >= new Date(preDispatch))
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
  
              if (candidates.length > 0) {
                runId = candidates[0].id;
                break;
              }
            }
  
            if (!runId) {
              core.setFailed('Failed to locate dispatched run in the private repository.');
              return;
            }
  
            const runUrl = `https://github.com/${targetOwner}/${targetRepo}/actions/runs/${runId}`;
            core.info(`View run: ${runUrl}`);
            core.setOutput('run_id', String(runId));
            core.setOutput('run_url', runUrl);
  
      - name: Wait for Internal Tests to complete
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SPACETIMEDB_PRIVATE_TOKEN }}
          script: |
            const targetOwner = process.env.TARGET_OWNER;
            const targetRepo = process.env.TARGET_REPO;
            const runId = Number(`${{ steps.dispatch.outputs.run_id }}`);
            const runUrl = `${{ steps.dispatch.outputs.run_url }}`;
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
  
            core.info(`Waiting for workflow result... ${runUrl}`);
  
            let conclusion = null;
            for (let attempt = 0; attempt < 240; attempt++) { // up to ~2 hours
              const runResp = await github.rest.actions.getWorkflowRun({
                owner: targetOwner,
                repo: targetRepo,
                run_id: runId
              });
              const { status, conclusion: c } = runResp.data;
              if (status === 'completed') {
                conclusion = c || 'success';
                break;
              }
              await sleep(30000);
            }
  
            if (!conclusion) {
              core.setFailed('Timed out waiting for private workflow to complete.');
              return;
            }
  
            if (conclusion !== 'success') {
              core.setFailed(`Private workflow failed with conclusion: ${conclusion}`);
            }
  
      - name: Cancel invoked run if workflow cancelled
        if: ${{ cancelled() }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SPACETIMEDB_PRIVATE_TOKEN }}
          script: |
            const targetOwner = process.env.TARGET_OWNER;
            const targetRepo = process.env.TARGET_REPO;
            const runId = Number(`${{ steps.dispatch.outputs.run_id }}`);
            if (!runId) return;
            await github.rest.actions.cancelWorkflowRun({
              owner: targetOwner,
              repo: targetRepo,
              run_id: runId,
            });

  global_json_policy:
    name: Verify global.json files are symlinks
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Find Git ref
        env:
          PR_NUMBER: ${{ github.event.inputs.pr_number }}
        run: |
          if [ -n "$PR_NUMBER" ]; then
            GIT_REF="refs/pull/$PR_NUMBER/merge"
          else
            GIT_REF="${{ github.ref }}"
          fi
          echo "GIT_REF=${GIT_REF}" >>"$GITHUB_ENV"

      - name: Checkout sources
        uses: actions/checkout@v4
        with:
          ref: ${{ env.GIT_REF }}

      - uses: dsherret/rust-toolchain-file@v1

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: ${{ github.workspace }}
          shared-key: spacetimedb
          save-if: false
          prefix-key: v1

      - name: Check global.json policy
        run: cargo ci global-json-policy

  warn-python-smoketests:
    name: Check for Python smoketest edits
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    steps:
      - name: Checkout sources
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fail if Python smoketests were modified
        run: |
          MERGE_BASE="$(git merge-base origin/${{ github.base_ref }} HEAD)"
          PYTHON_SMOKETEST_CHANGES="$(git diff --name-only "$MERGE_BASE" HEAD -- 'smoketests/**.py')"

          if [ -n "$PYTHON_SMOKETEST_CHANGES" ]; then
            echo "::error::This PR modifies legacy Python smoketests. Please add new tests to the Rust smoketests in crates/smoketests/ instead."
            echo ""
            echo "Changed files:"
            echo "$PYTHON_SMOKETEST_CHANGES"
            echo ""
            echo "The Python smoketests are being replaced by Rust smoketests."
            echo "See crates/smoketests/DEVELOP.md for instructions on adding Rust smoketests."
            exit 1
          fi

          echo "No Python smoketest changes detected."
