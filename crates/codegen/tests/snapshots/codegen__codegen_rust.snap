---
source: crates/codegen/tests/codegen.rs
expression: outfiles
---
"add_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddPlayerArgs {
    pub name: String,
}

impl From<AddPlayerArgs> for super::Reducer {
    fn from(args: AddPlayerArgs) -> Self {
        Self::AddPlayer {
            name: args.name,
}
}
}

impl __sdk::InModule for AddPlayerArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_player {
    /// Request that the remote module invoke the reducer `add_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`add_player:add_player_then`] to run a callback after the reducer completes.
    fn add_player(&self, name: String,
) -> __sdk::Result<()> {
        self.add_player_then(name,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `add_player` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn add_player_then(
        &self,
        name: String,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl add_player for super::RemoteReducers {
    fn add_player_then(
        &self,
        name: String,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(AddPlayerArgs { name,  }, callback)
    }
}

'''
"add_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddPrivateArgs {
    pub name: String,
}

impl From<AddPrivateArgs> for super::Reducer {
    fn from(args: AddPrivateArgs) -> Self {
        Self::AddPrivate {
            name: args.name,
}
}
}

impl __sdk::InModule for AddPrivateArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_private {
    /// Request that the remote module invoke the reducer `add_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`add_private:add_private_then`] to run a callback after the reducer completes.
    fn add_private(&self, name: String,
) -> __sdk::Result<()> {
        self.add_private_then(name,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `add_private` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn add_private_then(
        &self,
        name: String,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl add_private for super::RemoteReducers {
    fn add_private_then(
        &self,
        name: String,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(AddPrivateArgs { name,  }, callback)
    }
}

'''
"add_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddArgs {
    pub name: String,
    pub age: u8,
}

impl From<AddArgs> for super::Reducer {
    fn from(args: AddArgs) -> Self {
        Self::Add {
            name: args.name,
            age: args.age,
}
}
}

impl __sdk::InModule for AddArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add {
    /// Request that the remote module invoke the reducer `add` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`add:add_then`] to run a callback after the reducer completes.
    fn add(&self, name: String,
age: u8,
) -> __sdk::Result<()> {
        self.add_then(name, age,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `add` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn add_then(
        &self,
        name: String,
age: u8,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl add for super::RemoteReducers {
    fn add_then(
        &self,
        name: String,
age: u8,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(AddArgs { name, age,  }, callback)
    }
}

'''
"assert_caller_identity_is_module_identity_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AssertCallerIdentityIsModuleIdentityArgs {
    }

impl From<AssertCallerIdentityIsModuleIdentityArgs> for super::Reducer {
    fn from(args: AssertCallerIdentityIsModuleIdentityArgs) -> Self {
        Self::AssertCallerIdentityIsModuleIdentity
}
}

impl __sdk::InModule for AssertCallerIdentityIsModuleIdentityArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `assert_caller_identity_is_module_identity`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait assert_caller_identity_is_module_identity {
    /// Request that the remote module invoke the reducer `assert_caller_identity_is_module_identity` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`assert_caller_identity_is_module_identity:assert_caller_identity_is_module_identity_then`] to run a callback after the reducer completes.
    fn assert_caller_identity_is_module_identity(&self, ) -> __sdk::Result<()> {
        self.assert_caller_identity_is_module_identity_then( |_, _| {})
    }

    /// Request that the remote module invoke the reducer `assert_caller_identity_is_module_identity` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn assert_caller_identity_is_module_identity_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl assert_caller_identity_is_module_identity for super::RemoteReducers {
    fn assert_caller_identity_is_module_identity_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(AssertCallerIdentityIsModuleIdentityArgs {  }, callback)
    }
}

'''
"baz_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Baz {
    pub field: String,
}


impl __sdk::InModule for Baz {
    type Module = super::RemoteModule;
}

'''
"delete_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct DeletePlayerArgs {
    pub id: u64,
}

impl From<DeletePlayerArgs> for super::Reducer {
    fn from(args: DeletePlayerArgs) -> Self {
        Self::DeletePlayer {
            id: args.id,
}
}
}

impl __sdk::InModule for DeletePlayerArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_player {
    /// Request that the remote module invoke the reducer `delete_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`delete_player:delete_player_then`] to run a callback after the reducer completes.
    fn delete_player(&self, id: u64,
) -> __sdk::Result<()> {
        self.delete_player_then(id,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `delete_player` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn delete_player_then(
        &self,
        id: u64,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl delete_player for super::RemoteReducers {
    fn delete_player_then(
        &self,
        id: u64,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(DeletePlayerArgs { id,  }, callback)
    }
}

'''
"delete_players_by_name_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct DeletePlayersByNameArgs {
    pub name: String,
}

impl From<DeletePlayersByNameArgs> for super::Reducer {
    fn from(args: DeletePlayersByNameArgs) -> Self {
        Self::DeletePlayersByName {
            name: args.name,
}
}
}

impl __sdk::InModule for DeletePlayersByNameArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_players_by_name`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_players_by_name {
    /// Request that the remote module invoke the reducer `delete_players_by_name` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`delete_players_by_name:delete_players_by_name_then`] to run a callback after the reducer completes.
    fn delete_players_by_name(&self, name: String,
) -> __sdk::Result<()> {
        self.delete_players_by_name_then(name,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `delete_players_by_name` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn delete_players_by_name_then(
        &self,
        name: String,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl delete_players_by_name for super::RemoteReducers {
    fn delete_players_by_name_then(
        &self,
        name: String,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(DeletePlayersByNameArgs { name,  }, callback)
    }
}

'''
"foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::baz_type::Baz;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum Foobar {
    Baz(Baz),

    Bar,

    Har(u32),

}



impl __sdk::InModule for Foobar {
    type Module = super::RemoteModule;
}

'''
"get_my_schema_via_http_procedure.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
 struct GetMySchemaViaHttpArgs {
    }


impl __sdk::InModule for GetMySchemaViaHttpArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the procedure `get_my_schema_via_http`.
///
/// Implemented for [`super::RemoteProcedures`].
pub trait get_my_schema_via_http {
    fn get_my_schema_via_http(&self, ) {
        self.get_my_schema_via_http_then( |_, _| {});
    }

    fn get_my_schema_via_http_then(
        &self,
        
        __callback: impl FnOnce(&super::ProcedureEventContext, Result<String, __sdk::InternalError>) + Send + 'static,
    );
}

impl get_my_schema_via_http for super::RemoteProcedures {
    fn get_my_schema_via_http_then(
        &self,
        
        __callback: impl FnOnce(&super::ProcedureEventContext, Result<String, __sdk::InternalError>) + Send + 'static,
    ) {
        self.imp.invoke_procedure_with_callback::<_, String>(
            "get_my_schema_via_http",
            GetMySchemaViaHttpArgs {  },
            __callback,
        );
    }
}

'''
"has_special_stuff_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct HasSpecialStuff {
    pub identity: __sdk::Identity,
    pub connection_id: __sdk::ConnectionId,
}


impl __sdk::InModule for HasSpecialStuff {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `HasSpecialStuff`.
///
/// Provides typed access to columns for query building.
pub struct HasSpecialStuffCols {
    pub identity: __sdk::__query_builder::Col<HasSpecialStuff, __sdk::Identity>,
    pub connection_id: __sdk::__query_builder::Col<HasSpecialStuff, __sdk::ConnectionId>,
}

impl __sdk::__query_builder::HasCols for HasSpecialStuff {
    type Cols = HasSpecialStuffCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        HasSpecialStuffCols {
            identity: __sdk::__query_builder::Col::new(table_name, "identity"),
            connection_id: __sdk::__query_builder::Col::new(table_name, "connection_id"),

        }
    }
}

/// Indexed column accessor struct for the table `HasSpecialStuff`.
///
/// Provides typed access to indexed columns for query building.
pub struct HasSpecialStuffIxCols {
}

impl __sdk::__query_builder::HasIxCols for HasSpecialStuff {
    type IxCols = HasSpecialStuffIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        HasSpecialStuffIxCols {

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for HasSpecialStuff {}

'''
"list_over_age_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct ListOverAgeArgs {
    pub age: u8,
}

impl From<ListOverAgeArgs> for super::Reducer {
    fn from(args: ListOverAgeArgs) -> Self {
        Self::ListOverAge {
            age: args.age,
}
}
}

impl __sdk::InModule for ListOverAgeArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `list_over_age`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait list_over_age {
    /// Request that the remote module invoke the reducer `list_over_age` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`list_over_age:list_over_age_then`] to run a callback after the reducer completes.
    fn list_over_age(&self, age: u8,
) -> __sdk::Result<()> {
        self.list_over_age_then(age,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `list_over_age` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn list_over_age_then(
        &self,
        age: u8,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl list_over_age for super::RemoteReducers {
    fn list_over_age_then(
        &self,
        age: u8,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(ListOverAgeArgs { age,  }, callback)
    }
}

'''
"log_module_identity_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct LogModuleIdentityArgs {
    }

impl From<LogModuleIdentityArgs> for super::Reducer {
    fn from(args: LogModuleIdentityArgs) -> Self {
        Self::LogModuleIdentity
}
}

impl __sdk::InModule for LogModuleIdentityArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `log_module_identity`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait log_module_identity {
    /// Request that the remote module invoke the reducer `log_module_identity` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`log_module_identity:log_module_identity_then`] to run a callback after the reducer completes.
    fn log_module_identity(&self, ) -> __sdk::Result<()> {
        self.log_module_identity_then( |_, _| {})
    }

    /// Request that the remote module invoke the reducer `log_module_identity` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn log_module_identity_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl log_module_identity for super::RemoteReducers {
    fn log_module_identity_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(LogModuleIdentityArgs {  }, callback)
    }
}

'''
"logged_out_player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `logged_out_player`.
///
/// Obtain a handle from the [`LoggedOutPlayerTableAccess::logged_out_player`] method on [`super::RemoteTables`],
/// like `ctx.db.logged_out_player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.logged_out_player().on_insert(...)`.
pub struct LoggedOutPlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `logged_out_player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait LoggedOutPlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`LoggedOutPlayerTableHandle`], which mediates access to the table `logged_out_player`.
    fn logged_out_player(&self) -> LoggedOutPlayerTableHandle<'_>;
}

impl LoggedOutPlayerTableAccess for super::RemoteTables {
    fn logged_out_player(&self) -> LoggedOutPlayerTableHandle<'_> {
        LoggedOutPlayerTableHandle {
            imp: self.imp.get_table::<Player>("logged_out_player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct LoggedOutPlayerInsertCallbackId(__sdk::CallbackId);
pub struct LoggedOutPlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for LoggedOutPlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = LoggedOutPlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerInsertCallbackId {
        LoggedOutPlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: LoggedOutPlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = LoggedOutPlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerDeleteCallbackId {
        LoggedOutPlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: LoggedOutPlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

pub struct LoggedOutPlayerUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for LoggedOutPlayerTableHandle<'ctx> {
    type UpdateCallbackId = LoggedOutPlayerUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerUpdateCallbackId {
        LoggedOutPlayerUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: LoggedOutPlayerUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

        /// Access to the `identity` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerIdentityUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().identity().find(...)`.
        pub struct LoggedOutPlayerIdentityUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, __sdk::Identity>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `identity` unique index on the table `logged_out_player`.
            pub fn identity(&self) -> LoggedOutPlayerIdentityUnique<'ctx> {
                LoggedOutPlayerIdentityUnique {
                    imp: self.imp.get_unique_constraint::<__sdk::Identity>("identity"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerIdentityUnique<'ctx> {
            /// Find the subscribed row whose `identity` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &__sdk::Identity) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `player_id` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerPlayerIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().player_id().find(...)`.
        pub struct LoggedOutPlayerPlayerIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `player_id` unique index on the table `logged_out_player`.
            pub fn player_id(&self) -> LoggedOutPlayerPlayerIdUnique<'ctx> {
                LoggedOutPlayerPlayerIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("player_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerPlayerIdUnique<'ctx> {
            /// Find the subscribed row whose `player_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `name` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerNameUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().name().find(...)`.
        pub struct LoggedOutPlayerNameUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, String>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `name` unique index on the table `logged_out_player`.
            pub fn name(&self) -> LoggedOutPlayerNameUnique<'ctx> {
                LoggedOutPlayerNameUnique {
                    imp: self.imp.get_unique_constraint::<String>("name"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerNameUnique<'ctx> {
            /// Find the subscribed row whose `name` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &String) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

    let _table = client_cache.get_or_make_table::<Player>("logged_out_player");
    _table.add_unique_constraint::<__sdk::Identity>("identity", |row| &row.identity);
    _table.add_unique_constraint::<u64>("player_id", |row| &row.player_id);
    _table.add_unique_constraint::<String>("name", |row| &row.name);
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::v2::TableUpdate,
) -> __sdk::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Player>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        #[allow(non_camel_case_types)]
        /// Extension trait for query builder access to the table `Player`.
        ///
        /// Implemented for [`__sdk::QueryTableAccessor`].
        pub trait logged_out_playerQueryTableAccess {
            #[allow(non_snake_case)]
            /// Get a query builder for the table `Player`.
            fn logged_out_player(&self) -> __sdk::__query_builder::Table<Player>;
        }

        impl logged_out_playerQueryTableAccess for __sdk::QueryTableAccessor {
            fn logged_out_player(&self) -> __sdk::__query_builder::Table<Player> {
                __sdk::__query_builder::Table::new("logged_out_player")
            }
        }

'''
"mod.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

VERSION_COMMENT

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

pub mod baz_type;
pub mod foobar_type;
pub mod has_special_stuff_type;
pub mod person_type;
pub mod pk_multi_identity_type;
pub mod player_type;
pub mod point_type;
pub mod private_table_type;
pub mod remove_table_type;
pub mod repeating_test_arg_type;
pub mod test_a_type;
pub mod test_b_type;
pub mod test_d_type;
pub mod test_e_type;
pub mod test_foobar_type;
pub mod namespace_test_c_type;
pub mod namespace_test_f_type;
pub mod add_reducer;
pub mod add_player_reducer;
pub mod add_private_reducer;
pub mod assert_caller_identity_is_module_identity_reducer;
pub mod delete_player_reducer;
pub mod delete_players_by_name_reducer;
pub mod list_over_age_reducer;
pub mod log_module_identity_reducer;
pub mod query_private_reducer;
pub mod say_hello_reducer;
pub mod test_reducer;
pub mod test_btree_index_args_reducer;
pub mod logged_out_player_table;
pub mod person_table;
pub mod player_table;
pub mod test_d_table;
pub mod test_f_table;
pub mod my_player_table;
pub mod get_my_schema_via_http_procedure;
pub mod return_value_procedure;
pub mod sleep_one_second_procedure;
pub mod with_tx_procedure;

pub use baz_type::Baz;
pub use foobar_type::Foobar;
pub use has_special_stuff_type::HasSpecialStuff;
pub use person_type::Person;
pub use pk_multi_identity_type::PkMultiIdentity;
pub use player_type::Player;
pub use point_type::Point;
pub use private_table_type::PrivateTable;
pub use remove_table_type::RemoveTable;
pub use repeating_test_arg_type::RepeatingTestArg;
pub use test_a_type::TestA;
pub use test_b_type::TestB;
pub use test_d_type::TestD;
pub use test_e_type::TestE;
pub use test_foobar_type::TestFoobar;
pub use namespace_test_c_type::NamespaceTestC;
pub use namespace_test_f_type::NamespaceTestF;
pub use logged_out_player_table::*;
pub use my_player_table::*;
pub use person_table::*;
pub use player_table::*;
pub use test_d_table::*;
pub use test_f_table::*;
pub use add_reducer::add;
pub use add_player_reducer::add_player;
pub use add_private_reducer::add_private;
pub use assert_caller_identity_is_module_identity_reducer::assert_caller_identity_is_module_identity;
pub use delete_player_reducer::delete_player;
pub use delete_players_by_name_reducer::delete_players_by_name;
pub use list_over_age_reducer::list_over_age;
pub use log_module_identity_reducer::log_module_identity;
pub use query_private_reducer::query_private;
pub use say_hello_reducer::say_hello;
pub use test_reducer::test;
pub use test_btree_index_args_reducer::test_btree_index_args;
pub use get_my_schema_via_http_procedure::get_my_schema_via_http;
pub use return_value_procedure::return_value;
pub use sleep_one_second_procedure::sleep_one_second;
pub use with_tx_procedure::with_tx;

#[derive(Clone, PartialEq, Debug)]

/// One of the reducers defined by this module.
///
/// Contained within a [`__sdk::ReducerEvent`] in [`EventContext`]s for reducer events
/// to indicate which reducer caused the event.

pub enum Reducer {
        Add {
        name: String,
        age: u8,
}    ,
    AddPlayer {
        name: String,
}    ,
    AddPrivate {
        name: String,
}    ,
    AssertCallerIdentityIsModuleIdentity ,
    DeletePlayer {
        id: u64,
}    ,
    DeletePlayersByName {
        name: String,
}    ,
    ListOverAge {
        age: u8,
}    ,
    LogModuleIdentity ,
    QueryPrivate ,
    SayHello ,
    Test {
        arg: TestA,
        arg_2: TestB,
        arg_3: NamespaceTestC,
        arg_4: NamespaceTestF,
}    ,
    TestBtreeIndexArgs ,
}


impl __sdk::InModule for Reducer {
    type Module = RemoteModule;
}

impl __sdk::Reducer for Reducer {
    fn reducer_name(&self) -> &'static str {
        match self {
                        Reducer::Add { .. } => "add",
            Reducer::AddPlayer { .. } => "add_player",
            Reducer::AddPrivate { .. } => "add_private",
            Reducer::AssertCallerIdentityIsModuleIdentity => "assert_caller_identity_is_module_identity",
            Reducer::DeletePlayer { .. } => "delete_player",
            Reducer::DeletePlayersByName { .. } => "delete_players_by_name",
            Reducer::ListOverAge { .. } => "list_over_age",
            Reducer::LogModuleIdentity => "log_module_identity",
            Reducer::QueryPrivate => "query_private",
            Reducer::SayHello => "say_hello",
            Reducer::Test { .. } => "test",
            Reducer::TestBtreeIndexArgs => "test_btree_index_args",
            _ => unreachable!(),
}
}
    #[allow(clippy::clone_on_copy)]
fn args_bsatn(&self) -> Result<Vec<u8>, __sats::bsatn::EncodeError> {
        match self {
                        Reducer::Add{
                name,
                age,
}             => __sats::bsatn::to_vec(&add_reducer::AddArgs {
                name: name.clone(),
                age: age.clone(),
}),
            Reducer::AddPlayer{
                name,
}             => __sats::bsatn::to_vec(&add_player_reducer::AddPlayerArgs {
                name: name.clone(),
}),
            Reducer::AddPrivate{
                name,
}             => __sats::bsatn::to_vec(&add_private_reducer::AddPrivateArgs {
                name: name.clone(),
}),
            Reducer::AssertCallerIdentityIsModuleIdentity => __sats::bsatn::to_vec(&assert_caller_identity_is_module_identity_reducer::AssertCallerIdentityIsModuleIdentityArgs {
                }),
Reducer::DeletePlayer{
                id,
}             => __sats::bsatn::to_vec(&delete_player_reducer::DeletePlayerArgs {
                id: id.clone(),
}),
            Reducer::DeletePlayersByName{
                name,
}             => __sats::bsatn::to_vec(&delete_players_by_name_reducer::DeletePlayersByNameArgs {
                name: name.clone(),
}),
            Reducer::ListOverAge{
                age,
}             => __sats::bsatn::to_vec(&list_over_age_reducer::ListOverAgeArgs {
                age: age.clone(),
}),
            Reducer::LogModuleIdentity => __sats::bsatn::to_vec(&log_module_identity_reducer::LogModuleIdentityArgs {
                }),
Reducer::QueryPrivate => __sats::bsatn::to_vec(&query_private_reducer::QueryPrivateArgs {
                }),
Reducer::SayHello => __sats::bsatn::to_vec(&say_hello_reducer::SayHelloArgs {
                }),
Reducer::Test{
                arg,
                arg_2,
                arg_3,
                arg_4,
}             => __sats::bsatn::to_vec(&test_reducer::TestArgs {
                arg: arg.clone(),
                arg_2: arg_2.clone(),
                arg_3: arg_3.clone(),
                arg_4: arg_4.clone(),
}),
            Reducer::TestBtreeIndexArgs => __sats::bsatn::to_vec(&test_btree_index_args_reducer::TestBtreeIndexArgsArgs {
                }),
_ => unreachable!(),
}
}
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct DbUpdate {
        logged_out_player: __sdk::TableUpdate<Player>,
    my_player: __sdk::TableUpdate<Player>,
    person: __sdk::TableUpdate<Person>,
    player: __sdk::TableUpdate<Player>,
    test_d: __sdk::TableUpdate<TestD>,
    test_f: __sdk::TableUpdate<TestFoobar>,
}


impl TryFrom<__ws::v2::TransactionUpdate> for DbUpdate {
    type Error = __sdk::Error;
    fn try_from(raw: __ws::v2::TransactionUpdate) -> Result<Self, Self::Error> {
        let mut db_update = DbUpdate::default();
        for table_update in __sdk::transaction_update_iter_table_updates(raw) {
            match &table_update.table_name[..] {

        "logged_out_player" => db_update.logged_out_player.append(logged_out_player_table::parse_table_update(table_update)?),
    "my_player" => db_update.my_player.append(my_player_table::parse_table_update(table_update)?),
    "person" => db_update.person.append(person_table::parse_table_update(table_update)?),
    "player" => db_update.player.append(player_table::parse_table_update(table_update)?),
    "test_d" => db_update.test_d.append(test_d_table::parse_table_update(table_update)?),
    "test_f" => db_update.test_f.append(test_f_table::parse_table_update(table_update)?),

                unknown => {
                    return Err(__sdk::InternalError::unknown_name(
                        "table",
                        unknown,
                        "DatabaseUpdate",
                    ).into());
                }
            }
        }
        Ok(db_update)
    }
}

impl __sdk::InModule for DbUpdate {
    type Module = RemoteModule;
}

impl __sdk::DbUpdate for DbUpdate {
    fn apply_to_client_cache(&self, cache: &mut __sdk::ClientCache<RemoteModule>) -> AppliedDiff<'_> {
                    let mut diff = AppliedDiff::default();
                
                diff.logged_out_player = cache.apply_diff_to_table::<Player>("logged_out_player", &self.logged_out_player).with_updates_by_pk(|row| &row.identity);
        diff.person = cache.apply_diff_to_table::<Person>("person", &self.person).with_updates_by_pk(|row| &row.id);
        diff.player = cache.apply_diff_to_table::<Player>("player", &self.player).with_updates_by_pk(|row| &row.identity);
        diff.test_d = cache.apply_diff_to_table::<TestD>("test_d", &self.test_d);
        diff.test_f = cache.apply_diff_to_table::<TestFoobar>("test_f", &self.test_f);
        diff.my_player = cache.apply_diff_to_table::<Player>("my_player", &self.my_player);

                    diff
                }
fn parse_initial_rows(raw: __ws::v2::QueryRows) -> __sdk::Result<Self> {
                let mut db_update = DbUpdate::default();
for table_rows in raw.tables {
            match &table_rows.table[..] {
                                "logged_out_player" => db_update.logged_out_player.append(__sdk::parse_row_list_as_inserts(table_rows.rows)?),
                "my_player" => db_update.my_player.append(__sdk::parse_row_list_as_inserts(table_rows.rows)?),
                "person" => db_update.person.append(__sdk::parse_row_list_as_inserts(table_rows.rows)?),
                "player" => db_update.player.append(__sdk::parse_row_list_as_inserts(table_rows.rows)?),
                "test_d" => db_update.test_d.append(__sdk::parse_row_list_as_inserts(table_rows.rows)?),
                "test_f" => db_update.test_f.append(__sdk::parse_row_list_as_inserts(table_rows.rows)?),
                unknown => { return Err(__sdk::InternalError::unknown_name("table", unknown, "QueryRows").into()); }
}}        Ok(db_update)
}
fn parse_unsubscribe_rows(raw: __ws::v2::QueryRows) -> __sdk::Result<Self> {
                let mut db_update = DbUpdate::default();
for table_rows in raw.tables {
            match &table_rows.table[..] {
                                "logged_out_player" => db_update.logged_out_player.append(__sdk::parse_row_list_as_deletes(table_rows.rows)?),
                "my_player" => db_update.my_player.append(__sdk::parse_row_list_as_deletes(table_rows.rows)?),
                "person" => db_update.person.append(__sdk::parse_row_list_as_deletes(table_rows.rows)?),
                "player" => db_update.player.append(__sdk::parse_row_list_as_deletes(table_rows.rows)?),
                "test_d" => db_update.test_d.append(__sdk::parse_row_list_as_deletes(table_rows.rows)?),
                "test_f" => db_update.test_f.append(__sdk::parse_row_list_as_deletes(table_rows.rows)?),
                unknown => { return Err(__sdk::InternalError::unknown_name("table", unknown, "QueryRows").into()); }
}}        Ok(db_update)
}
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct AppliedDiff<'r> {
        logged_out_player: __sdk::TableAppliedDiff<'r, Player>,
    my_player: __sdk::TableAppliedDiff<'r, Player>,
    person: __sdk::TableAppliedDiff<'r, Person>,
    player: __sdk::TableAppliedDiff<'r, Player>,
    test_d: __sdk::TableAppliedDiff<'r, TestD>,
    test_f: __sdk::TableAppliedDiff<'r, TestFoobar>,
    __unused: std::marker::PhantomData<&'r ()>,
}


impl __sdk::InModule for AppliedDiff<'_> {
    type Module = RemoteModule;
}

impl<'r> __sdk::AppliedDiff<'r> for AppliedDiff<'r> {
    fn invoke_row_callbacks(&self, event: &EventContext, callbacks: &mut __sdk::DbCallbacks<RemoteModule>) {
                callbacks.invoke_table_row_callbacks::<Player>("logged_out_player", &self.logged_out_player, event);
        callbacks.invoke_table_row_callbacks::<Player>("my_player", &self.my_player, event);
        callbacks.invoke_table_row_callbacks::<Person>("person", &self.person, event);
        callbacks.invoke_table_row_callbacks::<Player>("player", &self.player, event);
        callbacks.invoke_table_row_callbacks::<TestD>("test_d", &self.test_d, event);
        callbacks.invoke_table_row_callbacks::<TestFoobar>("test_f", &self.test_f, event);
}
}


#[doc(hidden)]
pub struct RemoteModule;

impl __sdk::InModule for RemoteModule {
    type Module = Self;
}

/// The `reducers` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
pub struct RemoteReducers {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteReducers {
    type Module = RemoteModule;
}

/// The `procedures` field of [`DbConnection`] and other [`DbContext`] types,
/// with methods provided by extension traits for each procedure defined by the module.
pub struct RemoteProcedures {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteProcedures {
    type Module = RemoteModule;
}

/// The `db` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each table defined by the module.
pub struct RemoteTables {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteTables {
    type Module = RemoteModule;
}

/// A connection to a remote module, including a materialized view of a subset of the database.
///
/// Connect to a remote module by calling [`DbConnection::builder`]
/// and using the [`__sdk::DbConnectionBuilder`] builder-pattern constructor.
///
/// You must explicitly advance the connection by calling any one of:
///
/// - [`DbConnection::frame_tick`].
/// - [`DbConnection::run_threaded`].
/// - [`DbConnection::run_async`].
/// - [`DbConnection::advance_one_message`].
/// - [`DbConnection::advance_one_message_blocking`].
/// - [`DbConnection::advance_one_message_async`].
///
/// Which of these methods you should call depends on the specific needs of your application,
/// but you must call one of them, or else the connection will never progress.
pub struct DbConnection {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    #[doc(hidden)]

    /// Access to procedures defined by the module via extension traits implemented for [`RemoteProcedures`].
    pub procedures: RemoteProcedures,

    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for DbConnection {
    type Module = RemoteModule;
}

impl __sdk::DbContext for DbConnection {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn procedures(&self) -> &Self::Procedures {
        &self.procedures
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl DbConnection {
    /// Builder-pattern constructor for a connection to a remote module.
    ///
    /// See [`__sdk::DbConnectionBuilder`] for required and optional configuration for the new connection.
    pub fn builder() -> __sdk::DbConnectionBuilder<RemoteModule> {
        __sdk::DbConnectionBuilder::new()
    }

    /// If any WebSocket messages are waiting, process one of them.
    ///
    /// Returns `true` if a message was processed, or `false` if the queue is empty.
    /// Callers should invoke this message in a loop until it returns `false`
    /// or for as much time is available to process messages.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::frame_tick`] each frame
    /// to fully exhaust the queue whenever time is available.
    pub fn advance_one_message(&self) -> __sdk::Result<bool> {
        self.imp.advance_one_message()
    }

    /// Process one WebSocket message, potentially blocking the current thread until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_threaded`] to spawn a thread
    /// which advances the connection automatically.
    pub fn advance_one_message_blocking(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_blocking()
    }

    /// Process one WebSocket message, `await`ing until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_async`] to run an `async` loop
    /// which advances the connection when polled.
    pub async fn advance_one_message_async(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_async().await
    }

    /// Process all WebSocket messages waiting in the queue,
    /// then return without `await`ing or blocking the current thread.
    pub fn frame_tick(&self) -> __sdk::Result<()> {
        self.imp.frame_tick()
    }

    /// Spawn a thread which processes WebSocket messages as they are received.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn run_threaded(&self) -> std::thread::JoinHandle<()> {
        self.imp.run_threaded()
    }

    #[cfg(target_arch = "wasm32")]
    pub fn run_threaded(&self) {
        self.imp.run_threaded()
    }

    /// Run an `async` loop which processes WebSocket messages when polled.
    pub async fn run_async(&self) -> __sdk::Result<()> {
        self.imp.run_async().await
    }
}

impl __sdk::DbConnection for DbConnection {
    fn new(imp: __sdk::DbContextImpl<RemoteModule>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            procedures: RemoteProcedures { imp: imp.clone() },
            imp,
        }
    }
}

/// A handle on a subscribed query.
// TODO: Document this better after implementing the new subscription API.
#[derive(Clone)]
pub struct SubscriptionHandle {
    imp: __sdk::SubscriptionHandleImpl<RemoteModule>,
}

impl __sdk::InModule for SubscriptionHandle {
    type Module = RemoteModule;
}

impl __sdk::SubscriptionHandle for SubscriptionHandle {
    fn new(imp: __sdk::SubscriptionHandleImpl<RemoteModule>) -> Self {
        Self { imp }
    }

    /// Returns true if this subscription has been terminated due to an unsubscribe call or an error.
    fn is_ended(&self) -> bool {
        self.imp.is_ended()
    }

    /// Returns true if this subscription has been applied and has not yet been unsubscribed.
    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    /// Unsubscribe from the query controlled by this `SubscriptionHandle`,
    /// then run `on_end` when its rows are removed from the client cache.
    fn unsubscribe_then(self, on_end: __sdk::OnEndedCallback<RemoteModule>) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(Some(on_end))
    }

    fn unsubscribe(self) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(None)
    }

}

/// Alias trait for a [`__sdk::DbContext`] connected to this module,
/// with that trait's associated types bounded to this module's concrete types.
///
/// Users can use this trait as a boundary on definitions which should accept
/// either a [`DbConnection`] or an [`EventContext`] and operate on either.
pub trait RemoteDbContext: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
> {}
impl<Ctx: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
>> RemoteDbContext for Ctx {}


/// An [`__sdk::DbContext`] augmented with a [`__sdk::Event`],
/// passed to [`__sdk::Table::on_insert`], [`__sdk::Table::on_delete`] and [`__sdk::TableWithPrimaryKey::on_update`] callbacks.
pub struct EventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to procedures defined by the module via extension traits implemented for [`RemoteProcedures`].
    pub procedures: RemoteProcedures,
    /// The event which caused these callbacks to run.
    pub event: __sdk::Event<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for EventContext {
    type Event = __sdk::Event<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            procedures: RemoteProcedures { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for EventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for EventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn procedures(&self) -> &Self::Procedures {
        &self.procedures
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::EventContext for EventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::ReducerEvent`],
/// passed to on-reducer callbacks.
pub struct ReducerEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to procedures defined by the module via extension traits implemented for [`RemoteProcedures`].
    pub procedures: RemoteProcedures,
    /// The event which caused these callbacks to run.
    pub event: __sdk::ReducerEvent<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ReducerEventContext {
    type Event = __sdk::ReducerEvent<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            procedures: RemoteProcedures { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ReducerEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ReducerEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn procedures(&self) -> &Self::Procedures {
        &self.procedures
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::ReducerEventContext for ReducerEventContext {}

/// An [`__sdk::DbContext`] passed to procedure callbacks.
pub struct ProcedureEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to procedures defined by the module via extension traits implemented for [`RemoteProcedures`].
    pub procedures: RemoteProcedures,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ProcedureEventContext {
    type Event = ();
    fn event(&self) -> &Self::Event {
        &()
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, _event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            procedures: RemoteProcedures { imp: imp.clone() },
            imp,
        }
    }
}

impl __sdk::InModule for ProcedureEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ProcedureEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn procedures(&self) -> &Self::Procedures {
        &self.procedures
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::ProcedureEventContext for ProcedureEventContext {}

/// An [`__sdk::DbContext`] passed to [`__sdk::SubscriptionBuilder::on_applied`] and [`SubscriptionHandle::unsubscribe_then`] callbacks.
pub struct SubscriptionEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to procedures defined by the module via extension traits implemented for [`RemoteProcedures`].
    pub procedures: RemoteProcedures,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for SubscriptionEventContext {
    type Event = ();
    fn event(&self) -> &Self::Event {
        &()
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, _event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            procedures: RemoteProcedures { imp: imp.clone() },
            imp,
        }
    }
}

impl __sdk::InModule for SubscriptionEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for SubscriptionEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn procedures(&self) -> &Self::Procedures {
        &self.procedures
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::SubscriptionEventContext for SubscriptionEventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::Error`],
/// passed to [`__sdk::DbConnectionBuilder::on_disconnect`], [`__sdk::DbConnectionBuilder::on_connect_error`] and [`__sdk::SubscriptionBuilder::on_error`] callbacks.
pub struct ErrorContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to procedures defined by the module via extension traits implemented for [`RemoteProcedures`].
    pub procedures: RemoteProcedures,
    /// The event which caused these callbacks to run.
    pub event: Option<__sdk::Error>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ErrorContext {
    type Event = Option<__sdk::Error>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            procedures: RemoteProcedures { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ErrorContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ErrorContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn procedures(&self) -> &Self::Procedures {
        &self.procedures
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
    fn try_connection_id(&self) -> Option<__sdk::ConnectionId> {
        self.imp.try_connection_id()
    }
}

impl __sdk::ErrorContext for ErrorContext {}

impl __sdk::SpacetimeModule for RemoteModule {
    
    type DbConnection = DbConnection;
    type EventContext = EventContext;
    type ReducerEventContext = ReducerEventContext;
    type ProcedureEventContext = ProcedureEventContext;
    type SubscriptionEventContext = SubscriptionEventContext;
    type ErrorContext = ErrorContext;
    type Reducer = Reducer;
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type Procedures = RemoteProcedures;
    type DbUpdate = DbUpdate;
    type AppliedDiff<'r> = AppliedDiff<'r>;
    type SubscriptionHandle = SubscriptionHandle;
    type QueryBuilder = __sdk::QueryBuilder;

fn register_tables(client_cache: &mut __sdk::ClientCache<Self>) {
                logged_out_player_table::register_table(client_cache);
        my_player_table::register_table(client_cache);
        person_table::register_table(client_cache);
        player_table::register_table(client_cache);
        test_d_table::register_table(client_cache);
        test_f_table::register_table(client_cache);
}
const ALL_TABLE_NAMES: &'static [&'static str] = &[
                "logged_out_player",
        "my_player",
        "person",
        "player",
        "test_d",
        "test_f",
];
}
'''
"my_player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `my_player`.
///
/// Obtain a handle from the [`MyPlayerTableAccess::my_player`] method on [`super::RemoteTables`],
/// like `ctx.db.my_player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.my_player().on_insert(...)`.
pub struct MyPlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `my_player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait MyPlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`MyPlayerTableHandle`], which mediates access to the table `my_player`.
    fn my_player(&self) -> MyPlayerTableHandle<'_>;
}

impl MyPlayerTableAccess for super::RemoteTables {
    fn my_player(&self) -> MyPlayerTableHandle<'_> {
        MyPlayerTableHandle {
            imp: self.imp.get_table::<Player>("my_player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct MyPlayerInsertCallbackId(__sdk::CallbackId);
pub struct MyPlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for MyPlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = MyPlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> MyPlayerInsertCallbackId {
        MyPlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: MyPlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = MyPlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> MyPlayerDeleteCallbackId {
        MyPlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: MyPlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<Player>("my_player");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::v2::TableUpdate,
) -> __sdk::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Player>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        #[allow(non_camel_case_types)]
        /// Extension trait for query builder access to the table `Player`.
        ///
        /// Implemented for [`__sdk::QueryTableAccessor`].
        pub trait my_playerQueryTableAccess {
            #[allow(non_snake_case)]
            /// Get a query builder for the table `Player`.
            fn my_player(&self) -> __sdk::__query_builder::Table<Player>;
        }

        impl my_playerQueryTableAccess for __sdk::QueryTableAccessor {
            fn my_player(&self) -> __sdk::__query_builder::Table<Player> {
                __sdk::__query_builder::Table::new("my_player")
            }
        }

'''
"namespace_test_c_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
#[derive(Copy, Eq, Hash)]
pub enum NamespaceTestC {
    Foo,

    Bar,

}



impl __sdk::InModule for NamespaceTestC {
    type Module = super::RemoteModule;
}

'''
"namespace_test_f_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestF {
    Foo,

    Bar,

    Baz(String),

}



impl __sdk::InModule for NamespaceTestF {
    type Module = super::RemoteModule;
}

'''
"person_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::person_type::Person;

/// Table handle for the table `person`.
///
/// Obtain a handle from the [`PersonTableAccess::person`] method on [`super::RemoteTables`],
/// like `ctx.db.person()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.person().on_insert(...)`.
pub struct PersonTableHandle<'ctx> {
    imp: __sdk::TableHandle<Person>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `person`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PersonTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PersonTableHandle`], which mediates access to the table `person`.
    fn person(&self) -> PersonTableHandle<'_>;
}

impl PersonTableAccess for super::RemoteTables {
    fn person(&self) -> PersonTableHandle<'_> {
        PersonTableHandle {
            imp: self.imp.get_table::<Person>("person"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PersonInsertCallbackId(__sdk::CallbackId);
pub struct PersonDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PersonTableHandle<'ctx> {
    type Row = Person;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Person> + '_ { self.imp.iter() }

    type InsertCallbackId = PersonInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PersonInsertCallbackId {
        PersonInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PersonInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PersonDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PersonDeleteCallbackId {
        PersonDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PersonDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

pub struct PersonUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PersonTableHandle<'ctx> {
    type UpdateCallbackId = PersonUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PersonUpdateCallbackId {
        PersonUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PersonUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

        /// Access to the `id` unique index on the table `person`,
        /// which allows point queries on the field of the same name
        /// via the [`PersonIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.person().id().find(...)`.
        pub struct PersonIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Person, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PersonTableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `person`.
            pub fn id(&self) -> PersonIdUnique<'ctx> {
                PersonIdUnique {
                    imp: self.imp.get_unique_constraint::<u32>("id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PersonIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<Person> {
                self.imp.find(col_val)
            }
        }
        
#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

    let _table = client_cache.get_or_make_table::<Person>("person");
    _table.add_unique_constraint::<u32>("id", |row| &row.id);
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::v2::TableUpdate,
) -> __sdk::Result<__sdk::TableUpdate<Person>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Person>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        #[allow(non_camel_case_types)]
        /// Extension trait for query builder access to the table `Person`.
        ///
        /// Implemented for [`__sdk::QueryTableAccessor`].
        pub trait personQueryTableAccess {
            #[allow(non_snake_case)]
            /// Get a query builder for the table `Person`.
            fn person(&self) -> __sdk::__query_builder::Table<Person>;
        }

        impl personQueryTableAccess for __sdk::QueryTableAccessor {
            fn person(&self) -> __sdk::__query_builder::Table<Person> {
                __sdk::__query_builder::Table::new("person")
            }
        }

'''
"person_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Person {
    pub id: u32,
    pub name: String,
    pub age: u8,
}


impl __sdk::InModule for Person {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `Person`.
///
/// Provides typed access to columns for query building.
pub struct PersonCols {
    pub id: __sdk::__query_builder::Col<Person, u32>,
    pub name: __sdk::__query_builder::Col<Person, String>,
    pub age: __sdk::__query_builder::Col<Person, u8>,
}

impl __sdk::__query_builder::HasCols for Person {
    type Cols = PersonCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        PersonCols {
            id: __sdk::__query_builder::Col::new(table_name, "id"),
            name: __sdk::__query_builder::Col::new(table_name, "name"),
            age: __sdk::__query_builder::Col::new(table_name, "age"),

        }
    }
}

/// Indexed column accessor struct for the table `Person`.
///
/// Provides typed access to indexed columns for query building.
pub struct PersonIxCols {
    pub age: __sdk::__query_builder::IxCol<Person, u8>,
    pub id: __sdk::__query_builder::IxCol<Person, u32>,
}

impl __sdk::__query_builder::HasIxCols for Person {
    type IxCols = PersonIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        PersonIxCols {
            age: __sdk::__query_builder::IxCol::new(table_name, "age"),
            id: __sdk::__query_builder::IxCol::new(table_name, "id"),

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for Person {}

'''
"pk_multi_identity_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct PkMultiIdentity {
    pub id: u32,
    pub other: u32,
}


impl __sdk::InModule for PkMultiIdentity {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `PkMultiIdentity`.
///
/// Provides typed access to columns for query building.
pub struct PkMultiIdentityCols {
    pub id: __sdk::__query_builder::Col<PkMultiIdentity, u32>,
    pub other: __sdk::__query_builder::Col<PkMultiIdentity, u32>,
}

impl __sdk::__query_builder::HasCols for PkMultiIdentity {
    type Cols = PkMultiIdentityCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        PkMultiIdentityCols {
            id: __sdk::__query_builder::Col::new(table_name, "id"),
            other: __sdk::__query_builder::Col::new(table_name, "other"),

        }
    }
}

/// Indexed column accessor struct for the table `PkMultiIdentity`.
///
/// Provides typed access to indexed columns for query building.
pub struct PkMultiIdentityIxCols {
    pub id: __sdk::__query_builder::IxCol<PkMultiIdentity, u32>,
    pub other: __sdk::__query_builder::IxCol<PkMultiIdentity, u32>,
}

impl __sdk::__query_builder::HasIxCols for PkMultiIdentity {
    type IxCols = PkMultiIdentityIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        PkMultiIdentityIxCols {
            id: __sdk::__query_builder::IxCol::new(table_name, "id"),
            other: __sdk::__query_builder::IxCol::new(table_name, "other"),

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for PkMultiIdentity {}

'''
"player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `player`.
///
/// Obtain a handle from the [`PlayerTableAccess::player`] method on [`super::RemoteTables`],
/// like `ctx.db.player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.player().on_insert(...)`.
pub struct PlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PlayerTableHandle`], which mediates access to the table `player`.
    fn player(&self) -> PlayerTableHandle<'_>;
}

impl PlayerTableAccess for super::RemoteTables {
    fn player(&self) -> PlayerTableHandle<'_> {
        PlayerTableHandle {
            imp: self.imp.get_table::<Player>("player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PlayerInsertCallbackId(__sdk::CallbackId);
pub struct PlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = PlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PlayerInsertCallbackId {
        PlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PlayerDeleteCallbackId {
        PlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

pub struct PlayerUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PlayerTableHandle<'ctx> {
    type UpdateCallbackId = PlayerUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PlayerUpdateCallbackId {
        PlayerUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PlayerUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

        /// Access to the `identity` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerIdentityUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().identity().find(...)`.
        pub struct PlayerIdentityUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, __sdk::Identity>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `identity` unique index on the table `player`.
            pub fn identity(&self) -> PlayerIdentityUnique<'ctx> {
                PlayerIdentityUnique {
                    imp: self.imp.get_unique_constraint::<__sdk::Identity>("identity"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerIdentityUnique<'ctx> {
            /// Find the subscribed row whose `identity` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &__sdk::Identity) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `player_id` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerPlayerIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().player_id().find(...)`.
        pub struct PlayerPlayerIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `player_id` unique index on the table `player`.
            pub fn player_id(&self) -> PlayerPlayerIdUnique<'ctx> {
                PlayerPlayerIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("player_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerPlayerIdUnique<'ctx> {
            /// Find the subscribed row whose `player_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `name` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerNameUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().name().find(...)`.
        pub struct PlayerNameUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, String>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `name` unique index on the table `player`.
            pub fn name(&self) -> PlayerNameUnique<'ctx> {
                PlayerNameUnique {
                    imp: self.imp.get_unique_constraint::<String>("name"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerNameUnique<'ctx> {
            /// Find the subscribed row whose `name` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &String) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

    let _table = client_cache.get_or_make_table::<Player>("player");
    _table.add_unique_constraint::<__sdk::Identity>("identity", |row| &row.identity);
    _table.add_unique_constraint::<u64>("player_id", |row| &row.player_id);
    _table.add_unique_constraint::<String>("name", |row| &row.name);
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::v2::TableUpdate,
) -> __sdk::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Player>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        #[allow(non_camel_case_types)]
        /// Extension trait for query builder access to the table `Player`.
        ///
        /// Implemented for [`__sdk::QueryTableAccessor`].
        pub trait playerQueryTableAccess {
            #[allow(non_snake_case)]
            /// Get a query builder for the table `Player`.
            fn player(&self) -> __sdk::__query_builder::Table<Player>;
        }

        impl playerQueryTableAccess for __sdk::QueryTableAccessor {
            fn player(&self) -> __sdk::__query_builder::Table<Player> {
                __sdk::__query_builder::Table::new("player")
            }
        }

'''
"player_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Player {
    pub identity: __sdk::Identity,
    pub player_id: u64,
    pub name: String,
}


impl __sdk::InModule for Player {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `Player`.
///
/// Provides typed access to columns for query building.
pub struct PlayerCols {
    pub identity: __sdk::__query_builder::Col<Player, __sdk::Identity>,
    pub player_id: __sdk::__query_builder::Col<Player, u64>,
    pub name: __sdk::__query_builder::Col<Player, String>,
}

impl __sdk::__query_builder::HasCols for Player {
    type Cols = PlayerCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        PlayerCols {
            identity: __sdk::__query_builder::Col::new(table_name, "identity"),
            player_id: __sdk::__query_builder::Col::new(table_name, "player_id"),
            name: __sdk::__query_builder::Col::new(table_name, "name"),

        }
    }
}

/// Indexed column accessor struct for the table `Player`.
///
/// Provides typed access to indexed columns for query building.
pub struct PlayerIxCols {
    pub identity: __sdk::__query_builder::IxCol<Player, __sdk::Identity>,
    pub name: __sdk::__query_builder::IxCol<Player, String>,
    pub player_id: __sdk::__query_builder::IxCol<Player, u64>,
}

impl __sdk::__query_builder::HasIxCols for Player {
    type IxCols = PlayerIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        PlayerIxCols {
            identity: __sdk::__query_builder::IxCol::new(table_name, "identity"),
            name: __sdk::__query_builder::IxCol::new(table_name, "name"),
            player_id: __sdk::__query_builder::IxCol::new(table_name, "player_id"),

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for Player {}

'''
"point_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Point {
    pub x: i64,
    pub y: i64,
}


impl __sdk::InModule for Point {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `Point`.
///
/// Provides typed access to columns for query building.
pub struct PointCols {
    pub x: __sdk::__query_builder::Col<Point, i64>,
    pub y: __sdk::__query_builder::Col<Point, i64>,
}

impl __sdk::__query_builder::HasCols for Point {
    type Cols = PointCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        PointCols {
            x: __sdk::__query_builder::Col::new(table_name, "x"),
            y: __sdk::__query_builder::Col::new(table_name, "y"),

        }
    }
}

/// Indexed column accessor struct for the table `Point`.
///
/// Provides typed access to indexed columns for query building.
pub struct PointIxCols {
}

impl __sdk::__query_builder::HasIxCols for Point {
    type IxCols = PointIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        PointIxCols {

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for Point {}

'''
"private_table_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct PrivateTable {
    pub name: String,
}


impl __sdk::InModule for PrivateTable {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `PrivateTable`.
///
/// Provides typed access to columns for query building.
pub struct PrivateTableCols {
    pub name: __sdk::__query_builder::Col<PrivateTable, String>,
}

impl __sdk::__query_builder::HasCols for PrivateTable {
    type Cols = PrivateTableCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        PrivateTableCols {
            name: __sdk::__query_builder::Col::new(table_name, "name"),

        }
    }
}

/// Indexed column accessor struct for the table `PrivateTable`.
///
/// Provides typed access to indexed columns for query building.
pub struct PrivateTableIxCols {
}

impl __sdk::__query_builder::HasIxCols for PrivateTable {
    type IxCols = PrivateTableIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        PrivateTableIxCols {

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for PrivateTable {}

'''
"query_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct QueryPrivateArgs {
    }

impl From<QueryPrivateArgs> for super::Reducer {
    fn from(args: QueryPrivateArgs) -> Self {
        Self::QueryPrivate
}
}

impl __sdk::InModule for QueryPrivateArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `query_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait query_private {
    /// Request that the remote module invoke the reducer `query_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`query_private:query_private_then`] to run a callback after the reducer completes.
    fn query_private(&self, ) -> __sdk::Result<()> {
        self.query_private_then( |_, _| {})
    }

    /// Request that the remote module invoke the reducer `query_private` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn query_private_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl query_private for super::RemoteReducers {
    fn query_private_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(QueryPrivateArgs {  }, callback)
    }
}

'''
"remove_table_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct RemoveTable {
    pub id: u32,
}


impl __sdk::InModule for RemoveTable {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `RemoveTable`.
///
/// Provides typed access to columns for query building.
pub struct RemoveTableCols {
    pub id: __sdk::__query_builder::Col<RemoveTable, u32>,
}

impl __sdk::__query_builder::HasCols for RemoveTable {
    type Cols = RemoveTableCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        RemoveTableCols {
            id: __sdk::__query_builder::Col::new(table_name, "id"),

        }
    }
}

/// Indexed column accessor struct for the table `RemoveTable`.
///
/// Provides typed access to indexed columns for query building.
pub struct RemoveTableIxCols {
}

impl __sdk::__query_builder::HasIxCols for RemoveTable {
    type IxCols = RemoveTableIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        RemoveTableIxCols {

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for RemoveTable {}

'''
"repeating_test_arg_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct RepeatingTestArg {
    pub scheduled_id: u64,
    pub scheduled_at: __sdk::ScheduleAt,
    pub prev_time: __sdk::Timestamp,
}


impl __sdk::InModule for RepeatingTestArg {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `RepeatingTestArg`.
///
/// Provides typed access to columns for query building.
pub struct RepeatingTestArgCols {
    pub scheduled_id: __sdk::__query_builder::Col<RepeatingTestArg, u64>,
    pub scheduled_at: __sdk::__query_builder::Col<RepeatingTestArg, __sdk::ScheduleAt>,
    pub prev_time: __sdk::__query_builder::Col<RepeatingTestArg, __sdk::Timestamp>,
}

impl __sdk::__query_builder::HasCols for RepeatingTestArg {
    type Cols = RepeatingTestArgCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        RepeatingTestArgCols {
            scheduled_id: __sdk::__query_builder::Col::new(table_name, "scheduled_id"),
            scheduled_at: __sdk::__query_builder::Col::new(table_name, "scheduled_at"),
            prev_time: __sdk::__query_builder::Col::new(table_name, "prev_time"),

        }
    }
}

/// Indexed column accessor struct for the table `RepeatingTestArg`.
///
/// Provides typed access to indexed columns for query building.
pub struct RepeatingTestArgIxCols {
    pub scheduled_id: __sdk::__query_builder::IxCol<RepeatingTestArg, u64>,
}

impl __sdk::__query_builder::HasIxCols for RepeatingTestArg {
    type IxCols = RepeatingTestArgIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        RepeatingTestArgIxCols {
            scheduled_id: __sdk::__query_builder::IxCol::new(table_name, "scheduled_id"),

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for RepeatingTestArg {}

'''
"return_value_procedure.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::baz_type::Baz;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
 struct ReturnValueArgs {
    pub foo: u64,
}


impl __sdk::InModule for ReturnValueArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the procedure `return_value`.
///
/// Implemented for [`super::RemoteProcedures`].
pub trait return_value {
    fn return_value(&self, foo: u64,
) {
        self.return_value_then(foo,  |_, _| {});
    }

    fn return_value_then(
        &self,
        foo: u64,

        __callback: impl FnOnce(&super::ProcedureEventContext, Result<Baz, __sdk::InternalError>) + Send + 'static,
    );
}

impl return_value for super::RemoteProcedures {
    fn return_value_then(
        &self,
        foo: u64,

        __callback: impl FnOnce(&super::ProcedureEventContext, Result<Baz, __sdk::InternalError>) + Send + 'static,
    ) {
        self.imp.invoke_procedure_with_callback::<_, Baz>(
            "return_value",
            ReturnValueArgs { foo,  },
            __callback,
        );
    }
}

'''
"say_hello_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct SayHelloArgs {
    }

impl From<SayHelloArgs> for super::Reducer {
    fn from(args: SayHelloArgs) -> Self {
        Self::SayHello
}
}

impl __sdk::InModule for SayHelloArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `say_hello`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait say_hello {
    /// Request that the remote module invoke the reducer `say_hello` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`say_hello:say_hello_then`] to run a callback after the reducer completes.
    fn say_hello(&self, ) -> __sdk::Result<()> {
        self.say_hello_then( |_, _| {})
    }

    /// Request that the remote module invoke the reducer `say_hello` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn say_hello_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl say_hello for super::RemoteReducers {
    fn say_hello_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(SayHelloArgs {  }, callback)
    }
}

'''
"sleep_one_second_procedure.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
 struct SleepOneSecondArgs {
    }


impl __sdk::InModule for SleepOneSecondArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the procedure `sleep_one_second`.
///
/// Implemented for [`super::RemoteProcedures`].
pub trait sleep_one_second {
    fn sleep_one_second(&self, ) {
        self.sleep_one_second_then( |_, _| {});
    }

    fn sleep_one_second_then(
        &self,
        
        __callback: impl FnOnce(&super::ProcedureEventContext, Result<(), __sdk::InternalError>) + Send + 'static,
    );
}

impl sleep_one_second for super::RemoteProcedures {
    fn sleep_one_second_then(
        &self,
        
        __callback: impl FnOnce(&super::ProcedureEventContext, Result<(), __sdk::InternalError>) + Send + 'static,
    ) {
        self.imp.invoke_procedure_with_callback::<_, ()>(
            "sleep_one_second",
            SleepOneSecondArgs {  },
            __callback,
        );
    }
}

'''
"test_a_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestA {
    pub x: u32,
    pub y: u32,
    pub z: String,
}


impl __sdk::InModule for TestA {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `TestA`.
///
/// Provides typed access to columns for query building.
pub struct TestACols {
    pub x: __sdk::__query_builder::Col<TestA, u32>,
    pub y: __sdk::__query_builder::Col<TestA, u32>,
    pub z: __sdk::__query_builder::Col<TestA, String>,
}

impl __sdk::__query_builder::HasCols for TestA {
    type Cols = TestACols;
    fn cols(table_name: &'static str) -> Self::Cols {
        TestACols {
            x: __sdk::__query_builder::Col::new(table_name, "x"),
            y: __sdk::__query_builder::Col::new(table_name, "y"),
            z: __sdk::__query_builder::Col::new(table_name, "z"),

        }
    }
}

/// Indexed column accessor struct for the table `TestA`.
///
/// Provides typed access to indexed columns for query building.
pub struct TestAIxCols {
    pub x: __sdk::__query_builder::IxCol<TestA, u32>,
}

impl __sdk::__query_builder::HasIxCols for TestA {
    type IxCols = TestAIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        TestAIxCols {
            x: __sdk::__query_builder::IxCol::new(table_name, "x"),

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for TestA {}

'''
"test_b_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestB {
    pub foo: String,
}


impl __sdk::InModule for TestB {
    type Module = super::RemoteModule;
}

'''
"test_btree_index_args_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct TestBtreeIndexArgsArgs {
    }

impl From<TestBtreeIndexArgsArgs> for super::Reducer {
    fn from(args: TestBtreeIndexArgsArgs) -> Self {
        Self::TestBtreeIndexArgs
}
}

impl __sdk::InModule for TestBtreeIndexArgsArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test_btree_index_args`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test_btree_index_args {
    /// Request that the remote module invoke the reducer `test_btree_index_args` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`test_btree_index_args:test_btree_index_args_then`] to run a callback after the reducer completes.
    fn test_btree_index_args(&self, ) -> __sdk::Result<()> {
        self.test_btree_index_args_then( |_, _| {})
    }

    /// Request that the remote module invoke the reducer `test_btree_index_args` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn test_btree_index_args_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl test_btree_index_args for super::RemoteReducers {
    fn test_btree_index_args_then(
        &self,
        
        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(TestBtreeIndexArgsArgs {  }, callback)
    }
}

'''
"test_d_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::test_d_type::TestD;
use super::namespace_test_c_type::NamespaceTestC;

/// Table handle for the table `test_d`.
///
/// Obtain a handle from the [`TestDTableAccess::test_d`] method on [`super::RemoteTables`],
/// like `ctx.db.test_d()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_d().on_insert(...)`.
pub struct TestDTableHandle<'ctx> {
    imp: __sdk::TableHandle<TestD>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_d`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestDTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestDTableHandle`], which mediates access to the table `test_d`.
    fn test_d(&self) -> TestDTableHandle<'_>;
}

impl TestDTableAccess for super::RemoteTables {
    fn test_d(&self) -> TestDTableHandle<'_> {
        TestDTableHandle {
            imp: self.imp.get_table::<TestD>("test_d"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestDInsertCallbackId(__sdk::CallbackId);
pub struct TestDDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestDTableHandle<'ctx> {
    type Row = TestD;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestD> + '_ { self.imp.iter() }

    type InsertCallbackId = TestDInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDInsertCallbackId {
        TestDInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestDInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestDDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDDeleteCallbackId {
        TestDDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestDDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<TestD>("test_d");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::v2::TableUpdate,
) -> __sdk::Result<__sdk::TableUpdate<TestD>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<TestD>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        #[allow(non_camel_case_types)]
        /// Extension trait for query builder access to the table `TestD`.
        ///
        /// Implemented for [`__sdk::QueryTableAccessor`].
        pub trait test_dQueryTableAccess {
            #[allow(non_snake_case)]
            /// Get a query builder for the table `TestD`.
            fn test_d(&self) -> __sdk::__query_builder::Table<TestD>;
        }

        impl test_dQueryTableAccess for __sdk::QueryTableAccessor {
            fn test_d(&self) -> __sdk::__query_builder::Table<TestD> {
                __sdk::__query_builder::Table::new("test_d")
            }
        }

'''
"test_d_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::namespace_test_c_type::NamespaceTestC;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestD {
    pub test_c: Option::<NamespaceTestC>,
}


impl __sdk::InModule for TestD {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `TestD`.
///
/// Provides typed access to columns for query building.
pub struct TestDCols {
    pub test_c: __sdk::__query_builder::Col<TestD, Option::<NamespaceTestC>>,
}

impl __sdk::__query_builder::HasCols for TestD {
    type Cols = TestDCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        TestDCols {
            test_c: __sdk::__query_builder::Col::new(table_name, "test_c"),

        }
    }
}

/// Indexed column accessor struct for the table `TestD`.
///
/// Provides typed access to indexed columns for query building.
pub struct TestDIxCols {
}

impl __sdk::__query_builder::HasIxCols for TestD {
    type IxCols = TestDIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        TestDIxCols {

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for TestD {}

'''
"test_e_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestE {
    pub id: u64,
    pub name: String,
}


impl __sdk::InModule for TestE {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `TestE`.
///
/// Provides typed access to columns for query building.
pub struct TestECols {
    pub id: __sdk::__query_builder::Col<TestE, u64>,
    pub name: __sdk::__query_builder::Col<TestE, String>,
}

impl __sdk::__query_builder::HasCols for TestE {
    type Cols = TestECols;
    fn cols(table_name: &'static str) -> Self::Cols {
        TestECols {
            id: __sdk::__query_builder::Col::new(table_name, "id"),
            name: __sdk::__query_builder::Col::new(table_name, "name"),

        }
    }
}

/// Indexed column accessor struct for the table `TestE`.
///
/// Provides typed access to indexed columns for query building.
pub struct TestEIxCols {
    pub id: __sdk::__query_builder::IxCol<TestE, u64>,
    pub name: __sdk::__query_builder::IxCol<TestE, String>,
}

impl __sdk::__query_builder::HasIxCols for TestE {
    type IxCols = TestEIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        TestEIxCols {
            id: __sdk::__query_builder::IxCol::new(table_name, "id"),
            name: __sdk::__query_builder::IxCol::new(table_name, "name"),

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for TestE {}

'''
"test_f_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::test_foobar_type::TestFoobar;
use super::foobar_type::Foobar;

/// Table handle for the table `test_f`.
///
/// Obtain a handle from the [`TestFTableAccess::test_f`] method on [`super::RemoteTables`],
/// like `ctx.db.test_f()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_f().on_insert(...)`.
pub struct TestFTableHandle<'ctx> {
    imp: __sdk::TableHandle<TestFoobar>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_f`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestFTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestFTableHandle`], which mediates access to the table `test_f`.
    fn test_f(&self) -> TestFTableHandle<'_>;
}

impl TestFTableAccess for super::RemoteTables {
    fn test_f(&self) -> TestFTableHandle<'_> {
        TestFTableHandle {
            imp: self.imp.get_table::<TestFoobar>("test_f"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestFInsertCallbackId(__sdk::CallbackId);
pub struct TestFDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestFTableHandle<'ctx> {
    type Row = TestFoobar;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestFoobar> + '_ { self.imp.iter() }

    type InsertCallbackId = TestFInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFInsertCallbackId {
        TestFInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestFInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestFDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFDeleteCallbackId {
        TestFDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestFDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<TestFoobar>("test_f");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::v2::TableUpdate,
) -> __sdk::Result<__sdk::TableUpdate<TestFoobar>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<TestFoobar>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        #[allow(non_camel_case_types)]
        /// Extension trait for query builder access to the table `TestFoobar`.
        ///
        /// Implemented for [`__sdk::QueryTableAccessor`].
        pub trait test_fQueryTableAccess {
            #[allow(non_snake_case)]
            /// Get a query builder for the table `TestFoobar`.
            fn test_f(&self) -> __sdk::__query_builder::Table<TestFoobar>;
        }

        impl test_fQueryTableAccess for __sdk::QueryTableAccessor {
            fn test_f(&self) -> __sdk::__query_builder::Table<TestFoobar> {
                __sdk::__query_builder::Table::new("test_f")
            }
        }

'''
"test_foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::foobar_type::Foobar;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestFoobar {
    pub field: Foobar,
}


impl __sdk::InModule for TestFoobar {
    type Module = super::RemoteModule;
}


/// Column accessor struct for the table `TestFoobar`.
///
/// Provides typed access to columns for query building.
pub struct TestFoobarCols {
    pub field: __sdk::__query_builder::Col<TestFoobar, Foobar>,
}

impl __sdk::__query_builder::HasCols for TestFoobar {
    type Cols = TestFoobarCols;
    fn cols(table_name: &'static str) -> Self::Cols {
        TestFoobarCols {
            field: __sdk::__query_builder::Col::new(table_name, "field"),

        }
    }
}

/// Indexed column accessor struct for the table `TestFoobar`.
///
/// Provides typed access to indexed columns for query building.
pub struct TestFoobarIxCols {
}

impl __sdk::__query_builder::HasIxCols for TestFoobar {
    type IxCols = TestFoobarIxCols;
    fn ix_cols(table_name: &'static str) -> Self::IxCols {
        TestFoobarIxCols {

        }
    }
}

impl __sdk::__query_builder::CanBeLookupTable for TestFoobar {}

'''
"test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::test_a_type::TestA;
use super::test_b_type::TestB;
use super::namespace_test_c_type::NamespaceTestC;
use super::namespace_test_f_type::NamespaceTestF;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct TestArgs {
    pub arg: TestA,
    pub arg_2: TestB,
    pub arg_3: NamespaceTestC,
    pub arg_4: NamespaceTestF,
}

impl From<TestArgs> for super::Reducer {
    fn from(args: TestArgs) -> Self {
        Self::Test {
            arg: args.arg,
            arg_2: args.arg_2,
            arg_3: args.arg_3,
            arg_4: args.arg_4,
}
}
}

impl __sdk::InModule for TestArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test {
    /// Request that the remote module invoke the reducer `test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and this method provides no way to listen for its completion status.
    /// /// Use [`test:test_then`] to run a callback after the reducer completes.
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __sdk::Result<()> {
        self.test_then(arg, arg_2, arg_3, arg_4,  |_, _| {})
    }

    /// Request that the remote module invoke the reducer `test` to run as soon as possible,
    /// registering `callback` to run when we are notified that the reducer completed.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed with the `callback`.
    fn test_then(
        &self,
        arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()>;
}

impl test for super::RemoteReducers {
    fn test_then(
        &self,
        arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,

        callback: impl FnOnce(&super::ReducerEventContext, Result<Result<(), String>, __sdk::InternalError>)
            + Send
            + 'static,
    ) -> __sdk::Result<()> {
        self.imp.invoke_reducer_with_callback(TestArgs { arg, arg_2, arg_3, arg_4,  }, callback)
    }
}

'''
"with_tx_procedure.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
 struct WithTxArgs {
    }


impl __sdk::InModule for WithTxArgs {
    type Module = super::RemoteModule;
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the procedure `with_tx`.
///
/// Implemented for [`super::RemoteProcedures`].
pub trait with_tx {
    fn with_tx(&self, ) {
        self.with_tx_then( |_, _| {});
    }

    fn with_tx_then(
        &self,
        
        __callback: impl FnOnce(&super::ProcedureEventContext, Result<(), __sdk::InternalError>) + Send + 'static,
    );
}

impl with_tx for super::RemoteProcedures {
    fn with_tx_then(
        &self,
        
        __callback: impl FnOnce(&super::ProcedureEventContext, Result<(), __sdk::InternalError>) + Send + 'static,
    ) {
        self.imp.invoke_procedure_with_callback::<_, ()>(
            "with_tx",
            WithTxArgs {  },
            __callback,
        );
    }
}

'''
