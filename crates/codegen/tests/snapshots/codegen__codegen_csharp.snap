---
source: crates/codegen/tests/codegen.rs
assertion_line: 37
expression: outfiles
---
"Reducers/Add.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AddHandler(ReducerEventContext ctx, string name, byte age);
        public event AddHandler? OnAdd;

        public void Add(string name, byte age)
        {
            conn.InternalCallReducer(new Reducer.Add(name, age), this.SetCallReducerFlags.AddFlags);
        }

        public bool InvokeAdd(ReducerEventContext ctx, Reducer.Add args)
        {
            if (OnAdd == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAdd(
                ctx,
                args.Name,
                args.Age
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class Add : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;
            [DataMember(Name = "age")]
            public byte Age;

            public Add(
                string Name,
                byte Age
            )
            {
                this.Name = Name;
                this.Age = Age;
            }

            public Add()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "add";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AddFlags;
        public void Add(CallReducerFlags flags) => AddFlags = flags;
    }
}
'''
"Reducers/AddPlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AddPlayerHandler(ReducerEventContext ctx, string name);
        public event AddPlayerHandler? OnAddPlayer;

        public void AddPlayer(string name)
        {
            conn.InternalCallReducer(new Reducer.AddPlayer(name), this.SetCallReducerFlags.AddPlayerFlags);
        }

        public bool InvokeAddPlayer(ReducerEventContext ctx, Reducer.AddPlayer args)
        {
            if (OnAddPlayer == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAddPlayer(
                ctx,
                args.Name
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class AddPlayer : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;

            public AddPlayer(string Name)
            {
                this.Name = Name;
            }

            public AddPlayer()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "add_player";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AddPlayerFlags;
        public void AddPlayer(CallReducerFlags flags) => AddPlayerFlags = flags;
    }
}
'''
"Reducers/AddPrivate.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AddPrivateHandler(ReducerEventContext ctx, string name);
        public event AddPrivateHandler? OnAddPrivate;

        public void AddPrivate(string name)
        {
            conn.InternalCallReducer(new Reducer.AddPrivate(name), this.SetCallReducerFlags.AddPrivateFlags);
        }

        public bool InvokeAddPrivate(ReducerEventContext ctx, Reducer.AddPrivate args)
        {
            if (OnAddPrivate == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAddPrivate(
                ctx,
                args.Name
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class AddPrivate : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;

            public AddPrivate(string Name)
            {
                this.Name = Name;
            }

            public AddPrivate()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "add_private";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AddPrivateFlags;
        public void AddPrivate(CallReducerFlags flags) => AddPrivateFlags = flags;
    }
}
'''
"Reducers/AssertCallerIdentityIsModuleIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AssertCallerIdentityIsModuleIdentityHandler(ReducerEventContext ctx);
        public event AssertCallerIdentityIsModuleIdentityHandler? OnAssertCallerIdentityIsModuleIdentity;

        public void AssertCallerIdentityIsModuleIdentity()
        {
            conn.InternalCallReducer(new Reducer.AssertCallerIdentityIsModuleIdentity(), this.SetCallReducerFlags.AssertCallerIdentityIsModuleIdentityFlags);
        }

        public bool InvokeAssertCallerIdentityIsModuleIdentity(ReducerEventContext ctx, Reducer.AssertCallerIdentityIsModuleIdentity args)
        {
            if (OnAssertCallerIdentityIsModuleIdentity == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAssertCallerIdentityIsModuleIdentity(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class AssertCallerIdentityIsModuleIdentity : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "assert_caller_identity_is_module_identity";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AssertCallerIdentityIsModuleIdentityFlags;
        public void AssertCallerIdentityIsModuleIdentity(CallReducerFlags flags) => AssertCallerIdentityIsModuleIdentityFlags = flags;
    }
}
'''
"Reducers/ClientConnected.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void ClientConnectedHandler(ReducerEventContext ctx);
        public event ClientConnectedHandler? OnClientConnected;

        public bool InvokeClientConnected(ReducerEventContext ctx, Reducer.ClientConnected args)
        {
            if (OnClientConnected == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnClientConnected(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class ClientConnected : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "client_connected";
        }
    }
}
'''
"Reducers/DeletePlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void DeletePlayerHandler(ReducerEventContext ctx, ulong id);
        public event DeletePlayerHandler? OnDeletePlayer;

        public void DeletePlayer(ulong id)
        {
            conn.InternalCallReducer(new Reducer.DeletePlayer(id), this.SetCallReducerFlags.DeletePlayerFlags);
        }

        public bool InvokeDeletePlayer(ReducerEventContext ctx, Reducer.DeletePlayer args)
        {
            if (OnDeletePlayer == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnDeletePlayer(
                ctx,
                args.Id
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class DeletePlayer : Reducer, IReducerArgs
        {
            [DataMember(Name = "id")]
            public ulong Id;

            public DeletePlayer(ulong Id)
            {
                this.Id = Id;
            }

            public DeletePlayer()
            {
            }

            string IReducerArgs.ReducerName => "delete_player";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags DeletePlayerFlags;
        public void DeletePlayer(CallReducerFlags flags) => DeletePlayerFlags = flags;
    }
}
'''
"Reducers/DeletePlayersByName.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void DeletePlayersByNameHandler(ReducerEventContext ctx, string name);
        public event DeletePlayersByNameHandler? OnDeletePlayersByName;

        public void DeletePlayersByName(string name)
        {
            conn.InternalCallReducer(new Reducer.DeletePlayersByName(name), this.SetCallReducerFlags.DeletePlayersByNameFlags);
        }

        public bool InvokeDeletePlayersByName(ReducerEventContext ctx, Reducer.DeletePlayersByName args)
        {
            if (OnDeletePlayersByName == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnDeletePlayersByName(
                ctx,
                args.Name
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class DeletePlayersByName : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;

            public DeletePlayersByName(string Name)
            {
                this.Name = Name;
            }

            public DeletePlayersByName()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "delete_players_by_name";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags DeletePlayersByNameFlags;
        public void DeletePlayersByName(CallReducerFlags flags) => DeletePlayersByNameFlags = flags;
    }
}
'''
"Reducers/ListOverAge.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void ListOverAgeHandler(ReducerEventContext ctx, byte age);
        public event ListOverAgeHandler? OnListOverAge;

        public void ListOverAge(byte age)
        {
            conn.InternalCallReducer(new Reducer.ListOverAge(age), this.SetCallReducerFlags.ListOverAgeFlags);
        }

        public bool InvokeListOverAge(ReducerEventContext ctx, Reducer.ListOverAge args)
        {
            if (OnListOverAge == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnListOverAge(
                ctx,
                args.Age
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class ListOverAge : Reducer, IReducerArgs
        {
            [DataMember(Name = "age")]
            public byte Age;

            public ListOverAge(byte Age)
            {
                this.Age = Age;
            }

            public ListOverAge()
            {
            }

            string IReducerArgs.ReducerName => "list_over_age";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags ListOverAgeFlags;
        public void ListOverAge(CallReducerFlags flags) => ListOverAgeFlags = flags;
    }
}
'''
"Reducers/LogModuleIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void LogModuleIdentityHandler(ReducerEventContext ctx);
        public event LogModuleIdentityHandler? OnLogModuleIdentity;

        public void LogModuleIdentity()
        {
            conn.InternalCallReducer(new Reducer.LogModuleIdentity(), this.SetCallReducerFlags.LogModuleIdentityFlags);
        }

        public bool InvokeLogModuleIdentity(ReducerEventContext ctx, Reducer.LogModuleIdentity args)
        {
            if (OnLogModuleIdentity == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnLogModuleIdentity(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class LogModuleIdentity : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "log_module_identity";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags LogModuleIdentityFlags;
        public void LogModuleIdentity(CallReducerFlags flags) => LogModuleIdentityFlags = flags;
    }
}
'''
"Reducers/QueryPrivate.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void QueryPrivateHandler(ReducerEventContext ctx);
        public event QueryPrivateHandler? OnQueryPrivate;

        public void QueryPrivate()
        {
            conn.InternalCallReducer(new Reducer.QueryPrivate(), this.SetCallReducerFlags.QueryPrivateFlags);
        }

        public bool InvokeQueryPrivate(ReducerEventContext ctx, Reducer.QueryPrivate args)
        {
            if (OnQueryPrivate == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnQueryPrivate(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class QueryPrivate : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "query_private";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags QueryPrivateFlags;
        public void QueryPrivate(CallReducerFlags flags) => QueryPrivateFlags = flags;
    }
}
'''
"Reducers/RepeatingTest.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void RepeatingTestHandler(ReducerEventContext ctx, RepeatingTestArg arg);
        public event RepeatingTestHandler? OnRepeatingTest;

        public void RepeatingTest(RepeatingTestArg arg)
        {
            conn.InternalCallReducer(new Reducer.RepeatingTest(arg), this.SetCallReducerFlags.RepeatingTestFlags);
        }

        public bool InvokeRepeatingTest(ReducerEventContext ctx, Reducer.RepeatingTest args)
        {
            if (OnRepeatingTest == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnRepeatingTest(
                ctx,
                args.Arg
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class RepeatingTest : Reducer, IReducerArgs
        {
            [DataMember(Name = "arg")]
            public RepeatingTestArg Arg;

            public RepeatingTest(RepeatingTestArg Arg)
            {
                this.Arg = Arg;
            }

            public RepeatingTest()
            {
                this.Arg = new();
            }

            string IReducerArgs.ReducerName => "repeating_test";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags RepeatingTestFlags;
        public void RepeatingTest(CallReducerFlags flags) => RepeatingTestFlags = flags;
    }
}
'''
"Reducers/SayHello.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void SayHelloHandler(ReducerEventContext ctx);
        public event SayHelloHandler? OnSayHello;

        public void SayHello()
        {
            conn.InternalCallReducer(new Reducer.SayHello(), this.SetCallReducerFlags.SayHelloFlags);
        }

        public bool InvokeSayHello(ReducerEventContext ctx, Reducer.SayHello args)
        {
            if (OnSayHello == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnSayHello(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class SayHello : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "say_hello";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags SayHelloFlags;
        public void SayHello(CallReducerFlags flags) => SayHelloFlags = flags;
    }
}
'''
"Reducers/Test.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void TestHandler(ReducerEventContext ctx, TestA arg, TestB arg2, NamespaceTestC arg3, NamespaceTestF arg4);
        public event TestHandler? OnTest;

        public void Test(TestA arg, TestB arg2, NamespaceTestC arg3, NamespaceTestF arg4)
        {
            conn.InternalCallReducer(new Reducer.Test(arg, arg2, arg3, arg4), this.SetCallReducerFlags.TestFlags);
        }

        public bool InvokeTest(ReducerEventContext ctx, Reducer.Test args)
        {
            if (OnTest == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnTest(
                ctx,
                args.Arg,
                args.Arg2,
                args.Arg3,
                args.Arg4
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class Test : Reducer, IReducerArgs
        {
            [DataMember(Name = "arg")]
            public TestA Arg;
            [DataMember(Name = "arg2")]
            public TestB Arg2;
            [DataMember(Name = "arg3")]
            public NamespaceTestC Arg3;
            [DataMember(Name = "arg4")]
            public NamespaceTestF Arg4;

            public Test(
                TestA Arg,
                TestB Arg2,
                NamespaceTestC Arg3,
                NamespaceTestF Arg4
            )
            {
                this.Arg = Arg;
                this.Arg2 = Arg2;
                this.Arg3 = Arg3;
                this.Arg4 = Arg4;
            }

            public Test()
            {
                this.Arg = new();
                this.Arg2 = new();
                this.Arg4 = null!;
            }

            string IReducerArgs.ReducerName => "test";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags TestFlags;
        public void Test(CallReducerFlags flags) => TestFlags = flags;
    }
}
'''
"Reducers/TestBtreeIndexArgs.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void TestBtreeIndexArgsHandler(ReducerEventContext ctx);
        public event TestBtreeIndexArgsHandler? OnTestBtreeIndexArgs;

        public void TestBtreeIndexArgs()
        {
            conn.InternalCallReducer(new Reducer.TestBtreeIndexArgs(), this.SetCallReducerFlags.TestBtreeIndexArgsFlags);
        }

        public bool InvokeTestBtreeIndexArgs(ReducerEventContext ctx, Reducer.TestBtreeIndexArgs args)
        {
            if (OnTestBtreeIndexArgs == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnTestBtreeIndexArgs(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class TestBtreeIndexArgs : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "test_btree_index_args";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags TestBtreeIndexArgsFlags;
        public void TestBtreeIndexArgs(CallReducerFlags flags) => TestBtreeIndexArgsFlags = flags;
    }
}
'''
"SpacetimeDBClient.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

VERSION_COMMENT

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        internal RemoteReducers(DbConnection conn, SetReducerFlags flags) : base(conn) => SetCallReducerFlags = flags;
        internal readonly SetReducerFlags SetCallReducerFlags;
        internal event Action<ReducerEventContext, Exception>? InternalOnUnhandledReducerError;
    }

    public sealed partial class RemoteTables : RemoteTablesBase
    {
        public RemoteTables(DbConnection conn)
        {
            AddTable(HasSpecialStuff = new(conn));
            AddTable(LoggedOutPlayer = new(conn));
            AddTable(Person = new(conn));
            AddTable(PkMultiIdentity = new(conn));
            AddTable(Player = new(conn));
            AddTable(Points = new(conn));
            AddTable(PrivateTable = new(conn));
            AddTable(RepeatingTestArg = new(conn));
            AddTable(TestA = new(conn));
            AddTable(TestD = new(conn));
            AddTable(TestE = new(conn));
            AddTable(TestF = new(conn));
        }
    }

    public sealed partial class SetReducerFlags { }

        public interface IRemoteDbContext : IDbContext<RemoteTables, RemoteReducers, SetReducerFlags, SubscriptionBuilder> {
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError;
        }

        public sealed class EventContext : IEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;

            /// <summary>
            /// The event that caused this callback to run.
            /// </summary>
            public readonly Event<Reducer> Event;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal EventContext(DbConnection conn, Event<Reducer> Event)
            {
                this.conn = conn;
                this.Event = Event;
            }
        }

        public sealed class ReducerEventContext : IReducerEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;
            /// <summary>
            /// The reducer event that caused this callback to run.
            /// </summary>
            public readonly ReducerEvent<Reducer> Event;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal ReducerEventContext(DbConnection conn, ReducerEvent<Reducer> reducerEvent)
            {
                this.conn = conn;
                Event = reducerEvent;
            }
        }

        public sealed class ErrorContext : IErrorContext, IRemoteDbContext
        {
            private readonly DbConnection conn;
            /// <summary>
            /// The <c>Exception</c> that caused this error callback to be run.
            /// </summary>
            public readonly Exception Event;
            Exception IErrorContext.Event {
                get {
                    return Event;
                }
            }

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal ErrorContext(DbConnection conn, Exception error)
            {
                this.conn = conn;
                Event = error;
            }
        }

        public sealed class SubscriptionEventContext : ISubscriptionEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal SubscriptionEventContext(DbConnection conn)
            {
                this.conn = conn;
            }
        }

        /// <summary>
        /// Builder-pattern constructor for subscription queries.
        /// </summary>
        public sealed class SubscriptionBuilder
        {
            private readonly IDbConnection conn;

            private event Action<SubscriptionEventContext>? Applied;
            private event Action<ErrorContext, Exception>? Error;

            /// <summary>
            /// Private API, use <c>conn.SubscriptionBuilder()</c> instead.
            /// </summary>
            public SubscriptionBuilder(IDbConnection conn)
            {
                this.conn = conn;
            }

            /// <summary>
            /// Register a callback to run when the subscription is applied.
            /// </summary>
            public SubscriptionBuilder OnApplied(
                Action<SubscriptionEventContext> callback
            )
            {
                Applied += callback;
                return this;
            }

            /// <summary>
            /// Register a callback to run when the subscription fails.
            ///
            /// Note that this callback may run either when attempting to apply the subscription,
            /// in which case <c>Self::on_applied</c> will never run,
            /// or later during the subscription's lifetime if the module's interface changes,
            /// in which case <c>Self::on_applied</c> may have already run.
            /// </summary>
            public SubscriptionBuilder OnError(
                Action<ErrorContext, Exception> callback
            )
            {
                Error += callback;
                return this;
            }

            /// <summary>
            /// Subscribe to the following SQL queries.
            ///
            /// This method returns immediately, with the data not yet added to the DbConnection.
            /// The provided callbacks will be invoked once the data is returned from the remote server.
            /// Data from all the provided queries will be returned at the same time.
            ///
            /// See the SpacetimeDB SQL docs for more information on SQL syntax:
            /// <a href="https://spacetimedb.com/docs/sql">https://spacetimedb.com/docs/sql</a>
            /// </summary>
            public SubscriptionHandle Subscribe(
                string[] querySqls
            ) => new(conn, Applied, Error, querySqls);

            /// <summary>
            /// Subscribe to all rows from all tables.
            ///
            /// This method is intended as a convenience
            /// for applications where client-side memory use and network bandwidth are not concerns.
            /// Applications where these resources are a constraint
            /// should register more precise queries via <c>Self.Subscribe</c>
            /// in order to replicate only the subset of data which the client needs to function.
            ///
            /// This method should not be combined with <c>Self.Subscribe</c> on the same <c>DbConnection</c>.
            /// A connection may either <c>Self.Subscribe</c> to particular queries,
            /// or <c>Self.SubscribeToAllTables</c>, but not both.
            /// Attempting to call <c>Self.Subscribe</c>
            /// on a <c>DbConnection</c> that has previously used <c>Self.SubscribeToAllTables</c>,
            /// or vice versa, may misbehave in any number of ways,
            /// including dropping subscriptions, corrupting the client cache, or panicking.
            /// </summary>
            public void SubscribeToAllTables()
            {
                // Make sure we use the legacy handle constructor here, even though there's only 1 query.
                // We drop the error handler, since it can't be called for legacy subscriptions.
                new SubscriptionHandle(
                    conn,
                    Applied,
                    new string[] { "SELECT * FROM *" }
                );
            }
        }

        public sealed class SubscriptionHandle : SubscriptionHandleBase<SubscriptionEventContext, ErrorContext> {
            /// <summary>
            /// Internal API. Construct <c>SubscriptionHandle</c>s using <c>conn.SubscriptionBuilder</c>.
            /// </summary>
            public SubscriptionHandle(IDbConnection conn, Action<SubscriptionEventContext>? onApplied, string[] querySqls) : base(conn, onApplied, querySqls)
            { }

            /// <summary>
            /// Internal API. Construct <c>SubscriptionHandle</c>s using <c>conn.SubscriptionBuilder</c>.
            /// </summary>
            public SubscriptionHandle(
                IDbConnection conn,
                Action<SubscriptionEventContext>? onApplied,
                Action<ErrorContext, Exception>? onError,
                string[] querySqls
            ) : base(conn, onApplied, onError, querySqls)
            { }
        }

    public abstract partial class Reducer
    {
        private Reducer() { }
    }

    public sealed class DbConnection : DbConnectionBase<DbConnection, RemoteTables, Reducer>
    {
        public override RemoteTables Db { get; }
        public readonly RemoteReducers Reducers;
        public readonly SetReducerFlags SetReducerFlags = new();

        public DbConnection()
        {
            Db = new(this);
            Reducers = new(this, SetReducerFlags);
        }

        protected override Reducer ToReducer(TransactionUpdate update)
        {
            var encodedArgs = update.ReducerCall.Args;
            return update.ReducerCall.ReducerName switch {
                "add" => BSATNHelpers.Decode<Reducer.Add>(encodedArgs),
                "add_player" => BSATNHelpers.Decode<Reducer.AddPlayer>(encodedArgs),
                "add_private" => BSATNHelpers.Decode<Reducer.AddPrivate>(encodedArgs),
                "assert_caller_identity_is_module_identity" => BSATNHelpers.Decode<Reducer.AssertCallerIdentityIsModuleIdentity>(encodedArgs),
                "client_connected" => BSATNHelpers.Decode<Reducer.ClientConnected>(encodedArgs),
                "delete_player" => BSATNHelpers.Decode<Reducer.DeletePlayer>(encodedArgs),
                "delete_players_by_name" => BSATNHelpers.Decode<Reducer.DeletePlayersByName>(encodedArgs),
                "list_over_age" => BSATNHelpers.Decode<Reducer.ListOverAge>(encodedArgs),
                "log_module_identity" => BSATNHelpers.Decode<Reducer.LogModuleIdentity>(encodedArgs),
                "query_private" => BSATNHelpers.Decode<Reducer.QueryPrivate>(encodedArgs),
                "repeating_test" => BSATNHelpers.Decode<Reducer.RepeatingTest>(encodedArgs),
                "say_hello" => BSATNHelpers.Decode<Reducer.SayHello>(encodedArgs),
                "test" => BSATNHelpers.Decode<Reducer.Test>(encodedArgs),
                "test_btree_index_args" => BSATNHelpers.Decode<Reducer.TestBtreeIndexArgs>(encodedArgs),
                "" => throw new SpacetimeDBEmptyReducerNameException("Reducer name is empty"),
                var reducer => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        protected override IEventContext ToEventContext(Event<Reducer> Event) =>
        new EventContext(this, Event);

        protected override IReducerEventContext ToReducerEventContext(ReducerEvent<Reducer> reducerEvent) =>
        new ReducerEventContext(this, reducerEvent);

        protected override ISubscriptionEventContext MakeSubscriptionEventContext() =>
        new SubscriptionEventContext(this);

        protected override IErrorContext ToErrorContext(Exception exception) =>
        new ErrorContext(this, exception);

        protected override bool Dispatch(IReducerEventContext context, Reducer reducer)
        {
            var eventContext = (ReducerEventContext)context;
            return reducer switch {
                Reducer.Add args => Reducers.InvokeAdd(eventContext, args),
                Reducer.AddPlayer args => Reducers.InvokeAddPlayer(eventContext, args),
                Reducer.AddPrivate args => Reducers.InvokeAddPrivate(eventContext, args),
                Reducer.AssertCallerIdentityIsModuleIdentity args => Reducers.InvokeAssertCallerIdentityIsModuleIdentity(eventContext, args),
                Reducer.ClientConnected args => Reducers.InvokeClientConnected(eventContext, args),
                Reducer.DeletePlayer args => Reducers.InvokeDeletePlayer(eventContext, args),
                Reducer.DeletePlayersByName args => Reducers.InvokeDeletePlayersByName(eventContext, args),
                Reducer.ListOverAge args => Reducers.InvokeListOverAge(eventContext, args),
                Reducer.LogModuleIdentity args => Reducers.InvokeLogModuleIdentity(eventContext, args),
                Reducer.QueryPrivate args => Reducers.InvokeQueryPrivate(eventContext, args),
                Reducer.RepeatingTest args => Reducers.InvokeRepeatingTest(eventContext, args),
                Reducer.SayHello args => Reducers.InvokeSayHello(eventContext, args),
                Reducer.Test args => Reducers.InvokeTest(eventContext, args),
                Reducer.TestBtreeIndexArgs args => Reducers.InvokeTestBtreeIndexArgs(eventContext, args),
                _ => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        public SubscriptionBuilder SubscriptionBuilder() => new(this);
        public event Action<ReducerEventContext, Exception> OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }
    }
}
'''
"Tables/HasSpecialStuff.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class HasSpecialStuffHandle : RemoteTableHandle<EventContext, HasSpecialStuff>
        {
            protected override string RemoteTableName => "has_special_stuff";

            internal HasSpecialStuffHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly HasSpecialStuffHandle HasSpecialStuff;
    }
}
'''
"Tables/LoggedOutPlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class LoggedOutPlayerHandle : RemoteTableHandle<EventContext, Player>
        {
            protected override string RemoteTableName => "logged_out_player";

            public sealed class IdentityUniqueIndex : UniqueIndexBase<SpacetimeDB.Identity>
            {
                protected override SpacetimeDB.Identity GetKey(Player row) => row.Identity;

                public IdentityUniqueIndex(LoggedOutPlayerHandle table) : base(table) { }
            }

            public readonly IdentityUniqueIndex Identity;

            public sealed class NameUniqueIndex : UniqueIndexBase<string>
            {
                protected override string GetKey(Player row) => row.Name;

                public NameUniqueIndex(LoggedOutPlayerHandle table) : base(table) { }
            }

            public readonly NameUniqueIndex Name;

            public sealed class PlayerIdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(Player row) => row.PlayerId;

                public PlayerIdUniqueIndex(LoggedOutPlayerHandle table) : base(table) { }
            }

            public readonly PlayerIdUniqueIndex PlayerId;

            internal LoggedOutPlayerHandle(DbConnection conn) : base(conn)
            {
                Identity = new(this);
                Name = new(this);
                PlayerId = new(this);
            }

            protected override object GetPrimaryKey(Player row) => row.Identity;
        }

        public readonly LoggedOutPlayerHandle LoggedOutPlayer;
    }
}
'''
"Tables/Person.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PersonHandle : RemoteTableHandle<EventContext, Person>
        {
            protected override string RemoteTableName => "person";

            public sealed class AgeIndex : BTreeIndexBase<byte>
            {
                protected override byte GetKey(Person row) => row.Age;

                public AgeIndex(PersonHandle table) : base(table) { }
            }

            public readonly AgeIndex Age;

            public sealed class IdUniqueIndex : UniqueIndexBase<uint>
            {
                protected override uint GetKey(Person row) => row.Id;

                public IdUniqueIndex(PersonHandle table) : base(table) { }
            }

            public readonly IdUniqueIndex Id;

            internal PersonHandle(DbConnection conn) : base(conn)
            {
                Age = new(this);
                Id = new(this);
            }

            protected override object GetPrimaryKey(Person row) => row.Id;
        }

        public readonly PersonHandle Person;
    }
}
'''
"Tables/PkMultiIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PkMultiIdentityHandle : RemoteTableHandle<EventContext, PkMultiIdentity>
        {
            protected override string RemoteTableName => "pk_multi_identity";

            public sealed class IdUniqueIndex : UniqueIndexBase<uint>
            {
                protected override uint GetKey(PkMultiIdentity row) => row.Id;

                public IdUniqueIndex(PkMultiIdentityHandle table) : base(table) { }
            }

            public readonly IdUniqueIndex Id;

            public sealed class OtherUniqueIndex : UniqueIndexBase<uint>
            {
                protected override uint GetKey(PkMultiIdentity row) => row.Other;

                public OtherUniqueIndex(PkMultiIdentityHandle table) : base(table) { }
            }

            public readonly OtherUniqueIndex Other;

            internal PkMultiIdentityHandle(DbConnection conn) : base(conn)
            {
                Id = new(this);
                Other = new(this);
            }

            protected override object GetPrimaryKey(PkMultiIdentity row) => row.Id;
        }

        public readonly PkMultiIdentityHandle PkMultiIdentity;
    }
}
'''
"Tables/Player.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PlayerHandle : RemoteTableHandle<EventContext, Player>
        {
            protected override string RemoteTableName => "player";

            public sealed class IdentityUniqueIndex : UniqueIndexBase<SpacetimeDB.Identity>
            {
                protected override SpacetimeDB.Identity GetKey(Player row) => row.Identity;

                public IdentityUniqueIndex(PlayerHandle table) : base(table) { }
            }

            public readonly IdentityUniqueIndex Identity;

            public sealed class NameUniqueIndex : UniqueIndexBase<string>
            {
                protected override string GetKey(Player row) => row.Name;

                public NameUniqueIndex(PlayerHandle table) : base(table) { }
            }

            public readonly NameUniqueIndex Name;

            public sealed class PlayerIdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(Player row) => row.PlayerId;

                public PlayerIdUniqueIndex(PlayerHandle table) : base(table) { }
            }

            public readonly PlayerIdUniqueIndex PlayerId;

            internal PlayerHandle(DbConnection conn) : base(conn)
            {
                Identity = new(this);
                Name = new(this);
                PlayerId = new(this);
            }

            protected override object GetPrimaryKey(Player row) => row.Identity;
        }

        public readonly PlayerHandle Player;
    }
}
'''
"Tables/Points.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PointsHandle : RemoteTableHandle<EventContext, Point>
        {
            protected override string RemoteTableName => "points";

            public sealed class MultiColumnIndexIndex : BTreeIndexBase<(long X, long Y)>
            {
                protected override (long X, long Y) GetKey(Point row) => (row.X, row.Y);

                public MultiColumnIndexIndex(PointsHandle table) : base(table) { }
            }

            public readonly MultiColumnIndexIndex MultiColumnIndex;

            internal PointsHandle(DbConnection conn) : base(conn)
            {
                MultiColumnIndex = new(this);
            }
        }

        public readonly PointsHandle Points;
    }
}
'''
"Tables/PrivateTable.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PrivateTableHandle : RemoteTableHandle<EventContext, PrivateTable>
        {
            protected override string RemoteTableName => "private_table";

            internal PrivateTableHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly PrivateTableHandle PrivateTable;
    }
}
'''
"Tables/RepeatingTestArg.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class RepeatingTestArgHandle : RemoteTableHandle<EventContext, RepeatingTestArg>
        {
            protected override string RemoteTableName => "repeating_test_arg";

            public sealed class ScheduledIdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(RepeatingTestArg row) => row.ScheduledId;

                public ScheduledIdUniqueIndex(RepeatingTestArgHandle table) : base(table) { }
            }

            public readonly ScheduledIdUniqueIndex ScheduledId;

            internal RepeatingTestArgHandle(DbConnection conn) : base(conn)
            {
                ScheduledId = new(this);
            }

            protected override object GetPrimaryKey(RepeatingTestArg row) => row.ScheduledId;
        }

        public readonly RepeatingTestArgHandle RepeatingTestArg;
    }
}
'''
"Tables/TestA.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestAHandle : RemoteTableHandle<EventContext, TestA>
        {
            protected override string RemoteTableName => "test_a";

            public sealed class FooIndex : BTreeIndexBase<uint>
            {
                protected override uint GetKey(TestA row) => row.X;

                public FooIndex(TestAHandle table) : base(table) { }
            }

            public readonly FooIndex Foo;

            internal TestAHandle(DbConnection conn) : base(conn)
            {
                Foo = new(this);
            }
        }

        public readonly TestAHandle TestA;
    }
}
'''
"Tables/TestD.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestDHandle : RemoteTableHandle<EventContext, TestD>
        {
            protected override string RemoteTableName => "test_d";

            internal TestDHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly TestDHandle TestD;
    }
}
'''
"Tables/TestE.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestEHandle : RemoteTableHandle<EventContext, TestE>
        {
            protected override string RemoteTableName => "test_e";

            public sealed class IdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(TestE row) => row.Id;

                public IdUniqueIndex(TestEHandle table) : base(table) { }
            }

            public readonly IdUniqueIndex Id;

            public sealed class NameIndex : BTreeIndexBase<string>
            {
                protected override string GetKey(TestE row) => row.Name;

                public NameIndex(TestEHandle table) : base(table) { }
            }

            public readonly NameIndex Name;

            internal TestEHandle(DbConnection conn) : base(conn)
            {
                Id = new(this);
                Name = new(this);
            }

            protected override object GetPrimaryKey(TestE row) => row.Id;
        }

        public readonly TestEHandle TestE;
    }
}
'''
"Tables/TestF.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestFHandle : RemoteTableHandle<EventContext, TestFoobar>
        {
            protected override string RemoteTableName => "test_f";

            internal TestFHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly TestFHandle TestF;
    }
}
'''
"Types/Baz.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Baz
    {
        [DataMember(Name = "field")]
        public string Field;

        public Baz(string Field)
        {
            this.Field = Field;
        }

        public Baz()
        {
            this.Field = "";
        }
    }
}
'''
"Types/Foobar.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    public partial record Foobar : SpacetimeDB.TaggedEnum<(
        Baz Baz,
        SpacetimeDB.Unit Bar,
        uint Har
    )>;
}
'''
"Types/HasSpecialStuff.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class HasSpecialStuff
    {
        [DataMember(Name = "identity")]
        public SpacetimeDB.Identity Identity;
        [DataMember(Name = "connection_id")]
        public SpacetimeDB.ConnectionId ConnectionId;

        public HasSpecialStuff(
            SpacetimeDB.Identity Identity,
            SpacetimeDB.ConnectionId ConnectionId
        )
        {
            this.Identity = Identity;
            this.ConnectionId = ConnectionId;
        }

        public HasSpecialStuff()
        {
        }
    }
}
'''
"Types/NamespaceTestC.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    public enum NamespaceTestC
    {
        Foo,
        Bar,
    }
}
'''
"Types/NamespaceTestF.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    public partial record NamespaceTestF : SpacetimeDB.TaggedEnum<(
        SpacetimeDB.Unit Foo,
        SpacetimeDB.Unit Bar,
        string Baz
    )>;
}
'''
"Types/Person.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Person
    {
        [DataMember(Name = "id")]
        public uint Id;
        [DataMember(Name = "name")]
        public string Name;
        [DataMember(Name = "age")]
        public byte Age;

        public Person(
            uint Id,
            string Name,
            byte Age
        )
        {
            this.Id = Id;
            this.Name = Name;
            this.Age = Age;
        }

        public Person()
        {
            this.Name = "";
        }
    }
}
'''
"Types/PkMultiIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class PkMultiIdentity
    {
        [DataMember(Name = "id")]
        public uint Id;
        [DataMember(Name = "other")]
        public uint Other;

        public PkMultiIdentity(
            uint Id,
            uint Other
        )
        {
            this.Id = Id;
            this.Other = Other;
        }

        public PkMultiIdentity()
        {
        }
    }
}
'''
"Types/Player.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Player
    {
        [DataMember(Name = "identity")]
        public SpacetimeDB.Identity Identity;
        [DataMember(Name = "player_id")]
        public ulong PlayerId;
        [DataMember(Name = "name")]
        public string Name;

        public Player(
            SpacetimeDB.Identity Identity,
            ulong PlayerId,
            string Name
        )
        {
            this.Identity = Identity;
            this.PlayerId = PlayerId;
            this.Name = Name;
        }

        public Player()
        {
            this.Name = "";
        }
    }
}
'''
"Types/Point.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Point
    {
        [DataMember(Name = "x")]
        public long X;
        [DataMember(Name = "y")]
        public long Y;

        public Point(
            long X,
            long Y
        )
        {
            this.X = X;
            this.Y = Y;
        }

        public Point()
        {
        }
    }
}
'''
"Types/PrivateTable.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class PrivateTable
    {
        [DataMember(Name = "name")]
        public string Name;

        public PrivateTable(string Name)
        {
            this.Name = Name;
        }

        public PrivateTable()
        {
            this.Name = "";
        }
    }
}
'''
"Types/RepeatingTestArg.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class RepeatingTestArg
    {
        [DataMember(Name = "scheduled_id")]
        public ulong ScheduledId;
        [DataMember(Name = "scheduled_at")]
        public SpacetimeDB.ScheduleAt ScheduledAt;
        [DataMember(Name = "prev_time")]
        public SpacetimeDB.Timestamp PrevTime;

        public RepeatingTestArg(
            ulong ScheduledId,
            SpacetimeDB.ScheduleAt ScheduledAt,
            SpacetimeDB.Timestamp PrevTime
        )
        {
            this.ScheduledId = ScheduledId;
            this.ScheduledAt = ScheduledAt;
            this.PrevTime = PrevTime;
        }

        public RepeatingTestArg()
        {
            this.ScheduledAt = null!;
        }
    }
}
'''
"Types/TestA.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestA
    {
        [DataMember(Name = "x")]
        public uint X;
        [DataMember(Name = "y")]
        public uint Y;
        [DataMember(Name = "z")]
        public string Z;

        public TestA(
            uint X,
            uint Y,
            string Z
        )
        {
            this.X = X;
            this.Y = Y;
            this.Z = Z;
        }

        public TestA()
        {
            this.Z = "";
        }
    }
}
'''
"Types/TestB.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestB
    {
        [DataMember(Name = "foo")]
        public string Foo;

        public TestB(string Foo)
        {
            this.Foo = Foo;
        }

        public TestB()
        {
            this.Foo = "";
        }
    }
}
'''
"Types/TestD.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestD
    {
        [DataMember(Name = "test_c")]
        public NamespaceTestC? TestC;

        public TestD(NamespaceTestC? TestC)
        {
            this.TestC = TestC;
        }

        public TestD()
        {
        }
    }
}
'''
"Types/TestE.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestE
    {
        [DataMember(Name = "id")]
        public ulong Id;
        [DataMember(Name = "name")]
        public string Name;

        public TestE(
            ulong Id,
            string Name
        )
        {
            this.Id = Id;
            this.Name = Name;
        }

        public TestE()
        {
            this.Name = "";
        }
    }
}
'''
"Types/TestFoobar.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestFoobar
    {
        [DataMember(Name = "field")]
        public Foobar Field;

        public TestFoobar(Foobar Field)
        {
            this.Field = Field;
        }

        public TestFoobar()
        {
            this.Field = null!;
        }
    }
}
'''
