---
source: crates/codegen/tests/codegen.rs
assertion_line: 37
expression: outfiles
---
"Procedures/GetMySchemaViaHttp.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteProcedures : RemoteBase
    {
        public void GetMySchemaViaHttp(ProcedureCallback<string> callback)
        {
            // Convert the clean callback to the wrapper callback
            InternalGetMySchemaViaHttp((ctx, result) => {
            if (result.IsSuccess && result.Value != null)
            {
                callback(ctx, ProcedureCallbackResult<string>.Success(result.Value.Value));
            }
            else
            {
                callback(ctx, ProcedureCallbackResult<string>.Failure(result.Error!));
            }
            });
        }

        private void InternalGetMySchemaViaHttp(ProcedureCallback<Procedure.GetMySchemaViaHttp> callback)
        {
            conn.InternalCallProcedure(new Procedure.GetMySchemaViaHttpArgs(), callback);
        }

    }

    public abstract partial class Procedure
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class GetMySchemaViaHttp
        {
            [DataMember(Name = "Value")]
            public string Value;

            public GetMySchemaViaHttp(string Value)
            {
                this.Value = Value;
            }

            public GetMySchemaViaHttp()
            {
                this.Value = "";
            }
        }
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class GetMySchemaViaHttpArgs : Procedure, IProcedureArgs
        {
            string IProcedureArgs.ProcedureName => "get_my_schema_via_http";
        }

    }
}
'''
"Procedures/ReturnValue.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteProcedures : RemoteBase
    {
        public void ReturnValue(ulong foo, ProcedureCallback<SpacetimeDB.Baz> callback)
        {
            // Convert the clean callback to the wrapper callback
            InternalReturnValue(foo, (ctx, result) => {
            if (result.IsSuccess && result.Value != null)
            {
                callback(ctx, ProcedureCallbackResult<SpacetimeDB.Baz>.Success(result.Value.Value));
            }
            else
            {
                callback(ctx, ProcedureCallbackResult<SpacetimeDB.Baz>.Failure(result.Error!));
            }
            });
        }

        private void InternalReturnValue(ulong foo, ProcedureCallback<Procedure.ReturnValue> callback)
        {
            conn.InternalCallProcedure(new Procedure.ReturnValueArgs(foo), callback);
        }

    }

    public abstract partial class Procedure
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class ReturnValue
        {
            [DataMember(Name = "Value")]
            public SpacetimeDB.Baz Value;

            public ReturnValue(SpacetimeDB.Baz Value)
            {
                this.Value = Value;
            }

            public ReturnValue()
            {
                this.Value = new();
            }
        }
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class ReturnValueArgs : Procedure, IProcedureArgs
        {
            [DataMember(Name = "foo")]
            public ulong Foo;

            public ReturnValueArgs(ulong Foo)
            {
                this.Foo = Foo;
            }

            public ReturnValueArgs()
            {
            }

            string IProcedureArgs.ProcedureName => "return_value";
        }

    }
}
'''
"Procedures/SleepOneSecond.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteProcedures : RemoteBase
    {
        public void SleepOneSecond(ProcedureCallback<SpacetimeDB.Unit> callback)
        {
            // Convert the clean callback to the wrapper callback
            InternalSleepOneSecond((ctx, result) => {
            if (result.IsSuccess && result.Value != null)
            {
                callback(ctx, ProcedureCallbackResult<SpacetimeDB.Unit>.Success(result.Value.Value));
            }
            else
            {
                callback(ctx, ProcedureCallbackResult<SpacetimeDB.Unit>.Failure(result.Error!));
            }
            });
        }

        private void InternalSleepOneSecond(ProcedureCallback<Procedure.SleepOneSecond> callback)
        {
            conn.InternalCallProcedure(new Procedure.SleepOneSecondArgs(), callback);
        }

    }

    public abstract partial class Procedure
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class SleepOneSecond
        {
            [DataMember(Name = "Value")]
            public SpacetimeDB.Unit Value;

            public SleepOneSecond(SpacetimeDB.Unit Value)
            {
                this.Value = Value;
            }

            public SleepOneSecond()
            {
            }
        }
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class SleepOneSecondArgs : Procedure, IProcedureArgs
        {
            string IProcedureArgs.ProcedureName => "sleep_one_second";
        }

    }
}
'''
"Procedures/WithTx.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteProcedures : RemoteBase
    {
        public void WithTx(ProcedureCallback<SpacetimeDB.Unit> callback)
        {
            // Convert the clean callback to the wrapper callback
            InternalWithTx((ctx, result) => {
            if (result.IsSuccess && result.Value != null)
            {
                callback(ctx, ProcedureCallbackResult<SpacetimeDB.Unit>.Success(result.Value.Value));
            }
            else
            {
                callback(ctx, ProcedureCallbackResult<SpacetimeDB.Unit>.Failure(result.Error!));
            }
            });
        }

        private void InternalWithTx(ProcedureCallback<Procedure.WithTx> callback)
        {
            conn.InternalCallProcedure(new Procedure.WithTxArgs(), callback);
        }

    }

    public abstract partial class Procedure
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class WithTx
        {
            [DataMember(Name = "Value")]
            public SpacetimeDB.Unit Value;

            public WithTx(SpacetimeDB.Unit Value)
            {
                this.Value = Value;
            }

            public WithTx()
            {
            }
        }
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class WithTxArgs : Procedure, IProcedureArgs
        {
            string IProcedureArgs.ProcedureName => "with_tx";
        }

    }
}
'''
"Reducers/Add.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AddHandler(ReducerEventContext ctx, string name, byte age);
        public event AddHandler? OnAdd;

        public void Add(string name, byte age)
        {
            conn.InternalCallReducer(new Reducer.Add(name, age), this.SetCallReducerFlags.AddFlags);
        }

        public bool InvokeAdd(ReducerEventContext ctx, Reducer.Add args)
        {
            if (OnAdd == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAdd(
                ctx,
                args.Name,
                args.Age
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class Add : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;
            [DataMember(Name = "age")]
            public byte Age;

            public Add(
                string Name,
                byte Age
            )
            {
                this.Name = Name;
                this.Age = Age;
            }

            public Add()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "add";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AddFlags;
        public void Add(CallReducerFlags flags) => AddFlags = flags;
    }
}
'''
"Reducers/AddPlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AddPlayerHandler(ReducerEventContext ctx, string name);
        public event AddPlayerHandler? OnAddPlayer;

        public void AddPlayer(string name)
        {
            conn.InternalCallReducer(new Reducer.AddPlayer(name), this.SetCallReducerFlags.AddPlayerFlags);
        }

        public bool InvokeAddPlayer(ReducerEventContext ctx, Reducer.AddPlayer args)
        {
            if (OnAddPlayer == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAddPlayer(
                ctx,
                args.Name
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class AddPlayer : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;

            public AddPlayer(string Name)
            {
                this.Name = Name;
            }

            public AddPlayer()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "add_player";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AddPlayerFlags;
        public void AddPlayer(CallReducerFlags flags) => AddPlayerFlags = flags;
    }
}
'''
"Reducers/AddPrivate.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AddPrivateHandler(ReducerEventContext ctx, string name);
        public event AddPrivateHandler? OnAddPrivate;

        public void AddPrivate(string name)
        {
            conn.InternalCallReducer(new Reducer.AddPrivate(name), this.SetCallReducerFlags.AddPrivateFlags);
        }

        public bool InvokeAddPrivate(ReducerEventContext ctx, Reducer.AddPrivate args)
        {
            if (OnAddPrivate == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAddPrivate(
                ctx,
                args.Name
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class AddPrivate : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;

            public AddPrivate(string Name)
            {
                this.Name = Name;
            }

            public AddPrivate()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "add_private";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AddPrivateFlags;
        public void AddPrivate(CallReducerFlags flags) => AddPrivateFlags = flags;
    }
}
'''
"Reducers/AssertCallerIdentityIsModuleIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void AssertCallerIdentityIsModuleIdentityHandler(ReducerEventContext ctx);
        public event AssertCallerIdentityIsModuleIdentityHandler? OnAssertCallerIdentityIsModuleIdentity;

        public void AssertCallerIdentityIsModuleIdentity()
        {
            conn.InternalCallReducer(new Reducer.AssertCallerIdentityIsModuleIdentity(), this.SetCallReducerFlags.AssertCallerIdentityIsModuleIdentityFlags);
        }

        public bool InvokeAssertCallerIdentityIsModuleIdentity(ReducerEventContext ctx, Reducer.AssertCallerIdentityIsModuleIdentity args)
        {
            if (OnAssertCallerIdentityIsModuleIdentity == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnAssertCallerIdentityIsModuleIdentity(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class AssertCallerIdentityIsModuleIdentity : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "assert_caller_identity_is_module_identity";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags AssertCallerIdentityIsModuleIdentityFlags;
        public void AssertCallerIdentityIsModuleIdentity(CallReducerFlags flags) => AssertCallerIdentityIsModuleIdentityFlags = flags;
    }
}
'''
"Reducers/ClientConnected.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void ClientConnectedHandler(ReducerEventContext ctx);
        public event ClientConnectedHandler? OnClientConnected;

        public bool InvokeClientConnected(ReducerEventContext ctx, Reducer.ClientConnected args)
        {
            if (OnClientConnected == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnClientConnected(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class ClientConnected : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "client_connected";
        }
    }
}
'''
"Reducers/DeletePlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void DeletePlayerHandler(ReducerEventContext ctx, ulong id);
        public event DeletePlayerHandler? OnDeletePlayer;

        public void DeletePlayer(ulong id)
        {
            conn.InternalCallReducer(new Reducer.DeletePlayer(id), this.SetCallReducerFlags.DeletePlayerFlags);
        }

        public bool InvokeDeletePlayer(ReducerEventContext ctx, Reducer.DeletePlayer args)
        {
            if (OnDeletePlayer == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnDeletePlayer(
                ctx,
                args.Id
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class DeletePlayer : Reducer, IReducerArgs
        {
            [DataMember(Name = "id")]
            public ulong Id;

            public DeletePlayer(ulong Id)
            {
                this.Id = Id;
            }

            public DeletePlayer()
            {
            }

            string IReducerArgs.ReducerName => "delete_player";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags DeletePlayerFlags;
        public void DeletePlayer(CallReducerFlags flags) => DeletePlayerFlags = flags;
    }
}
'''
"Reducers/DeletePlayersByName.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void DeletePlayersByNameHandler(ReducerEventContext ctx, string name);
        public event DeletePlayersByNameHandler? OnDeletePlayersByName;

        public void DeletePlayersByName(string name)
        {
            conn.InternalCallReducer(new Reducer.DeletePlayersByName(name), this.SetCallReducerFlags.DeletePlayersByNameFlags);
        }

        public bool InvokeDeletePlayersByName(ReducerEventContext ctx, Reducer.DeletePlayersByName args)
        {
            if (OnDeletePlayersByName == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnDeletePlayersByName(
                ctx,
                args.Name
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class DeletePlayersByName : Reducer, IReducerArgs
        {
            [DataMember(Name = "name")]
            public string Name;

            public DeletePlayersByName(string Name)
            {
                this.Name = Name;
            }

            public DeletePlayersByName()
            {
                this.Name = "";
            }

            string IReducerArgs.ReducerName => "delete_players_by_name";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags DeletePlayersByNameFlags;
        public void DeletePlayersByName(CallReducerFlags flags) => DeletePlayersByNameFlags = flags;
    }
}
'''
"Reducers/ListOverAge.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void ListOverAgeHandler(ReducerEventContext ctx, byte age);
        public event ListOverAgeHandler? OnListOverAge;

        public void ListOverAge(byte age)
        {
            conn.InternalCallReducer(new Reducer.ListOverAge(age), this.SetCallReducerFlags.ListOverAgeFlags);
        }

        public bool InvokeListOverAge(ReducerEventContext ctx, Reducer.ListOverAge args)
        {
            if (OnListOverAge == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnListOverAge(
                ctx,
                args.Age
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class ListOverAge : Reducer, IReducerArgs
        {
            [DataMember(Name = "age")]
            public byte Age;

            public ListOverAge(byte Age)
            {
                this.Age = Age;
            }

            public ListOverAge()
            {
            }

            string IReducerArgs.ReducerName => "list_over_age";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags ListOverAgeFlags;
        public void ListOverAge(CallReducerFlags flags) => ListOverAgeFlags = flags;
    }
}
'''
"Reducers/LogModuleIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void LogModuleIdentityHandler(ReducerEventContext ctx);
        public event LogModuleIdentityHandler? OnLogModuleIdentity;

        public void LogModuleIdentity()
        {
            conn.InternalCallReducer(new Reducer.LogModuleIdentity(), this.SetCallReducerFlags.LogModuleIdentityFlags);
        }

        public bool InvokeLogModuleIdentity(ReducerEventContext ctx, Reducer.LogModuleIdentity args)
        {
            if (OnLogModuleIdentity == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnLogModuleIdentity(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class LogModuleIdentity : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "log_module_identity";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags LogModuleIdentityFlags;
        public void LogModuleIdentity(CallReducerFlags flags) => LogModuleIdentityFlags = flags;
    }
}
'''
"Reducers/QueryPrivate.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void QueryPrivateHandler(ReducerEventContext ctx);
        public event QueryPrivateHandler? OnQueryPrivate;

        public void QueryPrivate()
        {
            conn.InternalCallReducer(new Reducer.QueryPrivate(), this.SetCallReducerFlags.QueryPrivateFlags);
        }

        public bool InvokeQueryPrivate(ReducerEventContext ctx, Reducer.QueryPrivate args)
        {
            if (OnQueryPrivate == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnQueryPrivate(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class QueryPrivate : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "query_private";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags QueryPrivateFlags;
        public void QueryPrivate(CallReducerFlags flags) => QueryPrivateFlags = flags;
    }
}
'''
"Reducers/RepeatingTest.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void RepeatingTestHandler(ReducerEventContext ctx, SpacetimeDB.RepeatingTestArg arg);
        public event RepeatingTestHandler? OnRepeatingTest;

        public void RepeatingTest(SpacetimeDB.RepeatingTestArg arg)
        {
            conn.InternalCallReducer(new Reducer.RepeatingTest(arg), this.SetCallReducerFlags.RepeatingTestFlags);
        }

        public bool InvokeRepeatingTest(ReducerEventContext ctx, Reducer.RepeatingTest args)
        {
            if (OnRepeatingTest == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnRepeatingTest(
                ctx,
                args.Arg
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class RepeatingTest : Reducer, IReducerArgs
        {
            [DataMember(Name = "arg")]
            public RepeatingTestArg Arg;

            public RepeatingTest(RepeatingTestArg Arg)
            {
                this.Arg = Arg;
            }

            public RepeatingTest()
            {
                this.Arg = new();
            }

            string IReducerArgs.ReducerName => "repeating_test";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags RepeatingTestFlags;
        public void RepeatingTest(CallReducerFlags flags) => RepeatingTestFlags = flags;
    }
}
'''
"Reducers/SayHello.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void SayHelloHandler(ReducerEventContext ctx);
        public event SayHelloHandler? OnSayHello;

        public void SayHello()
        {
            conn.InternalCallReducer(new Reducer.SayHello(), this.SetCallReducerFlags.SayHelloFlags);
        }

        public bool InvokeSayHello(ReducerEventContext ctx, Reducer.SayHello args)
        {
            if (OnSayHello == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnSayHello(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class SayHello : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "say_hello";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags SayHelloFlags;
        public void SayHello(CallReducerFlags flags) => SayHelloFlags = flags;
    }
}
'''
"Reducers/Test.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void TestHandler(ReducerEventContext ctx, SpacetimeDB.TestA arg, SpacetimeDB.TestB arg2, SpacetimeDB.NamespaceTestC arg3, SpacetimeDB.NamespaceTestF arg4);
        public event TestHandler? OnTest;

        public void Test(SpacetimeDB.TestA arg, SpacetimeDB.TestB arg2, SpacetimeDB.NamespaceTestC arg3, SpacetimeDB.NamespaceTestF arg4)
        {
            conn.InternalCallReducer(new Reducer.Test(arg, arg2, arg3, arg4), this.SetCallReducerFlags.TestFlags);
        }

        public bool InvokeTest(ReducerEventContext ctx, Reducer.Test args)
        {
            if (OnTest == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnTest(
                ctx,
                args.Arg,
                args.Arg2,
                args.Arg3,
                args.Arg4
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class Test : Reducer, IReducerArgs
        {
            [DataMember(Name = "arg")]
            public TestA Arg;
            [DataMember(Name = "arg2")]
            public TestB Arg2;
            [DataMember(Name = "arg3")]
            public NamespaceTestC Arg3;
            [DataMember(Name = "arg4")]
            public NamespaceTestF Arg4;

            public Test(
                TestA Arg,
                TestB Arg2,
                NamespaceTestC Arg3,
                NamespaceTestF Arg4
            )
            {
                this.Arg = Arg;
                this.Arg2 = Arg2;
                this.Arg3 = Arg3;
                this.Arg4 = Arg4;
            }

            public Test()
            {
                this.Arg = new();
                this.Arg2 = new();
                this.Arg4 = null!;
            }

            string IReducerArgs.ReducerName => "test";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags TestFlags;
        public void Test(CallReducerFlags flags) => TestFlags = flags;
    }
}
'''
"Reducers/TestBtreeIndexArgs.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        public delegate void TestBtreeIndexArgsHandler(ReducerEventContext ctx);
        public event TestBtreeIndexArgsHandler? OnTestBtreeIndexArgs;

        public void TestBtreeIndexArgs()
        {
            conn.InternalCallReducer(new Reducer.TestBtreeIndexArgs(), this.SetCallReducerFlags.TestBtreeIndexArgsFlags);
        }

        public bool InvokeTestBtreeIndexArgs(ReducerEventContext ctx, Reducer.TestBtreeIndexArgs args)
        {
            if (OnTestBtreeIndexArgs == null)
            {
                if (InternalOnUnhandledReducerError != null)
                {
                    switch(ctx.Event.Status)
                    {
                        case Status.Failed(var reason): InternalOnUnhandledReducerError(ctx, new Exception(reason)); break;
                        case Status.OutOfEnergy(var _): InternalOnUnhandledReducerError(ctx, new Exception("out of energy")); break;
                    }
                }
                return false;
            }
            OnTestBtreeIndexArgs(
                ctx
            );
            return true;
        }
    }

    public abstract partial class Reducer
    {
        [SpacetimeDB.Type]
        [DataContract]
        public sealed partial class TestBtreeIndexArgs : Reducer, IReducerArgs
        {
            string IReducerArgs.ReducerName => "test_btree_index_args";
        }
    }

    public sealed partial class SetReducerFlags
    {
        internal CallReducerFlags TestBtreeIndexArgsFlags;
        public void TestBtreeIndexArgs(CallReducerFlags flags) => TestBtreeIndexArgsFlags = flags;
    }
}
'''
"SpacetimeDBClient.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

VERSION_COMMENT

#nullable enable

using System;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteReducers : RemoteBase
    {
        internal RemoteReducers(DbConnection conn, SetReducerFlags flags) : base(conn) => SetCallReducerFlags = flags;
        internal readonly SetReducerFlags SetCallReducerFlags;
        internal event Action<ReducerEventContext, Exception>? InternalOnUnhandledReducerError;
    }

    public sealed partial class RemoteProcedures : RemoteBase
    {
        internal RemoteProcedures(DbConnection conn) : base(conn) { }
    }

    public sealed partial class RemoteTables : RemoteTablesBase
    {
        public RemoteTables(DbConnection conn)
        {
            AddTable(HasSpecialStuff = new(conn));
            AddTable(LoggedOutPlayer = new(conn));
            AddTable(MyPlayer = new(conn));
            AddTable(Person = new(conn));
            AddTable(PkMultiIdentity = new(conn));
            AddTable(Player = new(conn));
            AddTable(Points = new(conn));
            AddTable(PrivateTable = new(conn));
            AddTable(RepeatingTestArg = new(conn));
            AddTable(TableToRemove = new(conn));
            AddTable(TestA = new(conn));
            AddTable(TestD = new(conn));
            AddTable(TestE = new(conn));
            AddTable(TestF = new(conn));
        }
    }

    public sealed partial class SetReducerFlags { }

        public interface IRemoteDbContext : IDbContext<RemoteTables, RemoteReducers, SetReducerFlags, SubscriptionBuilder, RemoteProcedures> {
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError;
        }

        public sealed class EventContext : IEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;

            /// <summary>
            /// The event that caused this callback to run.
            /// </summary>
            public readonly Event<Reducer> Event;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Access to procedures defined by the module.
            ///
            /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
            /// with a callback for when the procedure completes and returns a value.
            /// </summary>
            public RemoteProcedures Procedures => conn.Procedures;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal EventContext(DbConnection conn, Event<Reducer> Event)
            {
                this.conn = conn;
                this.Event = Event;
            }
        }

        public sealed class ReducerEventContext : IReducerEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;
            /// <summary>
            /// The reducer event that caused this callback to run.
            /// </summary>
            public readonly ReducerEvent<Reducer> Event;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Access to procedures defined by the module.
            ///
            /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
            /// with a callback for when the procedure completes and returns a value.
            /// </summary>
            public RemoteProcedures Procedures => conn.Procedures;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal ReducerEventContext(DbConnection conn, ReducerEvent<Reducer> reducerEvent)
            {
                this.conn = conn;
                Event = reducerEvent;
            }
        }

        public sealed class ErrorContext : IErrorContext, IRemoteDbContext
        {
            private readonly DbConnection conn;
            /// <summary>
            /// The <c>Exception</c> that caused this error callback to be run.
            /// </summary>
            public readonly Exception Event;
            Exception IErrorContext.Event {
                get {
                    return Event;
                }
            }

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Access to procedures defined by the module.
            ///
            /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
            /// with a callback for when the procedure completes and returns a value.
            /// </summary>
            public RemoteProcedures Procedures => conn.Procedures;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal ErrorContext(DbConnection conn, Exception error)
            {
                this.conn = conn;
                Event = error;
            }
        }

        public sealed class SubscriptionEventContext : ISubscriptionEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Access to procedures defined by the module.
            ///
            /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
            /// with a callback for when the procedure completes and returns a value.
            /// </summary>
            public RemoteProcedures Procedures => conn.Procedures;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal SubscriptionEventContext(DbConnection conn)
            {
                this.conn = conn;
            }
        }

        public sealed class ProcedureEventContext : IProcedureEventContext, IRemoteDbContext
        {
            private readonly DbConnection conn;
            /// <summary>
            /// The procedure event that caused this callback to run.
            /// </summary>
            public readonly ProcedureEvent Event;

            /// <summary>
            /// Access to tables in the client cache, which stores a read-only replica of the remote database state.
            ///
            /// The returned <c>DbView</c> will have a method to access each table defined by the module.
            /// </summary>
            public RemoteTables Db => conn.Db;
            /// <summary>
            /// Access to reducers defined by the module.
            ///
            /// The returned <c>RemoteReducers</c> will have a method to invoke each reducer defined by the module,
            /// plus methods for adding and removing callbacks on each of those reducers.
            /// </summary>
            public RemoteReducers Reducers => conn.Reducers;
            /// <summary>
            /// Access to setters for per-reducer flags.
            ///
            /// The returned <c>SetReducerFlags</c> will have a method to invoke,
            /// for each reducer defined by the module,
            /// which call-flags for the reducer can be set.
            /// </summary>
            public SetReducerFlags SetReducerFlags => conn.SetReducerFlags;
            /// <summary>
            /// Access to procedures defined by the module.
            ///
            /// The returned <c>RemoteProcedures</c> will have a method to invoke each procedure defined by the module,
            /// with a callback for when the procedure completes and returns a value.
            /// </summary>
            public RemoteProcedures Procedures => conn.Procedures;
            /// <summary>
            /// Returns <c>true</c> if the connection is active, i.e. has not yet disconnected.
            /// </summary>
            public bool IsActive => conn.IsActive;
            /// <summary>
            /// Close the connection.
            ///
            /// Throws an error if the connection is already closed.
            /// </summary>
            public void Disconnect() {
                conn.Disconnect();
            }
            /// <summary>
            /// Start building a subscription.
            /// </summary>
            /// <returns>A builder-pattern constructor for subscribing to queries,
            /// causing matching rows to be replicated into the client cache.</returns>
            public SubscriptionBuilder SubscriptionBuilder() => conn.SubscriptionBuilder();
            /// <summary>
            /// Get the <c>Identity</c> of this connection.
            ///
            /// This method returns null if the connection was constructed anonymously
            /// and we have not yet received our newly-generated <c>Identity</c> from the host.
            /// </summary>
            public Identity? Identity => conn.Identity;
            /// <summary>
            /// Get this connection's <c>ConnectionId</c>.
            /// </summary>
            public ConnectionId ConnectionId => conn.ConnectionId;
            /// <summary>
            /// Register a callback to be called when a reducer with no handler returns an error.
            /// </summary>
            public event Action<ReducerEventContext, Exception>? OnUnhandledReducerError {
                add => Reducers.InternalOnUnhandledReducerError += value;
                remove => Reducers.InternalOnUnhandledReducerError -= value;
            }

            internal ProcedureEventContext(DbConnection conn, ProcedureEvent Event)
            {
                this.conn = conn;
                this.Event = Event;
            }
        }

        /// <summary>
        /// Builder-pattern constructor for subscription queries.
        /// </summary>
        public sealed class SubscriptionBuilder
        {
            private readonly IDbConnection conn;

            private event Action<SubscriptionEventContext>? Applied;
            private event Action<ErrorContext, Exception>? Error;

            /// <summary>
            /// Private API, use <c>conn.SubscriptionBuilder()</c> instead.
            /// </summary>
            public SubscriptionBuilder(IDbConnection conn)
            {
                this.conn = conn;
            }

            /// <summary>
            /// Register a callback to run when the subscription is applied.
            /// </summary>
            public SubscriptionBuilder OnApplied(
                Action<SubscriptionEventContext> callback
            )
            {
                Applied += callback;
                return this;
            }

            /// <summary>
            /// Register a callback to run when the subscription fails.
            ///
            /// Note that this callback may run either when attempting to apply the subscription,
            /// in which case <c>Self::on_applied</c> will never run,
            /// or later during the subscription's lifetime if the module's interface changes,
            /// in which case <c>Self::on_applied</c> may have already run.
            /// </summary>
            public SubscriptionBuilder OnError(
                Action<ErrorContext, Exception> callback
            )
            {
                Error += callback;
                return this;
            }
        
            /// <summary>
            /// Add a typed query to this subscription.
            ///
            /// This is the entry point for building subscriptions without writing SQL by hand.
            /// Once a typed query is added, only typed queries may follow (SQL and typed queries cannot be mixed).
            /// </summary>
            public TypedSubscriptionBuilder AddQuery<TRow>(
                Func<QueryBuilder, global::SpacetimeDB.Query<TRow>> build
            )
            {
                var typed = new TypedSubscriptionBuilder(conn, Applied, Error);
                return typed.AddQuery(build);
            }

            /// <summary>
            /// Subscribe to the following SQL queries.
            ///
            /// This method returns immediately, with the data not yet added to the DbConnection.
            /// The provided callbacks will be invoked once the data is returned from the remote server.
            /// Data from all the provided queries will be returned at the same time.
            ///
            /// See the SpacetimeDB SQL docs for more information on SQL syntax:
            /// <a href="https://spacetimedb.com/docs/sql">https://spacetimedb.com/docs/sql</a>
            /// </summary>
            public SubscriptionHandle Subscribe(
                string[] querySqls
            ) => new(conn, Applied, Error, querySqls);

            /// <summary>
            /// Subscribe to all rows from all tables.
            ///
            /// This method is intended as a convenience
            /// for applications where client-side memory use and network bandwidth are not concerns.
            /// Applications where these resources are a constraint
            /// should register more precise queries via <c>Self.Subscribe</c>
            /// in order to replicate only the subset of data which the client needs to function.
            ///
            /// This method should not be combined with <c>Self.Subscribe</c> on the same <c>DbConnection</c>.
            /// A connection may either <c>Self.Subscribe</c> to particular queries,
            /// or <c>Self.SubscribeToAllTables</c>, but not both.
            /// Attempting to call <c>Self.Subscribe</c>
            /// on a <c>DbConnection</c> that has previously used <c>Self.SubscribeToAllTables</c>,
            /// or vice versa, may misbehave in any number of ways,
            /// including dropping subscriptions, corrupting the client cache, or panicking.
            /// </summary>
            public void SubscribeToAllTables()
            {
                // Make sure we use the legacy handle constructor here, even though there's only 1 query.
                // We drop the error handler, since it can't be called for legacy subscriptions.
                new SubscriptionHandle(
                    conn,
                    Applied,
                    new string[] { "SELECT * FROM *" }
                );
            }
        }

        public sealed class SubscriptionHandle : SubscriptionHandleBase<SubscriptionEventContext, ErrorContext> {
            /// <summary>
            /// Internal API. Construct <c>SubscriptionHandle</c>s using <c>conn.SubscriptionBuilder</c>.
            /// </summary>
            public SubscriptionHandle(IDbConnection conn, Action<SubscriptionEventContext>? onApplied, string[] querySqls) : base(conn, onApplied, querySqls)
            { }

            /// <summary>
            /// Internal API. Construct <c>SubscriptionHandle</c>s using <c>conn.SubscriptionBuilder</c>.
            /// </summary>
            public SubscriptionHandle(
                IDbConnection conn,
                Action<SubscriptionEventContext>? onApplied,
                Action<ErrorContext, Exception>? onError,
                string[] querySqls
            ) : base(conn, onApplied, onError, querySqls)
            { }
        }

    public sealed class QueryBuilder
    {
        public From From { get; } = new();
    }

    public sealed class From
    {
        public global::SpacetimeDB.Table<HasSpecialStuff, HasSpecialStuffCols, HasSpecialStuffIxCols> HasSpecialStuff() => new("has_special_stuff", new HasSpecialStuffCols("has_special_stuff"), new HasSpecialStuffIxCols("has_special_stuff"));
        public global::SpacetimeDB.Table<Player, LoggedOutPlayerCols, LoggedOutPlayerIxCols> LoggedOutPlayer() => new("logged_out_player", new LoggedOutPlayerCols("logged_out_player"), new LoggedOutPlayerIxCols("logged_out_player"));
        public global::SpacetimeDB.Table<Player, MyPlayerCols, MyPlayerIxCols> MyPlayer() => new("my_player", new MyPlayerCols("my_player"), new MyPlayerIxCols("my_player"));
        public global::SpacetimeDB.Table<Person, PersonCols, PersonIxCols> Person() => new("person", new PersonCols("person"), new PersonIxCols("person"));
        public global::SpacetimeDB.Table<PkMultiIdentity, PkMultiIdentityCols, PkMultiIdentityIxCols> PkMultiIdentity() => new("pk_multi_identity", new PkMultiIdentityCols("pk_multi_identity"), new PkMultiIdentityIxCols("pk_multi_identity"));
        public global::SpacetimeDB.Table<Player, PlayerCols, PlayerIxCols> Player() => new("player", new PlayerCols("player"), new PlayerIxCols("player"));
        public global::SpacetimeDB.Table<Point, PointsCols, PointsIxCols> Points() => new("points", new PointsCols("points"), new PointsIxCols("points"));
        public global::SpacetimeDB.Table<PrivateTable, PrivateTableCols, PrivateTableIxCols> PrivateTable() => new("private_table", new PrivateTableCols("private_table"), new PrivateTableIxCols("private_table"));
        public global::SpacetimeDB.Table<RepeatingTestArg, RepeatingTestArgCols, RepeatingTestArgIxCols> RepeatingTestArg() => new("repeating_test_arg", new RepeatingTestArgCols("repeating_test_arg"), new RepeatingTestArgIxCols("repeating_test_arg"));
        public global::SpacetimeDB.Table<RemoveTable, TableToRemoveCols, TableToRemoveIxCols> TableToRemove() => new("table_to_remove", new TableToRemoveCols("table_to_remove"), new TableToRemoveIxCols("table_to_remove"));
        public global::SpacetimeDB.Table<TestA, TestACols, TestAIxCols> TestA() => new("test_a", new TestACols("test_a"), new TestAIxCols("test_a"));
        public global::SpacetimeDB.Table<TestD, TestDCols, TestDIxCols> TestD() => new("test_d", new TestDCols("test_d"), new TestDIxCols("test_d"));
        public global::SpacetimeDB.Table<TestE, TestECols, TestEIxCols> TestE() => new("test_e", new TestECols("test_e"), new TestEIxCols("test_e"));
        public global::SpacetimeDB.Table<TestFoobar, TestFCols, TestFIxCols> TestF() => new("test_f", new TestFCols("test_f"), new TestFIxCols("test_f"));
    }

    public sealed class TypedSubscriptionBuilder
    {
        private readonly IDbConnection conn;
        private Action<SubscriptionEventContext>? Applied;
        private Action<ErrorContext, Exception>? Error;
        private readonly List<string> querySqls = new();

        internal TypedSubscriptionBuilder(IDbConnection conn, Action<SubscriptionEventContext>? applied, Action<ErrorContext, Exception>? error)
        {
            this.conn = conn;
            Applied = applied;
            Error = error;
        }

        public TypedSubscriptionBuilder OnApplied(Action<SubscriptionEventContext> callback)
        {
            Applied += callback;
            return this;
        }

        public TypedSubscriptionBuilder OnError(Action<ErrorContext, Exception> callback)
        {
            Error += callback;
            return this;
        }

        public TypedSubscriptionBuilder AddQuery<TRow>(Func<QueryBuilder, global::SpacetimeDB.Query<TRow>> build)
        {
            var qb = new QueryBuilder();
            querySqls.Add(build(qb).ToSql());
            return this;
        }

        public SubscriptionHandle Subscribe() => new(conn, Applied, Error, querySqls.ToArray());
    }

    public abstract partial class Reducer
    {
        private Reducer() { }
    }

    public abstract partial class Procedure
    {
        private Procedure() { }
    }

    public sealed class DbConnection : DbConnectionBase<DbConnection, RemoteTables, Reducer>
    {
        public override RemoteTables Db { get; }
        public readonly RemoteReducers Reducers;
        public readonly SetReducerFlags SetReducerFlags = new();
        public readonly RemoteProcedures Procedures;

        public DbConnection()
        {
            Db = new(this);
            Reducers = new(this, SetReducerFlags);
            Procedures = new(this);
        }

        protected override Reducer ToReducer(TransactionUpdate update)
        {
            var encodedArgs = update.ReducerCall.Args;
            return update.ReducerCall.ReducerName switch {
                "add" => BSATNHelpers.Decode<Reducer.Add>(encodedArgs),
                "add_player" => BSATNHelpers.Decode<Reducer.AddPlayer>(encodedArgs),
                "add_private" => BSATNHelpers.Decode<Reducer.AddPrivate>(encodedArgs),
                "assert_caller_identity_is_module_identity" => BSATNHelpers.Decode<Reducer.AssertCallerIdentityIsModuleIdentity>(encodedArgs),
                "client_connected" => BSATNHelpers.Decode<Reducer.ClientConnected>(encodedArgs),
                "delete_player" => BSATNHelpers.Decode<Reducer.DeletePlayer>(encodedArgs),
                "delete_players_by_name" => BSATNHelpers.Decode<Reducer.DeletePlayersByName>(encodedArgs),
                "list_over_age" => BSATNHelpers.Decode<Reducer.ListOverAge>(encodedArgs),
                "log_module_identity" => BSATNHelpers.Decode<Reducer.LogModuleIdentity>(encodedArgs),
                "query_private" => BSATNHelpers.Decode<Reducer.QueryPrivate>(encodedArgs),
                "repeating_test" => BSATNHelpers.Decode<Reducer.RepeatingTest>(encodedArgs),
                "say_hello" => BSATNHelpers.Decode<Reducer.SayHello>(encodedArgs),
                "test" => BSATNHelpers.Decode<Reducer.Test>(encodedArgs),
                "test_btree_index_args" => BSATNHelpers.Decode<Reducer.TestBtreeIndexArgs>(encodedArgs),
                "" => throw new SpacetimeDBEmptyReducerNameException("Reducer name is empty"),
                var reducer => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        protected override IEventContext ToEventContext(Event<Reducer> Event) =>
        new EventContext(this, Event);

        protected override IReducerEventContext ToReducerEventContext(ReducerEvent<Reducer> reducerEvent) =>
        new ReducerEventContext(this, reducerEvent);

        protected override ISubscriptionEventContext MakeSubscriptionEventContext() =>
        new SubscriptionEventContext(this);

        protected override IErrorContext ToErrorContext(Exception exception) =>
        new ErrorContext(this, exception);

        protected override IProcedureEventContext ToProcedureEventContext(ProcedureEvent procedureEvent) =>
        new ProcedureEventContext(this, procedureEvent);

        protected override bool Dispatch(IReducerEventContext context, Reducer reducer)
        {
            var eventContext = (ReducerEventContext)context;
            return reducer switch {
                Reducer.Add args => Reducers.InvokeAdd(eventContext, args),
                Reducer.AddPlayer args => Reducers.InvokeAddPlayer(eventContext, args),
                Reducer.AddPrivate args => Reducers.InvokeAddPrivate(eventContext, args),
                Reducer.AssertCallerIdentityIsModuleIdentity args => Reducers.InvokeAssertCallerIdentityIsModuleIdentity(eventContext, args),
                Reducer.ClientConnected args => Reducers.InvokeClientConnected(eventContext, args),
                Reducer.DeletePlayer args => Reducers.InvokeDeletePlayer(eventContext, args),
                Reducer.DeletePlayersByName args => Reducers.InvokeDeletePlayersByName(eventContext, args),
                Reducer.ListOverAge args => Reducers.InvokeListOverAge(eventContext, args),
                Reducer.LogModuleIdentity args => Reducers.InvokeLogModuleIdentity(eventContext, args),
                Reducer.QueryPrivate args => Reducers.InvokeQueryPrivate(eventContext, args),
                Reducer.RepeatingTest args => Reducers.InvokeRepeatingTest(eventContext, args),
                Reducer.SayHello args => Reducers.InvokeSayHello(eventContext, args),
                Reducer.Test args => Reducers.InvokeTest(eventContext, args),
                Reducer.TestBtreeIndexArgs args => Reducers.InvokeTestBtreeIndexArgs(eventContext, args),
                _ => throw new ArgumentOutOfRangeException("Reducer", $"Unknown reducer {reducer}")
            };
        }

        public SubscriptionBuilder SubscriptionBuilder() => new(this);
        public event Action<ReducerEventContext, Exception> OnUnhandledReducerError
        {
            add => Reducers.InternalOnUnhandledReducerError += value;
            remove => Reducers.InternalOnUnhandledReducerError -= value;
        }
    }
}
'''
"Tables/HasSpecialStuff.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class HasSpecialStuffHandle : RemoteTableHandle<EventContext, HasSpecialStuff>
        {
            protected override string RemoteTableName => "has_special_stuff";

            internal HasSpecialStuffHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly HasSpecialStuffHandle HasSpecialStuff;
    }

    public sealed class HasSpecialStuffCols
    {
        public global::SpacetimeDB.Col<HasSpecialStuff, SpacetimeDB.Identity> Identity { get; }
        public global::SpacetimeDB.Col<HasSpecialStuff, SpacetimeDB.ConnectionId> ConnectionId { get; }

        public HasSpecialStuffCols(string tableName)
        {
            Identity = new global::SpacetimeDB.Col<HasSpecialStuff, SpacetimeDB.Identity>(tableName, "identity");
            ConnectionId = new global::SpacetimeDB.Col<HasSpecialStuff, SpacetimeDB.ConnectionId>(tableName, "connection_id");
        }
    }

    public sealed class HasSpecialStuffIxCols
    {

        public HasSpecialStuffIxCols(string tableName)
        {
        }
    }
}
'''
"Tables/LoggedOutPlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class LoggedOutPlayerHandle : RemoteTableHandle<EventContext, Player>
        {
            protected override string RemoteTableName => "logged_out_player";

            public sealed class IdentityUniqueIndex : UniqueIndexBase<SpacetimeDB.Identity>
            {
                protected override SpacetimeDB.Identity GetKey(Player row) => row.Identity;

                public IdentityUniqueIndex(LoggedOutPlayerHandle table) : base(table) { }
            }

            public readonly IdentityUniqueIndex Identity;

            public sealed class NameUniqueIndex : UniqueIndexBase<string>
            {
                protected override string GetKey(Player row) => row.Name;

                public NameUniqueIndex(LoggedOutPlayerHandle table) : base(table) { }
            }

            public readonly NameUniqueIndex Name;

            public sealed class PlayerIdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(Player row) => row.PlayerId;

                public PlayerIdUniqueIndex(LoggedOutPlayerHandle table) : base(table) { }
            }

            public readonly PlayerIdUniqueIndex PlayerId;

            internal LoggedOutPlayerHandle(DbConnection conn) : base(conn)
            {
                Identity = new(this);
                Name = new(this);
                PlayerId = new(this);
            }

            protected override object GetPrimaryKey(Player row) => row.Identity;
        }

        public readonly LoggedOutPlayerHandle LoggedOutPlayer;
    }

    public sealed class LoggedOutPlayerCols
    {
        public global::SpacetimeDB.Col<Player, SpacetimeDB.Identity> Identity { get; }
        public global::SpacetimeDB.Col<Player, ulong> PlayerId { get; }
        public global::SpacetimeDB.Col<Player, string> Name { get; }

        public LoggedOutPlayerCols(string tableName)
        {
            Identity = new global::SpacetimeDB.Col<Player, SpacetimeDB.Identity>(tableName, "identity");
            PlayerId = new global::SpacetimeDB.Col<Player, ulong>(tableName, "player_id");
            Name = new global::SpacetimeDB.Col<Player, string>(tableName, "name");
        }
    }

    public sealed class LoggedOutPlayerIxCols
    {
        public global::SpacetimeDB.IxCol<Player, SpacetimeDB.Identity> Identity { get; }
        public global::SpacetimeDB.IxCol<Player, ulong> PlayerId { get; }
        public global::SpacetimeDB.IxCol<Player, string> Name { get; }

        public LoggedOutPlayerIxCols(string tableName)
        {
            Identity = new global::SpacetimeDB.IxCol<Player, SpacetimeDB.Identity>(tableName, "identity");
            PlayerId = new global::SpacetimeDB.IxCol<Player, ulong>(tableName, "player_id");
            Name = new global::SpacetimeDB.IxCol<Player, string>(tableName, "name");
        }
    }
}
'''
"Tables/MyPlayer.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class MyPlayerHandle : RemoteTableHandle<EventContext, Player>
        {
            protected override string RemoteTableName => "my_player";

            internal MyPlayerHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly MyPlayerHandle MyPlayer;
    }

    public sealed class MyPlayerCols
    {
        public global::SpacetimeDB.Col<Player, SpacetimeDB.Identity> Identity { get; }
        public global::SpacetimeDB.Col<Player, ulong> PlayerId { get; }
        public global::SpacetimeDB.Col<Player, string> Name { get; }

        public MyPlayerCols(string tableName)
        {
            Identity = new global::SpacetimeDB.Col<Player, SpacetimeDB.Identity>(tableName, "identity");
            PlayerId = new global::SpacetimeDB.Col<Player, ulong>(tableName, "player_id");
            Name = new global::SpacetimeDB.Col<Player, string>(tableName, "name");
        }
    }

    public sealed class MyPlayerIxCols
    {

        public MyPlayerIxCols(string tableName)
        {
        }
    }
}
'''
"Tables/Person.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PersonHandle : RemoteTableHandle<EventContext, Person>
        {
            protected override string RemoteTableName => "person";

            public sealed class AgeIndex : BTreeIndexBase<byte>
            {
                protected override byte GetKey(Person row) => row.Age;

                public AgeIndex(PersonHandle table) : base(table) { }
            }

            public readonly AgeIndex Age;

            public sealed class IdUniqueIndex : UniqueIndexBase<uint>
            {
                protected override uint GetKey(Person row) => row.Id;

                public IdUniqueIndex(PersonHandle table) : base(table) { }
            }

            public readonly IdUniqueIndex Id;

            internal PersonHandle(DbConnection conn) : base(conn)
            {
                Age = new(this);
                Id = new(this);
            }

            protected override object GetPrimaryKey(Person row) => row.Id;
        }

        public readonly PersonHandle Person;
    }

    public sealed class PersonCols
    {
        public global::SpacetimeDB.Col<Person, uint> Id { get; }
        public global::SpacetimeDB.Col<Person, string> Name { get; }
        public global::SpacetimeDB.Col<Person, byte> Age { get; }

        public PersonCols(string tableName)
        {
            Id = new global::SpacetimeDB.Col<Person, uint>(tableName, "id");
            Name = new global::SpacetimeDB.Col<Person, string>(tableName, "name");
            Age = new global::SpacetimeDB.Col<Person, byte>(tableName, "age");
        }
    }

    public sealed class PersonIxCols
    {
        public global::SpacetimeDB.IxCol<Person, uint> Id { get; }
        public global::SpacetimeDB.IxCol<Person, byte> Age { get; }

        public PersonIxCols(string tableName)
        {
            Id = new global::SpacetimeDB.IxCol<Person, uint>(tableName, "id");
            Age = new global::SpacetimeDB.IxCol<Person, byte>(tableName, "age");
        }
    }
}
'''
"Tables/PkMultiIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PkMultiIdentityHandle : RemoteTableHandle<EventContext, PkMultiIdentity>
        {
            protected override string RemoteTableName => "pk_multi_identity";

            public sealed class IdUniqueIndex : UniqueIndexBase<uint>
            {
                protected override uint GetKey(PkMultiIdentity row) => row.Id;

                public IdUniqueIndex(PkMultiIdentityHandle table) : base(table) { }
            }

            public readonly IdUniqueIndex Id;

            public sealed class OtherUniqueIndex : UniqueIndexBase<uint>
            {
                protected override uint GetKey(PkMultiIdentity row) => row.Other;

                public OtherUniqueIndex(PkMultiIdentityHandle table) : base(table) { }
            }

            public readonly OtherUniqueIndex Other;

            internal PkMultiIdentityHandle(DbConnection conn) : base(conn)
            {
                Id = new(this);
                Other = new(this);
            }

            protected override object GetPrimaryKey(PkMultiIdentity row) => row.Id;
        }

        public readonly PkMultiIdentityHandle PkMultiIdentity;
    }

    public sealed class PkMultiIdentityCols
    {
        public global::SpacetimeDB.Col<PkMultiIdentity, uint> Id { get; }
        public global::SpacetimeDB.Col<PkMultiIdentity, uint> Other { get; }

        public PkMultiIdentityCols(string tableName)
        {
            Id = new global::SpacetimeDB.Col<PkMultiIdentity, uint>(tableName, "id");
            Other = new global::SpacetimeDB.Col<PkMultiIdentity, uint>(tableName, "other");
        }
    }

    public sealed class PkMultiIdentityIxCols
    {
        public global::SpacetimeDB.IxCol<PkMultiIdentity, uint> Id { get; }
        public global::SpacetimeDB.IxCol<PkMultiIdentity, uint> Other { get; }

        public PkMultiIdentityIxCols(string tableName)
        {
            Id = new global::SpacetimeDB.IxCol<PkMultiIdentity, uint>(tableName, "id");
            Other = new global::SpacetimeDB.IxCol<PkMultiIdentity, uint>(tableName, "other");
        }
    }
}
'''
"Tables/Player.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PlayerHandle : RemoteTableHandle<EventContext, Player>
        {
            protected override string RemoteTableName => "player";

            public sealed class IdentityUniqueIndex : UniqueIndexBase<SpacetimeDB.Identity>
            {
                protected override SpacetimeDB.Identity GetKey(Player row) => row.Identity;

                public IdentityUniqueIndex(PlayerHandle table) : base(table) { }
            }

            public readonly IdentityUniqueIndex Identity;

            public sealed class NameUniqueIndex : UniqueIndexBase<string>
            {
                protected override string GetKey(Player row) => row.Name;

                public NameUniqueIndex(PlayerHandle table) : base(table) { }
            }

            public readonly NameUniqueIndex Name;

            public sealed class PlayerIdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(Player row) => row.PlayerId;

                public PlayerIdUniqueIndex(PlayerHandle table) : base(table) { }
            }

            public readonly PlayerIdUniqueIndex PlayerId;

            internal PlayerHandle(DbConnection conn) : base(conn)
            {
                Identity = new(this);
                Name = new(this);
                PlayerId = new(this);
            }

            protected override object GetPrimaryKey(Player row) => row.Identity;
        }

        public readonly PlayerHandle Player;
    }

    public sealed class PlayerCols
    {
        public global::SpacetimeDB.Col<Player, SpacetimeDB.Identity> Identity { get; }
        public global::SpacetimeDB.Col<Player, ulong> PlayerId { get; }
        public global::SpacetimeDB.Col<Player, string> Name { get; }

        public PlayerCols(string tableName)
        {
            Identity = new global::SpacetimeDB.Col<Player, SpacetimeDB.Identity>(tableName, "identity");
            PlayerId = new global::SpacetimeDB.Col<Player, ulong>(tableName, "player_id");
            Name = new global::SpacetimeDB.Col<Player, string>(tableName, "name");
        }
    }

    public sealed class PlayerIxCols
    {
        public global::SpacetimeDB.IxCol<Player, SpacetimeDB.Identity> Identity { get; }
        public global::SpacetimeDB.IxCol<Player, ulong> PlayerId { get; }
        public global::SpacetimeDB.IxCol<Player, string> Name { get; }

        public PlayerIxCols(string tableName)
        {
            Identity = new global::SpacetimeDB.IxCol<Player, SpacetimeDB.Identity>(tableName, "identity");
            PlayerId = new global::SpacetimeDB.IxCol<Player, ulong>(tableName, "player_id");
            Name = new global::SpacetimeDB.IxCol<Player, string>(tableName, "name");
        }
    }
}
'''
"Tables/Points.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PointsHandle : RemoteTableHandle<EventContext, Point>
        {
            protected override string RemoteTableName => "points";

            public sealed class MultiColumnIndexIndex : BTreeIndexBase<(long X, long Y)>
            {
                protected override (long X, long Y) GetKey(Point row) => (row.X, row.Y);

                public MultiColumnIndexIndex(PointsHandle table) : base(table) { }
            }

            public readonly MultiColumnIndexIndex MultiColumnIndex;

            internal PointsHandle(DbConnection conn) : base(conn)
            {
                MultiColumnIndex = new(this);
            }
        }

        public readonly PointsHandle Points;
    }

    public sealed class PointsCols
    {
        public global::SpacetimeDB.Col<Point, long> X { get; }
        public global::SpacetimeDB.Col<Point, long> Y { get; }

        public PointsCols(string tableName)
        {
            X = new global::SpacetimeDB.Col<Point, long>(tableName, "x");
            Y = new global::SpacetimeDB.Col<Point, long>(tableName, "y");
        }
    }

    public sealed class PointsIxCols
    {
        public global::SpacetimeDB.IxCol<Point, long> X { get; }
        public global::SpacetimeDB.IxCol<Point, long> Y { get; }

        public PointsIxCols(string tableName)
        {
            X = new global::SpacetimeDB.IxCol<Point, long>(tableName, "x");
            Y = new global::SpacetimeDB.IxCol<Point, long>(tableName, "y");
        }
    }
}
'''
"Tables/PrivateTable.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class PrivateTableHandle : RemoteTableHandle<EventContext, PrivateTable>
        {
            protected override string RemoteTableName => "private_table";

            internal PrivateTableHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly PrivateTableHandle PrivateTable;
    }

    public sealed class PrivateTableCols
    {
        public global::SpacetimeDB.Col<PrivateTable, string> Name { get; }

        public PrivateTableCols(string tableName)
        {
            Name = new global::SpacetimeDB.Col<PrivateTable, string>(tableName, "name");
        }
    }

    public sealed class PrivateTableIxCols
    {

        public PrivateTableIxCols(string tableName)
        {
        }
    }
}
'''
"Tables/RepeatingTestArg.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class RepeatingTestArgHandle : RemoteTableHandle<EventContext, RepeatingTestArg>
        {
            protected override string RemoteTableName => "repeating_test_arg";

            public sealed class ScheduledIdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(RepeatingTestArg row) => row.ScheduledId;

                public ScheduledIdUniqueIndex(RepeatingTestArgHandle table) : base(table) { }
            }

            public readonly ScheduledIdUniqueIndex ScheduledId;

            internal RepeatingTestArgHandle(DbConnection conn) : base(conn)
            {
                ScheduledId = new(this);
            }

            protected override object GetPrimaryKey(RepeatingTestArg row) => row.ScheduledId;
        }

        public readonly RepeatingTestArgHandle RepeatingTestArg;
    }

    public sealed class RepeatingTestArgCols
    {
        public global::SpacetimeDB.Col<RepeatingTestArg, ulong> ScheduledId { get; }
        public global::SpacetimeDB.Col<RepeatingTestArg, SpacetimeDB.ScheduleAt> ScheduledAt { get; }
        public global::SpacetimeDB.Col<RepeatingTestArg, SpacetimeDB.Timestamp> PrevTime { get; }

        public RepeatingTestArgCols(string tableName)
        {
            ScheduledId = new global::SpacetimeDB.Col<RepeatingTestArg, ulong>(tableName, "scheduled_id");
            ScheduledAt = new global::SpacetimeDB.Col<RepeatingTestArg, SpacetimeDB.ScheduleAt>(tableName, "scheduled_at");
            PrevTime = new global::SpacetimeDB.Col<RepeatingTestArg, SpacetimeDB.Timestamp>(tableName, "prev_time");
        }
    }

    public sealed class RepeatingTestArgIxCols
    {
        public global::SpacetimeDB.IxCol<RepeatingTestArg, ulong> ScheduledId { get; }

        public RepeatingTestArgIxCols(string tableName)
        {
            ScheduledId = new global::SpacetimeDB.IxCol<RepeatingTestArg, ulong>(tableName, "scheduled_id");
        }
    }
}
'''
"Tables/TableToRemove.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TableToRemoveHandle : RemoteTableHandle<EventContext, RemoveTable>
        {
            protected override string RemoteTableName => "table_to_remove";

            internal TableToRemoveHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly TableToRemoveHandle TableToRemove;
    }

    public sealed class TableToRemoveCols
    {
        public global::SpacetimeDB.Col<RemoveTable, uint> Id { get; }

        public TableToRemoveCols(string tableName)
        {
            Id = new global::SpacetimeDB.Col<RemoveTable, uint>(tableName, "id");
        }
    }

    public sealed class TableToRemoveIxCols
    {

        public TableToRemoveIxCols(string tableName)
        {
        }
    }
}
'''
"Tables/TestA.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestAHandle : RemoteTableHandle<EventContext, TestA>
        {
            protected override string RemoteTableName => "test_a";

            public sealed class FooIndex : BTreeIndexBase<uint>
            {
                protected override uint GetKey(TestA row) => row.X;

                public FooIndex(TestAHandle table) : base(table) { }
            }

            public readonly FooIndex Foo;

            internal TestAHandle(DbConnection conn) : base(conn)
            {
                Foo = new(this);
            }
        }

        public readonly TestAHandle TestA;
    }

    public sealed class TestACols
    {
        public global::SpacetimeDB.Col<TestA, uint> X { get; }
        public global::SpacetimeDB.Col<TestA, uint> Y { get; }
        public global::SpacetimeDB.Col<TestA, string> Z { get; }

        public TestACols(string tableName)
        {
            X = new global::SpacetimeDB.Col<TestA, uint>(tableName, "x");
            Y = new global::SpacetimeDB.Col<TestA, uint>(tableName, "y");
            Z = new global::SpacetimeDB.Col<TestA, string>(tableName, "z");
        }
    }

    public sealed class TestAIxCols
    {
        public global::SpacetimeDB.IxCol<TestA, uint> X { get; }

        public TestAIxCols(string tableName)
        {
            X = new global::SpacetimeDB.IxCol<TestA, uint>(tableName, "x");
        }
    }
}
'''
"Tables/TestD.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestDHandle : RemoteTableHandle<EventContext, TestD>
        {
            protected override string RemoteTableName => "test_d";

            internal TestDHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly TestDHandle TestD;
    }

    public sealed class TestDCols
    {
        public global::SpacetimeDB.NullableCol<TestD, NamespaceTestC> TestC { get; }

        public TestDCols(string tableName)
        {
            TestC = new global::SpacetimeDB.NullableCol<TestD, NamespaceTestC>(tableName, "test_c");
        }
    }

    public sealed class TestDIxCols
    {

        public TestDIxCols(string tableName)
        {
        }
    }
}
'''
"Tables/TestE.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestEHandle : RemoteTableHandle<EventContext, TestE>
        {
            protected override string RemoteTableName => "test_e";

            public sealed class IdUniqueIndex : UniqueIndexBase<ulong>
            {
                protected override ulong GetKey(TestE row) => row.Id;

                public IdUniqueIndex(TestEHandle table) : base(table) { }
            }

            public readonly IdUniqueIndex Id;

            public sealed class NameIndex : BTreeIndexBase<string>
            {
                protected override string GetKey(TestE row) => row.Name;

                public NameIndex(TestEHandle table) : base(table) { }
            }

            public readonly NameIndex Name;

            internal TestEHandle(DbConnection conn) : base(conn)
            {
                Id = new(this);
                Name = new(this);
            }

            protected override object GetPrimaryKey(TestE row) => row.Id;
        }

        public readonly TestEHandle TestE;
    }

    public sealed class TestECols
    {
        public global::SpacetimeDB.Col<TestE, ulong> Id { get; }
        public global::SpacetimeDB.Col<TestE, string> Name { get; }

        public TestECols(string tableName)
        {
            Id = new global::SpacetimeDB.Col<TestE, ulong>(tableName, "id");
            Name = new global::SpacetimeDB.Col<TestE, string>(tableName, "name");
        }
    }

    public sealed class TestEIxCols
    {
        public global::SpacetimeDB.IxCol<TestE, ulong> Id { get; }
        public global::SpacetimeDB.IxCol<TestE, string> Name { get; }

        public TestEIxCols(string tableName)
        {
            Id = new global::SpacetimeDB.IxCol<TestE, ulong>(tableName, "id");
            Name = new global::SpacetimeDB.IxCol<TestE, string>(tableName, "name");
        }
    }
}
'''
"Tables/TestF.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using SpacetimeDB.BSATN;
using SpacetimeDB.ClientApi;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    public sealed partial class RemoteTables
    {
        public sealed class TestFHandle : RemoteTableHandle<EventContext, TestFoobar>
        {
            protected override string RemoteTableName => "test_f";

            internal TestFHandle(DbConnection conn) : base(conn)
            {
            }
        }

        public readonly TestFHandle TestF;
    }

    public sealed class TestFCols
    {
        public global::SpacetimeDB.Col<TestFoobar, Foobar> Field { get; }

        public TestFCols(string tableName)
        {
            Field = new global::SpacetimeDB.Col<TestFoobar, Foobar>(tableName, "field");
        }
    }

    public sealed class TestFIxCols
    {

        public TestFIxCols(string tableName)
        {
        }
    }
}
'''
"Types/Baz.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Baz
    {
        [DataMember(Name = "field")]
        public string Field;

        public Baz(string Field)
        {
            this.Field = Field;
        }

        public Baz()
        {
            this.Field = "";
        }
    }
}
'''
"Types/Foobar.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    public partial record Foobar : SpacetimeDB.TaggedEnum<(
        Baz Baz,
        SpacetimeDB.Unit Bar,
        uint Har
    )>;
}
'''
"Types/HasSpecialStuff.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class HasSpecialStuff
    {
        [DataMember(Name = "identity")]
        public SpacetimeDB.Identity Identity;
        [DataMember(Name = "connection_id")]
        public SpacetimeDB.ConnectionId ConnectionId;

        public HasSpecialStuff(
            SpacetimeDB.Identity Identity,
            SpacetimeDB.ConnectionId ConnectionId
        )
        {
            this.Identity = Identity;
            this.ConnectionId = ConnectionId;
        }

        public HasSpecialStuff()
        {
        }
    }
}
'''
"Types/NamespaceTestC.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    public enum NamespaceTestC
    {
        Foo,
        Bar,
    }
}
'''
"Types/NamespaceTestF.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    public partial record NamespaceTestF : SpacetimeDB.TaggedEnum<(
        SpacetimeDB.Unit Foo,
        SpacetimeDB.Unit Bar,
        string Baz
    )>;
}
'''
"Types/Person.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Person
    {
        [DataMember(Name = "id")]
        public uint Id;
        [DataMember(Name = "name")]
        public string Name;
        [DataMember(Name = "age")]
        public byte Age;

        public Person(
            uint Id,
            string Name,
            byte Age
        )
        {
            this.Id = Id;
            this.Name = Name;
            this.Age = Age;
        }

        public Person()
        {
            this.Name = "";
        }
    }
}
'''
"Types/PkMultiIdentity.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class PkMultiIdentity
    {
        [DataMember(Name = "id")]
        public uint Id;
        [DataMember(Name = "other")]
        public uint Other;

        public PkMultiIdentity(
            uint Id,
            uint Other
        )
        {
            this.Id = Id;
            this.Other = Other;
        }

        public PkMultiIdentity()
        {
        }
    }
}
'''
"Types/Player.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Player
    {
        [DataMember(Name = "identity")]
        public SpacetimeDB.Identity Identity;
        [DataMember(Name = "player_id")]
        public ulong PlayerId;
        [DataMember(Name = "name")]
        public string Name;

        public Player(
            SpacetimeDB.Identity Identity,
            ulong PlayerId,
            string Name
        )
        {
            this.Identity = Identity;
            this.PlayerId = PlayerId;
            this.Name = Name;
        }

        public Player()
        {
            this.Name = "";
        }
    }
}
'''
"Types/Point.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class Point
    {
        [DataMember(Name = "x")]
        public long X;
        [DataMember(Name = "y")]
        public long Y;

        public Point(
            long X,
            long Y
        )
        {
            this.X = X;
            this.Y = Y;
        }

        public Point()
        {
        }
    }
}
'''
"Types/PrivateTable.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class PrivateTable
    {
        [DataMember(Name = "name")]
        public string Name;

        public PrivateTable(string Name)
        {
            this.Name = Name;
        }

        public PrivateTable()
        {
            this.Name = "";
        }
    }
}
'''
"Types/RemoveTable.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class RemoveTable
    {
        [DataMember(Name = "id")]
        public uint Id;

        public RemoveTable(uint Id)
        {
            this.Id = Id;
        }

        public RemoveTable()
        {
        }
    }
}
'''
"Types/RepeatingTestArg.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class RepeatingTestArg
    {
        [DataMember(Name = "scheduled_id")]
        public ulong ScheduledId;
        [DataMember(Name = "scheduled_at")]
        public SpacetimeDB.ScheduleAt ScheduledAt;
        [DataMember(Name = "prev_time")]
        public SpacetimeDB.Timestamp PrevTime;

        public RepeatingTestArg(
            ulong ScheduledId,
            SpacetimeDB.ScheduleAt ScheduledAt,
            SpacetimeDB.Timestamp PrevTime
        )
        {
            this.ScheduledId = ScheduledId;
            this.ScheduledAt = ScheduledAt;
            this.PrevTime = PrevTime;
        }

        public RepeatingTestArg()
        {
            this.ScheduledAt = null!;
        }
    }
}
'''
"Types/TestA.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestA
    {
        [DataMember(Name = "x")]
        public uint X;
        [DataMember(Name = "y")]
        public uint Y;
        [DataMember(Name = "z")]
        public string Z;

        public TestA(
            uint X,
            uint Y,
            string Z
        )
        {
            this.X = X;
            this.Y = Y;
            this.Z = Z;
        }

        public TestA()
        {
            this.Z = "";
        }
    }
}
'''
"Types/TestB.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestB
    {
        [DataMember(Name = "foo")]
        public string Foo;

        public TestB(string Foo)
        {
            this.Foo = Foo;
        }

        public TestB()
        {
            this.Foo = "";
        }
    }
}
'''
"Types/TestD.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestD
    {
        [DataMember(Name = "test_c")]
        public NamespaceTestC? TestC;

        public TestD(NamespaceTestC? TestC)
        {
            this.TestC = TestC;
        }

        public TestD()
        {
        }
    }
}
'''
"Types/TestE.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestE
    {
        [DataMember(Name = "id")]
        public ulong Id;
        [DataMember(Name = "name")]
        public string Name;

        public TestE(
            ulong Id,
            string Name
        )
        {
            this.Id = Id;
            this.Name = Name;
        }

        public TestE()
        {
            this.Name = "";
        }
    }
}
'''
"Types/TestFoobar.g.cs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#nullable enable

using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace SpacetimeDB
{
    [SpacetimeDB.Type]
    [DataContract]
    public sealed partial class TestFoobar
    {
        [DataMember(Name = "field")]
        public Foobar Field;

        public TestFoobar(Foobar Field)
        {
            this.Field = Field;
        }

        public TestFoobar()
        {
            this.Field = null!;
        }
    }
}
'''
