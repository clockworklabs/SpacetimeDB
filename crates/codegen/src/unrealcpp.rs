//! Autogenerated Unreal‑C++ code‑gen backend for SpacetimeDB CLI
use crate::code_indenter::CodeIndenter;
use crate::util::{
    collect_case, fmt_fn, iter_tables, print_auto_generated_file_comment, print_auto_generated_version_comment,
};
use crate::util::{iter_indexes, iter_reducers};
use crate::Lang;
use crate::OutputFile;
use convert_case::{Case, Casing};
use spacetimedb_lib::sats::layout::PrimitiveType;
use spacetimedb_schema::def::{BTreeAlgorithm, IndexAlgorithm};
use spacetimedb_schema::def::{ModuleDef, ReducerDef, TableDef, TypeDef};
use spacetimedb_schema::identifier::Identifier;
use spacetimedb_schema::schema::{Schema, TableSchema};
use spacetimedb_schema::type_for_generate::{
    AlgebraicTypeDef, AlgebraicTypeUse, PlainEnumTypeDef, ProductTypeDef, SumTypeDef,
};
use std::collections::HashSet;
use std::fmt::{self};
use std::ops::Deref;
use std::path::Path;

pub struct UnrealCpp<'opts> {
    pub module_name: &'opts str,
    pub uproject_dir: &'opts Path,
}

// ---------------------------------------------------------------------------
//  Lang impl
// ---------------------------------------------------------------------------

impl UnrealCpp<'_> {
    fn get_api_macro(&self) -> String {
        format!("{}_API", self.module_name.to_uppercase())
    }
}

impl Lang for UnrealCpp<'_> {
    fn generate_table_file(&self, module: &ModuleDef, table: &TableDef) -> OutputFile {
        let struct_name = type_ref_name(module, table.product_type_ref);
        let self_header = struct_name.clone() + "Table";

        let mut output = UnrealCppAutogen::new(
            &[
                "Types/Builtins.h",
                &format!("ModuleBindings/Types/{struct_name}Type.g.h"),
                "Tables/RemoteTable.h",
                "DBCache/WithBsatn.h",
                "DBCache/TableHandle.h",
                "DBCache/TableCache.h",
            ],
            &self_header,
            false,
        );

        let row_struct = format!("F{struct_name}Type"); // e.g. "FUserType", "FMessageType"
        let handle_cls = format!("U{struct_name}Table"); // "UMessageTable"
        let table_name = table.name.deref().to_string();
        let table_pascal = struct_name.clone();

        let schema = TableSchema::from_module_def(module, table, (), 0.into())
            .validated()
            .expect("table schema should validate");

        // Generate unique index classes first
        let product_type = module.typespace_for_generate()[table.product_type_ref].as_product();

        let mut unique_indexes = Vec::new();
        let mut multi_key_indexes = Vec::new();

        for idx in iter_indexes(table) {
            let Some(accessor_name) = idx.accessor_name.as_ref() else {
                continue;
            };

            if let IndexAlgorithm::BTree(BTreeAlgorithm { columns }) = &idx.algorithm {
                if schema.is_unique(columns) {
                    if let Some(col) = columns.as_singleton() {
                        let (f_name, f_ty) = &product_type.unwrap().elements[col.idx()];
                        let field_name = f_name.deref().to_case(Case::Pascal);
                        let field_type = cpp_ty_fmt_with_module(module, f_ty, self.module_name).to_string();
                        let index_name = accessor_name.deref().to_case(Case::Pascal);
                        let index_class_name = format!("U{table_pascal}{index_name}UniqueIndex");
                        let key_type = field_type.clone();
                        let field_name_lowercase = field_name.to_lowercase();

                        writeln!(output, "UCLASS(Blueprintable)");
                        writeln!(
                            output,
                            "class {} {index_class_name} : public UObject",
                            self.get_api_macro()
                        );
                        writeln!(output, "{{");
                        writeln!(output, "    GENERATED_BODY()");
                        writeln!(output);
                        writeln!(output, "private:");
                        writeln!(output, "    // Declare an instance of your templated helper.");
                        writeln!(
                            output,
                            "    // It's private because the UObject wrapper will expose its functionality."
                        );
                        writeln!(
                            output,
                            "    FUniqueIndexHelper<{row_struct}, {key_type}, FTableCache<{row_struct}>> {index_name}IndexHelper;"
                        );
                        writeln!(output);
                        writeln!(output, "public:");
                        writeln!(output, "    {index_class_name}()");
                        writeln!(
                            output,
                            "        // Initialize the helper with the specific unique index name"
                        );
                        writeln!(output, "        : {index_name}IndexHelper(\"{}\") {{", f_name.deref());
                        writeln!(output, "    }}");
                        writeln!(output);
                        writeln!(output, "    /**");
                        writeln!(
                            output,
                            "     * Finds a {table_pascal} by their unique {field_name_lowercase}."
                        );
                        writeln!(output, "     * @param Key The {field_name_lowercase} to search for.");
                        writeln!(
                            output,
                            "     * @return The found {row_struct}, or a default-constructed {row_struct} if not found."
                        );
                        writeln!(output, "     */");

                        // Only mark as BlueprintCallable if the key type is Blueprint-compatible
                        if is_blueprintable(module, f_ty) {
                            writeln!(
                                output,
                                "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{table_pascal}Index\")"
                            );
                        } else {
                            writeln!(
                                output,
                                "    // NOTE: Not exposed to Blueprint because {key_type} types are not Blueprint-compatible"                                
                            );
                        }

                        writeln!(output, "    {row_struct} Find({key_type} Key)");
                        writeln!(output, "    {{");
                        writeln!(output, "        // Simply delegate the call to the internal helper");
                        writeln!(output, "        return {index_name}IndexHelper.FindUniqueIndex(Key);");
                        writeln!(output, "    }}");
                        writeln!(output);
                        writeln!(
                            output,
                            "    // A public setter to provide the cache to the helper after construction"
                        );
                        writeln!(output, "    // This is a common pattern when the cache might be created or provided by another system.");
                        writeln!(
                            output,
                            "    void SetCache(TSharedPtr<const FTableCache<{row_struct}>> In{table_pascal}Cache)"
                        );
                        writeln!(output, "    {{");
                        writeln!(output, "        {index_name}IndexHelper.Cache = In{table_pascal}Cache;");
                        writeln!(output, "    }}");
                        writeln!(output, "}};");
                        writeln!(output, "/***/");
                        writeln!(output);

                        unique_indexes.push((index_name, index_class_name, field_type, f_name.deref().to_string()));
                    }
                }
                // Handle non-unique BTree indexes
                else {
                    // Generate non-unique BTree index class
                    let _index_name = accessor_name.deref().to_case(Case::Pascal);
                    let index_class_name = format!("U{table_pascal}{_index_name}Index");

                    // Get column information
                    let column_info: Vec<_> = columns
                        .iter()
                        .map(|col| {
                            let (f_name, f_ty) = &product_type.unwrap().elements[col.idx()];
                            let field_name = f_name.deref().to_case(Case::Pascal);
                            let field_type = cpp_ty_fmt_with_module(module, f_ty, self.module_name).to_string();
                            let param_type = format!("const {field_type}&");

                            (field_name, field_type, param_type, f_ty, f_name.deref().to_string())
                        })
                        .collect();

                    // Create filter method name by concatenating column names
                    let filter_method_name = format!(
                        "Filter{}",
                        column_info
                            .iter()
                            .map(|(name, _, _, _, _)| name.as_str())
                            .collect::<Vec<_>>()
                            .join("")
                    );

                    // Create parameter list for methods
                    let method_params = column_info
                        .iter()
                        .map(|(field_name, _, param_type, _, _)| format!("{param_type} {field_name}"))
                        .collect::<Vec<_>>()
                        .join(", ");

                    // Create parameter names for internal call
                    let param_names = column_info
                        .iter()
                        .map(|(field_name, _, _, _, _)| field_name.clone())
                        .collect::<Vec<_>>()
                        .join(", ");

                    // Create TTuple type for FindByMultiKeyBTreeIndex
                    let tuple_types = column_info
                        .iter()
                        .map(|(_, field_type, _, _, _)| field_type.clone())
                        .collect::<Vec<_>>()
                        .join(", ");

                    // This is a potential bug in the original code, but keeping it as is for now
                    // Originally Arvikasoft had if column_info.len() == 1 { format!("TTuple<{tuple_types}>"); } else { format!("TTuple<{tuple_types}>"); }
                    // This makes no sense since both branches are the same
                    let tuple_type = format!("TTuple<{tuple_types}>");

                    writeln!(output, "UCLASS(Blueprintable)");
                    writeln!(output, "class {index_class_name} : public UObject");
                    writeln!(output, "{{");
                    writeln!(output, "    GENERATED_BODY()");
                    writeln!(output);
                    writeln!(output, "public:");

                    writeln!(output, "    TArray<{row_struct}> Filter({method_params}) const");
                    writeln!(output, "    {{");
                    writeln!(output, "        TArray<{row_struct}> OutResults;");
                    writeln!(output);
                    writeln!(output, "        LocalCache->FindByMultiKeyBTreeIndex<{tuple_type}>(");
                    writeln!(output, "            OutResults,");
                    writeln!(output, "            TEXT(\"{}\"),", accessor_name.deref());
                    writeln!(output, "            MakeTuple({param_names})");
                    writeln!(output, "        );");
                    writeln!(output);
                    writeln!(output, "        return OutResults;");
                    writeln!(output, "    }}");
                    writeln!(output);

                    writeln!(
                        output,
                        "    void SetCache(TSharedPtr<FTableCache<{row_struct}>> InCache)"
                    );
                    writeln!(output, "    {{");
                    writeln!(output, "        LocalCache = InCache;");
                    writeln!(output, "    }}");
                    writeln!(output);
                    writeln!(output, "private:");

                    // Check if all parameter types are Blueprint-compatible
                    let all_blueprintable = column_info
                        .iter()
                        .all(|(_, _, _, f_ty, _)| is_blueprintable(module, f_ty));

                    if all_blueprintable {
                        writeln!(output, "    UFUNCTION(BlueprintCallable)");
                    } else {
                        writeln!(output, "    // NOTE: Not exposed to Blueprint because some parameter types are not Blueprint-compatible");
                    }

                    writeln!(
                        output,
                        "    void {filter_method_name}(TArray<{row_struct}>& OutResults, {method_params})"
                    );
                    writeln!(output, "    {{");
                    writeln!(output, "        OutResults = Filter({param_names});");
                    writeln!(output, "    }}");
                    writeln!(output);

                    writeln!(output, "    TSharedPtr<FTableCache<{row_struct}>> LocalCache;");
                    writeln!(output, "}};");
                    writeln!(output);

                    // Store information for PostInitialize generation
                    let property_name = accessor_name.deref().to_case(Case::Pascal);
                    multi_key_indexes.push((property_name, index_class_name));
                }
            }
        }

        writeln!(output, "UCLASS(BlueprintType)");
        writeln!(
            output,
            "class {} {handle_cls} : public URemoteTable",
            self.get_api_macro()
        );
        writeln!(output, "{{");
        writeln!(output, "    GENERATED_BODY()");
        writeln!(output);
        writeln!(output, "public:");

        // Generate unique index properties
        for (index_name, index_class_name, _, _) in &unique_indexes {
            writeln!(output, "    UPROPERTY(BlueprintReadOnly)");
            writeln!(output, "    {index_class_name}* {index_name};");
            writeln!(output);
        }

        // Generate non-unique BTree index properties
        for (index_name, index_class_name) in &multi_key_indexes {
            writeln!(output, "    UPROPERTY(BlueprintReadOnly)");
            writeln!(output, "    {index_class_name}* {};", index_name.to_case(Case::Pascal));
            writeln!(output);
        }

        writeln!(output, "    void PostInitialize();");
        writeln!(output);

        writeln!(output, "    /** Update function for {table_name} table*/");
        writeln!(
            output,
            "    FTableAppliedDiff<{row_struct}> Update(TArray<FWithBsatn<{row_struct}>> InsertsRef, TArray<FWithBsatn<{row_struct}>> DeletesRef);"
        );
        writeln!(output);

        writeln!(output, "    /** Number of subscribed rows currently in the cache */");
        writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
        writeln!(output, "    int32 Count() const;");
        writeln!(output);

        writeln!(output, "    /** Return all subscribed rows in the cache */");
        writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
        writeln!(output, "    TArray<{row_struct}> Iter() const;");
        writeln!(output);

        // Generate table events in public section
        writeln!(output, "    // Table Events");
        writeln!(output, "    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams( ");
        writeln!(output, "        FOn{table_pascal}Insert,");
        writeln!(output, "        const FEventContext&, Context,");
        writeln!(output, "        const {row_struct}&, NewRow);");
        writeln!(output);

        writeln!(output, "    DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams( ");
        writeln!(output, "        FOn{table_pascal}Update,");
        writeln!(output, "        const FEventContext&, Context,");
        writeln!(output, "        const {row_struct}&, OldRow,");
        writeln!(output, "        const {row_struct}&, NewRow);");
        writeln!(output);

        writeln!(output, "    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams( ");
        writeln!(output, "        FOn{table_pascal}Delete,");
        writeln!(output, "        const FEventContext&, Context,");
        writeln!(output, "        const {row_struct}&, DeletedRow);");
        writeln!(output);

        writeln!(
            output,
            "    UPROPERTY(BlueprintAssignable, Category = \"SpacetimeDB Events\")"
        );
        writeln!(output, "    FOn{table_pascal}Insert OnInsert;");
        writeln!(output);

        writeln!(
            output,
            "    UPROPERTY(BlueprintAssignable, Category = \"SpacetimeDB Events\")"
        );
        writeln!(output, "    FOn{table_pascal}Update OnUpdate;");
        writeln!(output);

        writeln!(
            output,
            "    UPROPERTY(BlueprintAssignable, Category = \"SpacetimeDB Events\")"
        );
        writeln!(output, "    FOn{table_pascal}Delete OnDelete;");
        writeln!(output);

        writeln!(output, "private:");
        writeln!(output, "    const FString TableName = TEXT(\"{table_name}\");");
        writeln!(output);
        writeln!(output, "    TSharedPtr<UClientCache<{row_struct}>> Data;");

        writeln!(output, "}};"); // end UCLASS

        OutputFile {
            filename: format!(
                "Source/{}/Public/ModuleBindings/Tables/{}Table.g.h",
                self.module_name,
                type_ref_name(module, table.product_type_ref)
            ),
            code: output.into_inner(),
        }
    }

    fn generate_type_files(&self, module: &ModuleDef, typ: &TypeDef) -> Vec<OutputFile> {
        let name = typ
            .name
            .name_segments()
            .last()
            .map(|id| id.deref())
            .unwrap_or("Unnamed");
        let filename = format!(
            "Source/{}/Public/ModuleBindings/Types/{}Type.g.h",
            self.module_name,
            collect_case(Case::Pascal, typ.name.name_segments())
        );
        let code: String = match &module.typespace_for_generate()[typ.ty] {
            AlgebraicTypeDef::PlainEnum(plain_enum) => autogen_cpp_enum(name, plain_enum),
            AlgebraicTypeDef::Product(product_type_def) => {
                autogen_cpp_struct(module, name, product_type_def, &self.get_api_macro(), self.module_name)
            }
            AlgebraicTypeDef::Sum(sum_type_def) => {
                autogen_cpp_sum(module, name, sum_type_def, &self.get_api_macro(), self.module_name)
            }
        };

        vec![OutputFile { filename, code }]
    }

    fn generate_reducer_file(&self, module: &ModuleDef, reducer: &ReducerDef) -> OutputFile {
        let reducer_snake = reducer.name.deref();
        let pascal = reducer_snake.to_case(Case::Pascal);

        // Collect includes for parameter types
        let mut includes = HashSet::<String>::new();
        for (_param_name, param_type) in &reducer.params_for_generate.elements {
            collect_includes_for_type(module, param_type, &mut includes, self.module_name);
        }

        // Add ReducerBase.g.h for UReducerBase definition
        includes.insert("ModuleBindings/ReducerBase.g.h".to_string());

        // Convert to sorted vector
        let mut include_vec: Vec<String> = includes.into_iter().collect();
        include_vec.sort();

        // Convert to string references
        let include_refs: Vec<&str> = include_vec.iter().map(|s| s.as_str()).collect();

        let mut header = UnrealCppAutogen::new(&include_refs, &pascal, false);

        let args_struct = format!("F{pascal}Args");

        // Generate reducer arguments struct
        writeln!(header, "// Reducer arguments struct for {pascal}");
        writeln!(header, "USTRUCT(BlueprintType)");
        writeln!(header, "struct {} {args_struct}", self.get_api_macro());
        writeln!(header, "{{");
        writeln!(header, "    GENERATED_BODY()");
        writeln!(header);

        // Generate properties for each parameter
        for (param_name, param_type) in &reducer.params_for_generate.elements {
            let param_pascal = param_name.deref().to_case(Case::Pascal);
            let type_str = cpp_ty_fmt_with_module(module, param_type, self.module_name).to_string();
            let field_decl = format!("{type_str} {param_pascal}");

            // Check if the type is blueprintable
            if is_blueprintable(module, param_type) {
                writeln!(header, "    UPROPERTY(BlueprintReadWrite, Category=\"SpacetimeDB\")");
            } else {
                // Add comment explaining why the field isn't exposed as UPROPERTY
                writeln!(
                    header,
                    "    // NOTE: {type_str} field not exposed to Blueprint due to non-blueprintable elements"
                );
            }
            writeln!(header, "    {field_decl};");
            writeln!(header);
        }

        // Generate default constructor
        writeln!(header, "    {args_struct}() = default;");
        writeln!(header);

        // Generate parameterized constructor (for BSATN/internal use)
        if !reducer.params_for_generate.elements.is_empty() {
            write!(header, "    {args_struct}(");
            let mut first = true;
            for (param_name, param_type) in &reducer.params_for_generate.elements {
                if !first {
                    write!(header, ", ");
                }
                first = false;
                let param_pascal = param_name.deref().to_case(Case::Pascal);
                let type_str = cpp_ty_fmt_with_module(module, param_type, self.module_name).to_string();

                write!(header, "const {type_str}& In{param_pascal}");
            }
            writeln!(header, ")");

            write!(header, "        : ");
            let mut first = true;
            for (param_name, _) in &reducer.params_for_generate.elements {
                if !first {
                    write!(header, ", ");
                }
                first = false;
                let param_pascal = param_name.deref().to_case(Case::Pascal);
                write!(header, "{param_pascal}(In{param_pascal})");
            }
            writeln!(header);
            writeln!(header, "    {{}}");
            writeln!(header);
        }

        // Add operator== and operator!=
        writeln!(header);
        writeln!(
            header,
            "    FORCEINLINE bool operator==(const {args_struct}& Other) const"
        );
        writeln!(header, "    {{");

        // Generate comparison for each field
        let mut comparisons = Vec::new();
        for (param_name, _) in &reducer.params_for_generate.elements {
            let param_pascal = param_name.deref().to_case(Case::Pascal);

            // For value types, direct comparison
            comparisons.push(format!("{param_pascal} == Other.{param_pascal}"));
        }

        if comparisons.is_empty() {
            writeln!(header, "        return true;");
        } else {
            writeln!(header, "        return {};", comparisons.join(" && "));
        }

        writeln!(header, "    }}");
        writeln!(
            header,
            "    FORCEINLINE bool operator!=(const {args_struct}& Other) const"
        );
        writeln!(header, "    {{");
        writeln!(header, "        return !(*this == Other);");
        writeln!(header, "    }}");

        writeln!(header, "}};");
        writeln!(header);

        // Add BSATN serialization support for reducer args struct
        writeln!(header, "namespace UE::SpacetimeDB");
        writeln!(header, "{{");

        // Generate the field list for the UE_SPACETIMEDB_STRUCT macro
        let field_names: Vec<String> = reducer
            .params_for_generate
            .elements
            .iter()
            .map(|(name, _)| name.deref().to_case(Case::Pascal))
            .collect();

        if field_names.is_empty() {
            writeln!(header, "    UE_SPACETIMEDB_STRUCT_EMPTY({args_struct});");
        } else {
            writeln!(
                header,
                "    UE_SPACETIMEDB_STRUCT({args_struct}, {});",
                field_names.join(", ")
            );
        }

        writeln!(header, "}}");
        writeln!(header);

        // Generate the reducer class
        writeln!(header, "// Reducer class for internal dispatching");
        writeln!(header, "UCLASS(BlueprintType)");
        writeln!(
            header,
            "class {} U{pascal}Reducer : public UReducerBase",
            self.get_api_macro()
        );
        writeln!(header, "{{");
        writeln!(header, "    GENERATED_BODY()");
        writeln!(header);
        writeln!(header, "public:");

        // Generate properties for each parameter (for dispatching)
        for (param_name, param_type) in &reducer.params_for_generate.elements {
            let param_pascal = param_name.deref().to_case(Case::Pascal);
            let type_str = cpp_ty_fmt_with_module(module, param_type, self.module_name).to_string();
            let field_decl = format!("{type_str} {param_pascal}");

            // Check if the type is blueprintable
            if is_blueprintable(module, param_type) {
                writeln!(header, "    UPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
            } else {
                // Add comment explaining why the field isn't exposed as UPROPERTY
                writeln!(
                    header,
                    "    // NOTE: {type_str} field not exposed to Blueprint due to non-blueprintable elements"
                );
            }
            writeln!(header, "    {field_decl};");
        }
        if !reducer.params_for_generate.elements.is_empty() {
            writeln!(header);
        }

        writeln!(header, "}};");
        writeln!(header);

        writeln!(header);

        let module_name = &self.module_name;
        OutputFile {
            filename: format!("Source/{module_name}/Public/ModuleBindings/Reducers/{pascal}.g.h"),
            code: header.into_inner(),
        }
    }

    fn generate_global_files(&self, module: &ModuleDef) -> Vec<OutputFile> {
        let mut files: Vec<OutputFile> = vec![];

        // First, collect and generate all optional types
        let optional_types = collect_optional_types(module);
        for optional_name in optional_types {
            let module_name = &self.module_name;
            let module_name_pascal = module_name.to_case(Case::Pascal);
            let filename =
                format!("Source/{module_name}/Public/ModuleBindings/Optionals/{module_name_pascal}{optional_name}.g.h");

            let content = generate_optional_type(&optional_name, module, &self.get_api_macro(), self.module_name);
            files.push(OutputFile {
                filename,
                code: content,
            });
        }

        // Generate the main SpacetimeDBClient file with proper manual includes
        let mut includes = HashSet::<String>::new();

        // Add base includes
        includes.insert("Connection/DbConnectionBase.h".to_string());
        includes.insert("Connection/DbConnectionBuilder.h".to_string());
        includes.insert("Connection/Subscription.h".to_string());
        includes.insert("Connection/SetReducerFlags.h".to_string());
        includes.insert("Connection/Callback.h".to_string());
        includes.insert("ModuleBindings/ReducerBase.g.h".to_string());
        includes.insert("Kismet/BlueprintFunctionLibrary.h".to_string());

        // Include reducers
        for reducer in iter_reducers(module) {
            let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
            includes.insert(format!("ModuleBindings/Reducers/{reducer_pascal}.g.h"));
        }

        // Collect includes for types used in delegates and contexts
        // FSpacetimeDBIdentity is used in FOnConnectDelegate and context methods
        collect_includes_for_type(module, &AlgebraicTypeUse::Identity, &mut includes, self.module_name);
        // FSpacetimeDBConnectionId is used in context methods
        collect_includes_for_type(module, &AlgebraicTypeUse::ConnectionId, &mut includes, self.module_name);

        // Collect includes for all reducer parameter types
        for reducer in iter_reducers(module) {
            for (_param_name, param_type) in &reducer.params_for_generate.elements {
                collect_includes_for_type(module, param_type, &mut includes, self.module_name);
            }
        }

        // Convert to sorted vector
        let mut include_vec: Vec<String> = includes.into_iter().collect();
        include_vec.sort();

        // Convert to string references
        let include_refs: Vec<&str> = include_vec.iter().map(|s| s.as_str()).collect();

        let mut client_h = UnrealCppAutogen::new(&include_refs, "SpacetimeDBClient", true);

        // Forward declarations
        writeln!(client_h, "// Forward declarations");
        writeln!(client_h, "class UDbConnection;");
        writeln!(client_h, "class URemoteTables;");
        writeln!(client_h, "class URemoteReducers;");
        writeln!(client_h, "class USubscriptionBuilder;");
        writeln!(client_h, "class USubscriptionHandle;");
        writeln!(client_h);

        writeln!(client_h, "/** Forward declaration for tables */");
        for table in iter_tables(module) {
            let table_pascal = type_ref_name(module, table.product_type_ref);
            writeln!(client_h, "class U{table_pascal}Table;");
        }
        writeln!(client_h, "/***/");
        writeln!(client_h);

        // Delegates first (as in manual)
        generate_delegates(&mut client_h);

        // Context structs
        generate_context_structs(
            &mut client_h,
            module,
            &self.get_api_macro(),
            &self.module_name.to_case(Case::Pascal),
        );

        // SetReducerFlags class - inherits from USetReducerFlagsBase
        writeln!(client_h, "UCLASS(BlueprintType)");
        writeln!(
            client_h,
            "class {} USetReducerFlags : public USetReducerFlagsBase",
            self.get_api_macro()
        );
        writeln!(client_h, "{{");
        writeln!(client_h, "\tGENERATED_BODY()");
        writeln!(client_h);
        writeln!(client_h, "public:");

        for reducer in iter_reducers(module) {
            let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
            writeln!(client_h, "\tUFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
            writeln!(client_h, "\tvoid {reducer_pascal}(ECallReducerFlags Flag);");
        }

        writeln!(client_h);
        writeln!(client_h, "}};");
        writeln!(client_h);

        // RemoteTables class
        generate_remote_tables_class(&mut client_h, module, &self.get_api_macro());

        // RemoteReducers class
        generate_remote_reducers_class(&mut client_h, module, &self.get_api_macro(), self.module_name);

        // SubscriptionBuilder class
        generate_subscription_builder_class(&mut client_h, &self.get_api_macro());

        // SubscriptionHandle class
        generate_subscription_handle_class(&mut client_h, &self.get_api_macro());

        // DbConnectionBuilder class
        generate_db_connection_builder_class(&mut client_h, &self.get_api_macro());

        // Main DbConnection class
        generate_db_connection_class(&mut client_h, module, &self.get_api_macro());

        // Generate the separate ReducerBase file
        let mut reducer_base_header = UnrealCppAutogen::new(&[], "ReducerBase", false);

        // Generate the UReducerBase class
        writeln!(reducer_base_header, "// Abstract Reducer base class");
        writeln!(reducer_base_header, "UCLASS(Abstract, BlueprintType)");
        writeln!(
            reducer_base_header,
            "class {} UReducerBase : public UObject",
            self.get_api_macro()
        );
        writeln!(reducer_base_header, "{{");
        writeln!(reducer_base_header, "    GENERATED_BODY()");
        writeln!(reducer_base_header);
        writeln!(reducer_base_header, "public:");
        writeln!(reducer_base_header, "    virtual ~UReducerBase() = default;");
        writeln!(reducer_base_header, "}};");
        writeln!(reducer_base_header);

        files.push(OutputFile {
            filename: format!("Source/{}/Public/ModuleBindings/ReducerBase.g.h", self.module_name),
            code: reducer_base_header.into_inner(),
        });

        files.push(OutputFile {
            filename: format!(
                "Source/{}/Public/ModuleBindings/SpacetimeDBClient.g.h",
                self.module_name
            ),
            code: client_h.into_inner(),
        });

        // Build table includes
        let table_includes: Vec<String> = module
            .tables()
            .map(|table| {
                format!(
                    "ModuleBindings/Tables/{}Table.g.h",
                    type_ref_name(module, table.product_type_ref)
                )
            })
            .collect();
        let table_includes_str: Vec<&str> = table_includes.iter().map(|s| s.as_str()).collect();

        let mut cpp_includes = vec!["ModuleBindings/SpacetimeDBClient.g.h"];

        // Add additional includes from manual reference
        cpp_includes.extend_from_slice(&["DBCache/WithBsatn.h", "BSATN/UEBSATNHelpers.h"]);

        // Add table includes
        cpp_includes.extend(table_includes_str);

        let mut client_cpp = UnrealCppAutogen::new_cpp(&cpp_includes);
        generate_client_implementation(&mut client_cpp, module, self.module_name);
        files.push(OutputFile {
            filename: format!(
                "Source/{}/Private/ModuleBindings/SpacetimeDBClient.g.cpp",
                self.module_name
            ),
            code: client_cpp.into_inner(),
        });

        // Generate .cpp implementation files for each table
        for table in module.tables() {
            let table_cpp_content = generate_table_cpp(module, table, self.module_name);
            let table_cpp_filename = format!(
                "Source/{}/Private/ModuleBindings/Tables/{}Table.g.cpp",
                self.module_name,
                type_ref_name(module, table.product_type_ref)
            );
            files.push(OutputFile {
                filename: table_cpp_filename,
                code: table_cpp_content,
            });
        }

        files
    }
}

// Helper function to generate table .cpp implementation files
fn generate_table_cpp(module: &ModuleDef, table: &TableDef, module_name: &str) -> String {
    let table_pascal = type_ref_name(module, table.product_type_ref);
    let row_struct = format!("F{table_pascal}Type");

    // Include the table header and other necessary headers
    let table_header = format!("ModuleBindings/Tables/{table_pascal}Table.g.h");
    let includes = vec![
        table_header.as_str(),
        "DBCache/UniqueIndex.h",
        "DBCache/BTreeUniqueIndex.h",
        "DBCache/ClientCache.h",
        "DBCache/TableCache.h",
    ];

    let mut output = UnrealCppAutogen::new_cpp(&includes);

    let schema = TableSchema::from_module_def(module, table, (), 0.into())
        .validated()
        .expect("table schema should validate");

    // Get unique indexes and non-unique BTree indexes
    let product_type = module.typespace_for_generate()[table.product_type_ref].as_product();

    let mut unique_indexes = Vec::new();
    let mut multi_key_indexes = Vec::new();

    for idx in iter_indexes(table) {
        let Some(accessor_name) = idx.accessor_name.as_ref() else {
            continue;
        };
        if let IndexAlgorithm::BTree(BTreeAlgorithm { columns }) = &idx.algorithm {
            if schema.is_unique(columns) {
                if let Some(col) = columns.as_singleton() {
                    let (f_name, f_ty) = &product_type.unwrap().elements[col.idx()];
                    let _field_name = f_name.deref().to_case(Case::Pascal);
                    let field_type = cpp_ty_fmt_with_module(module, f_ty, module_name).to_string();
                    let index_name = accessor_name.deref().to_case(Case::Pascal);
                    unique_indexes.push((index_name, field_type, f_name.deref().to_string()));
                }
            } else {
                // Non-unique BTree index
                let index_name = accessor_name.deref().to_case(Case::Pascal);
                let index_class_name = format!("U{table_pascal}{index_name}Index");

                // Collect column information for AddMultiKeyBTreeIndex call
                let column_info: Vec<_> = columns
                    .iter()
                    .map(|col| {
                        let (f_name, f_ty) = &product_type.unwrap().elements[col.idx()];
                        let field_name = f_name.deref().to_case(Case::Pascal);
                        let field_type = cpp_ty_fmt_with_module(module, f_ty, module_name).to_string();
                        (field_name, field_type)
                    })
                    .collect();

                multi_key_indexes.push((
                    index_name,
                    index_class_name,
                    accessor_name.deref().to_string(),
                    column_info,
                ));
            }
        }
    }

    // Generate PostInitialize implementation
    writeln!(output, "void U{table_pascal}Table::PostInitialize()");
    writeln!(output, "{{");
    writeln!(output, "    /** Client cache init and setting up indexes*/");
    writeln!(output, "    Data = MakeShared<UClientCache<{row_struct}>>();");
    writeln!(output);
    writeln!(
        output,
        "    TSharedPtr<FTableCache<{row_struct}>> {table_pascal}Table = Data->GetOrAdd(TableName);"
    );

    // Add unique constraints for each unique index
    for (_index_name, field_type, field_name) in &unique_indexes {
        writeln!(
            output,
            "    {table_pascal}Table->AddUniqueConstraint<{field_type}>(\"{}\", [](const {row_struct}& Row) -> const {field_type}& {{",
            field_name.to_lowercase()
        );
        writeln!(output, "        return Row.{}; }});", field_name.to_case(Case::Pascal));
    }

    writeln!(output);
    for (index_name, _, _) in &unique_indexes {
        let index_class_name = format!("U{table_pascal}{index_name}UniqueIndex");
        writeln!(output, "    {index_name} = NewObject<{index_class_name}>(this);");
        writeln!(output, "    {index_name}->SetCache({table_pascal}Table);");
        writeln!(output);
    }

    // Add multi-key BTree indexes
    for (index_name, index_class_name, accessor_name, column_info) in &multi_key_indexes {
        // Generate TTuple type for AddMultiKeyBTreeIndex
        let tuple_types: Vec<String> = column_info.iter().map(|(_, field_type)| field_type.clone()).collect();
        let tuple_type = format!("TTuple<{}>", tuple_types.join(", "));

        // Generate field access expressions
        let field_accesses: Vec<String> = column_info
            .iter()
            .map(|(field_name, _)| format!("Row.{field_name}"))
            .collect();

        writeln!(
            output,
            "    // Register a new multi-key B-Tree index named \"{accessor_name}\" on the {table_pascal}Table."
        );
        writeln!(output, "    {table_pascal}Table->AddMultiKeyBTreeIndex<{tuple_type}>(");
        writeln!(output, "        TEXT(\"{accessor_name}\"),");
        writeln!(output, "        [](const {row_struct}& Row)");
        writeln!(output, "        {{");
        writeln!(
            output,
            "            // This tuple is stored in the B-Tree index for fast composite key lookups."
        );
        writeln!(output, "            return MakeTuple({});", field_accesses.join(", "));
        writeln!(output, "        }}");
        writeln!(output, "    );");
        writeln!(output);
        writeln!(output, "    {index_name} = NewObject<{index_class_name}>(this);");
        writeln!(output, "    {index_name}->SetCache({table_pascal}Table);");
        writeln!(output);
    }

    writeln!(output, "    /***/");
    writeln!(output, "}}");
    writeln!(output);

    // Generate Update implementation
    writeln!(
        output,
        "FTableAppliedDiff<{row_struct}> U{table_pascal}Table::Update(TArray<FWithBsatn<{row_struct}>> InsertsRef, TArray<FWithBsatn<{row_struct}>> DeletesRef)"
    );
    writeln!(output, "{{");
    writeln!(
        output,
        "    FTableAppliedDiff<{row_struct}> Diff = BaseUpdate<{row_struct}>(InsertsRef, DeletesRef, Data, TableName);"
    );
    writeln!(output);

    // Add DeriveUpdatesByPrimaryKey if table has a primary key
    if let Some(pk) = schema.pk() {
        let pk_field_name = pk.col_name.deref().to_case(Case::Pascal);
        let pk_type = &product_type.unwrap().elements[pk.col_pos.idx()].1;
        let pk_type_str = cpp_ty_fmt_with_module(module, pk_type, module_name).to_string();
        writeln!(output, "    Diff.DeriveUpdatesByPrimaryKey<{pk_type_str}>(");
        writeln!(output, "        [](const {row_struct}& Row) ");
        writeln!(output, "        {{");
        writeln!(output, "            return Row.{pk_field_name}; ");
        writeln!(output, "        }}");
        writeln!(output, "    );");
        writeln!(output);
    }

    // Reset cache for indexes
    // for (index_name, _, _) in &unique_indexes {
    //     writeln!(output, "    {}->SetCache(Data->GetOrAdd(TableName));", index_name);
    // }

    // for (index_name, _, _, _) in &multi_key_indexes {
    //     writeln!(output, "    {}->SetCache(Data->GetOrAdd(TableName));", index_name);
    // }

    writeln!(output, "    return Diff;");
    writeln!(output, "}}");
    writeln!(output);

    // Generate Count implementation
    writeln!(output, "int32 U{table_pascal}Table::Count() const");
    writeln!(output, "{{");
    writeln!(
        output,
        "    return GetRowCountFromTable<{row_struct}>(Data, TableName);"
    );
    writeln!(output, "}}");
    writeln!(output);

    // Generate Iter implementation
    writeln!(output, "TArray<{row_struct}> U{table_pascal}Table::Iter() const");
    writeln!(output, "{{");
    writeln!(output, "    return GetAllRowsFromTable<{row_struct}>(Data, TableName);");
    writeln!(output, "}}");

    output.into_inner()
}

// Helper functions for generating the consolidated SpacetimeDBClient file

fn generate_delegates(output: &mut UnrealCppAutogen) {
    writeln!(
        output,
        "// Delegates using the generated connection type. These wrap the base"
    );
    writeln!(
        output,
        "// delegates defined in the SDK so that projects can work directly with"
    );
    writeln!(output, "// UDbConnection without manual casting in user code.");
    writeln!(output, "DECLARE_DYNAMIC_DELEGATE_ThreeParams(");
    writeln!(output, "\tFOnConnectDelegate,");
    writeln!(output, "\tUDbConnection*, Connection,");
    writeln!(output, "\tFSpacetimeDBIdentity, Identity,");
    writeln!(output, "\tconst FString&, Token);");
    writeln!(output);
    writeln!(output, "DECLARE_DYNAMIC_DELEGATE_TwoParams(");
    writeln!(output, "\tFOnDisconnectDelegate,");
    writeln!(output, "\tUDbConnection*, Connection,");
    writeln!(output, "\tconst FString&, Error);");
    writeln!(output);
    writeln!(output);
}

fn generate_context_structs(output: &mut UnrealCppAutogen, module: &ModuleDef, api_macro: &str, module_name: &str) {
    writeln!(output, "// Context classes for event handling");
    writeln!(output);
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} FContextBase");
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);
    writeln!(
        output,
        "\tFContextBase() : Db(nullptr), Reducers(nullptr), SetReducerFlags(nullptr), Conn(nullptr) {{}};"
    );
    writeln!(output, "\tFContextBase(UDbConnection* InConn);");
    writeln!(output);
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category = \"SpacetimeDB\")");
    writeln!(output, "\tURemoteTables* Db;");
    writeln!(output);
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category = \"SpacetimeDB\")");
    writeln!(output, "\tURemoteReducers* Reducers;");
    writeln!(output);
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category = \"SpacetimeDB\")");
    writeln!(output, "\tUSetReducerFlags* SetReducerFlags;");
    writeln!(output);
    writeln!(output, "\tbool IsActive() const;");
    writeln!(output, "\tvoid Disconnect();");
    writeln!(
        output,
        "\tbool TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const;"
    );
    writeln!(output, "\tFSpacetimeDBConnectionId GetConnectionId() const;");
    writeln!(output, "\tUSubscriptionBuilder* SubscriptionBuilder();");
    writeln!(output);
    writeln!(output, "protected:");
    writeln!(output, "\tUPROPERTY()");
    writeln!(output, "\tUDbConnection* Conn;");
    writeln!(output);
    writeln!(output, "}};");
    writeln!(output);

    // BPLib for FContextBase - Needed to allow inheritance in Blueprint
    writeln!(output, "UCLASS()");
    writeln!(
        output,
        "class {api_macro} UContextBaseBpLib : public UBlueprintFunctionLibrary"
    );
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);
    writeln!(output, "private:");

    writeln!(output, "\tUFUNCTION(BlueprintPure, Category=\"SpacetimeDB\")");
    writeln!(
        output,
        "\tstatic URemoteTables* GetDb(const FContextBase& Ctx) {{ return Ctx.Db; }}"
    );
    writeln!(output);
    writeln!(output, "\tUFUNCTION(BlueprintPure, Category=\"SpacetimeDB\")");
    writeln!(
        output,
        "\tstatic URemoteReducers* GetReducers(const FContextBase& Ctx) {{ return Ctx.Reducers; }}"
    );
    writeln!(output);
    writeln!(output, "\tUFUNCTION(BlueprintPure, Category=\"SpacetimeDB\")");
    writeln!(
        output,
        "\tstatic USetReducerFlags* GetSetReducerFlags(const FContextBase& Ctx) {{ return Ctx.SetReducerFlags; }}"
    );
    writeln!(output);
    writeln!(output, "\tUFUNCTION(BlueprintPure, Category=\"SpacetimeDB\")");
    writeln!(
        output,
        "\tstatic bool IsActive(const FContextBase& Ctx) {{ return Ctx.IsActive(); }}"
    );

    writeln!(output, "}};");
    writeln!(output);

    // ---------------------------------------------------------------------
    // Per-module typed Reducer tagged union + typed Event
    // ---------------------------------------------------------------------
    writeln!(output, "UENUM(BlueprintType, Category = \"SpacetimeDB\")");
    writeln!(output, "enum class EReducerTag : uint8");
    writeln!(output, "{{");
    {
        let mut first = true;
        for reducer in iter_reducers(module) {
            let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
            if !first {
                writeln!(output, ",");
            } else {
                first = false;
            }
            write!(output, "    {reducer_pascal}");
        }
        writeln!(output);
    }
    writeln!(output, "}};");
    writeln!(output);

    // FReducer: tagged union over reducer args, with optional metadata
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} FReducer");
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "public:");
    writeln!(output, "    UPROPERTY(BlueprintReadOnly, Category = \"SpacetimeDB\")");
    writeln!(output, "    EReducerTag Tag = static_cast<EReducerTag>(0);");
    writeln!(output);
    write!(output, "    TVariant<");
    {
        let mut first = true;
        for reducer in iter_reducers(module) {
            let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
            if !first {
                write!(output, ", ");
            } else {
                first = false;
            }
            write!(output, "F{reducer_pascal}Args");
        }
    }
    writeln!(output, "> Data;");
    writeln!(output);
    writeln!(output, "    // Optional metadata");
    writeln!(output, "    UPROPERTY(BlueprintReadOnly, Category = \"SpacetimeDB\")");
    writeln!(output, "    FString ReducerName;");
    writeln!(output, "    uint32 ReducerId = 0;");
    writeln!(output, "    uint32 RequestId = 0;");
    writeln!(output);

    // Static constructors, Is*, GetAs*
    for reducer in iter_reducers(module) {
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
        writeln!(
            output,
            "    static FReducer {reducer_pascal}(const F{reducer_pascal}Args& Value)"
        );
        writeln!(output, "    {{");
        writeln!(output, "        FReducer Out;");
        writeln!(output, "        Out.Tag = EReducerTag::{reducer_pascal};");
        writeln!(output, "        Out.Data.Set<F{reducer_pascal}Args>(Value);");
        writeln!(output, "        Out.ReducerName = TEXT(\"{}\");", reducer.name.deref());
        writeln!(output, "        return Out;");
        writeln!(output, "    }}");
        writeln!(output);
        writeln!(
            output,
            "    FORCEINLINE bool Is{reducer_pascal}() const {{ return Tag == EReducerTag::{reducer_pascal}; }}"
        );
        writeln!(
            output,
            "    FORCEINLINE F{reducer_pascal}Args GetAs{reducer_pascal}() const"
        );
        writeln!(output, "    {{");
        writeln!(
            output,
            "        ensureMsgf(Is{reducer_pascal}(), TEXT(\"Reducer does not hold {reducer_pascal}!\"));"
        );
        writeln!(output, "        return Data.Get<F{reducer_pascal}Args>();");
        writeln!(output, "    }}");
        writeln!(output);
    }
    writeln!(output, "    FORCEINLINE bool operator==(const FReducer& Other) const");
    writeln!(output, "    {{");
    writeln!(output, "        if (Tag != Other.Tag || ReducerId != Other.ReducerId || RequestId != Other.RequestId || ReducerName != Other.ReducerName) return false;");
    writeln!(output, "        switch (Tag)");
    writeln!(output, "        {{");
    for reducer in iter_reducers(module) {
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
        writeln!(output, "        case EReducerTag::{reducer_pascal}:");
        writeln!(
            output,
            "            return GetAs{reducer_pascal}() == Other.GetAs{reducer_pascal}();"
        );
    }
    writeln!(output, "        default: return false;");
    writeln!(output, "        }}");
    writeln!(output, "    }}");
    writeln!(
        output,
        "    FORCEINLINE bool operator!=(const FReducer& Other) const {{ return !(*this == Other); }}"
    );
    writeln!(output, "}};");
    writeln!(output);

    // BPLib for FReducer
    writeln!(output, "UCLASS()");
    writeln!(
        output,
        "class {api_macro} UReducerBpLib : public UBlueprintFunctionLibrary"
    );
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "private:");

    for reducer in iter_reducers(module) {
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
        // ---- Static constructors ----
        writeln!(output);
        writeln!(
            output,
            "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|Reducer\")"
        );
        writeln!(
            output,
            "    static FReducer {reducer_pascal}(const F{reducer_pascal}Args& Value) {{"
        );
        writeln!(output, "        return FReducer::{reducer_pascal}(Value);");
        writeln!(output, "    }}");
        writeln!(output);

        // Is*
        writeln!(
            output,
            "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|Reducer\")"
        );
        writeln!(
            output,
            "    static bool Is{reducer_pascal}(const FReducer& Reducer) {{ return Reducer.Is{reducer_pascal}(); }}"
        );
        writeln!(output);

        // GetAs*
        writeln!(
            output,
            "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|Reducer\")"
        );
        writeln!(
            output,
            "    static F{reducer_pascal}Args GetAs{reducer_pascal}(const FReducer& Reducer) {{"
        );
        writeln!(output, "        return Reducer.GetAs{reducer_pascal}();");
        writeln!(output, "    }}");
    }

    writeln!(output, "}};");
    writeln!(output);

    // FReducerEvent: metadata about a reducer invocation, with typed args
    writeln!(output, "/** Metadata describing a reducer run. */");
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} F{module_name}ReducerEvent");
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);

    writeln!(output, "\t/** Timestamp for when the reducer executed */");
    writeln!(
        output,
        "\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"SpacetimeDB\")"
    );
    writeln!(output, "\tFSpacetimeDBTimestamp Timestamp;");
    writeln!(output);

    writeln!(output, "\t/** Result status of the reducer */");
    writeln!(
        output,
        "\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"SpacetimeDB\")"
    );
    writeln!(output, "\tFSpacetimeDBStatus Status;");
    writeln!(output);

    writeln!(output, "\t/** Identity that initiated the call */");
    writeln!(
        output,
        "\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"SpacetimeDB\")"
    );
    writeln!(output, "\tFSpacetimeDBIdentity CallerIdentity;");
    writeln!(output);

    writeln!(output, "\t/** Connection ID for the caller */");
    writeln!(
        output,
        "\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"SpacetimeDB\")"
    );
    writeln!(output, "\tFSpacetimeDBConnectionId CallerConnectionId;");
    writeln!(output);

    writeln!(output, "\t/** Energy consumed while executing */");
    writeln!(
        output,
        "\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"SpacetimeDB\")"
    );
    writeln!(output, "\tFEnergyQuantaType EnergyConsumed;");
    writeln!(output);

    writeln!(output, "\t/** Detailed call information */");
    writeln!(
        output,
        "\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category=\"SpacetimeDB\")"
    );
    writeln!(output, "\tFReducer Reducer;");
    writeln!(output);

    writeln!(
        output,
        "\tFORCEINLINE bool operator==(const F{module_name}ReducerEvent& Other) const"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\treturn Status == Other.Status && Timestamp == Other.Timestamp && CallerIdentity == Other.CallerIdentity &&");
    writeln!(
        output,
        "\t\t\tCallerConnectionId == Other.CallerConnectionId && EnergyConsumed == Other.EnergyConsumed &&"
    );
    writeln!(output, "\t\t\tReducer == Other.Reducer;");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tFORCEINLINE bool operator!=(const F{module_name}ReducerEvent& Other) const"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\treturn !(*this == Other);");
    writeln!(output, "\t}}");
    writeln!(output, "}};");
    writeln!(output);

    // {}Event: union-like struct representing SpacetimeDB event messages
    writeln!(output, "/** Represents event with variant message data. */");
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} F{module_name}Event");
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);

    writeln!(
        output,
        "\t/** Tagged union holding reducer call, unit events, or error string */"
    );
    writeln!(output, "\tTVariant<FReducer, FSpacetimeDBUnit, FString> MessageData;");
    writeln!(output);

    writeln!(output, "\t/** Type tag indicating what this event represents */");
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
    writeln!(
        output,
        "\tESpacetimeDBEventTag Tag = ESpacetimeDBEventTag::UnknownTransaction;"
    );
    writeln!(output);

    // === Static factory methods ===
    writeln!(output, "\t/** === Static factory methods ===*/");
    writeln!(output, "\tstatic F{module_name}Event Reducer(const FReducer& Value)");
    writeln!(output, "\t{{");
    writeln!(output, "\t\tF{module_name}Event Obj;");
    writeln!(output, "\t\tObj.Tag = ESpacetimeDBEventTag::Reducer;");
    writeln!(output, "\t\tObj.MessageData.Set<FReducer>(Value);");
    writeln!(output, "\t\treturn Obj;");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tstatic F{module_name}Event SubscribeApplied(const FSpacetimeDBUnit& Value)"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\tF{module_name}Event Obj;");
    writeln!(output, "\t\tObj.Tag = ESpacetimeDBEventTag::SubscribeApplied;");
    writeln!(output, "\t\tObj.MessageData.Set<FSpacetimeDBUnit>(Value);");
    writeln!(output, "\t\treturn Obj;");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tstatic F{module_name}Event UnsubscribeApplied(const FSpacetimeDBUnit& Value)"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\tF{module_name}Event Obj;");
    writeln!(output, "\t\tObj.Tag = ESpacetimeDBEventTag::UnsubscribeApplied;");
    writeln!(output, "\t\tObj.MessageData.Set<FSpacetimeDBUnit>(Value);");
    writeln!(output, "\t\treturn Obj;");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tstatic F{module_name}Event Disconnected(const FSpacetimeDBUnit& Value)"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\tF{module_name}Event Obj;");
    writeln!(output, "\t\tObj.Tag = ESpacetimeDBEventTag::Disconnected;");
    writeln!(output, "\t\tObj.MessageData.Set<FSpacetimeDBUnit>(Value);");
    writeln!(output, "\t\treturn Obj;");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tstatic F{module_name}Event SubscribeError(const FString& Value)"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\tF{module_name}Event Obj;");
    writeln!(output, "\t\tObj.Tag = ESpacetimeDBEventTag::SubscribeError;");
    writeln!(output, "\t\tObj.MessageData.Set<FString>(Value);");
    writeln!(output, "\t\treturn Obj;");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tstatic F{module_name}Event UnknownTransaction(const FSpacetimeDBUnit& Value)"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\tF{module_name}Event Obj;");
    writeln!(output, "\t\tObj.Tag = ESpacetimeDBEventTag::UnknownTransaction;");
    writeln!(output, "\t\tObj.MessageData.Set<FSpacetimeDBUnit>(Value);");
    writeln!(output, "\t\treturn Obj;");
    writeln!(output, "\t}}");
    writeln!(output);

    // === Tag checks and getters ===
    writeln!(
        output,
        "\tFORCEINLINE bool IsReducer() const {{ return Tag == ESpacetimeDBEventTag::Reducer; }}"
    );
    writeln!(output, "\tFORCEINLINE FReducer GetAsReducer() const");
    writeln!(output, "\t{{");
    writeln!(
        output,
        "\t\tensureMsgf(IsReducer(), TEXT(\"MessageData does not hold Reducer!\"));"
    );
    writeln!(output, "\t\treturn MessageData.Get<FReducer>();");
    writeln!(output, "\t}}");
    writeln!(output);
    writeln!(
        output,
        "\tFORCEINLINE bool IsSubscribeApplied() const {{ return Tag == ESpacetimeDBEventTag::SubscribeApplied; }}"
    );
    writeln!(output, "\tFORCEINLINE FSpacetimeDBUnit GetAsSubscribeApplied() const");
    writeln!(output, "\t{{");
    writeln!(
        output,
        "\t\tensureMsgf(IsSubscribeApplied(), TEXT(\"MessageData does not hold SubscribeApplied!\"));"
    );
    writeln!(output, "\t\treturn MessageData.Get<FSpacetimeDBUnit>();");
    writeln!(output, "\t}}");
    writeln!(output);
    writeln!(
        output,
        "\tFORCEINLINE bool IsUnsubscribeApplied() const {{ return Tag == ESpacetimeDBEventTag::UnsubscribeApplied; }}"
    );
    writeln!(output, "\tFORCEINLINE FSpacetimeDBUnit GetAsUnsubscribeApplied() const");
    writeln!(output, "\t{{");
    writeln!(
        output,
        "\t\tensureMsgf(IsUnsubscribeApplied(), TEXT(\"MessageData does not hold UnsubscribeApplied!\"));"
    );
    writeln!(output, "\t\treturn MessageData.Get<FSpacetimeDBUnit>();");
    writeln!(output, "\t}}");
    writeln!(output);
    writeln!(
        output,
        "\tFORCEINLINE bool IsDisconnected() const {{ return Tag == ESpacetimeDBEventTag::Disconnected; }}"
    );
    writeln!(output, "\tFORCEINLINE FSpacetimeDBUnit GetAsDisconnected() const");
    writeln!(output, "\t{{");
    writeln!(
        output,
        "\t\tensureMsgf(IsDisconnected(), TEXT(\"MessageData does not hold Disconnected!\"));"
    );
    writeln!(output, "\t\treturn MessageData.Get<FSpacetimeDBUnit>();");
    writeln!(output, "\t}}");
    writeln!(output);
    writeln!(
        output,
        "\tFORCEINLINE bool IsSubscribeError() const {{ return Tag == ESpacetimeDBEventTag::SubscribeError; }}"
    );
    writeln!(output, "\tFORCEINLINE FString GetAsSubscribeError() const");
    writeln!(output, "\t{{");
    writeln!(
        output,
        "\t\tensureMsgf(IsSubscribeError(), TEXT(\"MessageData does not hold SubscribeError!\"));"
    );
    writeln!(output, "\t\treturn MessageData.Get<FString>();");
    writeln!(output, "\t}}");
    writeln!(output);
    writeln!(
        output,
        "\tFORCEINLINE bool IsUnknownTransaction() const {{ return Tag == ESpacetimeDBEventTag::UnknownTransaction; }}"
    );
    writeln!(output, "\tFORCEINLINE FSpacetimeDBUnit GetAsUnknownTransaction() const");
    writeln!(output, "\t{{");
    writeln!(
        output,
        "\t\tensureMsgf(IsUnknownTransaction(), TEXT(\"MessageData does not hold UnknownTransaction!\"));"
    );
    writeln!(output, "\t\treturn MessageData.Get<FSpacetimeDBUnit>();");
    writeln!(output, "\t}}");
    writeln!(output);

    // === Equality operators ===
    writeln!(
        output,
        "\tFORCEINLINE bool operator==(const F{module_name}Event& Other) const"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\tif (Tag != Other.Tag) return false;");
    writeln!(output, "\t\tswitch (Tag)");
    writeln!(output, "\t\t{{");
    writeln!(
        output,
        "\t\tcase ESpacetimeDBEventTag::Reducer: return GetAsReducer() == Other.GetAsReducer();"
    );
    writeln!(output, "\t\tcase ESpacetimeDBEventTag::SubscribeApplied: return GetAsSubscribeApplied() == Other.GetAsSubscribeApplied();");
    writeln!(output, "\t\tcase ESpacetimeDBEventTag::UnsubscribeApplied: return GetAsUnsubscribeApplied() == Other.GetAsUnsubscribeApplied();");
    writeln!(
        output,
        "\t\tcase ESpacetimeDBEventTag::Disconnected: return GetAsDisconnected() == Other.GetAsDisconnected();"
    );
    writeln!(
        output,
        "\t\tcase ESpacetimeDBEventTag::SubscribeError: return GetAsSubscribeError() == Other.GetAsSubscribeError();"
    );
    writeln!(output, "\t\tcase ESpacetimeDBEventTag::UnknownTransaction: return GetAsUnknownTransaction() == Other.GetAsUnknownTransaction();");
    writeln!(output, "\t\tdefault: return false;");
    writeln!(output, "\t\t}}");
    writeln!(output, "\t}}");
    writeln!(output);

    writeln!(
        output,
        "\tFORCEINLINE bool operator!=(const F{module_name}Event& Other) const"
    );
    writeln!(output, "\t{{");
    writeln!(output, "\t\treturn !(*this == Other);");
    writeln!(output, "\t}}");
    writeln!(output, "}};");
    writeln!(output);

    // BPLib
    writeln!(output, "UCLASS()");
    writeln!(
        output,
        "class {api_macro} U{module_name}EventBpLib : public UBlueprintFunctionLibrary"
    );
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "private:");

    // Reducer
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static F{module_name}Event Reducer(const FReducer& InValue)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return F{module_name}Event::Reducer(InValue);");
    writeln!(output, "    }}");
    writeln!(output);

    // SubscribeApplied
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static F{module_name}Event SubscribeApplied(const FSpacetimeDBUnit& InValue)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return F{module_name}Event::SubscribeApplied(InValue);");
    writeln!(output, "    }}");
    writeln!(output);

    // UnsubscribeApplied
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static F{module_name}Event UnsubscribeApplied(const FSpacetimeDBUnit& InValue)"
    );
    writeln!(output, "    {{");
    writeln!(
        output,
        "        return F{module_name}Event::UnsubscribeApplied(InValue);"
    );
    writeln!(output, "    }}");
    writeln!(output);

    // Disconnected
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static F{module_name}Event Disconnected(const FSpacetimeDBUnit& InValue)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return F{module_name}Event::Disconnected(InValue);");
    writeln!(output, "    }}");
    writeln!(output);

    // SubscribeError
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static F{module_name}Event SubscribeError(const FString& InValue)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return F{module_name}Event::SubscribeError(InValue);");
    writeln!(output, "    }}");
    writeln!(output);

    // UnknownTransaction
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static F{module_name}Event UnknownTransaction(const FSpacetimeDBUnit& InValue)"
    );
    writeln!(output, "    {{");
    writeln!(
        output,
        "        return F{module_name}Event::UnknownTransaction(InValue);"
    );
    writeln!(output, "    }}");
    writeln!(output);

    // Is* helpers
    for case in [
        "Reducer",
        "SubscribeApplied",
        "UnsubscribeApplied",
        "Disconnected",
        "SubscribeError",
        "UnknownTransaction",
    ] {
        writeln!(
            output,
            "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
        );
        writeln!(
            output,
            "    static bool Is{case}(const F{module_name}Event& Event) {{ return Event.Is{case}(); }}"
        );
        writeln!(output);
    }

    // GetAs* helpers
    writeln!(
        output,
        "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static FReducer GetAsReducer(const F{module_name}Event& Event)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return Event.GetAsReducer();");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(
        output,
        "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static FSpacetimeDBUnit GetAsSubscribeApplied(const F{module_name}Event& Event)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return Event.GetAsSubscribeApplied();");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(
        output,
        "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static FSpacetimeDBUnit GetAsUnsubscribeApplied(const F{module_name}Event& Event)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return Event.GetAsUnsubscribeApplied();");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(
        output,
        "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static FSpacetimeDBUnit GetAsDisconnected(const F{module_name}Event& Event)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return Event.GetAsDisconnected();");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(
        output,
        "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static FString GetAsSubscribeError(const F{module_name}Event& Event)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return Event.GetAsSubscribeError();");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(
        output,
        "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{module_name}Event\")"
    );
    writeln!(
        output,
        "    static FSpacetimeDBUnit GetAsUnknownTransaction(const F{module_name}Event& Event)"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return Event.GetAsUnknownTransaction();");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(output, "}};");
    writeln!(output);

    // FEventContext, FReducerEventContext, FErrorContext, FSubscriptionEventContext
    writeln!(output);
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} FEventContext : public FContextBase");
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);
    writeln!(output, "\tFEventContext() = default;");
    writeln!(
        output,
        "\tFEventContext(UDbConnection* InConn, const F{module_name}Event& InEvent) : FContextBase(InConn), Event(InEvent) {{}}"
    );
    writeln!(output);
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
    writeln!(output, "\tF{module_name}Event Event;");
    writeln!(output, "}};");
    writeln!(output);
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} FReducerEventContext : public FContextBase");
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);
    writeln!(output, "\tFReducerEventContext() = default;");
    writeln!(output, "\tFReducerEventContext(UDbConnection* InConn, F{module_name}ReducerEvent InEvent) : FContextBase(InConn), Event(InEvent) {{}}");
    writeln!(output, "\t");
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\") ");
    writeln!(output, "\tF{module_name}ReducerEvent Event;");
    writeln!(output, "}};");
    writeln!(output);
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} FErrorContext : public FContextBase");
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);
    writeln!(output, "\tFErrorContext() = default;");
    writeln!(
        output,
        "\tFErrorContext(UDbConnection* InConn, const FString& InError) : FContextBase(InConn), Error(InError) {{}}"
    );
    writeln!(output);
    writeln!(output, "\tUPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
    writeln!(output, "\tFString Error;");
    writeln!(output);
    writeln!(output, "}};");
    writeln!(output);
    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(
        output,
        "struct {api_macro} FSubscriptionEventContext : public FContextBase"
    );
    writeln!(output, "{{");
    writeln!(output, "\tGENERATED_BODY()");
    writeln!(output);
    writeln!(output, "\tFSubscriptionEventContext() = default;");
    writeln!(
        output,
        "\tFSubscriptionEventContext(UDbConnection* InConn) : FContextBase(InConn) {{}}"
    );
    writeln!(output);
    writeln!(output, "}};");
    writeln!(output);
    writeln!(output, "DECLARE_DYNAMIC_DELEGATE_OneParam(");
    writeln!(output, "\tFOnSubscriptionApplied,");
    writeln!(output, "\tFSubscriptionEventContext, Context);");
    writeln!(output);
    writeln!(output, "DECLARE_DYNAMIC_DELEGATE_OneParam(");
    writeln!(output, "\tFOnSubscriptionError,");
    writeln!(output, "\tFErrorContext, Context);");
    writeln!(output);
}

fn generate_remote_tables_class(output: &mut UnrealCppAutogen, module: &ModuleDef, api_macro: &str) {
    writeln!(output, "// RemoteTables class");
    writeln!(output, "UCLASS(BlueprintType)");
    writeln!(output, "class {api_macro} URemoteTables : public UObject");
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "public:");
    writeln!(output, "    void Initialize();");
    writeln!(output);

    // Generate table handle properties
    for table in module.tables() {
        let table_pascal = type_ref_name(module, table.product_type_ref);

        writeln!(output, "    UPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
        writeln!(
            output,
            "    U{table_pascal}Table* {};",
            table.name.deref().to_case(Case::Pascal)
        );
        writeln!(output);
    }

    writeln!(output, "}};");
    writeln!(output);
}

fn generate_remote_reducers_class(
    output: &mut UnrealCppAutogen,
    module: &ModuleDef,
    api_macro: &str,
    module_name: &str,
) {
    writeln!(output, "// RemoteReducers class");
    writeln!(output, "UCLASS(BlueprintType)");
    writeln!(output, "class {api_macro} URemoteReducers : public UObject");
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "public:");
    writeln!(output);

    // Generate reducer events and call methods
    for reducer in iter_reducers(module) {
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);

        // Generate delegate for reducer event
        let param_count = reducer.params_for_generate.elements.len() + 1; // +1 for context
        let use_args_struct = param_count > 9; // Unreal only supports up to 9 params in delegates

        let mut non_blueprintable_types_for_delegate = Vec::new();
        let mut non_blueprintable_types_for_function = Vec::new();

        if use_args_struct {
            // For more than 9 params, use a struct to wrap the arguments
            writeln!(output, "    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(");
            writeln!(output, "        F{reducer_pascal}Handler,");
            writeln!(output, "        const FReducerEventContext&, Context,");
            writeln!(output, "        const F{reducer_pascal}Args&, Args");
            writeln!(output, "    );");

            // For delegates using args struct, check the actual delegate parameters:
            // 1. FReducerEventContext (always blueprintable)
            // 2. F{Reducer}Args struct (always blueprintable as a USTRUCT)
            // So delegates with args struct are always blueprintable

            // But functions still need to check individual parameters
            for (_, param_type) in &reducer.params_for_generate.elements {
                if !is_type_blueprintable_for_delegates(module, param_type) {
                    let type_str = cpp_ty_fmt_with_module(module, param_type, module_name).to_string();
                    non_blueprintable_types_for_function.push(type_str);
                }
            }
        } else {
            // Use the original approach for 9 or fewer params
            let delegate_macro = match param_count {
                1 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam",
                2 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams",
                3 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams",
                4 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams",
                5 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_FiveParams",
                6 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_SixParams",
                7 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_SevenParams",
                8 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_EightParams",
                9 => "DECLARE_DYNAMIC_MULTICAST_DELEGATE_NineParams",
                _ => unreachable!("Should use args struct for >9 params"),
            };

            write!(
                output,
                "    {delegate_macro}(\n        F{reducer_pascal}Handler,\n        const FReducerEventContext&, Context"
            );

            for (param_name, param_type) in &reducer.params_for_generate.elements {
                // Use Blueprint-compatible types for delegates
                let type_str = cpp_ty_fmt_blueprint_compatible(module, param_type, module_name).to_string();

                // Collect non-blueprintable types for both delegate and function
                if !is_type_blueprintable_for_delegates(module, param_type) {
                    non_blueprintable_types_for_delegate.push(type_str.clone());
                    non_blueprintable_types_for_function.push(type_str.clone());
                }

                if should_pass_by_value_in_delegate(module, param_type) {
                    // Only true primitives are passed by value in delegates
                    write!(
                        output,
                        ",\n        {type_str}, {}",
                        param_name.deref().to_case(Case::Pascal)
                    );
                } else {
                    // Complex types (including FSpacetimeDB structs) use const references
                    write!(
                        output,
                        ",\n        const {type_str}&, {}",
                        param_name.deref().to_case(Case::Pascal)
                    );
                }
            }
            writeln!(output, "\n    );");
        }

        // Generate delegate property
        if non_blueprintable_types_for_delegate.is_empty() {
            writeln!(output, "    UPROPERTY(BlueprintAssignable, Category=\"SpacetimeDB\")");
        } else {
            // Generate specific message about which types are not Blueprint-compatible
            let types_str = non_blueprintable_types_for_delegate.join(", ");
            writeln!(
                output,
                "    // NOTE: Not exposed to Blueprint because {types_str} types are not Blueprint-compatible"
            );
        }
        writeln!(output, "    F{reducer_pascal}Handler On{reducer_pascal};");
        writeln!(output);

        // Generate call method
        if non_blueprintable_types_for_function.is_empty() {
            write!(
                output,
                "    UFUNCTION(BlueprintCallable, Category=\"SpacetimeDB\")\n    void {reducer_pascal}("
            );
        } else {
            // Generate specific message about which types are not Blueprint-compatible
            let types_str = non_blueprintable_types_for_function.join(", ");
            write!(
                output,
                "    // NOTE: Not exposed to Blueprint because {types_str} types are not Blueprint-compatible\n    void {reducer_pascal}("
            );
        }

        let mut first = true;
        for (param_name, param_type) in &reducer.params_for_generate.elements {
            if !first {
                write!(output, ", ");
            }
            first = false;

            // For UFUNCTION parameters, use Blueprint-compatible types
            let type_str = if non_blueprintable_types_for_function.is_empty() {
                cpp_ty_fmt_blueprint_compatible(module, param_type, module_name).to_string()
            } else {
                cpp_ty_fmt_with_module(module, param_type, module_name).to_string()
            };

            if should_pass_by_value_in_delegate(module, param_type) {
                // Primitives use const by-value in functions
                write!(
                    output,
                    "const {} {}",
                    type_str,
                    param_name.deref().to_case(Case::Pascal)
                );
            } else {
                // Complex types (including FSpacetimeDB structs) use const references
                write!(
                    output,
                    "const {}& {}",
                    type_str,
                    param_name.deref().to_case(Case::Pascal)
                );
            }
        }
        writeln!(output, ");");
        writeln!(output);

        // Generate invoke method
        write!(
            output,
            "    bool Invoke{reducer_pascal}(const FReducerEventContext& Context, const U{reducer_pascal}Reducer* Args);"
        );
        writeln!(output);
        writeln!(output);
    }

    // Internal error handling
    writeln!(output, "    // Internal error handling");
    writeln!(output, "    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FInternalOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);");
    writeln!(
        output,
        "    FInternalOnUnhandledReducerError InternalOnUnhandledReducerError;"
    );
    writeln!(output);

    writeln!(output, "private:");
    writeln!(output);
    writeln!(output, "    friend UDbConnection;");
    writeln!(output);
    writeln!(output, "    UPROPERTY()");
    writeln!(output, "    class UDbConnection* Conn;");
    writeln!(output);
    writeln!(output, "    UPROPERTY()");
    writeln!(output, "    USetReducerFlags* SetCallReducerFlags;");
    writeln!(output, "}};");
    writeln!(output);
}

fn generate_subscription_builder_class(output: &mut UnrealCppAutogen, api_macro: &str) {
    writeln!(output, "// SubscriptionBuilder class");
    writeln!(output, "UCLASS(BlueprintType)");
    writeln!(
        output,
        "class {api_macro} USubscriptionBuilder : public USubscriptionBuilderBase"
    );
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "public:");
    writeln!(output);
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    USubscriptionBuilder* OnApplied(FOnSubscriptionApplied Callback);"
    );
    writeln!(output);
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    USubscriptionBuilder* OnError(FOnSubscriptionError Callback);"
    );
    writeln!(output);
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category=\"SpacetimeDB\")");
    writeln!(
        output,
        "    USubscriptionHandle* Subscribe(const TArray<FString>& SQL);"
    );
    writeln!(output);
    writeln!(
        output,
        "    /** Convenience for subscribing to all rows from all tables */"
    );
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(output, "    USubscriptionHandle* SubscribeToAllTables();");
    writeln!(output);
    writeln!(output);
    writeln!(output, "    friend class UDbConnection;");
    writeln!(output, "    friend class UDbConnectionBase;");
    writeln!(output);
    writeln!(output, "protected:");
    writeln!(output, "    UPROPERTY()");
    writeln!(output, "    class UDbConnection* Conn;");
    writeln!(output);
    writeln!(
        output,
        "    // Delegates stored so Subscribe() can bind forwarding callbacks"
    );
    writeln!(output, "    FOnSubscriptionApplied OnAppliedDelegateInternal;");
    writeln!(output, "    FOnSubscriptionError OnErrorDelegateInternal;");
    writeln!(output, "}};");
    writeln!(output);
}

fn generate_subscription_handle_class(output: &mut UnrealCppAutogen, api_macro: &str) {
    writeln!(output, "// SubscriptionHandle class");
    writeln!(output, "UCLASS(BlueprintType)");
    writeln!(
        output,
        "class {api_macro} USubscriptionHandle : public USubscriptionHandleBase"
    );
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "public:");
    writeln!(output);
    writeln!(output, "    USubscriptionHandle() {{}};");
    writeln!(output);
    writeln!(output, "    explicit USubscriptionHandle(UDbConnection* InConn);");
    writeln!(output);
    writeln!(output, "    friend class USubscriptionBuilder;");
    writeln!(output);
    writeln!(output, "private:");
    writeln!(output, "    UPROPERTY()");
    writeln!(output, "    class UDbConnection* Conn;");
    writeln!(output);
    writeln!(
        output,
        "    // Delegates that expose subscription events with connection aware contexts"
    );
    writeln!(output, "    FOnSubscriptionApplied OnAppliedDelegate;");
    writeln!(output, "    FOnSubscriptionError OnErrorDelegate;");
    writeln!(output);
    writeln!(output, "    UFUNCTION()");
    writeln!(
        output,
        "    void ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx);"
    );
    writeln!(output);
    writeln!(output, "    UFUNCTION()");
    writeln!(output, "    void ForwardOnError(const FErrorContextBase& BaseCtx);");
    writeln!(output, "}};");
    writeln!(output);
}

fn generate_db_connection_builder_class(output: &mut UnrealCppAutogen, api_macro: &str) {
    writeln!(output, "/*");
    writeln!(output, "    @Note: Child class of UDbConnectionBuilderBase.");
    writeln!(output, "*/");
    writeln!(output, "UCLASS(BlueprintType)");
    writeln!(
        output,
        "class {api_macro} UDbConnectionBuilder : public UDbConnectionBuilderBase"
    );
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output, "public:");
    writeln!(output);
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(output, "    UDbConnectionBuilder* WithUri(const FString& InUri);");
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    UDbConnectionBuilder* WithModuleName(const FString& InName);"
    );
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(output, "    UDbConnectionBuilder* WithToken(const FString& InToken);");
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    UDbConnectionBuilder* WithCompression(const ESpacetimeDBCompression& InCompression);"
    );
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    UDbConnectionBuilder* OnConnect(FOnConnectDelegate Callback);"
    );
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    UDbConnectionBuilder* OnConnectError(FOnConnectErrorDelegate Callback);"
    );
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(
        output,
        "    UDbConnectionBuilder* OnDisconnect(FOnDisconnectDelegate Callback);"
    );
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\")");
    writeln!(output, "    UDbConnection* Build();");
    writeln!(output);
    writeln!(output, "private:");
    writeln!(output);
    writeln!(
        output,
        "    // Stored delegates which will be forwarded when the connection events occur."
    );
    writeln!(output, "    FOnConnectDelegate OnConnectDelegateInternal;");
    writeln!(output, "    FOnDisconnectDelegate OnDisconnectDelegateInternal;");
    writeln!(output, "}};");
    writeln!(output);
}

fn generate_db_connection_class(output: &mut UnrealCppAutogen, _module: &ModuleDef, api_macro: &str) {
    writeln!(output, "// Main DbConnection class");
    writeln!(output, "UCLASS(BlueprintType)");
    writeln!(output, "class {api_macro} UDbConnection : public UDbConnectionBase");
    writeln!(output, "{{");
    writeln!(output, "    GENERATED_BODY()");
    writeln!(output);
    writeln!(output, "public:");
    writeln!(
        output,
        "    explicit UDbConnection(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());"
    );
    writeln!(output);
    writeln!(output);
    writeln!(output, "    UPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
    writeln!(output, "    URemoteTables* Db;");
    writeln!(output);
    writeln!(output, "    UPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
    writeln!(output, "    URemoteReducers* Reducers;");
    writeln!(output);
    writeln!(output, "    UPROPERTY(BlueprintReadOnly, Category=\"SpacetimeDB\")");
    writeln!(output, "    USetReducerFlags* SetReducerFlags;");
    writeln!(output);
    writeln!(
        output,
        "    // Delegates that allow users to bind with the concrete connection type."
    );
    writeln!(output, "    FOnConnectDelegate OnConnectDelegate;");
    writeln!(output, "    FOnDisconnectDelegate OnDisconnectDelegate;");
    writeln!(output);
    writeln!(output, "    UFUNCTION(BlueprintCallable, Category=\"SpacetimeDB\")");
    writeln!(output, "    USubscriptionBuilder* SubscriptionBuilder();");
    writeln!(output);
    writeln!(output, "    /** Static entry point for constructing a connection. */");
    writeln!(
        output,
        "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB\", DisplayName = \"SpacetimeDB Builder\")"
    );
    writeln!(output, "    static UDbConnectionBuilder* Builder();");
    writeln!(output);
    writeln!(output, "    // Error handling");
    writeln!(output, "    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);");
    writeln!(output, "    UPROPERTY(BlueprintAssignable, Category=\"SpacetimeDB\")");
    writeln!(output, "    FOnUnhandledReducerError OnUnhandledReducerError;");
    writeln!(output);
    writeln!(output);
    writeln!(output, "protected:");
    writeln!(output);
    writeln!(output, "    // Hook up error handling to reducers");
    writeln!(output, "    virtual void PostInitProperties() override;");
    writeln!(output);
    writeln!(output, "    UFUNCTION()");
    writeln!(output, "    void ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken);");
    writeln!(output, "    UFUNCTION()");
    writeln!(
        output,
        "    void ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error);"
    );
    writeln!(output);
    writeln!(output, "    UFUNCTION()");
    writeln!(
        output,
        "    void OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error);"
    );
    writeln!(output);
    writeln!(
        output,
        "    // Override the DbConnectionBase methods to handle updates and events"
    );
    writeln!(
        output,
        "    virtual void DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event) override;"
    );
    writeln!(output, "    ");
    writeln!(
        output,
        "    // Override the reducer event handler to dispatch events to the appropriate reducers"
    );
    writeln!(
        output,
        "    virtual void ReducerEvent(const FReducerEvent& Event) override;"
    );
    writeln!(output, "    ");
    writeln!(output, "    // Override the reducer event failed handler");
    writeln!(
        output,
        "    virtual void ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage) override;"
    );
    writeln!(output, "}};");
    writeln!(output);
}

fn generate_client_implementation(output: &mut UnrealCppAutogen, module: &ModuleDef, module_name: &str) {
    // Helper: Decode reducer args into FReducer from either event types
    writeln!(output, "static FReducer DecodeReducer(const FReducerEvent& Event)");
    writeln!(output, "{{");
    writeln!(
        output,
        "    const FString& ReducerName = Event.ReducerCall.ReducerName;"
    );
    writeln!(output);

    for reducer in iter_reducers(module) {
        let reducer_name = reducer.name.deref();
        let reducer_pascal = reducer_name.to_case(Case::Pascal);

        writeln!(output, "    if (ReducerName == TEXT(\"{reducer_name}\"))");
        writeln!(output, "    {{");
        writeln!(
            output,
            "        F{reducer_pascal}Args Args = UE::SpacetimeDB::Deserialize<F{reducer_pascal}Args>(Event.ReducerCall.Args);"
        );
        writeln!(output, "        return FReducer::{reducer_pascal}(Args);");
        writeln!(output, "    }}");
        writeln!(output);
    }

    writeln!(output, "    return FReducer();");
    writeln!(output, "}}");
    writeln!(output);

    // UDbConnection constructor
    writeln!(
        output,
        "UDbConnection::UDbConnection(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tSetReducerFlags = ObjectInitializer.CreateDefaultSubobject<USetReducerFlags>(this, TEXT(\"SetReducerFlags\"));");
    writeln!(output);
    writeln!(
        output,
        "\tDb = ObjectInitializer.CreateDefaultSubobject<URemoteTables>(this, TEXT(\"RemoteTables\"));"
    );
    writeln!(output, "\tDb->Initialize();");
    writeln!(output, "\t");
    writeln!(
        output,
        "\tReducers = ObjectInitializer.CreateDefaultSubobject<URemoteReducers>(this, TEXT(\"RemoteReducers\"));"
    );
    writeln!(output, "\tReducers->SetCallReducerFlags = SetReducerFlags;");
    writeln!(output, "\tReducers->Conn = this;");
    writeln!(output);
    for table in module.tables() {
        let table_pascal = type_ref_name(module, table.product_type_ref);
        let table_name = table.name.deref();
        writeln!(
            output,
            "\tRegisterTable<F{}Type, U{}Table, FEventContext>(TEXT(\"{}\"), Db->{});",
            table_pascal,
            table_pascal,
            table_name,
            table.name.deref().to_case(Case::Pascal)
        );
    }
    writeln!(output, "}}");
    writeln!(output);

    // FContextBase constructor
    writeln!(output, "FContextBase::FContextBase(UDbConnection* InConn)");
    writeln!(output, "{{");
    writeln!(output, "\tDb = InConn->Db;");
    writeln!(output, "\tReducers = InConn->Reducers;");
    writeln!(output, "\tSetReducerFlags = InConn->SetReducerFlags;");
    writeln!(output, "\tConn = InConn;");
    writeln!(output, "}}");

    // FContextBase methods
    writeln!(output, "bool FContextBase::IsActive() const");
    writeln!(output, "{{");
    writeln!(output, "\treturn Conn->IsActive();");
    writeln!(output, "}}");
    writeln!(output, "void FContextBase::Disconnect()");
    writeln!(output, "{{");
    writeln!(output, "\tConn->Disconnect();");
    writeln!(output, "}}");
    writeln!(output, "USubscriptionBuilder* FContextBase::SubscriptionBuilder()");
    writeln!(output, "{{");
    writeln!(output, "\treturn Conn->SubscriptionBuilder();");
    writeln!(output, "}}");
    writeln!(
        output,
        "bool FContextBase::TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const"
    );
    writeln!(output, "{{");
    writeln!(output, "\treturn Conn->TryGetIdentity(OutIdentity);");
    writeln!(output, "}}");
    writeln!(output, "FSpacetimeDBConnectionId FContextBase::GetConnectionId() const");
    writeln!(output, "{{");
    writeln!(output, "\treturn Conn->GetConnectionId();");
    writeln!(output, "}}");
    writeln!(output);

    // URemoteTables Initialize method
    writeln!(output, "void URemoteTables::Initialize()");
    writeln!(output, "{{");
    writeln!(output);
    writeln!(output, "\t/** Creating tables */");
    for table in module.tables() {
        let table_pascal = type_ref_name(module, table.product_type_ref);
        writeln!(
            output,
            "\t{} = NewObject<U{}Table>(this);",
            table.name.deref().to_case(Case::Pascal),
            table_pascal
        );
    }
    writeln!(output, "\t/**/");
    writeln!(output);
    writeln!(output, "\t/** Initialization */");
    for table in module.tables() {
        writeln!(
            output,
            "\t{}->PostInitialize();",
            table.name.deref().to_case(Case::Pascal)
        );
    }
    writeln!(output, "\t/**/");
    writeln!(output, "}}");
    writeln!(output);

    // USetReducerFlags methods
    for reducer in iter_reducers(module) {
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
        writeln!(
            output,
            "void USetReducerFlags::{reducer_pascal}(ECallReducerFlags Flag)"
        );
        writeln!(output, "{{");
        writeln!(output, "\tFlagMap.Add(\"{reducer_pascal}\", Flag);");
        writeln!(output, "}}");
    }
    writeln!(output);

    // Reducer implementations
    for reducer in iter_reducers(module) {
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
        let reducer_snake = reducer.name.deref();

        // Call method implementation
        write!(output, "void URemoteReducers::{reducer_pascal}(");
        let mut first = true;
        for (param_name, param_type) in &reducer.params_for_generate.elements {
            if !first {
                write!(output, ", ");
            }
            first = false;
            // Use Blueprint-compatible types (same as UFUNCTION and delegates)
            let type_str = cpp_ty_fmt_blueprint_compatible(module, param_type, module_name).to_string();
            if should_pass_by_value_in_delegate(module, param_type) {
                // Primitives use const by-value in URemoteReducers methods (same as UFUNCTION)
                write!(
                    output,
                    "const {} {}",
                    type_str,
                    param_name.deref().to_case(Case::Pascal)
                );
            } else {
                // Complex types (including FSpacetimeDB structs) use const references
                write!(
                    output,
                    "const {}& {}",
                    type_str,
                    param_name.deref().to_case(Case::Pascal)
                );
            }
        }
        writeln!(output, ")");
        writeln!(output, "{{");
        writeln!(output, "    if (!Conn)");
        writeln!(output, "    {{");
        writeln!(
            output,
            "        UE_LOG(LogTemp, Error, TEXT(\"SpacetimeDB connection is null\"));"
        );
        writeln!(output, "        return;");
        writeln!(output, "    }}");
        writeln!(output);
        // Call reducer using typed helper to hide serialization
        if reducer.params_for_generate.elements.is_empty() {
            writeln!(
                output,
                "\tConn->CallReducerTyped(TEXT(\"{reducer_snake}\"), F{reducer_pascal}Args(), SetCallReducerFlags);"
            );
        } else {
            write!(
                output,
                "\tConn->CallReducerTyped(TEXT(\"{reducer_snake}\"), F{reducer_pascal}Args("
            );
            let mut first = true;
            for (param_name, _) in &reducer.params_for_generate.elements {
                if !first {
                    write!(output, ", ");
                }
                first = false;
                let param_pascal = param_name.deref().to_case(Case::Pascal);
                write!(output, "{param_pascal}");
            }
            writeln!(output, "), SetCallReducerFlags);");
        }
        writeln!(output, "}}");
        writeln!(output);

        // Invoke method implementation
        write!(
            output,
            "bool URemoteReducers::Invoke{reducer_pascal}(const FReducerEventContext& Context, const U{reducer_pascal}Reducer* Args)"
        );
        writeln!(output);
        writeln!(output, "{{");
        writeln!(output, "    if (!On{reducer_pascal}.IsBound())");
        writeln!(output, "    {{");
        writeln!(output, "        // Handle unhandled reducer error");
        writeln!(output, "        if (InternalOnUnhandledReducerError.IsBound())");
        writeln!(output, "        {{");
        writeln!(
            output,
            "            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases"
        );
        writeln!(output, "            // For now, just broadcast any error");
        writeln!(
            output,
            "            InternalOnUnhandledReducerError.Broadcast(Context, TEXT(\"No handler registered for {reducer_pascal}\"));"
        );
        writeln!(output, "        }}");
        writeln!(output, "        return false;");
        writeln!(output, "    }}");
        writeln!(output);

        // Check if we're using args struct (more than 9 params including context)
        let param_count = reducer.params_for_generate.elements.len() + 1; // +1 for context
        let use_args_struct = param_count > 9;

        if use_args_struct {
            // Create args struct from individual fields
            writeln!(output, "    F{reducer_pascal}Args ArgsStruct;");
            for (param_name, _) in &reducer.params_for_generate.elements {
                let param_pascal = param_name.deref().to_case(Case::Pascal);
                writeln!(output, "    ArgsStruct.{param_pascal} = Args->{param_pascal};");
            }
            writeln!(output, "    On{reducer_pascal}.Broadcast(Context, ArgsStruct);");
        } else {
            // Use individual parameters
            write!(output, "    On{reducer_pascal}.Broadcast(Context");
            for (param_name, _) in &reducer.params_for_generate.elements {
                let param_pascal = param_name.deref().to_case(Case::Pascal);
                write!(output, ", Args->{param_pascal}");
            }
            writeln!(output, ");");
        }

        writeln!(output, "    return true;");
        writeln!(output, "}}");
        writeln!(output);
    }

    // Hook up error handling
    writeln!(output, "void UDbConnection::PostInitProperties()");
    writeln!(output, "{{");
    writeln!(output, "    Super::PostInitProperties();");
    writeln!(output, "    ");
    writeln!(
        output,
        "    // Connect OnUnhandledReducerError to Reducers.InternalOnUnhandledReducerError"
    );
    writeln!(output, "    if (Reducers)");
    writeln!(output, "    {{");
    writeln!(output, "        Reducers->InternalOnUnhandledReducerError.AddDynamic(this, &UDbConnection::OnUnhandledReducerErrorHandler);");
    writeln!(output, "    }}");
    writeln!(output, "}}");
    writeln!(output);

    // Error handler method
    writeln!(output, "UFUNCTION()");
    writeln!(
        output,
        "void UDbConnection::OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error)"
    );
    writeln!(output, "{{");
    writeln!(output, "    if (OnUnhandledReducerError.IsBound())");
    writeln!(output, "    {{");
    writeln!(output, "        OnUnhandledReducerError.Broadcast(Context, Error);");
    writeln!(output, "    }}");
    writeln!(output, "}}");
    writeln!(output);

    // ReducerEvent method implementation
    writeln!(output, "void UDbConnection::ReducerEvent(const FReducerEvent& Event)");
    writeln!(output, "{{");
    writeln!(output, "    if (!Reducers) {{ return; }}");
    writeln!(output);

    // Decode reducer call args
    writeln!(output, "    FReducer DecodedReducer = DecodeReducer(Event);");
    writeln!(output);

    let module_name_pascal = module_name.to_case(Case::Pascal);
    // Build the {}ReducerEvent object
    writeln!(output, "    F{module_name_pascal}ReducerEvent ReducerEvent;");
    writeln!(
        output,
        "    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;"
    );
    writeln!(output, "    ReducerEvent.CallerIdentity     = Event.CallerIdentity;");
    writeln!(output, "    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;");
    writeln!(output, "    ReducerEvent.Status             = Event.Status;");
    writeln!(output, "    ReducerEvent.Timestamp          = Event.Timestamp;");
    writeln!(output, "    ReducerEvent.Reducer            = DecodedReducer;");
    writeln!(output);

    writeln!(output, "    FReducerEventContext Context(this, ReducerEvent);");
    writeln!(output);
    writeln!(output, "    // Use hardcoded string matching for reducer dispatching");
    writeln!(
        output,
        "    const FString& ReducerName = Event.ReducerCall.ReducerName;"
    );
    writeln!(output);

    for reducer in iter_reducers(module) {
        let reducer_name = reducer.name.deref();
        let reducer_pascal = reducer.name.deref().to_case(Case::Pascal);
        writeln!(output, "    if (ReducerName == TEXT(\"{reducer_name}\"))");
        writeln!(output, "    {{");
        writeln!(
            output,
            "        F{reducer_pascal}Args Args = ReducerEvent.Reducer.GetAs{reducer_pascal}();"
        );
        writeln!(
            output,
            "        U{reducer_pascal}Reducer* Reducer = NewObject<U{reducer_pascal}Reducer>();"
        );

        // Copy fields from Args struct to Reducer object
        for (param_name, _) in &reducer.params_for_generate.elements {
            let param_pascal = param_name.deref().to_case(Case::Pascal);
            writeln!(output, "        Reducer->{param_pascal} = Args.{param_pascal};");
        }

        writeln!(output, "        Reducers->Invoke{reducer_pascal}(Context, Reducer);");
        writeln!(output, "        return;");
        writeln!(output, "    }}");
    }
    writeln!(output);
    writeln!(
        output,
        "    UE_LOG(LogTemp, Warning, TEXT(\"Unknown reducer: %s\"), *ReducerName);"
    );
    writeln!(output, "}}");
    writeln!(output);

    // ReducerEventFailed method implementation
    writeln!(
        output,
        "void UDbConnection::ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage)"
    );
    writeln!(output, "{{");
    writeln!(output, "    if (!Reducers) {{ return; }}");
    writeln!(output);

    // Build the {}ReducerEvent object
    writeln!(output, "    F{module_name_pascal}ReducerEvent ReducerEvent;");
    writeln!(
        output,
        "    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;"
    );
    writeln!(output, "    ReducerEvent.CallerIdentity     = Event.CallerIdentity;");
    writeln!(output, "    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;");
    writeln!(output, "    ReducerEvent.Status             = Event.Status;");
    writeln!(output, "    ReducerEvent.Timestamp          = Event.Timestamp;");
    writeln!(output);

    writeln!(output, "    FReducerEventContext Context(this, ReducerEvent);");
    writeln!(output);
    writeln!(output, "    if (Reducers->InternalOnUnhandledReducerError.IsBound())");
    writeln!(output, "    {{");
    writeln!(
        output,
        "        Reducers->InternalOnUnhandledReducerError.Broadcast(Context, ErrorMessage);"
    );
    writeln!(output, "    }}");
    writeln!(output, "}}");
    writeln!(output);

    // Additional methods from manual reference
    writeln!(output, "UDbConnectionBuilder* UDbConnection::Builder()");
    writeln!(output, "{{");
    writeln!(output, "\treturn NewObject<UDbConnectionBuilder>();");
    writeln!(output, "}}");
    writeln!(output, "// Added for creating subscriptions");
    writeln!(output, "USubscriptionBuilder* UDbConnection::SubscriptionBuilder()");
    writeln!(output, "{{");
    writeln!(
        output,
        "\tUSubscriptionBuilder* Builder = NewObject<USubscriptionBuilder>(this);"
    );
    writeln!(output, "\tBuilder->Conn = this;");
    writeln!(output, "\treturn Builder;");
    writeln!(output, "}}");
    writeln!(
        output,
        "USubscriptionBuilder* USubscriptionBuilder::OnApplied(FOnSubscriptionApplied Callback)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tOnAppliedDelegateInternal = Callback;");
    writeln!(output, "\treturn this;");
    writeln!(output, "}}");
    writeln!(
        output,
        "USubscriptionBuilder* USubscriptionBuilder::OnError(FOnSubscriptionError Callback)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tOnErrorDelegateInternal = Callback;");
    writeln!(output, "\treturn this;");
    writeln!(output, "}}");
    writeln!(
        output,
        "USubscriptionHandle* USubscriptionBuilder::Subscribe(const TArray<FString>& SQL)"
    );
    writeln!(output, "{{");
    writeln!(
        output,
        "\tUSubscriptionHandle* Handle = NewObject<USubscriptionHandle>();"
    );
    writeln!(output);
    writeln!(output, "\t// Store user callbacks on the handle");
    writeln!(output, "\tHandle->Conn = Conn;");
    writeln!(output, "\tHandle->OnAppliedDelegate = OnAppliedDelegateInternal;");
    writeln!(output, "\tHandle->OnErrorDelegate = OnErrorDelegateInternal;");
    writeln!(output);
    writeln!(output, "\t// Bind forwarding functions that will convert base contexts");
    writeln!(output, "\tFSubscriptionEventDelegate BaseApplied;");
    writeln!(
        output,
        "\tBaseApplied.BindUFunction(Handle, TEXT(\"ForwardOnApplied\"));"
    );
    writeln!(output, "\tOnAppliedBase(BaseApplied);");
    writeln!(output);
    writeln!(output, "\tFSubscriptionErrorDelegate BaseError;");
    writeln!(output, "\tBaseError.BindUFunction(Handle, TEXT(\"ForwardOnError\"));");
    writeln!(output, "\tOnErrorBase(BaseError);");
    writeln!(output);
    writeln!(output, "\tSubscribeBase(SQL, Handle);");
    writeln!(output, "\tif (Conn)");
    writeln!(output, "\t{{");
    writeln!(output, "\t\tConn->StartSubscription(Handle);");
    writeln!(output, "\t}}");
    writeln!(output, "\treturn Handle;");
    writeln!(output, "}}");
    writeln!(
        output,
        "USubscriptionHandle* USubscriptionBuilder::SubscribeToAllTables()"
    );
    writeln!(output, "{{");
    writeln!(output, "\treturn Subscribe({{ \"SELECT * FROM * \" }});");
    writeln!(output, "}}");
    writeln!(output);
    writeln!(
        output,
        "USubscriptionHandle::USubscriptionHandle(UDbConnection* InConn)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tConn = InConn;");
    writeln!(output, "}}");
    writeln!(output);
    writeln!(
        output,
        "void USubscriptionHandle::ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tif (OnAppliedDelegate.IsBound())");
    writeln!(output, "\t{{");
    writeln!(output, "\t\tFSubscriptionEventContext Ctx(Conn);");
    writeln!(output, "\t\tOnAppliedDelegate.Execute(Ctx);");
    writeln!(output, "\t}}");
    writeln!(output, "}}");
    writeln!(output);
    writeln!(
        output,
        "void USubscriptionHandle::ForwardOnError(const FErrorContextBase& BaseCtx)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tif (OnErrorDelegate.IsBound())");
    writeln!(output, "\t{{");
    writeln!(output, "\t\tFErrorContext Ctx(Conn, BaseCtx.Error);");
    writeln!(output, "\t\tOnErrorDelegate.Execute(Ctx);");
    writeln!(output, "\t}}");
    writeln!(output, "}}");
    writeln!(output);
    writeln!(output);
    writeln!(output, "// Cast from parent to child class");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::WithUri(const FString& InUri)"
    );
    writeln!(output, "{{");
    writeln!(output, "\treturn Cast<UDbConnectionBuilder>(WithUriBase(InUri));");
    writeln!(output, "}}");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::WithModuleName(const FString& InName)"
    );
    writeln!(output, "{{");
    writeln!(
        output,
        "\treturn Cast<UDbConnectionBuilder>(WithModuleNameBase(InName));"
    );
    writeln!(output, "}}");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::WithToken(const FString& InToken)"
    );
    writeln!(output, "{{");
    writeln!(output, "\treturn Cast<UDbConnectionBuilder>(WithTokenBase(InToken));");
    writeln!(output, "}}");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::WithCompression(const ESpacetimeDBCompression& InCompression)"
    );
    writeln!(output, "{{");
    writeln!(
        output,
        "\treturn Cast<UDbConnectionBuilder>(WithCompressionBase(InCompression));"
    );
    writeln!(output, "}}");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::OnConnect(FOnConnectDelegate Callback)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tOnConnectDelegateInternal = Callback;");
    writeln!(output, "\treturn this;");
    writeln!(output, "}}");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::OnConnectError(FOnConnectErrorDelegate Callback)"
    );
    writeln!(output, "{{");
    writeln!(
        output,
        "\treturn Cast<UDbConnectionBuilder>(OnConnectErrorBase(Callback));"
    );
    writeln!(output, "}}");
    writeln!(
        output,
        "UDbConnectionBuilder* UDbConnectionBuilder::OnDisconnect(FOnDisconnectDelegate Callback)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tOnDisconnectDelegateInternal = Callback;");
    writeln!(output, "\treturn this;");
    writeln!(output, "}}");
    writeln!(output, "UDbConnection* UDbConnectionBuilder::Build()");
    writeln!(output, "{{");
    writeln!(output, "\tUDbConnection* Connection = NewObject<UDbConnection>();");
    writeln!(output);
    writeln!(output, "\t// Store delegates on the connection for later use");
    writeln!(output, "\tConnection->OnConnectDelegate = OnConnectDelegateInternal;");
    writeln!(
        output,
        "\tConnection->OnDisconnectDelegate = OnDisconnectDelegateInternal;"
    );
    writeln!(output);
    writeln!(output, "\t// Wrap delegates so the base builder can bind them");
    writeln!(output, "\tFOnConnectBaseDelegate BaseConnect;");
    writeln!(
        output,
        "\tBaseConnect.BindUFunction(Connection, TEXT(\"ForwardOnConnect\"));"
    );
    writeln!(output, "\tConnection->SetOnConnectDelegate(BaseConnect);");
    writeln!(output, "\tOnConnectBase(BaseConnect);");
    writeln!(output);
    writeln!(output, "\tFOnDisconnectBaseDelegate BaseDisconnect;");
    writeln!(
        output,
        "\tBaseDisconnect.BindUFunction(Connection, TEXT(\"ForwardOnDisconnect\"));"
    );
    writeln!(output, "\tConnection->SetOnDisconnectDelegate(BaseDisconnect);");
    writeln!(output, "\tOnDisconnectBase(BaseDisconnect);");
    writeln!(output);
    writeln!(output, "\treturn Cast<UDbConnection>(BuildConnection(Connection));");
    writeln!(output, "}}");
    writeln!(output, "void UDbConnection::ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken)");
    writeln!(output, "{{");
    writeln!(output, "\tif (OnConnectDelegate.IsBound())");
    writeln!(output, "\t{{");
    writeln!(output, "\t\tOnConnectDelegate.Execute(this, Identity, Token);");
    writeln!(output, "\t}}");
    writeln!(output, "}}");
    writeln!(
        output,
        "void UDbConnection::ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error)"
    );
    writeln!(output, "{{");
    writeln!(output, "\tif (OnDisconnectDelegate.IsBound())");
    writeln!(output, "\t{{");
    writeln!(output, "\t\tOnDisconnectDelegate.Execute(this, Error);");
    writeln!(output, "\t}}");
    writeln!(output, "}}");
    writeln!(output);
    writeln!(output);

    writeln!(
        output,
        "void UDbConnection::DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event)"
    );
    writeln!(output, "{{");

    // Create {}Event
    writeln!(output, "    F{module_name_pascal}Event BaseEvent;");
    writeln!(output, "    BaseEvent.Tag = Event.Tag;");
    writeln!(output);

    // Switch on Event.Tag
    writeln!(output, "    switch (Event.Tag)");
    writeln!(output, "    {{");

    // Reducer case
    writeln!(output, "    case ESpacetimeDBEventTag::Reducer:");
    writeln!(output, "    {{");
    writeln!(output, "        FReducerEvent ReducerEvent = Event.GetAsReducer();");
    writeln!(output, "        FReducer Reducer = DecodeReducer(ReducerEvent);");
    writeln!(
        output,
        "        BaseEvent = F{module_name_pascal}Event::Reducer(Reducer);"
    );
    writeln!(output, "        break;");
    writeln!(output, "    }}");
    writeln!(output);

    // Other cases
    writeln!(output, "    case ESpacetimeDBEventTag::SubscribeApplied:");
    writeln!(
        output,
        "        BaseEvent = F{module_name_pascal}Event::SubscribeApplied(Event.GetAsSubscribeApplied());"
    );
    writeln!(output, "        break;");
    writeln!(output);

    writeln!(output, "    case ESpacetimeDBEventTag::UnsubscribeApplied:");
    writeln!(
        output,
        "        BaseEvent = F{module_name_pascal}Event::UnsubscribeApplied(Event.GetAsUnsubscribeApplied());"
    );
    writeln!(output, "        break;");
    writeln!(output);

    writeln!(output, "    case ESpacetimeDBEventTag::Disconnected:");
    writeln!(
        output,
        "        BaseEvent = F{module_name_pascal}Event::Disconnected(Event.GetAsDisconnected());"
    );
    writeln!(output, "        break;");
    writeln!(output);

    writeln!(output, "    case ESpacetimeDBEventTag::SubscribeError:");
    writeln!(
        output,
        "        BaseEvent = F{module_name_pascal}Event::SubscribeError(Event.GetAsSubscribeError());"
    );
    writeln!(output, "        break;");
    writeln!(output);

    writeln!(output, "    case ESpacetimeDBEventTag::UnknownTransaction:");
    writeln!(
        output,
        "        BaseEvent = F{module_name_pascal}Event::UnknownTransaction(Event.GetAsUnknownTransaction());"
    );
    writeln!(output, "        break;");
    writeln!(output);

    writeln!(output, "    default:");
    writeln!(output, "        break;");
    writeln!(output, "    }}");
    writeln!(output);

    // Wrap in EventContext
    writeln!(output, "    FEventContext Context(this, BaseEvent);");
    writeln!(
        output,
        "    // Populate typed reducer args for convenience in table handlers"
    );
    writeln!(output);

    // Apply updates
    writeln!(output, "    ApplyRegisteredTableUpdates(Update, &Context);");
    writeln!(output, "}}");
    writeln!(output);
}

struct UnrealCppAutogen {
    output: CodeIndenter<String>,
}

impl Deref for UnrealCppAutogen {
    type Target = CodeIndenter<String>;
    fn deref(&self) -> &Self::Target {
        &self.output
    }
}
impl std::ops::DerefMut for UnrealCppAutogen {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.output
    }
}

impl UnrealCppAutogen {
    fn new(extra_includes: &[&str], self_header: &str, include_version: bool) -> Self {
        let mut output = CodeIndenter::new(String::new(), "    ");
        print_auto_generated_file_comment(&mut output);
        if include_version {
            print_auto_generated_version_comment(&mut output);
        }
        writeln!(output, "#pragma once");
        writeln!(output, "#include \"CoreMinimal.h\"");
        writeln!(output, "#include \"BSATN/UESpacetimeDB.h\"");

        // Add specific includes based on what's needed
        for include in extra_includes {
            writeln!(output, "#include \"{include}\"");
        }
        writeln!(output, "#include \"{self_header}.g.generated.h\""); // need to include the generated header for Unreal's reflection
        writeln!(output);
        Self { output }
    }

    fn new_cpp(extra_includes: &[&str]) -> Self {
        let mut output = CodeIndenter::new(String::new(), "    ");
        print_auto_generated_file_comment(&mut output);
        for include in extra_includes {
            writeln!(output, "#include \"{include}\"");
        }
        writeln!(output);
        Self { output }
    }

    fn into_inner(self) -> String {
        self.output.into_inner()
    }
}

// ---------------------------------------------------------------------------
//  Helpers
// ---------------------------------------------------------------------------

fn collect_optional_types(module: &ModuleDef) -> HashSet<String> {
    let mut optional_types = HashSet::new();

    // Helper function to collect from a type
    fn collect_from_type(module: &ModuleDef, ty: &AlgebraicTypeUse, out: &mut HashSet<String>) {
        match ty {
            AlgebraicTypeUse::Option(inner) => {
                // Generate the optional type name
                let optional_name = get_optional_type_name(module, inner);
                out.insert(optional_name);
                // Recursively collect from inner type
                collect_from_type(module, inner, out);
            }
            AlgebraicTypeUse::Array(elem) => {
                collect_from_type(module, elem, out);
            }
            AlgebraicTypeUse::Ref(r) => {
                // Check if the referenced type contains optionals
                match &module.typespace_for_generate()[*r] {
                    AlgebraicTypeDef::Product(product) => {
                        for (_, field_ty) in &product.elements {
                            collect_from_type(module, field_ty, out);
                        }
                    }
                    AlgebraicTypeDef::Sum(sum) => {
                        for (_, variant_ty) in &sum.variants {
                            collect_from_type(module, variant_ty, out);
                        }
                    }
                    _ => {}
                }
            }
            _ => {}
        }
    }

    // Collect from all tables
    for table in module.tables() {
        let product_type = module.typespace_for_generate()[table.product_type_ref]
            .as_product()
            .unwrap();
        for (_, field_ty) in &product_type.elements {
            collect_from_type(module, field_ty, &mut optional_types);
        }
    }

    // Collect from all types
    for typ in module.types() {
        match &module.typespace_for_generate()[typ.ty] {
            AlgebraicTypeDef::Product(product) => {
                for (_, field_ty) in &product.elements {
                    collect_from_type(module, field_ty, &mut optional_types);
                }
            }
            AlgebraicTypeDef::Sum(sum) => {
                for (_, variant_ty) in &sum.variants {
                    collect_from_type(module, variant_ty, &mut optional_types);
                }
            }
            _ => {}
        }
    }

    // Collect from reducer parameters
    for reducer in iter_reducers(module) {
        for (_, param_ty) in &reducer.params_for_generate.elements {
            collect_from_type(module, param_ty, &mut optional_types);
        }
    }

    optional_types
}

// Helper function to get C++ type for array elements in optional arrays
fn get_cpp_type_for_array_element(elem_type_str: &str, _: &ModuleDef, module_name: &str) -> String {
    match elem_type_str {
        "Bool" => "bool".to_string(),
        "I8" => "int8".to_string(),
        "U8" => "uint8".to_string(),
        "I16" => "int16".to_string(),
        "U16" => "uint16".to_string(),
        "I32" => "int32".to_string(),
        "U32" => "uint32".to_string(),
        "I64" => "int64".to_string(),
        "U64" => "uint64".to_string(),
        "F32" => "float".to_string(),
        "F64" => "double".to_string(),
        "I128" => "FSpacetimeDBInt128".to_string(),
        "U128" => "FSpacetimeDBUInt128".to_string(),
        "I256" => "FSpacetimeDBInt256".to_string(),
        "U256" => "FSpacetimeDBUInt256".to_string(),
        "String" => "FString".to_string(),
        "Identity" => "FSpacetimeDBIdentity".to_string(),
        "ConnectionId" => "FSpacetimeDBConnectionId".to_string(),
        "Timestamp" => "FSpacetimeDBTimestamp".to_string(),
        "TimeDuration" => "FSpacetimeDBTimeDuration".to_string(),
        "ScheduleAt" => "FSpacetimeDBScheduleAt".to_string(),
        _ if elem_type_str.starts_with("Int32") => {
            // Handle nested optionals like Int32 from OptionalInt32
            let module_name_pascal = module_name.to_case(Case::Pascal);
            format!("F{module_name_pascal}OptionalInt32")
        }
        _ => {
            format!("E{elem_type_str}Type")
        }
    }
}

// Helper function to get array element type name for optional array types
fn get_array_element_type_name(module: &ModuleDef, elem: &AlgebraicTypeUse) -> String {
    match elem {
        AlgebraicTypeUse::Primitive(p) => match p {
            PrimitiveType::Bool => "Bool".to_string(),
            PrimitiveType::I8 => "I8".to_string(),
            PrimitiveType::U8 => "U8".to_string(),
            PrimitiveType::I16 => "I16".to_string(),
            PrimitiveType::U16 => "U16".to_string(),
            PrimitiveType::I32 => "I32".to_string(),
            PrimitiveType::U32 => "U32".to_string(),
            PrimitiveType::I64 => "I64".to_string(),
            PrimitiveType::U64 => "U64".to_string(),
            PrimitiveType::F32 => "F32".to_string(),
            PrimitiveType::F64 => "F64".to_string(),
            PrimitiveType::I128 => "I128".to_string(),
            PrimitiveType::U128 => "U128".to_string(),
            PrimitiveType::I256 => "I256".to_string(),
            PrimitiveType::U256 => "U256".to_string(),
        },
        AlgebraicTypeUse::String => "String".to_string(),
        AlgebraicTypeUse::Identity => "Identity".to_string(),
        AlgebraicTypeUse::ConnectionId => "ConnectionId".to_string(),
        AlgebraicTypeUse::Timestamp => "Timestamp".to_string(),
        AlgebraicTypeUse::TimeDuration => "TimeDuration".to_string(),
        AlgebraicTypeUse::ScheduleAt => "ScheduleAt".to_string(),
        AlgebraicTypeUse::Ref(r) => type_ref_name(module, *r),
        AlgebraicTypeUse::Option(nested_inner) => {
            // Handle optional elements in arrays like Vec<Option<i32>>
            let inner_optional_name = get_optional_type_name(module, nested_inner);
            inner_optional_name
                .strip_prefix("Optional")
                .unwrap_or(&inner_optional_name)
                .to_string()
        }
        _ => "Unknown".to_string(),
    }
}

// Get the name for an optional type (e.g., "OptionalString", "OptionalInt32")
fn get_optional_type_name(module: &ModuleDef, inner: &AlgebraicTypeUse) -> String {
    match inner {
        AlgebraicTypeUse::Primitive(p) => match p {
            PrimitiveType::Bool => "OptionalBool".to_string(),
            PrimitiveType::I8 => "OptionalInt8".to_string(),
            PrimitiveType::U8 => "OptionalUInt8".to_string(),
            PrimitiveType::I16 => "OptionalInt16".to_string(),
            PrimitiveType::U16 => "OptionalUInt16".to_string(),
            PrimitiveType::I32 => "OptionalInt32".to_string(),
            PrimitiveType::U32 => "OptionalUInt32".to_string(),
            PrimitiveType::I64 => "OptionalInt64".to_string(),
            PrimitiveType::U64 => "OptionalUInt64".to_string(),
            PrimitiveType::F32 => "OptionalFloat".to_string(),
            PrimitiveType::F64 => "OptionalDouble".to_string(),
            PrimitiveType::I128 => "OptionalInt128".to_string(),
            PrimitiveType::U128 => "OptionalUInt128".to_string(),
            PrimitiveType::I256 => "OptionalInt256".to_string(),
            PrimitiveType::U256 => "OptionalUInt256".to_string(),
        },
        AlgebraicTypeUse::String => "OptionalString".to_string(),
        AlgebraicTypeUse::Identity => "OptionalIdentity".to_string(),
        AlgebraicTypeUse::ConnectionId => "OptionalConnectionId".to_string(),
        AlgebraicTypeUse::Timestamp => "OptionalTimestamp".to_string(),
        AlgebraicTypeUse::TimeDuration => "OptionalTimeDuration".to_string(),
        AlgebraicTypeUse::ScheduleAt => "OptionalScheduleAt".to_string(),
        AlgebraicTypeUse::Array(elem) => {
            // Generate specific optional array types based on element type
            let elem_name = get_array_element_type_name(module, elem);
            format!("OptionalVec{elem_name}")
        }
        AlgebraicTypeUse::Ref(r) => {
            let type_name = type_ref_name(module, *r);
            format!("Optional{type_name}")
        }
        AlgebraicTypeUse::Option(nested_inner) => {
            // Handle nested optionals like Option<Option<String>>
            let inner_optional_name = get_optional_type_name(module, nested_inner);
            format!("Optional{inner_optional_name}")
        }
        _ => "OptionalUnknown".to_string(),
    }
}

// Generate the content for an optional type file
fn generate_optional_type(optional_name: &str, module: &ModuleDef, api_macro: &str, module_name: &str) -> String {
    // Extract the inner type from the optional name
    let inner_type_str = optional_name.strip_prefix("Optional").unwrap_or(optional_name);

    // Determine the C++ type for the inner value
    let cpp_inner_type = match inner_type_str {
        "Bool" => "bool".to_string(),
        "Int8" => "int8".to_string(),
        "UInt8" => "uint8".to_string(),
        "Int16" => "int16".to_string(),
        "UInt16" => "uint16".to_string(),
        "Int32" => "int32".to_string(),
        "UInt32" => "uint32".to_string(),
        "Int64" => "int64".to_string(),
        "UInt64" => "uint64".to_string(),
        "Float" => "float".to_string(),
        "Double" => "double".to_string(),
        "Int128" => "FSpacetimeDBInt128".to_string(),
        "UInt128" => "FSpacetimeDBUInt128".to_string(),
        "Int256" => "FSpacetimeDBInt256".to_string(),
        "UInt256" => "FSpacetimeDBUInt256".to_string(),
        "String" => "FString".to_string(),
        "Identity" => "FSpacetimeDBIdentity".to_string(),
        "ConnectionId" => "FSpacetimeDBConnectionId".to_string(),
        "Timestamp" => "FSpacetimeDBTimestamp".to_string(),
        "TimeDuration" => "FSpacetimeDBTimeDuration".to_string(),
        "ScheduleAt" => "FSpacetimeDBScheduleAt".to_string(),
        "Array" => "TArray<uint8>".to_string(), // Fallback for generic array type (should not be used with new system)
        _ if inner_type_str.starts_with("Optional") => {
            // Handle nested optionals like OptionalOptionalString
            let module_name_pascal = module_name.to_case(Case::Pascal);
            format!("F{module_name_pascal}{inner_type_str}")
        }
        _ if inner_type_str.starts_with("Vec") => {
            // Handle OptionalVecXxx -> should use TArray<FModuleOptionalXxx>
            let elem_type_str = &inner_type_str[3..]; // Remove "Vec" prefix
            let module_name_pascal = module_name.to_case(Case::Pascal);
            format!("TArray<F{module_name_pascal}Optional{elem_type_str}>")
        }
        _ if inner_type_str.starts_with("OptionalVec") => {
            // Handle specific optional array types like OptionalVecI32, OptionalVecString, etc.
            let elem_type_str = &inner_type_str[11..]; // Remove "OptionalVec" prefix
            let cpp_elem_type = get_cpp_type_for_array_element(elem_type_str, module, module_name);
            format!("TArray<{cpp_elem_type}>")
        }
        _ => {
            // For custom types, check if it's an enum or struct
            let is_enum = module.types().any(|type_def| {
                let type_name = type_def
                    .name
                    .name_segments()
                    .last()
                    .map(|id| id.deref().to_string())
                    .unwrap_or_else(|| "Unnamed".to_string());
                type_name == inner_type_str
                    && matches!(
                        module.typespace_for_generate()[type_def.ty],
                        AlgebraicTypeDef::Sum(_) | AlgebraicTypeDef::PlainEnum(_)
                    )
            });

            if is_enum {
                format!("E{inner_type_str}Type")
            } else {
                format!("F{inner_type_str}Type")
            }
        }
    };

    // Determine if we need extra includes
    let mut extra_includes = vec![];
    match inner_type_str {
        "Identity" | "ConnectionId" | "Timestamp" | "TimeDuration" | "ScheduleAt" => {
            extra_includes.push("Types/Builtins.h".to_string());
        }
        "Int128" | "UInt128" | "Int256" | "UInt256" => {
            extra_includes.push("Types/LargeIntegers.h".to_string());
        }
        "String" | "Bool" | "Int8" | "UInt8" | "Int16" | "UInt16" | "Int32" | "UInt32" | "Int64" | "UInt64"
        | "Float" | "Double" | "Array" => {
            // Basic types, no extra includes needed
        }
        _ if inner_type_str.starts_with("Vec") => {
            // Handle OptionalVecXxx -> needs OptionalXxx include
            let elem_type_str = &inner_type_str[3..]; // Remove "Vec" prefix
            let module_name_pascal = module_name.to_case(Case::Pascal);
            extra_includes.push(format!(
                "ModuleBindings/Optionals/{module_name_pascal}Optional{elem_type_str}.g.h"
            ));
        }
        _ if inner_type_str.starts_with("OptionalVec") => {
            // Handle includes for specific optional array types
            let elem_type_str = &inner_type_str[11..]; // Remove "OptionalVec" prefix
            match elem_type_str {
                "Identity" | "ConnectionId" | "Timestamp" | "TimeDuration" | "ScheduleAt" => {
                    extra_includes.push("Types/Builtins.h".to_string());
                }
                "I128" | "U128" | "I256" | "U256" => {
                    extra_includes.push("Types/LargeIntegers.h".to_string());
                }
                _ if elem_type_str.starts_with("Int32") => {
                    // Handle nested optional includes like Int32 from OptionalInt32
                    let module_name_pascal = module_name.to_case(Case::Pascal);
                    extra_includes.push(format!(
                        "ModuleBindings/Optionals/{module_name_pascal}OptionalInt32.g.h"
                    ));
                }
                _ if !elem_type_str.starts_with("Bool")
                    && !elem_type_str.starts_with("I")
                    && !elem_type_str.starts_with("U")
                    && !elem_type_str.starts_with("F")
                    && elem_type_str != "String" =>
                {
                    // Custom type, need its header
                    extra_includes.push(format!("ModuleBindings/Types/{elem_type_str}Type.g.h"));
                }
                _ => {} // Primitive types don't need extra includes
            }
        }
        _ if inner_type_str.starts_with("Optional") => {
            // Nested optional, need its header
            let module_name_pascal = module_name.to_case(Case::Pascal);
            extra_includes.push(format!(
                "ModuleBindings/Optionals/{module_name_pascal}{inner_type_str}.g.h"
            ));
        }
        _ if !inner_type_str.starts_with("Int") && !inner_type_str.starts_with("UInt") => {
            // Custom type, need its header
            extra_includes.push(format!("ModuleBindings/Types/{inner_type_str}Type.g.h"));
        }
        _ => {}
    }

    let extra_includes_refs: Vec<&str> = extra_includes.iter().map(|s| s.as_str()).collect();
    let module_name_pascal = module_name.to_case(Case::Pascal);
    let struct_name = format!("F{module_name_pascal}{optional_name}");
    let header_name = format!("{module_name_pascal}{optional_name}");
    let mut output = UnrealCppAutogen::new(&extra_includes_refs, &header_name, false);

    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} {struct_name}");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "GENERATED_BODY()");
    writeln!(output);

    // Has value flag
    writeln!(
        output,
        "UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SpacetimeDB\")"
    );
    writeln!(output, "bool bHasValue = false;");
    writeln!(output);

    // The actual value
    // Check if the type is blueprintable
    let is_blueprintable = match inner_type_str {
        "UInt16" | "UInt32" | "UInt64" => false,
        _ if inner_type_str.starts_with("Vec") => {
            // Check blueprintability of array element type for VecXxx types
            let elem_type_str = &inner_type_str[3..]; // Remove "Vec" prefix
            match elem_type_str {
                "UInt16" | "UInt32" | "UInt64" => false, // Unsigned types are not blueprintable
                _ => true,
            }
        }
        _ if inner_type_str.starts_with("OptionalVec") => {
            // Check blueprintability of array element type
            let elem_type_str = &inner_type_str[11..]; // Remove "OptionalVec" prefix
            match elem_type_str {
                "U16" | "U32" | "U64" => false, // Unsigned types are not blueprintable
                _ => true,
            }
        }
        _ => true,
    };

    if is_blueprintable {
        writeln!(output, "UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SpacetimeDB\", meta = (EditCondition = \"bHasValue\"))");
    } else {
        writeln!(
            output,
            "// NOTE: {cpp_inner_type} field not exposed to Blueprint due to non-blueprintable elements"
        );
    }
    writeln!(output, "{cpp_inner_type} Value;");
    writeln!(output);

    // Constructors
    writeln!(output, "{struct_name}() = default;");
    writeln!(output);
    writeln!(output, "explicit {struct_name}(const {cpp_inner_type}& InValue)");
    writeln!(output, "    : bHasValue(true), Value(InValue) {{}}");
    writeln!(output);

    // Helper methods
    writeln!(output, "bool IsSet() const {{ return bHasValue; }}");
    writeln!(output, "void Reset() {{ bHasValue = false; }}");
    writeln!(output);

    // Operators
    writeln!(output, "FORCEINLINE bool operator==(const {struct_name}& Other) const");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "if (bHasValue != Other.bHasValue) return false;");
    writeln!(output, "return !bHasValue || Value == Other.Value;");
    output.dedent(1);
    writeln!(output, "}}");
    writeln!(output);

    writeln!(output, "FORCEINLINE bool operator!=(const {struct_name}& Other) const");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "return !(*this == Other);");
    output.dedent(1);
    writeln!(output, "}}");

    output.dedent(1);
    writeln!(output, "}};");
    writeln!(output);

    // Add GetTypeHash implementation for optional types
    writeln!(output, "/**");
    writeln!(output, " * Custom hash function for {struct_name}.");
    writeln!(output, " * Hashes the HasValue flag and the Value if present.");
    writeln!(output, " * @param Optional The {struct_name} instance to hash.");
    writeln!(output, " * @return The combined hash value.");
    writeln!(output, " */");
    writeln!(output, "FORCEINLINE uint32 GetTypeHash(const {struct_name}& Optional)");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "uint32 Hash = GetTypeHash(Optional.bHasValue);");
    writeln!(output, "if (Optional.bHasValue)");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "Hash = HashCombine(Hash, GetTypeHash(Optional.Value));");
    output.dedent(1);
    writeln!(output, "}}");
    writeln!(output, "return Hash;");
    output.dedent(1);
    writeln!(output, "}}");
    writeln!(output);

    // BSATN serialization support
    writeln!(output, "namespace UE::SpacetimeDB");
    writeln!(output, "{{");

    writeln!(output, "    UE_SPACETIMEDB_ENABLE_TARRAY({struct_name});");

    writeln!(output);

    writeln!(output, "    UE_SPACETIMEDB_OPTIONAL({struct_name}, bHasValue, Value);");
    writeln!(output, "}}");

    output.into_inner()
}

fn autogen_cpp_struct(
    module: &ModuleDef,
    name: &str, // Changed to &str
    product_type: &ProductTypeDef,
    api_macro: &str,
    module_name: &str,
) -> String {
    let mut headers = HashSet::<String>::new();

    for (_, field_ty) in product_type {
        collect_includes_for_type(module, field_ty, &mut headers, module_name);
    }

    // Convert to `Vec<&str>` so UnrealCppAutogen::new works
    let mut slices: Vec<&str> = headers.iter().map(|s| s.as_str()).collect();
    slices.sort(); // make output deterministic

    // --------- start writing file ---------
    let type_name = format!("{name}Type");
    let mut output = UnrealCppAutogen::new(&slices, &type_name, false);

    writeln!(output, "USTRUCT(BlueprintType)");
    writeln!(output, "struct {api_macro} F{name}Type");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "GENERATED_BODY()");
    writeln!(output);

    for (orig_name, ty) in product_type.into_iter() {
        let field_name = orig_name.deref().to_case(Case::Pascal);
        let ty_str = cpp_ty_fmt_with_module(module, ty, module_name).to_string();
        let init_str = cpp_ty_init_fmt_impl(ty);
        let field_decl = format!("{ty_str} {field_name}{init_str}");

        // Check if the type is blueprintable
        if is_blueprintable(module, ty) {
            writeln!(
                output,
                "UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"SpacetimeDB\")"
            );
        } else {
            // Add comment explaining why the field isn't exposed as UPROPERTY
            writeln!(
                output,
                "// NOTE: {ty_str} field not exposed to Blueprint due to non-blueprintable elements"
            );
        }
        writeln!(output, "{field_decl};");
        writeln!(output);
    }

    // Generate operator== and operator!=
    writeln!(output, "FORCEINLINE bool operator==(const F{name}Type& Other) const");
    writeln!(output, "{{");
    output.indent(1);

    // Generate comparison for each field
    let mut comparisons = Vec::new();
    for (orig_name, _) in product_type.into_iter() {
        let field_name = orig_name.deref().to_case(Case::Pascal);

        // For value types, direct comparison
        comparisons.push(format!("{field_name} == Other.{field_name}"));
    }

    if comparisons.is_empty() {
        writeln!(output, "return true;");
    } else {
        writeln!(output, "return {};", comparisons.join(" && "));
    }

    output.dedent(1);
    writeln!(output, "}}");
    writeln!(output);

    writeln!(output, "FORCEINLINE bool operator!=(const F{name}Type& Other) const");
    writeln!(output, "{{");
    output.indent(1);
    writeln!(output, "return !(*this == Other);");
    output.dedent(1);
    writeln!(output, "}}");

    output.dedent(1);
    writeln!(output, "}};");
    writeln!(output);

    // Add GetTypeHash implementation
    writeln!(output, "/**");
    writeln!(output, " * Custom hash function for F{name}Type.");
    writeln!(
        output,
        " * Combines the hashes of all fields that are compared in operator==."
    );
    writeln!(output, " * @param {name}Type The F{name}Type instance to hash.");
    writeln!(output, " * @return The combined hash value.");
    writeln!(output, " */");
    writeln!(output, "FORCEINLINE uint32 GetTypeHash(const F{name}Type& {name}Type)");
    writeln!(output, "{{");
    output.indent(1);

    // Generate hash combining for each field
    let field_names: Vec<String> = product_type
        .into_iter()
        .map(|(name, _)| name.deref().to_case(Case::Pascal))
        .collect();

    if field_names.is_empty() {
        writeln!(output, "return 0; // Empty struct");
    } else {
        // First field
        writeln!(output, "uint32 Hash = GetTypeHash({}Type.{});", name, field_names[0]);

        // Combine with remaining fields
        for field_name in field_names.iter().skip(1) {
            writeln!(
                output,
                "Hash = HashCombine(Hash, GetTypeHash({name}Type.{field_name}));"
            );
        }

        writeln!(output, "return Hash;");
    }

    output.dedent(1);
    writeln!(output, "}}");
    writeln!(output);

    // Add BSATN serialization support
    writeln!(output, "namespace UE::SpacetimeDB");
    writeln!(output, "{{");

    writeln!(output, "    UE_SPACETIMEDB_ENABLE_TARRAY(F{name}Type);");

    writeln!(output);

    if field_names.is_empty() {
        writeln!(output, "    UE_SPACETIMEDB_STRUCT_EMPTY(F{name}Type);");
    } else {
        writeln!(
            output,
            "    UE_SPACETIMEDB_STRUCT(F{}Type, {});",
            name,
            field_names.join(", ")
        );
    }

    writeln!(output, "}}");

    output.into_inner()
}

fn is_primitive_or_fstring(ty: &AlgebraicTypeUse) -> bool {
    matches!(ty, AlgebraicTypeUse::Primitive(_) | AlgebraicTypeUse::String)
}

// Helper function to check if a type should be passed by value (only true primitives)
fn should_pass_by_value_in_delegate(_module: &ModuleDef, ty: &AlgebraicTypeUse) -> bool {
    match ty {
        // Only basic C++ primitives should be passed by value in delegates
        AlgebraicTypeUse::Primitive(p) => match p {
            PrimitiveType::Bool
            | PrimitiveType::I8
            | PrimitiveType::U8
            | PrimitiveType::I16
            | PrimitiveType::U16
            | PrimitiveType::I32
            | PrimitiveType::U32
            | PrimitiveType::I64
            | PrimitiveType::U64
            | PrimitiveType::F32
            | PrimitiveType::F64 => true,
            // These are mapped to FSpacetimeDB types which are USTRUCTs
            PrimitiveType::I128 | PrimitiveType::U128 | PrimitiveType::I256 | PrimitiveType::U256 => false,
        },
        AlgebraicTypeUse::Unit => true,
        // ALL built-in SpacetimeDB types are USTRUCTs, use const references
        AlgebraicTypeUse::String => false,
        AlgebraicTypeUse::Identity => false,     // FSpacetimeDBIdentity is a USTRUCT
        AlgebraicTypeUse::ConnectionId => false, // FSpacetimeDBConnectionId is a USTRUCT
        AlgebraicTypeUse::Timestamp => false,    // FSpacetimeDBTimestamp is a USTRUCT
        AlgebraicTypeUse::TimeDuration => false, // FSpacetimeDBTimeDuration is a USTRUCT
        // Custom structs/enums use const references
        AlgebraicTypeUse::Ref(_) => false,
        AlgebraicTypeUse::Array(_) => false, // Arrays use const references
        AlgebraicTypeUse::Option(inner) => should_pass_by_value_in_delegate(_module, inner),
        AlgebraicTypeUse::ScheduleAt => false,
        AlgebraicTypeUse::Never => false,
    }
}

// Helper function to check if a type is blueprintable as a field (UPROPERTY)
fn is_blueprintable(module: &ModuleDef, ty: &AlgebraicTypeUse) -> bool {
    match ty {
        AlgebraicTypeUse::Primitive(p) => match p {
            // These types are not blueprintable in Unreal Engine
            PrimitiveType::I8 | PrimitiveType::I16 | PrimitiveType::U16 | PrimitiveType::U32 | PrimitiveType::U64 => {
                false
            }
            // All other primitive types are blueprintable
            _ => true,
        },
        // Arrays are blueprintable if their element type is a struct/enum/primitive that can be used in Blueprint
        // TArray<USTRUCT> is always blueprintable, even if the USTRUCT has non-blueprintable fields
        AlgebraicTypeUse::Array(inner) => match inner.as_ref() {
            AlgebraicTypeUse::Ref(r) => {
                // TArray<CustomType> is blueprintable if CustomType is a UStruct/UEnum
                match &module.typespace_for_generate()[*r] {
                    AlgebraicTypeDef::Product(_) => true,   // TArray<USTRUCT> is always blueprintable
                    AlgebraicTypeDef::Sum(_) => true,       // TArray<UENUM> is always blueprintable
                    AlgebraicTypeDef::PlainEnum(_) => true, // TArray<PlainEnum> is always blueprintable
                }
            }
            // For primitive arrays, check if the primitive is blueprintable
            _ => is_blueprintable(module, inner),
        },
        AlgebraicTypeUse::String => true,
        AlgebraicTypeUse::Identity => true,
        AlgebraicTypeUse::ConnectionId => true,
        AlgebraicTypeUse::Timestamp => true,
        AlgebraicTypeUse::TimeDuration => true,
        AlgebraicTypeUse::ScheduleAt => true, // ScheduleAt is blueprintable as a property (TObjectPtr)
        AlgebraicTypeUse::Unit => true,
        AlgebraicTypeUse::Ref(r) => {
            // For struct/class fields, USTRUCTs and UENUMs are always blueprintable as field types
            // The individual fields within the struct may not be accessible, but the struct itself can be used
            match &module.typespace_for_generate()[*r] {
                AlgebraicTypeDef::Product(_) => true, // USTRUCTs are always blueprintable as field types
                AlgebraicTypeDef::Sum(_) => true,     // Sum types are blueprintable
                AlgebraicTypeDef::PlainEnum(_) => true, // Enums are blueprintable
            }
        }
        AlgebraicTypeUse::Option(inner) => is_blueprintable(module, inner),
        AlgebraicTypeUse::Never => false,
    }
}

// Helper function to check if a type can be used as a delegate parameter
// For delegates, structs are blueprintable even if they contain non-blueprintable fields
fn is_type_blueprintable_for_delegates(module: &ModuleDef, ty: &AlgebraicTypeUse) -> bool {
    match ty {
        AlgebraicTypeUse::Primitive(p) => match p {
            // These types are not blueprintable in Unreal Engine
            PrimitiveType::I8 | PrimitiveType::I16 | PrimitiveType::U16 | PrimitiveType::U32 | PrimitiveType::U64 => {
                false
            }
            // All other primitive types are blueprintable
            _ => true,
        },
        // Arrays are blueprintable only if their element type is blueprintable for delegates
        AlgebraicTypeUse::Array(inner) => is_type_blueprintable_for_delegates(module, inner),
        AlgebraicTypeUse::String => true,
        AlgebraicTypeUse::Identity => true,
        AlgebraicTypeUse::ConnectionId => true,
        AlgebraicTypeUse::Timestamp => true,
        AlgebraicTypeUse::TimeDuration => true,
        AlgebraicTypeUse::ScheduleAt => true,
        AlgebraicTypeUse::Unit => true,
        AlgebraicTypeUse::Ref(r) => {
            // For delegate parameters, any USTRUCT is blueprintable regardless of its fields
            match &module.typespace_for_generate()[*r] {
                AlgebraicTypeDef::Product(_) => true, // All structs are blueprintable as delegate params
                _ => true,                            // Enums and sum types are generally blueprintable
            }
        }
        AlgebraicTypeUse::Option(inner) => is_type_blueprintable_for_delegates(module, inner),
        AlgebraicTypeUse::Never => false,
    }
}

// Helper function to generate a C++ enum definition
fn autogen_cpp_enum(name: &str, enum_type: &PlainEnumTypeDef) -> String {
    // Changed name to &str

    let type_name = format!("{name}Type");
    let mut output = UnrealCppAutogen::new(&[], &type_name, false);
    writeln!(output, "UENUM(BlueprintType)");
    writeln!(output, "enum class E{name}Type : uint8");
    writeln!(output, "{{");
    output.indent(1);

    for variant in &*enum_type.variants {
        writeln!(output, "{},", variant.deref().to_case(Case::Pascal)); // Ensure variants are PascalCase, common for UE enums
    }

    output.dedent(1);
    writeln!(output, "}};");
    writeln!(output);

    // Add BSATN serialization support
    writeln!(output, "namespace UE::SpacetimeDB");
    writeln!(output, "{{");

    writeln!(output, "    UE_SPACETIMEDB_ENABLE_TARRAY(E{name}Type);");

    writeln!(output, "}}");

    output.into_inner()
}

fn autogen_cpp_sum(
    module: &ModuleDef,
    name: &str,
    sum_type: &SumTypeDef,
    api_macro: &str,
    module_name: &str,
) -> String {
    use convert_case::Case;

    /* ------------------------------------------------------------------ */
    /* 1. gather #includes for every variant payload -------------------- */
    /* ------------------------------------------------------------------ */
    let mut includes = HashSet::<String>::new();
    for (_, alg_ty) in &sum_type.variants {
        collect_includes_for_type(module, alg_ty, &mut includes, module_name);
    }

    includes.insert("Kismet/BlueprintFunctionLibrary.h".to_string());

    let include_slices: Vec<&str> = includes.iter().map(|s| s.as_str()).collect();

    // /* ------------------------------------------------------------------ */
    // /* 2. emit boiler-plate + forward decls ----------------------------- */
    // /* ------------------------------------------------------------------ */
    let type_name = format!("{name}Type");
    let mut output = UnrealCppAutogen::new(&include_slices, &type_name, false);

    /* ------------------------------------------------------------------ */
    /* 3. generate the tag enum ----------------------------------------- */
    /* ------------------------------------------------------------------ */
    writeln!(output, "UENUM(BlueprintType)\nenum class E{name}Tag : uint8\n{{");

    let mut variant_type = HashSet::<String>::new();

    for (ix, (variant, _variant_type)) in sum_type.variants.iter().enumerate() {
        let comma = if ix + 1 == sum_type.variants.len() { "" } else { "," };
        writeln!(output, "    {}{}", variant.to_case(Case::Pascal), comma);

        let variant_cpp_type = cpp_ty_fmt_with_module(module, _variant_type, module_name).to_string();
        variant_type.insert(variant_cpp_type);
    }
    writeln!(output, "}};\n");

    /* ------------------------------------------------------------------ */
    /* 4. generate the UStruct ----------------------------------- */
    /* ------------------------------------------------------------------ */

    writeln!(output, "USTRUCT(BlueprintType)\nstruct {api_macro} F{name}Type\n{{");
    writeln!(output, "    GENERATED_BODY()\n");

    // default ctor
    writeln!(output, "public:\n    F{name}Type() = default;\n");

    // data + tag
    writeln!(
        output,
        "    TVariant<{}> MessageData;",
        variant_type
            .iter()
            .map(|s| s.as_str())
            .collect::<Vec<&str>>()
            .join(", ")
    );

    writeln!(output);

    writeln!(
        output,
        "    UPROPERTY(BlueprintReadOnly)\n    E{name}Tag Tag = static_cast<E{name}Tag>(0);\n"
    );

    /* 4a. Static factories per variant -------------------------------- */
    for (variant_name, variant_type) in &sum_type.variants {
        let pas = variant_name.to_case(Case::Pascal);
        let variant_cpp_type = cpp_ty_fmt_with_module(module, variant_type, module_name).to_string();
        let param_type = format!("const {variant_cpp_type}& ");

        writeln!(output, "    static F{name}Type {pas}({param_type}Value)\n    {{");

        writeln!(output, "        F{name}Type Obj;");
        writeln!(output, "        Obj.Tag = E{name}Tag::{pas};");

        writeln!(
            output,
            "        Obj.MessageData.Set<{variant_cpp_type}>(Value);\n        return Obj;\n    }}\n"
        );
    }

    /* 4b. Get/Is helpers ---------------------------------------------- */
    for (variant_name, variant_type) in &sum_type.variants {
        let pas = variant_name.to_case(Case::Pascal);
        let variant_cpp_type = cpp_ty_fmt_with_module(module, variant_type, module_name).to_string();

        // Is*
        writeln!(
            output,
            "    FORCEINLINE bool Is{pas}() const {{ return Tag == E{name}Tag::{pas}; }}"
        );

        // GetAs*
        writeln!(
            output,
            "\n    FORCEINLINE {variant_cpp_type} GetAs{pas}() const\n    {{"
        );

        writeln!(
            output,
            "        ensureMsgf(Is{pas}(), TEXT(\"MessageData does not hold {pas}!\"));\n        return MessageData.Get<{variant_cpp_type}>();\n    }}\n"
        );
    }

    // Add inline equality operators
    writeln!(output, "    // Inline equality operators");
    writeln!(
        output,
        "    FORCEINLINE bool operator==(const F{name}Type& Other) const"
    );
    writeln!(output, "    {{");
    writeln!(output, "        if (Tag != Other.Tag) return false;");
    writeln!(output);
    writeln!(output, "        switch (Tag)");
    writeln!(output, "        {{");

    // Generate cases for each variant
    for (variant_name, _variant_type) in &sum_type.variants {
        let pas = variant_name.to_case(Case::Pascal);

        writeln!(output, "            case E{name}Tag::{pas}:");
        writeln!(
            output,
            "                return GetAs{variant_name}() == Other.GetAs{variant_name}();"
        );
    }

    writeln!(output, "            default:");
    writeln!(output, "                return false;");
    writeln!(output, "        }}");
    writeln!(output, "    }}");
    writeln!(output);

    writeln!(
        output,
        "    FORCEINLINE bool operator!=(const F{name}Type& Other) const"
    );
    writeln!(output, "    {{");
    writeln!(output, "        return !(*this == Other);");
    writeln!(output, "    }}");

    writeln!(output, "}};\n");

    // Add GetTypeHash implementation
    writeln!(output, "/**");
    writeln!(output, " * Custom hash function for F{name}Type.");
    writeln!(
        output,
        " * Combines the hashes of all fields that are compared in operator==."
    );
    writeln!(output, " * @param {name}Type The F{name}Type instance to hash.");
    writeln!(output, " * @return The combined hash value.");
    writeln!(output, " */");
    writeln!(output, "FORCEINLINE uint32 GetTypeHash(const F{name}Type& {name})");
    writeln!(output, "{{");
    writeln!(
        output,
        "    const uint32 TagHash = GetTypeHash(static_cast<uint8>({name}.Tag));"
    );

    writeln!(output, "    switch ({name}.Tag)");
    writeln!(output, "    {{");

    output.indent(1);

    for (variant_name, variant_type) in &sum_type.variants {
        let pascal_variant = variant_name.deref().to_case(Case::Pascal);

        let hash_fn_prefix = if is_primitive_or_fstring(variant_type) {
            "GetTypeHash"
        } else {
            "::GetTypeHash"
        };

        writeln!(
            output,
            "    case E{name}Tag::{pascal_variant}: return HashCombine(TagHash, {hash_fn_prefix}({name}.GetAs{pascal_variant}()));"
        );
    }

    writeln!(output, "    default: return TagHash;");

    output.dedent(1);
    writeln!(output, "    }}");
    writeln!(output, "}}");
    writeln!(output);

    // Add BSATN serialization support for tagged variant
    writeln!(output, "namespace UE::SpacetimeDB");
    writeln!(output, "{{");

    writeln!(output, "    UE_SPACETIMEDB_ENABLE_TARRAY(F{name}Type);");

    writeln!(output);

    writeln!(output, "    UE_SPACETIMEDB_TAGGED_ENUM(");
    writeln!(output, "        F{name}Type,");
    writeln!(output, "        E{name}Tag,");
    writeln!(output, "        MessageData,");

    // Generate the variant list
    let variant_count = sum_type.variants.len();
    for (idx, (variant_name, variant_type)) in sum_type.variants.iter().enumerate() {
        let variant_pascal = variant_name.to_case(Case::Pascal);
        let variant_cpp_type = cpp_ty_fmt_with_module(module, variant_type, module_name).to_string();

        if idx < variant_count - 1 {
            writeln!(output, "        {variant_pascal}, {variant_cpp_type},");
        } else {
            writeln!(output, "        {variant_pascal}, {variant_cpp_type}");
        }
    }

    writeln!(output, "    );");
    writeln!(output, "}}");
    writeln!(output);

    // Blueprint Function Library support for BPs
    writeln!(
        output,
        "UCLASS()\nclass {api_macro} U{name}BpLib : public UBlueprintFunctionLibrary\n{{"
    );
    writeln!(output, "    GENERATED_BODY()\n");

    writeln!(output, "private:");

    for (variant_name, variant_type) in &sum_type.variants {
        let pas = variant_name.to_case(Case::Pascal);
        let variant_cpp_type = cpp_ty_fmt_with_module(module, variant_type, module_name).to_string();

        // ctor functions
        if is_blueprintable(module, variant_type) {
            writeln!(
                output,
                "    UFUNCTION(BlueprintCallable, Category = \"SpacetimeDB|{name}\")"
            );
        } else {
            writeln!(
                output,
                "    // NOTE: Not exposed to Blueprint because {variant_cpp_type} types are not Blueprint-compatible"
            );
        }

        writeln!(
            output,
            "    static F{name}Type {pas}(const {variant_cpp_type}& InValue)"
        );
        writeln!(output, "    {{");
        writeln!(output, "        return F{name}Type::{pas}(InValue);");
        writeln!(output, "    }}");
        writeln!(output);

        // Is*
        writeln!(
            output,
            "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{name}\")"
        );
        writeln!(
            output,
            "    static bool Is{pas}(const F{name}Type& InValue) {{ return InValue.Is{pas}(); }}"
        );

        writeln!(output);

        // GetAs*
        if is_blueprintable(module, variant_type) {
            writeln!(
                output,
                "    UFUNCTION(BlueprintPure, Category = \"SpacetimeDB|{name}\")"
            );
        } else {
            writeln!(
                output,
                "    // NOTE: Not exposed to Blueprint because {variant_cpp_type} types are not Blueprint-compatible"
            );
        }
        writeln!(
            output,
            "    static {variant_cpp_type} GetAs{pas}(const F{name}Type& InValue)\n    {{"
        );

        writeln!(output, "        return InValue.GetAs{pas}();\n    }}\n");
    }

    writeln!(output, "}};");

    output.into_inner()
}

// Helper trait for Identifier case conversion
trait IdentifierCasing {
    fn to_case(&self, case: Case) -> String;
}

impl IdentifierCasing for Identifier {
    fn to_case(&self, case: Case) -> String {
        self.deref().to_case(case)
    }
}

fn cpp_ty_fmt_with_module<'a>(
    module: &'a ModuleDef,
    ty: &'a AlgebraicTypeUse,
    module_name: &'a str,
) -> impl fmt::Display + 'a {
    cpp_ty_fmt_impl(module, ty, module_name)
}

fn cpp_ty_fmt_blueprint_compatible<'a>(
    module: &'a ModuleDef,
    ty: &'a AlgebraicTypeUse,
    module_name: &'a str,
) -> impl fmt::Display + 'a {
    cpp_ty_fmt_blueprint_impl(module, ty, module_name)
}

fn cpp_ty_fmt_blueprint_impl<'a>(
    module: &'a ModuleDef,
    ty: &'a AlgebraicTypeUse,
    module_name: &'a str,
) -> impl fmt::Display + 'a {
    fmt_fn(move |f| match ty {
        AlgebraicTypeUse::Array(elem) => {
            let elem_type = cpp_ty_fmt_with_module(module, elem, module_name).to_string();
            write!(f, "TArray<{elem_type}>")
        }
        // For all other types, use the regular implementation
        _ => {
            let display_obj = cpp_ty_fmt_with_module(module, ty, module_name);
            write!(f, "{display_obj}")
        }
    })
}

fn cpp_ty_fmt_impl<'a>(
    module: &'a ModuleDef,
    ty: &'a AlgebraicTypeUse,
    module_name: &'a str,
) -> impl fmt::Display + 'a {
    fmt_fn(move |f| match ty {
        // --------- primitives etc ---------
        AlgebraicTypeUse::Primitive(p) => f.write_str(match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::I8 => "int8",
            PrimitiveType::U8 => "uint8",
            PrimitiveType::I16 => "int16",
            PrimitiveType::U16 => "uint16",
            PrimitiveType::I32 => "int32",
            PrimitiveType::U32 => "uint32",
            PrimitiveType::I64 => "int64",
            PrimitiveType::U64 => "uint64",
            PrimitiveType::F32 => "float",
            PrimitiveType::F64 => "double",
            PrimitiveType::I128 => "FSpacetimeDBInt128",
            PrimitiveType::U128 => "FSpacetimeDBUInt128",
            PrimitiveType::I256 => "FSpacetimeDBInt256",
            PrimitiveType::U256 => "FSpacetimeDBUInt256",
        }),

        AlgebraicTypeUse::Array(elem) if matches!(elem.as_ref(), AlgebraicTypeUse::Primitive(PrimitiveType::U8)) => {
            f.write_str("TArray<uint8>")
        }

        AlgebraicTypeUse::Array(elem) => {
            let elem_type = cpp_ty_fmt_impl(module, elem, module_name).to_string();
            write!(f, "TArray<{elem_type}>")
        }

        AlgebraicTypeUse::String => f.write_str("FString"),
        AlgebraicTypeUse::Identity => f.write_str("FSpacetimeDBIdentity"),
        AlgebraicTypeUse::ConnectionId => f.write_str("FSpacetimeDBConnectionId"),
        AlgebraicTypeUse::Timestamp => f.write_str("FSpacetimeDBTimestamp"),
        AlgebraicTypeUse::TimeDuration => f.write_str("FSpacetimeDBTimeDuration"),
        AlgebraicTypeUse::ScheduleAt => f.write_str("FSpacetimeDBScheduleAt"),
        AlgebraicTypeUse::Unit => f.write_str("FSpacetimeDBUnit"),

        // --------- references to user-defined types ---------
        AlgebraicTypeUse::Ref(r) => {
            let scoped = type_ref_name(module, *r); // PascalCase
            match &module.typespace_for_generate()[*r] {
                AlgebraicTypeDef::PlainEnum(_) => write!(f, "E{scoped}Type"), // enum → EFooType
                AlgebraicTypeDef::Product(_) => write!(f, "F{scoped}Type"),   // struct/record → FFooType
                AlgebraicTypeDef::Sum(_) => write!(f, "F{scoped}Type"),       // sum type → FFooType (UStruct)
            }
        }

        // Options use the generated optional types
        AlgebraicTypeUse::Option(inner) => {
            let optional_name = get_optional_type_name(module, inner);
            if module_name.is_empty() {
                write!(f, "F{optional_name}")
            } else {
                let module_name_pascal = module_name.to_case(Case::Pascal);
                write!(f, "F{module_name_pascal}{optional_name}")
            }
        }

        AlgebraicTypeUse::Never => unreachable!("never type"),
    })
}

// For UPROPERTY() Unreal expects initialization values for certain types
// (e.g. bools default to true if not explicitly initialized to false).
fn cpp_ty_init_fmt_impl<'a>(ty: &'a AlgebraicTypeUse) -> impl fmt::Display + 'a {
    fmt_fn(move |f| match ty {
        AlgebraicTypeUse::Primitive(p) => f.write_str(match p {
            PrimitiveType::Bool => " = false",
            PrimitiveType::I8 => " = 0",
            PrimitiveType::U8 => " = 0",
            PrimitiveType::I16 => " = 0",
            PrimitiveType::U16 => " = 0",
            PrimitiveType::I32 => " = 0",
            PrimitiveType::U32 => " = 0",
            PrimitiveType::I64 => " = 0",
            PrimitiveType::U64 => " = 0",
            PrimitiveType::F32 => " = 0.0f",
            PrimitiveType::F64 => " = 0.0",
            PrimitiveType::I128 => "",
            PrimitiveType::U128 => "",
            PrimitiveType::I256 => "",
            PrimitiveType::U256 => "",
        }),
        AlgebraicTypeUse::Array(_elem) => f.write_str(""),
        AlgebraicTypeUse::String => f.write_str(""),
        AlgebraicTypeUse::Identity => f.write_str(""),
        AlgebraicTypeUse::ConnectionId => f.write_str(""),
        AlgebraicTypeUse::Timestamp => f.write_str(""),
        AlgebraicTypeUse::TimeDuration => f.write_str(""),
        AlgebraicTypeUse::ScheduleAt => f.write_str(""),
        AlgebraicTypeUse::Unit => f.write_str(""),
        // --------- references to user-defined types ---------
        AlgebraicTypeUse::Ref(_r) => f.write_str(""),
        // Options use the generated optional types
        AlgebraicTypeUse::Option(_inner) => f.write_str(""),
        AlgebraicTypeUse::Never => unreachable!("never type"),
    })
}

// Given an `AlgebraicTypeUse`, add every referenced type’s generated
// header name (`"<FTypeName>.g.h"`) into `out` (a `HashSet` avoids dups).
fn collect_includes_for_type(
    module: &ModuleDef,
    ty: &AlgebraicTypeUse,
    out: &mut std::collections::HashSet<String>,
    module_name: &str,
) {
    use AlgebraicTypeUse::*;
    match ty {
        Ref(r) => {
            let header = format!("ModuleBindings/Types/{}Type.g.h", type_ref_name(module, *r));
            out.insert(header);
        }
        Option(inner) => {
            // Add the optional type header
            let optional_name = get_optional_type_name(module, inner);
            let module_name_pascal = module_name.to_case(Case::Pascal);
            let header = format!("ModuleBindings/Optionals/{module_name_pascal}{optional_name}.g.h");
            out.insert(header);
            // Also collect includes for the inner type
            collect_includes_for_type(module, inner, out, module_name);
        }
        Array(inner) => {
            collect_includes_for_type(module, inner, out, module_name);
        }
        // Builtin types that require Builtins.h (also includes LargeIntegers.h)
        Identity | ConnectionId | Timestamp | TimeDuration | ScheduleAt => {
            out.insert("Types/Builtins.h".to_string());
        }
        // Large integer primitives also need Builtins.h (for LargeIntegers.h)
        Primitive(PrimitiveType::I128)
        | Primitive(PrimitiveType::U128)
        | Primitive(PrimitiveType::I256)
        | Primitive(PrimitiveType::U256) => {
            out.insert("Types/Builtins.h".to_string());
        }
        // String type - we use FString directly, no special includes needed
        String => {
            // FString is a native Unreal type, no additional includes required
        }
        // Other primitive types - we use native C++ types directly, no special includes needed
        Primitive(_) => {
            // Native types like uint8, int32, float, etc. don't need special includes
        }
        // Unit type needs UnitType.h header
        Unit => {
            out.insert("Types/UnitType.h".to_string());
        }
        // Never type needs no special headers
        Never => {}
    }
}

// UnrealCPP-specific type reference name function that preserves original case
fn type_ref_name(module: &ModuleDef, typeref: spacetimedb_lib::sats::AlgebraicTypeRef) -> String {
    let (name, _def) = module.type_def_from_ref(typeref).unwrap();
    // Preserve original case instead of applying Pascal case conversion
    name.name_segments()
        .last()
        .map(|id| id.deref().to_string())
        .unwrap_or_else(|| "Unnamed".to_string())
}
