//! Minimal C++ code generation for SpacetimeDB module definitions.
//! Generates only schema definitions - framework provides all functionality.

use crate::Lang;
use crate::OutputFile;
use spacetimedb_lib::sats::layout::PrimitiveType;
use spacetimedb_schema::def::{ModuleDef, ReducerDef, TableDef, TypeDef};
use spacetimedb_schema::type_for_generate::{
    AlgebraicTypeDef, AlgebraicTypeUse, PlainEnumTypeDef, ProductTypeDef, SumTypeDef,
};
// Removed unused import
use std::collections::HashSet;
use std::fmt::{self, Write};

pub struct Cpp<'opts> {
    pub namespace: &'opts str,
}

impl<'opts> Cpp<'opts> {
    fn write_header_comment(&self, output: &mut String) {
        writeln!(
            output,
            "// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE"
        )
        .unwrap();
        writeln!(
            output,
            "// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD."
        )
        .unwrap();
        writeln!(output).unwrap();
        writeln!(output, "// This was generated using spacetimedb codegen.").unwrap();
        writeln!(output).unwrap();
    }

    fn write_standard_includes(&self, output: &mut String) {
        writeln!(output, "#pragma once").unwrap();
        writeln!(output).unwrap();
        writeln!(output, "#include <cstdint>").unwrap();
        writeln!(output, "#include <string>").unwrap();
        writeln!(output, "#include <vector>").unwrap();
        writeln!(output, "#include <optional>").unwrap();
        writeln!(output, "#include <memory>").unwrap();
        writeln!(output, "#include \"../autogen_base.h\"").unwrap();
        writeln!(output, "#include \"spacetimedb/bsatn/bsatn.h\"").unwrap();
    }

    fn cpp_primitive_type(&self, p: &PrimitiveType) -> &'static str {
        match p {
            PrimitiveType::Bool => "bool",
            PrimitiveType::I8 => "int8_t",
            PrimitiveType::U8 => "uint8_t",
            PrimitiveType::I16 => "int16_t",
            PrimitiveType::U16 => "uint16_t",
            PrimitiveType::I32 => "int32_t",
            PrimitiveType::U32 => "uint32_t",
            PrimitiveType::I64 => "int64_t",
            PrimitiveType::U64 => "uint64_t",
            PrimitiveType::I128 => "SpacetimeDb::I128",
            PrimitiveType::U128 => "SpacetimeDb::U128",
            PrimitiveType::I256 => "I256Placeholder", // TODO: proper 256-bit support
            PrimitiveType::U256 => "U256Placeholder", // TODO: proper 256-bit support
            PrimitiveType::F32 => "float",
            PrimitiveType::F64 => "double",
        }
    }

    fn write_algebraic_type(&self, output: &mut String, module: &ModuleDef, typ: &AlgebraicTypeUse) -> fmt::Result {
        match typ {
            AlgebraicTypeUse::Primitive(p) => write!(output, "{}", self.cpp_primitive_type(p)),
            AlgebraicTypeUse::Array(elem_type) => {
                write!(output, "std::vector<")?;
                self.write_algebraic_type(output, module, elem_type)?;
                write!(output, ">")
            }
            AlgebraicTypeUse::Option(inner_type) => {
                write!(output, "std::optional<")?;
                self.write_algebraic_type(output, module, inner_type)?;
                write!(output, ">")
            }
            AlgebraicTypeUse::String => write!(output, "std::string"),
            AlgebraicTypeUse::Identity => write!(output, "__sdk::Identity"),
            AlgebraicTypeUse::ConnectionId => write!(output, "__sdk::ConnectionId"),
            AlgebraicTypeUse::Timestamp => write!(output, "__sdk::Timestamp"),
            AlgebraicTypeUse::TimeDuration => write!(output, "__sdk::TimeDuration"),
            AlgebraicTypeUse::ScheduleAt => write!(output, "__sdk::ScheduleAt"),
            AlgebraicTypeUse::Unit => write!(output, "std::monostate"),
            AlgebraicTypeUse::Never => write!(output, "std::monostate"),
            AlgebraicTypeUse::Ref(type_ref) => {
                if let Some((type_name, _type_def)) = module.type_def_from_ref(*type_ref) {
                    let name = type_name.name().to_string();
                    write!(output, "{}::{}", self.namespace, name)
                } else {
                    write!(output, "UnknownType /* ref {} */", type_ref.idx())
                }
            }
        }
    }

    fn collect_dependencies(module: &ModuleDef, typ: &AlgebraicTypeUse) -> HashSet<String> {
        let mut deps = HashSet::new();
        match typ {
            AlgebraicTypeUse::Array(elem_type) | AlgebraicTypeUse::Option(elem_type) => {
                deps.extend(Self::collect_dependencies(module, elem_type));
            }
            AlgebraicTypeUse::Ref(type_ref) => {
                if let Some((type_name, _)) = module.type_def_from_ref(*type_ref) {
                    deps.insert(type_name.name().to_string());
                }
            }
            _ => {}
        }
        deps
    }

    fn collect_product_dependencies(&self, module: &ModuleDef, product: &ProductTypeDef) -> HashSet<String> {
        let mut deps = HashSet::new();
        for (_, field_type) in &product.elements {
            deps.extend(Self::collect_dependencies(module, field_type));
        }
        deps
    }

    fn collect_sum_dependencies(&self, module: &ModuleDef, sum: &SumTypeDef) -> HashSet<String> {
        let mut deps = HashSet::new();
        for (_, variant_type) in &sum.variants {
            deps.extend(Self::collect_dependencies(module, variant_type));
        }
        deps
    }

    // Generate minimal product type (struct with fields only)
    fn write_product_type(&self, output: &mut String, module: &ModuleDef, type_name: &str, product: &ProductTypeDef) {
        // Use INTERNAL macro for Internal namespace
        let macro_name = if self.namespace == "SpacetimeDb::Internal" {
            "SPACETIMEDB_INTERNAL_PRODUCT_TYPE"
        } else {
            "SPACETIMEDB_PRODUCT_TYPE"
        };
        writeln!(output, "{}({}) {{", macro_name, type_name).unwrap();

        // Write fields only
        for (field_name, field_type) in &product.elements {
            write!(output, "    ").unwrap();
            self.write_algebraic_type(output, module, field_type).unwrap();
            writeln!(output, " {};", field_name).unwrap();
        }

        writeln!(output).unwrap();

        // Only generate serialization for Internal types (no deserialization needed)
        writeln!(
            output,
            "    void bsatn_serialize(::SpacetimeDb::bsatn::Writer& writer) const {{"
        )
        .unwrap();
        for (field_name, _) in &product.elements {
            writeln!(
                output,
                "        ::SpacetimeDb::bsatn::serialize(writer, {});",
                field_name
            )
            .unwrap();
        }
        writeln!(output, "    }}").unwrap();

        // Generate equality method
        if !product.elements.is_empty() {
            write!(output, "    SPACETIMEDB_PRODUCT_TYPE_EQUALITY(").unwrap();
            for (i, (field_name, _)) in product.elements.iter().enumerate() {
                if i > 0 {
                    write!(output, ", ").unwrap();
                }
                write!(output, "{}", field_name).unwrap();
            }
            writeln!(output, ")").unwrap();
        }

        writeln!(output, "}};").unwrap();
    }

    // Generate minimal sum type (TaggedEnum only)
    fn write_sum_type(&self, output: &mut String, module: &ModuleDef, type_name: &str, sum: &SumTypeDef) {
        // Special case: Generate proper tagged enum for RawIndexAlgorithm with data variants
        if type_name == "RawIndexAlgorithm" {
            // Generate data structures for each algorithm variant
            writeln!(output, "// BTree algorithm data").unwrap();
            writeln!(
                output,
                "SPACETIMEDB_INTERNAL_PRODUCT_TYPE(RawIndexAlgorithmBTreeData) {{"
            )
            .unwrap();
            writeln!(output, "    std::vector<uint16_t> columns;").unwrap();
            writeln!(
                output,
                "    void bsatn_serialize(::SpacetimeDb::bsatn::Writer& writer) const {{"
            )
            .unwrap();
            writeln!(output, "        ::SpacetimeDb::bsatn::serialize(writer, columns);").unwrap();
            writeln!(output, "    }}").unwrap();
            writeln!(output, "    SPACETIMEDB_PRODUCT_TYPE_EQUALITY(columns)").unwrap();
            writeln!(output, "}};").unwrap();
            writeln!(output).unwrap();

            // Generate Hash data structure (for future use)
            writeln!(output, "// Hash algorithm data (not currently used)").unwrap();
            writeln!(
                output,
                "SPACETIMEDB_INTERNAL_PRODUCT_TYPE(RawIndexAlgorithmHashData) {{"
            )
            .unwrap();
            writeln!(output, "    std::vector<uint16_t> columns;").unwrap();
            writeln!(
                output,
                "    void bsatn_serialize(::SpacetimeDb::bsatn::Writer& writer) const {{"
            )
            .unwrap();
            writeln!(output, "        ::SpacetimeDb::bsatn::serialize(writer, columns);").unwrap();
            writeln!(output, "    }}").unwrap();
            writeln!(output, "    SPACETIMEDB_PRODUCT_TYPE_EQUALITY(columns)").unwrap();
            writeln!(output, "}};").unwrap();
            writeln!(output).unwrap();

            // Generate Direct data structure (not currently used)
            writeln!(output, "// Direct algorithm data (not currently used)").unwrap();
            writeln!(
                output,
                "SPACETIMEDB_INTERNAL_PRODUCT_TYPE(RawIndexAlgorithmDirectData) {{"
            )
            .unwrap();
            writeln!(output, "    uint16_t column;").unwrap();
            writeln!(
                output,
                "    void bsatn_serialize(::SpacetimeDb::bsatn::Writer& writer) const {{"
            )
            .unwrap();
            writeln!(output, "        ::SpacetimeDb::bsatn::serialize(writer, column);").unwrap();
            writeln!(output, "    }}").unwrap();
            writeln!(output, "    SPACETIMEDB_PRODUCT_TYPE_EQUALITY(column)").unwrap();
            writeln!(output, "}};").unwrap();
            writeln!(output).unwrap();

            // Generate the tagged enum
            writeln!(output, "// RawIndexAlgorithm tagged enum with data variants").unwrap();
            writeln!(output, "SPACETIMEDB_INTERNAL_TAGGED_ENUM({}, ", type_name).unwrap();
            writeln!(output, "    SpacetimeDb::Internal::RawIndexAlgorithmBTreeData,").unwrap();
            writeln!(output, "    SpacetimeDb::Internal::RawIndexAlgorithmHashData,").unwrap();
            writeln!(output, "    SpacetimeDb::Internal::RawIndexAlgorithmDirectData").unwrap();
            writeln!(output, ")").unwrap();
            return;
        }

        // Use INTERNAL macro for Internal namespace
        let macro_name = if self.namespace == "SpacetimeDb::Internal" {
            "SPACETIMEDB_INTERNAL_TAGGED_ENUM"
        } else {
            "SPACETIMEDB_TAGGED_ENUM"
        };

        // Collect variant types and check for duplicates
        let mut variant_types = Vec::new();
        let mut type_strings = Vec::new();

        for (variant_name, variant_type) in &sum.variants {
            let mut type_str = String::new();
            self.write_algebraic_type(&mut type_str, module, variant_type).unwrap();

            // Check if this type already exists
            let duplicate_index = type_strings.iter().position(|s| s == &type_str);

            if let Some(_idx) = duplicate_index {
                // Found duplicate - create a wrapper struct to make it unique
                let wrapper_name = format!("{}_{}_Wrapper", type_name, variant_name);
                writeln!(output, "struct {} {{ {} value; }};", wrapper_name, type_str).unwrap();
                variant_types.push(wrapper_name);
            } else {
                // No duplicate, use the type directly
                type_strings.push(type_str.clone());
                variant_types.push(type_str);
            }
        }

        // Generate the tagged enum with (potentially wrapped) variant types
        write!(output, "{}({}", macro_name, type_name).unwrap();

        if !variant_types.is_empty() {
            write!(output, ", ").unwrap();
            for (i, variant_type) in variant_types.iter().enumerate() {
                if i > 0 {
                    write!(output, ", ").unwrap();
                }
                write!(output, "{}", variant_type).unwrap();
            }
        }

        writeln!(output, ")").unwrap();
    }

    // Generate minimal plain enum
    fn write_plain_enum(&self, output: &mut String, type_name: &str, plain_enum: &PlainEnumTypeDef) {
        writeln!(output, "enum class {} : uint8_t {{", type_name).unwrap();

        for (i, variant) in plain_enum.variants.iter().enumerate() {
            writeln!(output, "    {} = {},", variant, i).unwrap();
        }

        writeln!(output, "}};").unwrap();
    }

    // Special generation for AlgebraicType to handle circular dependencies
    fn generate_algebraic_type_special(&self) -> String {
        r#"// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb codegen.

#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <optional>
#include <memory>
#include <variant>
#include "spacetimedb/bsatn/bsatn.h"
#include "../forward_declarations.h"

namespace SpacetimeDb::Internal {

// AlgebraicType is special - it uses pointers to break circular dependencies
// This is a custom implementation due to circular references between:
// AlgebraicType -> SumType -> SumTypeVariant -> AlgebraicType
// AlgebraicType -> ProductType -> ProductTypeElement -> AlgebraicType
class AlgebraicType {
public:
    enum class Tag : uint8_t {
        Ref = 0,
        Sum = 1, 
        Product = 2,
        Array = 3,
        String = 4,
        Bool = 5,
        I8 = 6,
        U8 = 7,
        I16 = 8,
        U16 = 9,
        I32 = 10,
        U32 = 11,
        I64 = 12,
        U64 = 13,
        I128 = 14,
        U128 = 15,
        I256 = 16,
        U256 = 17,
        F32 = 18,
        F64 = 19
    };

    using DataType = std::variant<
        uint32_t,                                          // Ref
        std::unique_ptr<SpacetimeDb::Internal::SumType>,   // Sum
        std::unique_ptr<SpacetimeDb::Internal::ProductType>, // Product 
        std::unique_ptr<SpacetimeDb::Internal::AlgebraicType>, // Array element type
        std::monostate  // All primitive types (String, Bool, I8, U8, etc.)
    >;

private:
    Tag tag_;
    DataType data_;

public:
    AlgebraicType();
    AlgebraicType(Tag primitive_tag);
    AlgebraicType(const AlgebraicType& other);
    AlgebraicType& operator=(const AlgebraicType& other);
    
    Tag get_tag() const { return tag_; }
    
    template<size_t Index>
    const auto& get() const { return std::get<Index>(data_); }

    template<size_t Index>
    auto& get() { return std::get<Index>(data_); }

    template<size_t Index, typename T>
    void set(T&& value);

    template<size_t Index>
    bool is() const { return tag_ == static_cast<Tag>(Index); }

    template<typename Visitor>
    auto visit(Visitor&& visitor) const -> decltype(auto) {
        return std::visit(std::forward<Visitor>(visitor), data_);
    }

    template<typename Visitor>  
    auto visit(Visitor&& visitor) -> decltype(auto) {
        return std::visit(std::forward<Visitor>(visitor), data_);
    }

    void bsatn_serialize(::SpacetimeDb::bsatn::Writer& writer) const;

    bool operator==(const AlgebraicType& other) const;
    bool operator!=(const AlgebraicType& other) const { return !(*this == other); }
};

} // namespace SpacetimeDb::Internal
"#
        .to_string()
    }
}

impl Lang for Cpp<'_> {
    fn generate_table_file(&self, module: &ModuleDef, table: &TableDef) -> OutputFile {
        let mut output = String::new();
        self.write_header_comment(&mut output);
        self.write_standard_includes(&mut output);

        // Add includes for dependencies
        if let Some(AlgebraicTypeDef::Product(product)) = module.typespace_for_generate().get(table.product_type_ref) {
            let deps = self.collect_product_dependencies(module, product);
            for dep in deps {
                if dep != table.name.to_string() {
                    writeln!(output, "#include \"{}.g.h\"", dep).unwrap();
                }
            }
        }

        writeln!(output).unwrap();
        writeln!(output, "namespace {} {{", self.namespace).unwrap();
        writeln!(output).unwrap();

        // Generate table as a product type
        if let Some(AlgebraicTypeDef::Product(product)) = module.typespace_for_generate().get(table.product_type_ref) {
            self.write_product_type(&mut output, module, &table.name, product);
        }

        writeln!(output, "}} // namespace {}", self.namespace).unwrap();

        OutputFile {
            filename: format!("{}.g.h", table.name),
            code: output,
        }
    }

    fn generate_type_files(&self, module: &ModuleDef, type_def: &TypeDef) -> Vec<OutputFile> {
        let mut output = String::new();
        self.write_header_comment(&mut output);

        let name = type_def.name.name();

        // Special handling for AlgebraicType due to circular dependencies
        if name.to_string() == "AlgebraicType" {
            return vec![OutputFile {
                filename: format!("{name}.g.h"),
                code: self.generate_algebraic_type_special(),
            }];
        }

        self.write_standard_includes(&mut output);

        // Add includes for dependencies
        let deps = match module.typespace_for_generate().get(type_def.ty) {
            Some(AlgebraicTypeDef::Product(product)) => self.collect_product_dependencies(module, product),
            Some(AlgebraicTypeDef::Sum(sum)) => self.collect_sum_dependencies(module, sum),
            Some(AlgebraicTypeDef::PlainEnum(_)) => HashSet::new(),
            None => HashSet::new(),
        };

        for dep in deps {
            if dep != name.to_string() {
                writeln!(output, "#include \"{}.g.h\"", dep).unwrap();
            }
        }

        writeln!(output).unwrap();
        writeln!(output, "namespace {} {{", self.namespace).unwrap();
        writeln!(output).unwrap();

        match module.typespace_for_generate().get(type_def.ty) {
            Some(AlgebraicTypeDef::Product(product)) => {
                self.write_product_type(&mut output, module, name, product);
            }
            Some(AlgebraicTypeDef::Sum(sum)) => {
                self.write_sum_type(&mut output, module, name, sum);
            }
            Some(AlgebraicTypeDef::PlainEnum(plain_enum)) => {
                self.write_plain_enum(&mut output, name, plain_enum);
            }
            None => {
                writeln!(output, "// ERROR: Could not resolve type definition for {}", name).unwrap();
            }
        }

        writeln!(output, "}} // namespace {}", self.namespace).unwrap();
        vec![OutputFile {
            filename: format!("{name}.g.h"),
            code: output,
        }]
    }

    fn generate_reducer_file(&self, _module: &ModuleDef, reducer: &ReducerDef) -> OutputFile {
        let mut output = String::new();
        self.write_header_comment(&mut output);
        self.write_standard_includes(&mut output);

        writeln!(output).unwrap();
        writeln!(output, "namespace {} {{", self.namespace).unwrap();
        writeln!(output).unwrap();

        writeln!(output, "// Reducer: {}", reducer.name).unwrap();
        writeln!(output, "// This file is intentionally minimal - reducer implementation").unwrap();
        writeln!(output, "// is handled by the SpacetimeDB framework.").unwrap();

        writeln!(output, "}} // namespace {}", self.namespace).unwrap();
        OutputFile {
            filename: format!("{}.g.h", reducer.name),
            code: output,
        }
    }

    fn generate_global_files(&self, _module: &ModuleDef) -> Vec<OutputFile> {
        vec![]
    }
}
