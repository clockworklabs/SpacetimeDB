#[doc(hidden)]
pub mod callbacks;
#[doc(hidden)]
pub mod spacetime_module;

pub mod identity;
pub mod reducer;
pub mod table;
use callbacks::CallbackId;
use global_connection::{with_connection, with_connection_mut, with_disconnect_callbacks, with_subscription_callbacks};

// Any `#[doc(hidden)]` modules are public because code generated by the CLI's codegen
// references them, but users should not.

#[doc(hidden)]
pub use spacetimedb_client_api_messages::client_api as client_api_messages;

#[doc(hidden)]
pub mod client_cache;

#[doc(hidden)]
pub mod global_connection;

#[doc(hidden)]
pub mod websocket;

#[doc(hidden)]
pub mod background_connection;

// We re-export `spacetimedb_lib` so the cli codegen can reference it through us, rather
// than requiring downstream users to depend on it explicitly.
// TODO: determine if this should be `#[doc(hidden)]`
pub use spacetimedb_lib::{self, Address};

// Ditto re-exporing `log`.
// TODO: determine if this should be `#[doc(hidden)]`.
pub use log;

// Ditto re-exporting `anyhow`. This is not `#[doc(hidden)]`, because users may want to
// refer to results we return as `anyhow::Result`.
// TODO: determine if we should re-export anything.
pub use anyhow;

#[doc(hidden)]
pub use http;

#[doc(hidden)]
pub use spacetimedb_sats as sats;

/// Subscribe to a set of queries,
/// to be notified when rows which match those queries are altered.
///
/// The `queries` should be a slice of strings representing SQL queries.
///
/// A new call to `subscribe` (or [`subscribe_owned`]) will remove all previous subscriptions
/// and replace them with the new `queries`.
/// If any rows matched the previous subscribed queries but do not match the new queries,
/// those rows will be removed from the client cache,
/// and `TableType::on_delete` callbacks will be invoked for them.
///
/// `subscribe` will return an error if called before establishing a connection
/// with the autogenerated `connect` function.
/// In that case, the queries are not registered.
pub fn subscribe(queries: &[&str]) -> anyhow::Result<()> {
    with_connection(|conn| conn.subscribe(queries))
}

/// Subscribe to a set of queries,
/// to be notified when rows which match those queries are altered.
///
/// The `queries` should be a `Vec` of `String`s representing SQL queries.
///
/// A new call to `subscribe_owned` (or [`subscribe`]) will remove all previous subscriptions
/// and replace them with the new `queries`.
/// If any rows matched the previous subscribed queries but do not match the new queries,
/// those rows will be removed from the client cache,
/// and `TableType::on_delete` callbacks will be invoked for them.
///
/// `subscribe_owned` will return an error if called before establishing a connection
/// with the autogenerated `connect` function.
/// In that case, the queries are not registered.
pub fn subscribe_owned(queries: Vec<String>) -> anyhow::Result<()> {
    with_connection(|conn| conn.subscribe_owned(queries))
}

#[derive(Copy, Clone)]
pub struct SubscriptionCallbackId {
    id: CallbackId<()>,
}

/// Register a callback to be invoked upon a subscription's matching rows becoming available.
///
/// The callback will be invoked after a successful [`subscribe`] or [`subscribe_owned`] call
/// when the initial set of matching rows becomes available.
///
/// The returned `SubscriptionCallbackId` can be passed to `remove_on_subscription_applied`
/// to unregister the callback.
pub fn on_subscription_applied(callback: impl FnMut() + Send + 'static) -> SubscriptionCallbackId {
    let id = with_subscription_callbacks(|sub_callbacks| sub_callbacks.register_on_subscription_applied(callback));
    SubscriptionCallbackId { id }
}

/// Register a callback to be invoked once upon a subscription's matching rows becoming available.
///
/// The callback will be invoked after a successful [`subscribe`] or [`subscribe_owned`] call
/// when the initial set of matching rows becomes available.
///
/// The callback will be unregistered after running.
///
/// The returned `SubscriptionCallbackId` can be passed to `remove_on_subscription_applied`
/// to unregister the callback.
pub fn once_on_subscription_applied(callback: impl FnOnce() + Send + 'static) -> SubscriptionCallbackId {
    let id =
        with_subscription_callbacks(|sub_callbacks| sub_callbacks.register_on_subscription_applied_oneshot(callback));
    SubscriptionCallbackId { id }
}

/// Unregister a previously-registered [`on_subscription_applied`] callback.
///
/// If `id` does not refer to a currently-registered callback, this operation does
/// nothing.
pub fn remove_on_subscription_applied(id: SubscriptionCallbackId) {
    with_subscription_callbacks(|sub_callbacks| sub_callbacks.unregister_on_subscription_applied(id.id));
}

/// Gracefully close the current WebSocket connection.
///
/// If there is no active connection, this operation does nothing.
pub fn disconnect() {
    with_connection_mut(|x| x.disconnect());
}

#[derive(Copy, Clone)]
pub struct DisconnectCallbackId {
    id: CallbackId<()>,
}

/// Register a callback to be invoked when a connection ends.
///
/// The callback will be invoked after a connection closes,
/// either because of a call to [`disconnect`] or because the server closed the connection.
///
/// The returned `DisconnectCallbackId` can be passed to `remove_on_disconnect`
/// to unregister the callback.
pub fn on_disconnect(callback: impl FnMut() + Send + 'static) -> DisconnectCallbackId {
    let id = with_disconnect_callbacks(|dc_callbacks| dc_callbacks.register_on_disconnect(callback));
    DisconnectCallbackId { id }
}

/// Register a callback to be invoked when a connection ends.
///
/// The callback will be invoked after a connection closes,
/// either because of a call to [`disconnect`] or because the server closed the connection.
///
/// The callback will be unregistered after running.
///
/// The returned `DisconnectCallbackId` can be passed to `remove_on_disconnect`
/// to unregister the callback.
pub fn once_on_disconnect(callback: impl FnOnce() + Send + 'static) -> DisconnectCallbackId {
    let id = with_disconnect_callbacks(|dc_callbacks| dc_callbacks.register_on_disconnect_oneshot(callback));
    DisconnectCallbackId { id }
}

/// Unregister a previously-registered [`on_disconnect`] callback.
///
/// If `id` does not refer to a currently-registered callback, this operation does
/// nothing.
pub fn remove_on_disconnect(id: DisconnectCallbackId) {
    with_disconnect_callbacks(|dc_callbacks| dc_callbacks.unregister_on_disconnect(id.id));
}
