//! The client cache, which stores a read-only replica of a subset of a remote database.
//!
//! Our representation is arguably too clever: each table is an [`im::HashMap`],
//! on which we perform a persistent clone-and-mutate after each transaction,
//! rather than just using a [`std::collections::HashMap`] which gets destructively modified.
//! This is mostly a leftover from a previous version of the SDK which was more concurrent.
//!
//! This module is internal, and may incompatibly change without warning.

use crate::callbacks::CallbackId;
use crate::db_connection::{PendingMutation, SharedCell};
use crate::spacetime_module::{InModule, SpacetimeModule, TableUpdate};
use anymap::{any::Any, Map};
use bytes::Bytes;
use futures_channel::mpsc;
use std::collections::HashMap;
use std::marker::PhantomData;
use std::sync::Arc;

/// A local mirror of the subscribed rows of one table in the database.
pub struct TableCache<Row> {
    /// A map of row-bytes to rows.
    ///
    /// The keys are BSATN-serialized representations of the values.
    /// Storing both the bytes and the deserialized rows allows us to have a `HashMap`
    /// even when `Row` is not `Hash + Eq`, e.g. for row types which contain floats.
    /// We also suspect that hashing and equality comparisons for byte arrays
    /// are more efficient than for domain types,
    /// as they can be implemented directly via SIMD without skipping padding
    /// or branching on enum variants.
    pub(crate) entries: HashMap<Bytes, Row>,

    /// Each of the unique indices on this table.
    ///
    /// The values of this map will all be instances of `UniqueIndexImpl`.
    /// The boxing and `dyn` dispatch is necessary to erase the type of the indexed column.
    ///
    /// Entries are added to this map during [`crate::DbConnectionBuilder::build`],
    /// via a `register_table` function autogenerated for each table.
    pub(crate) unique_indices: HashMap<&'static str, Box<dyn UniqueIndexDyn<Row = Row>>>,
}

// Can't derive this because the `Row` generic messes us up.
impl<Row> Default for TableCache<Row> {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            unique_indices: Default::default(),
        }
    }
}

impl<Row: Clone + Send + Sync + 'static> TableCache<Row> {
    /// Apply all the deletes, inserts and updates recorded in `diff`.
    fn apply_diff(&mut self, diff: &TableUpdate<Row>) {
        // Apply deletes strictly before inserts,
        // to avoid duplicates in any unique index.

        for delete in &diff.deletes {
            self.entries.remove(&delete.bsatn);
            for index in self.unique_indices.values_mut() {
                index.remove_row(&delete.row);
            }
        }
        for update in &diff.updates {
            self.entries.remove(&update.delete.bsatn);
            for index in self.unique_indices.values_mut() {
                index.remove_row(&update.delete.row);
            }
        }
        for insert in &diff.inserts {
            self.entries.insert(insert.bsatn.clone(), insert.row.clone());
            for index in self.unique_indices.values_mut() {
                index.add_row(insert.row.clone());
            }
        }
        for update in &diff.updates {
            self.entries
                .insert(update.insert.bsatn.clone(), update.insert.row.clone());
            for index in self.unique_indices.values_mut() {
                index.add_row(update.insert.row.clone());
            }
        }
    }

    fn find_by_unique_index<'this>(
        &'this self,
        unique_index_name: &'static str,
        key: &'_ dyn std::any::Any,
    ) -> Option<&'this Row> {
        let index = self
            .unique_indices
            .get(unique_index_name)
            .unwrap_or_else(|| panic!("No such unique index: {unique_index_name}"));
        index.find_row(key)
    }

    /// Called by the codegen when initializing the client cache during [`crate::DbConnectionBuilder::build`].
    pub fn add_unique_constraint<Col>(&mut self, unique_index_name: &'static str, get_unique_col: fn(&Row) -> &Col)
    where
        Col: Any + Clone + std::hash::Hash + Eq + Send + Sync + std::fmt::Debug + 'static,
    {
        assert!(self.entries.is_empty(), "Cannot add a unique constraint to a populated table; constraints should only be added during initialization, before subscribing to any rows.");
        if self
            .unique_indices
            .insert(
                unique_index_name,
                Box::new(UniqueIndexImpl {
                    get_unique_col,
                    rows: Default::default(),
                }),
            )
            .is_some()
        {
            panic!("Duplicate unique constraint name {unique_index_name}");
        }
    }
}

/// A local mirror of the subscribed subset of the database.
pub struct ClientCache<M: SpacetimeModule + ?Sized> {
    /// "keyed" on the type `HashMap<&'static str, TableCache<Row>`.
    ///
    /// The strings are table names, since we may have multiple tables with the same row type.
    tables: Map<dyn Any + Send + Sync>,

    _module: PhantomData<M>,
}

impl<M: SpacetimeModule> Default for ClientCache<M> {
    fn default() -> Self {
        Self {
            tables: Map::new(),
            _module: PhantomData,
        }
    }
}

impl<M: SpacetimeModule> ClientCache<M> {
    /// Get a handle on the [`TableCache`] which stores rows of type `Row` for the table `table_name`.
    pub(crate) fn get_table<Row: InModule<Module = M> + Send + Sync + 'static>(
        &self,
        table_name: &'static str,
    ) -> Option<&TableCache<Row>> {
        self.tables
            .get::<HashMap<&'static str, TableCache<Row>>>()
            .and_then(|tables_of_row_type| tables_of_row_type.get(table_name))
    }

    /// Called internally when updating the client cache in response to WebSocket messages,
    /// and by the codegen when initializing the client cache during [`crate::DbConnectionBuilder::build`].
    pub fn get_or_make_table<Row: InModule<Module = M> + Send + Sync + 'static>(
        &mut self,
        table_name: &'static str,
    ) -> &mut TableCache<Row> {
        self.tables
            .entry::<HashMap<&'static str, TableCache<Row>>>()
            .or_insert_with(Default::default)
            .entry(table_name)
            .or_default()
    }

    /// Apply all the mutations in `diff`
    /// to the [`TableCache`] which stores rows of type `Row` for the table `table_name`.
    pub fn apply_diff_to_table<Row: InModule<Module = M> + Clone + Send + Sync + 'static>(
        &mut self,
        table_name: &'static str,
        diff: &TableUpdate<Row>,
    ) {
        if diff.is_empty() {
            return;
        }

        let table = self.get_or_make_table::<Row>(table_name);

        table.apply_diff(diff);
    }
}

/// Internal implementation of a generated `TableHandle` struct,
/// which mediates access to a table in the client cache.
///
/// `TableHandle`s don't actually hold a direct reference to the table they access,
/// as that would require both gnarly lifetimes and also a `MutexGuard` on the client cache.
/// Instead, they hold an `Arc<Mutex>` on the whole [`ClientCache`],
/// with every operation through the table handle
/// acquiring the lock only for the duration of the operation,
/// calling [`ClientCache::get_table`] and then discarding its reference before returning.
pub struct TableHandle<Row: InModule> {
    pub(crate) client_cache: SharedCell<ClientCache<Row::Module>>,
    /// Handle on the connection's `pending_mutations_send` channel,
    /// so we can send callback-related [`PendingMutation`] messages.
    pub(crate) pending_mutations: mpsc::UnboundedSender<PendingMutation<Row::Module>>,

    /// The name of the table.
    pub(crate) table_name: &'static str,
}

impl<Row: InModule> Clone for TableHandle<Row> {
    fn clone(&self) -> Self {
        Self {
            client_cache: Arc::clone(&self.client_cache),
            pending_mutations: self.pending_mutations.clone(),
            table_name: self.table_name,
        }
    }
}

impl<Row: InModule + Send + Sync + Clone + 'static> TableHandle<Row> {
    /// Read something out of the [`TableCache`] which this `TableHandle` accesses.
    fn with_table_cache<Res>(&self, get: impl FnOnce(&TableCache<Row>) -> Res) -> Res {
        let client_cache = self.client_cache.lock().unwrap();
        client_cache
            .get_table::<Row>(self.table_name)
            .map(get)
            .unwrap_or_else(|| panic!("No such table: {}", self.table_name))
    }

    /// Called by the autogenerated implementation of the [`crate::Table`] method of the same name.
    pub fn count(&self) -> u64 {
        self.with_table_cache(|table| table.entries.len() as u64)
    }

    /// Called by the autogenerated implementation of the [`crate::Table`] method of the same name.
    pub fn iter(&self) -> impl Iterator<Item = Row> {
        self.with_table_cache(|table| table.entries.values().cloned().collect::<Vec<_>>())
            .into_iter()
    }

    /// See [`DbContextImpl::queue_mutation`].
    fn queue_mutation(&self, mutation: PendingMutation<Row::Module>) {
        self.pending_mutations.unbounded_send(mutation).unwrap();
    }

    /// Called by the autogenerated implementation of the [`crate::Table`] method of the same name.
    pub fn on_insert(
        &self,
        mut callback: impl FnMut(&<Row::Module as SpacetimeModule>::EventContext, &Row) + Send + 'static,
    ) -> CallbackId {
        let callback_id = CallbackId::get_next();
        self.queue_mutation(PendingMutation::AddInsertCallback {
            table: self.table_name,
            callback: Box::new(move |ctx, row| {
                let row = row.downcast_ref::<Row>().unwrap();
                callback(ctx, row);
            }),
            callback_id,
        });
        callback_id
    }

    /// Called by the autogenerated implementation of the [`crate::Table`] method of the same name.
    pub fn remove_on_insert(&self, callback: CallbackId) {
        self.queue_mutation(PendingMutation::RemoveInsertCallback {
            table: self.table_name,
            callback_id: callback,
        });
    }

    /// Called by the autogenerated implementation of the [`crate::Table`] method of the same name.
    pub fn on_delete(
        &self,
        mut callback: impl FnMut(&<Row::Module as SpacetimeModule>::EventContext, &Row) + Send + 'static,
    ) -> CallbackId {
        let callback_id = CallbackId::get_next();
        self.queue_mutation(PendingMutation::AddDeleteCallback {
            table: self.table_name,
            callback: Box::new(move |ctx, row| {
                let row = row.downcast_ref::<Row>().unwrap();
                callback(ctx, row);
            }),
            callback_id,
        });
        callback_id
    }

    /// Called by the autogenerated implementation of the [`crate::Table`] method of the same name.
    pub fn remove_on_delete(&self, callback: CallbackId) {
        self.queue_mutation(PendingMutation::RemoveDeleteCallback {
            table: self.table_name,
            callback_id: callback,
        });
    }

    /// Called by the autogenerated implementation of the [`crate::TableWithPrimaryKey`] method of the same name.
    pub fn on_update(
        &self,
        mut callback: impl FnMut(&<Row::Module as SpacetimeModule>::EventContext, &Row, &Row) + Send + 'static,
    ) -> CallbackId {
        let callback_id = CallbackId::get_next();
        self.queue_mutation(PendingMutation::AddUpdateCallback {
            table: self.table_name,
            callback: Box::new(move |ctx, old, new| {
                let old = old.downcast_ref::<Row>().unwrap();
                let new = new.downcast_ref::<Row>().unwrap();
                callback(ctx, old, new);
            }),
            callback_id,
        });
        callback_id
    }

    /// Called by the autogenerated implementation of the [`crate::TableWithPrimaryKey`] method of the same name.
    pub fn remove_on_update(&self, callback: CallbackId) {
        self.queue_mutation(PendingMutation::RemoveUpdateCallback {
            table: self.table_name,
            callback_id: callback,
        });
    }

    /// Called by autogenerated unique index access methods.
    pub fn get_unique_constraint<Col>(&self, constraint_name: &'static str) -> UniqueConstraintHandle<Row, Col> {
        UniqueConstraintHandle {
            table_handle: self.clone(),
            unique_index_name: constraint_name,
            _phantom: PhantomData,
        }
    }
}

/// A fake implementation of a unique index.
///
/// This struct should allow efficient point queries of a particular field in the table,
/// but our current implementation just does a full scan.
///
/// Like [`TableHandle`], unique constraint handles don't hold a direct reference to their table
/// or an index within it. (No such index currently exists, anyways.)
/// Instead, they hold a handle on the whole [`ClientCache`],
/// and acquire short-lived exclusive access to it during operations.
pub struct UniqueConstraintHandle<Row: InModule, Col> {
    table_handle: TableHandle<Row>,
    unique_index_name: &'static str,
    _phantom: PhantomData<HashMap<Col, Row>>,
}

impl<
        Row: Clone + InModule + Send + Sync + 'static,
        Col: std::any::Any + Eq + std::hash::Hash + Clone + Send + Sync + std::fmt::Debug + 'static,
    > UniqueConstraintHandle<Row, Col>
{
    pub fn find(&self, col_val: &Col) -> Option<Row> {
        self.table_handle
            .with_table_cache(|table| table.find_by_unique_index(self.unique_index_name, col_val).cloned())
    }
}

/// [`UniqueIndexImpl`], but with its `Col` type parameter erased.
pub trait UniqueIndexDyn: Send + Sync + 'static {
    /// The `Row` type parameter to [`UniqueIndexImpl`]; the type of rows in the indexed table.
    type Row: Clone + Send + Sync + 'static;

    /// Insert a new row into the index.
    ///
    /// Panics if an existing row has the same value in the indexed column.
    fn add_row(&mut self, row: Self::Row);
    /// Delete a row from the index.
    ///
    /// Panics if no resident row in the index has the same value in the indexed column.
    ///
    /// Does not check that the row removed from the index is exactly equal to `row`,
    /// only that they have matching values in the indexed column.
    fn remove_row(&mut self, row: &Self::Row);
    /// Look up the row with `key` as its value in the indexed column,
    /// if such a row is resident in the client cache.
    ///
    /// Panics if `key` is not of the same type as the indexed column.
    fn find_row<'this>(&'this self, key: &'_ dyn std::any::Any) -> Option<&'this Self::Row>;
}

/// A unique index on a table with rows of type `Row`, indexing a column of type `Col`.
pub struct UniqueIndexImpl<Row, Col> {
    /// All the rows in the table, indexed by their unique column.
    ///
    /// Unpleasant hack: each unique index stores duplicates of the entire row,
    /// rather than, say, an index or reference into the containing table.
    /// This is because [`HashMap`] does not expose stable indices/references other than hashes,
    /// and the chief competitor which does, `IndexMap`, loses index/reference stability
    /// when removing elements, which would require complicated fixups.
    ///
    /// One could imagine storing an `IntMap` from opaque indices/references to rows,
    /// having the outer [`TableCache`] map row bytes to these integers,
    /// and having unique indices do the same.
    rows: HashMap<Col, Row>,
    /// Given a row, get the value of the indexed column.
    get_unique_col: fn(&Row) -> &Col,
}

impl<Row, Col> UniqueIndexDyn for UniqueIndexImpl<Row, Col>
where
    Row: Clone + Send + Sync + 'static,
    Col: Any + Clone + std::hash::Hash + Eq + Send + Sync + std::fmt::Debug + 'static,
{
    type Row = Row;
    fn add_row(&mut self, row: Self::Row) {
        let col = (self.get_unique_col)(&row).clone();
        if let Some(prev_row) = self.rows.insert(col, row) {
            panic!(
                "Duplicated entry in unique index at key {:?}",
                (self.get_unique_col)(&prev_row)
            );
        }
    }
    fn remove_row(&mut self, row: &Self::Row) {
        let col = (self.get_unique_col)(row);
        self.rows
            .remove(col)
            .expect("UniqueIndexDyn::remove_row for non-present row");
    }
    fn find_row<'this>(&'this self, key: &'_ dyn std::any::Any) -> Option<&'this Self::Row> {
        let col = key
            .downcast_ref::<Col>()
            .expect("UniqueIndexDyn::find_row with key of incorrect type");
        self.rows.get(col)
    }
}
