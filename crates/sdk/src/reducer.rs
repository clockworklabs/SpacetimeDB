use crate::callbacks::CallbackId;
use crate::global_connection::{with_connection, with_reducer_callbacks};
use crate::identity::Identity;
use crate::Address;
use anyhow::Result;
use spacetimedb_sats::{de::DeserializeOwned, ser::Serialize};
use std::any::Any;

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub enum Status {
    Committed,
    Failed(String),
    OutOfEnergy,
}

#[derive(Copy, Clone)]
pub struct ReducerCallbackId<R> {
    id: CallbackId<(Identity, Option<Address>, Status, R)>,
}

// Any bound so these can be keys in an `AnyMap` to store callbacks.
/// A type representing a reducer. The type itself will hold the reducer's arguments.
///
/// Types which implement `Reducer` autogenerated by the SpacetimeDB CLI's
/// `generate` command. Users should not `impl Reducer`.
pub trait Reducer: DeserializeOwned + Serialize + Any + Send + Sync + Clone {
    const REDUCER_NAME: &'static str;

    fn invoke(self) -> Result<()> {
        with_connection(|conn| conn.invoke_reducer(self))
    }

    /// Register a callback to run after the reducer runs.
    ///
    // TODO: the cli should generate a more convenient function `on_{REDUCER_NAME}` for
    //       each reducer, whose callback accepts the reducer args unpacked, rather than
    //       an instance of `Self`. Make sure to document that it uses the same shared
    //       resource, so an `on_{REDUCER_NAME}` followed by a
    //       `{REDUCER_TYPE}::on_reducer` will overwrite the first callback.
    //
    /// The returned `ReducerCallbackId` can be passed to `remove_on_reducer` to
    /// unregister the callback.
    fn on_reducer(
        callback: impl FnMut(&Identity, Option<Address>, &Status, &Self) + Send + 'static,
    ) -> ReducerCallbackId<Self> {
        let id = with_reducer_callbacks(|callbacks| callbacks.register_on_reducer::<Self>(callback));
        ReducerCallbackId { id }
    }

    /// Register a callback to run once after the reducer runs.
    ///
    /// The `callback` will run at most once, then unregister itself.
    /// It can also be unregistered by passing the returned `ReducerCallbackId`
    /// to `remove_on_reducer`.
    fn once_on_reducer(
        callback: impl FnOnce(&Identity, Option<Address>, &Status, &Self) + Send + 'static,
    ) -> ReducerCallbackId<Self> {
        let id = with_reducer_callbacks(|callbacks| callbacks.register_on_reducer_oneshot::<Self>(callback));
        ReducerCallbackId { id }
    }

    /// Unregister a previously-registered `on_reducer` callback.
    ///
    /// If `id` does not refer to a currently-registered callback, this operation will do
    /// nothing.
    fn remove_on_reducer(id: ReducerCallbackId<Self>) {
        with_reducer_callbacks(|callbacks| callbacks.unregister_on_reducer::<Self>(id.id));
    }
}

pub type AnyReducerEvent = dyn Any + Send + Sync;
