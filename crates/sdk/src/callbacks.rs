//! `CallbackMap`, a set of callbacks which run asynchronously in response to messages.
//!
//! The SpacetimeDB Rust Client SDK embraces a callback-driven API,
//! where client authors register callbacks to later run in response to some event.
//!
//! Client authors may want to register multiple callbacks on the same event,
//! and then to remove specific callbacks while leaving others,
//! so we define a `CallbackId` type which uniquely identifies a registered callback,
//! and can be used to remove it.
//!
//! Callbacks may access the global `CONNECTION`, individual `TableCache`s,
//! or register or remove other callbacks. This means that the event source,
//! e.g. a `TableCache`, cannot hold its callbacks directly; doing so would require
//! a `Mutex` or `RwLock` and cause deadlocks when the callbacks attempted to re-acquire it.
//! Instead, a `CallbackMap` holds a channel to a background worker,
//! which runs the callbacks without a lock held.

use crate::{
    client_api_messages,
    client_cache::ClientCacheView,
    global_connection::CurrentStateGuard,
    identity::{Credentials, Identity, Token},
    reducer::{AnyReducerEvent, Reducer, Status},
    spacetime_module::SpacetimeModule,
    table::TableType,
    Address,
};
use anyhow::Context;
use anymap::{any::Any, Map};
use futures::stream::StreamExt;
use futures_channel::mpsc;
use spacetimedb_sats::bsatn;
use std::{
    collections::HashMap,
    marker::PhantomData,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
};
use tokio::{runtime, task::JoinHandle};

/// An owned tuple which can be sent to a `CallbackMap` worker,
/// then converted to a borrowed form to be passed to any number of callbacks.
///
/// We handle callbacks by having a background worker (i.e. a Tokio future) maintain a set
/// of callbacks,
/// each of which takes a single argument, a borrowed `Copy`-able type (or a tuple thereof).
/// To invoke callbacks, a callee sends an owned, `'static` type (or a tuple thereof)
/// through a queue to the callback worker.
/// The worker then uses `OwnedArgs::borrow` to pass a reference to the arguments to each
/// registered callback.
///
/// This trait is exported to allow the export of `TableCallbacks`,
/// which is itself exported to allow autogenerated functions
/// in the `mod.rs` generated for a Spacetime module
/// to reference it.
/// Users should not refer to, depend on, or otherwise interact with this trait.
pub trait OwnedArgs: Send + 'static {
    type Borrowed<'a>: Copy;
    fn borrow(&self) -> Self::Borrowed<'_>;
}

/// A function from one argument, a tuple, which returns no values,
/// used as a callback on some event.
///
/// The `Args` type parameter must be a tuple which implements `OwnedArgs`.
/// The actual function will take `Args::Borrowed`, i.e. a tuple of references to its arguments.
/// A `CallbackMap` will receive `Args` as a tuple, borrow it via `OwnedArgs::borrow`,
/// then pass that tuple of references to all of the `Callback<Args>` that it holds.
pub(crate) type Callback<Args> = dyn for<'a> FnMut(<Args as OwnedArgs>::Borrowed<'a>) + Send + 'static;

/// An identifier for a registered callback of type `Callback<Args>`.
///
/// Registering a callback returns a `CallbackId`,
/// which can later be used to de-register the callback.
///
/// The type `Args` will be an implementor of `OwnedArgs`,
/// refering to the callback's tuple of arguments.
//
// Tagged with type information sufficient to identify the type of the callback in
// question in order to statically detect bugs,
// e.g. where a client registers a callback with `Foo::on_insert`,
// then passes the returned callback id to `Bar::remove_on_reducer`,
// thereby deregistering an unrelated callback.
pub(crate) struct CallbackId<Args> {
    id: usize,

    // Making `Args` invariant here is probably a bit overzealous,
    // since we're referring effectively to a `fn(Args)`,
    // but `Args` must always be `'static`,
    // so subtyping shouldn't come into play at all.
    _phantom: PhantomData<fn(Args) -> Args>,
}

// Putting `PhantomData` in a type pretty thoroughly breaks
// Rust's ability to derive traits for it,
// so we manually implement `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash` and `Debug`.
//
// More specifically, Rust will not derive traits for a type
// unless all of that type's parameters also implement that trait,
// so we have to manually implement e.g. `Hash` for `CallbackId<Args> where Args: !Hash`.

impl<Args> Clone for CallbackId<Args> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<Args> Copy for CallbackId<Args> {}

impl<Args> PartialEq for CallbackId<Args> {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl<Args> Eq for CallbackId<Args> {}

impl<Args> std::hash::Hash for CallbackId<Args> {
    fn hash<H: std::hash::Hasher>(&self, hasher: &mut H) {
        self.id.hash(hasher);
    }
}

// We want to print `CallbackId`s in log messages in response to errors,
// but there isn't a terribly useful way to do that which expresses the `Args` type,
// so we'll just print the integer id.
impl<Args> std::fmt::Debug for CallbackId<Args> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "CallbackId {{ id: {:?} }}", self.id)
    }
}

// We'll implement `OwnedArgs` only for (generalizations of) the arguments to callbacks
// exposed by the client SDK. These are:
//
// - `(T, U)` -> `(&T, &U)`, for `TableType::on_insert` and `TableType::on_delete`.
// - `Credentials` -> `&Credentials`, for `on_connect`.
// - `()` -> `()`, for `on_subscription_applied`.
// - `(T, T, U)` -> `(&T, &T, U)`, for `TableWithPrimaryKey::on_update`.
// - `(Identity, Option<Address>, Status, R)` -> `(&Identity, Option<Address>, &Status, &R)`, for `Reducer::on_reducer`.

impl OwnedArgs for (Credentials, Address) {
    type Borrowed<'a> = (&'a Credentials, Address);
    fn borrow(&self) -> (&Credentials, Address) {
        (&self.0, self.1)
    }
}

impl OwnedArgs for () {
    type Borrowed<'_a> = ();
    fn borrow(&self) {}
}

impl<T: TableType> OwnedArgs for (T, Option<Arc<AnyReducerEvent>>) {
    type Borrowed<'a> = (&'a T, Option<&'a T::ReducerEvent>);
    fn borrow(&self) -> (&T, Option<&T::ReducerEvent>) {
        (
            &self.0,
            self.1.as_ref().map(|x| {
                x.downcast_ref()
                    .expect("Found ReducerEvent of unexpected concrete type.")
            }),
        )
    }
}

impl<T: TableType> OwnedArgs for (T, T, Option<Arc<AnyReducerEvent>>) {
    type Borrowed<'a> = (&'a T, &'a T, Option<&'a T::ReducerEvent>);
    fn borrow(&self) -> (&T, &T, Option<&T::ReducerEvent>) {
        (
            &self.0,
            &self.1,
            self.2.as_ref().map(|x| {
                x.downcast_ref()
                    .expect("Found ReducerEvent of unexpected concrete type.")
            }),
        )
    }
}

impl<R> OwnedArgs for (Identity, Option<Address>, Status, R)
where
    R: Send + 'static,
{
    type Borrowed<'a> = (&'a Identity, Option<Address>, &'a Status, &'a R);
    fn borrow(&self) -> (&Identity, Option<Address>, &Status, &R) {
        (&self.0, self.1, &self.2, &self.3)
    }
}

/// A message sent by a `CallbackMap` to its background worker to request some action,
/// either adding a new callback, removing a previous callback,
/// or invoking all registered callbacks.
enum CallbackMessage<Args>
where
    // Trait bounds on types are generally undesirable, but this one is necessary
    // because the `Callback<Args>` alias requires `Args: OwnedArgs`
    Args: OwnedArgs,
{
    /// Register `callback` into the map, and identify it by `id`.
    ///
    /// The `id` will be chosen by `CallbackMap::insert` using a monotonically increasing
    /// `AtomicUsize` counter. This guarantees that it will be unique.
    ///
    /// The `id` must be chosen prior to sending the message so that it can be immediately
    /// returned from `insert`.
    /// The actual insertion happens asynchronously in the background.
    Register {
        id: CallbackId<Args>,
        callback: Box<Callback<Args>>,
    },

    /// Remove the callback identified by `id` from the map.
    ///
    /// If `id` does not refer to a currently-registered callback,
    /// either because it has already been removed,
    /// or a caller has violated our encapsulation and fabricated a dangling `CallbackId`,
    /// the background worker will log a warning, but otherwise the remove operation
    /// will silently no-op.
    Remove { id: CallbackId<Args> },

    /// Invoke all currently-registered callbacks with `args` as an argument.
    ///
    /// The worker will use `OwnedArgs::borrow` to convert `args` into a `Copy`-able tuple
    /// suitable for passing to each of the callbacks.
    ///
    /// The `db_state` should be the `ClientCache` state
    /// associated with the event that caused this callback to be invoked.
    /// It will be bound around the callback's invocation with a `CurrentStateGuard`
    /// in order to give callback a consistent view of that state.
    Invoke { args: Args, db_state: ClientCacheView },
}

/// A handle on a background worker which maintains a set of `Callback<Args>` callbacks.
///
/// This type is responsible for generating `CallbackId`s and for message passing.
///
/// Note that `CallbackMap` does not directly contain a map; the map is constructed within
/// `CallbackMap::callback_handler_loop`, which runs asynchronously and handles messages.
pub(crate) struct CallbackMap<Args>
where
    // Trait bounds on types are generally undesirable, but this one is necessary
    // because the `Callback<Args>` alias (through `CallbackMessage`) requires `Args: OwnedArgs`
    Args: OwnedArgs,
{
    /// A counter used to create unique `CallbackId`s.
    ///
    /// Because the range of `usize` is quite large, and `HashMap`s are sparse, we have no
    /// need to ever reclaim old `CallbackId`s. A client would have to run for a very long
    /// time, and register and remove a lot of events, in order to overflow this counter,
    /// even on a 32-bit machine.
    next_id: AtomicUsize,

    /// Channel for communicating with the background worker, for sending requests like,
    /// - Register a new callback.
    /// - Remove a previously-registered callback.
    /// - Invoke all currently-registered callbacks.
    send: mpsc::UnboundedSender<CallbackMessage<Args>>,

    /// The Tokio handle for the handler loop.
    #[allow(unused)]
    handle: JoinHandle<()>,
}

impl<Args: OwnedArgs> CallbackMap<Args> {
    /// Constructs a `HashMap` to store callbacks,
    /// and handles `CallbackMessage`s received via `recv`, which are sent from the `CallbackMap`.
    ///
    /// Upon constructing a `CallbackMap` via `spawn`, it will spawn a future which runs this loop.
    async fn callback_handler_loop(mut recv: mpsc::UnboundedReceiver<CallbackMessage<Args>>) {
        let mut callbacks = HashMap::new();
        while let Some(msg) = recv.next().await {
            match msg {
                CallbackMessage::Register { id, callback } => {
                    if callbacks.insert(id, callback).is_some() {
                        log::error!("Overwriting callback with id {:?}", id);
                    }
                }
                CallbackMessage::Remove { id } => {
                    if callbacks.remove(&id).is_none() {
                        log::warn!("Attempt to remove non-registered callback with id {:?}", id);
                    }
                }
                CallbackMessage::Invoke { args, db_state } => {
                    // Enter a dynamic context where `CURRENT_STATE`
                    // is the state which caused this callback invocation.
                    let _guard = CurrentStateGuard::with_current_state(db_state);

                    // We're invoking several callbacks, so none of them may consume `args`.
                    let borrowed = args.borrow();

                    // The callbacks are `FnMut`, so we need the `values_mut` iterator.
                    for callback in callbacks.values_mut() {
                        callback(borrowed);
                    }
                }
            }
        }
    }

    /// Construct a new `CallbackMap` with a background worker running in `Runtime`.
    ///
    /// This will create an unbounded channel, with the returned `CallbackMap` holding
    /// the sender, and the background handler loop holding the receiver.
    fn spawn(runtime: &runtime::Handle) -> Self {
        let (send, recv) = mpsc::unbounded();
        let handle = runtime.spawn(Self::callback_handler_loop(recv));
        CallbackMap {
            next_id: AtomicUsize::from(0),
            send,
            handle,
        }
    }

    fn fresh_id(&self) -> CallbackId<Args> {
        // `self.next_id` is not used for any additional synchronization;
        // it only needs to be a monotonically-increasing thread-safe counter.
        // So long as data dependencies are preserved, which they always are,
        // both the compiler and the CPU are free to re-order accesses to `next_id`
        // with respect to other memory accesses.
        let id = self.next_id.fetch_add(1, Ordering::Relaxed);
        CallbackId {
            id,
            _phantom: PhantomData,
        }
    }

    /// Register `callback` to be run on future `CallbackMap::invoke` calls.
    ///
    /// The returned `CallbackId` uniquely identifies the registered callback,
    /// and can be passed to `CallbackMap::remove` to un-register it.
    ///
    /// This operation happens asynchronously, and the `CallbackMap` processes events
    /// in FIFO order. That means that `callback` will not be called for any previous
    /// `CallbackMap::invoke`s, even if the worker has not executed those invocations yet;
    /// but `callback` will be called for any future `CallbackMap::invoke`s,
    /// even if the background worker has not fully inserted it yet.
    fn insert(&self, callback: Box<Callback<Args>>) -> CallbackId<Args> {
        let id = self.fresh_id();
        self.send
            .unbounded_send(CallbackMessage::Register { id, callback })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");

        id
    }

    /// Register a `FnOnce` callback to run once on an event.
    ///
    /// `callback` should be a function which accepts a tuple of borrowed args,
    ///            like `Callback<Args>`,
    ///            except that it need only be `FnOnce`, not `FnMut`.
    ///            It will be wrapped in a closure which arranges to call it
    ///            at most once, then unregisters it.
    fn insert_oneshot(&self, callback: impl for<'a> FnOnce(Args::Borrowed<'a>) + Send + 'static) -> CallbackId<Args> {
        // Store the inner callback in an `Option`, and `take` it to invoke it.
        let mut callback = Some(callback);
        let id = self.fresh_id();

        // `wrapper` holds a handle on the `send` end of the message queue
        // so that it can `Remove` itself upon running.
        let unsub_handle = self.send.clone();

        let wrapper = move |args: Args::Borrowed<'_>| {
            // Async-ness means that we can't count on `wrapper` being invoked at most once:
            // a second `Invoke` may be placed in the message queue before `wrapper` has a chance
            // to `Remove` itself.
            // So, check if we've already run the `callback`, and if we have, do nothing.
            if let Some(callback) = callback.take() {
                // `Remove` ourselves as soon as possible,
                // to reduce the odds of a second `Invoke` sneaking into the queue beforehand.
                unsub_handle
                    .unbounded_send(CallbackMessage::Remove { id })
                    // This should never fail; the channel will remain open as long as the
                    // handler loop is running, and the callback will be invoked in the
                    // handler loop.
                    .expect("CallbackMap handler loop panicked, but we are somehow in it?");

                // Actually invoke the inner callback.
                callback(args);
            }
        };

        self.send
            .unbounded_send(CallbackMessage::Register {
                id,
                callback: Box::new(wrapper),
            })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");

        id
    }

    /// Unregister a previously-registered callback identified by `id`.
    ///
    /// This operation happens asynchronously, and the `CallbackMap` processes events
    /// in FIFO order. This means that `callback` will still be called for any previous
    /// `CallbackMap::invoke`s, even if the worker has not executed those invocations yet.
    fn remove(&self, id: CallbackId<Args>) {
        self.send
            .unbounded_send(CallbackMessage::Remove { id })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");
    }

    /// Invoke each currently-registered callback in `self` with `args`.
    fn invoke(&self, args: Args, db_state: ClientCacheView) {
        self.send
            .unbounded_send(CallbackMessage::Invoke { args, db_state })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");
    }
}

// These `uncurry_N` functions take a function of N arguments
// and convert it into a function which takes an N-tuple.
// APIs which wrap a `CallbackMap` will accept a function of N arguments,
// e.g. a `FnMut(&Identity, Status, &R)` for `R::on_reducer`,
// and "uncurry" it to produce e.g. a `FnMut((&Identity, Status, &R))`
// suitable for use as a `Callback`.

/// Convert a function of two arguments into a function of a tuple
/// suitable for use as a `Callback`.
///
/// This function is intended specifically for `TableType::on_insert`
/// and `TableType::on_delete` callbacks, where the first argument is
/// (a reference to) the `TableType`, and the second is (a reference to)
/// `T::ReducerEvent`.
fn uncurry_row_callback<Row, ReducerEvent>(
    mut f: impl for<'a> FnMut(&'a Row, Option<&'a ReducerEvent>) + Send + 'static,
) -> impl for<'a> FnMut((&'a Row, Option<&'a ReducerEvent>)) + Send + 'static {
    move |(row, reducer_event)| f(row, reducer_event)
}

/// Convert a function of three arguments into a function of a 3-tuple
/// suitable for use as a `Callback`.
///
/// This function is intended specifically for `TableWithPrimaryKey::on_update` callbacks,
/// where the first two arguments are (references to) the `TableWithPrimaryKey` type,
/// and the third is (a reference to) the `TableType::ReducerEvent` type.
fn uncurry_update_callback<Row, ReducerEvent>(
    mut f: impl for<'a> FnMut(&'a Row, &'a Row, Option<&'a ReducerEvent>) + Send + 'static,
) -> impl for<'a> FnMut((&'a Row, &'a Row, Option<&'a ReducerEvent>)) + Send + 'static {
    move |(old, new, reducer_event)| f(old, new, reducer_event)
}

/// Convert a function of 3 arguments into a function of a 3-tuple
/// suitable for use as a `Callback`.
///
/// This function is intended specifically for `Reducer::on_reducer` callbacks.
fn uncurry_reducer_callback<R>(
    mut f: impl for<'a> FnMut(&'a Identity, Option<Address>, &'a Status, &'a R) + Send + 'static,
) -> impl for<'a> FnMut((&'a Identity, Option<Address>, &'a Status, &'a R)) + Send + 'static {
    move |(identity, address, status, reducer)| f(identity, address, status, reducer)
}

/// A collection of registered callbacks for `on_insert`, `on_delete` and `on_update` events
/// for a particular table.
///
/// References to this type are autogenerated in the `handle_table_update` and `handle_resubscribe`
/// functions in the `mod.rs` corresponding to a Spacetime module.
/// Users should not reference this type directly.
pub struct TableCallbacks<Table>
where
    Table: TableType,
{
    /// Callbacks to be invoked upon inserting a new row into the table.
    on_insert: CallbackMap<(Table, Option<Arc<AnyReducerEvent>>)>,

    /// Callbacks to be invoked upon removing a row from the table.
    on_delete: CallbackMap<(Table, Option<Arc<AnyReducerEvent>>)>,

    /// Callbacks to be invoked upon updating a row which is already resident in the table.
    ///
    /// Update events are only meaningful for tables with a column annotated as `#[primarykey]`.
    /// For tables with primary key columns, a delete followed by an insert
    /// where the altered rows have the same primary key is treated as an update.
    ///
    /// In order to prevent client authors from registering `on_update` callbacks
    /// which can never fire, public interfaces for `on_update` are exposed
    /// through the trait `TableWithPrimaryKey`, which is implemented
    /// only for tables which have a column annotated `#[primarykey]`.
    // TODO: split `on_update` into its own map, to avoid spawning a `CallbackMap`
    //       for tables without primary keys.
    //       In fact, consider splitting all three fields into separate `Map`s in the `DbCallbacks`,
    //       In order to lazily allocate the `CallbackMap`s.
    on_update: CallbackMap<(Table, Table, Option<Arc<AnyReducerEvent>>)>,
}

impl<Table> TableCallbacks<Table>
where
    Table: TableType,
{
    /// Register an `on_insert` callback for when a row is newly inserted into the
    /// database.
    ///
    /// The callback takes one argument, `row: &T`, the newly-inserted row value.
    ///
    /// Each call to `register_on_insert` will return a fresh `CallbackId` which can later
    /// be passed to `unregister_on_insert` to remove the callback.
    // TODO: reduce monomorphization by having this take a `Box<Callback>` instead of an
    //       `impl Callback`.
    pub(crate) fn register_on_insert(
        &mut self,
        on_insert: impl FnMut(&Table, Option<&Table::ReducerEvent>) + Send + 'static,
    ) -> CallbackId<(Table, Option<Arc<AnyReducerEvent>>)> {
        self.on_insert.insert(Box::new(uncurry_row_callback(on_insert)))
    }

    /// Unregister an on-insert callback with the given `id`.
    pub(crate) fn unregister_on_insert(&mut self, id: CallbackId<(Table, Option<Arc<AnyReducerEvent>>)>) {
        self.on_insert.remove(id);
    }

    pub(crate) fn invoke_on_insert(
        &mut self,
        inserted: Table,
        reducer_event: Option<Arc<AnyReducerEvent>>,
        db_state: ClientCacheView,
    ) {
        self.on_insert.invoke((inserted, reducer_event), db_state);
    }

    /// Register an `on_delete` callback for when a row is removed from the database.
    ///
    /// The callback takes one argument, `row: &T`, the previously-present row which is no
    /// longer resident in the database.
    ///
    /// Each call to `register_on_delete` will return a fresh `CallbackId` which can later
    /// be passed to `unregister_on_delete` to remove the callback.
    //
    // TODO: reduce monomorphization by having this take a `Box<Callback>` instead of an
    //       `impl Callback`.
    pub(crate) fn register_on_delete(
        &mut self,
        on_delete: impl FnMut(&Table, Option<&Table::ReducerEvent>) + Send + 'static,
    ) -> CallbackId<(Table, Option<Arc<AnyReducerEvent>>)> {
        self.on_delete.insert(Box::new(uncurry_row_callback(on_delete)))
    }

    /// Unregister an on-delete callback with the given `id`.
    pub(crate) fn unregister_on_delete(&mut self, id: CallbackId<(Table, Option<Arc<AnyReducerEvent>>)>) {
        self.on_delete.remove(id);
    }

    pub(crate) fn invoke_on_delete(
        &mut self,
        deleted: Table,
        reducer_event: Option<Arc<AnyReducerEvent>>,
        db_state: ClientCacheView,
    ) {
        self.on_delete.invoke((deleted, reducer_event), db_state);
    }

    pub(crate) fn new(runtime: &runtime::Handle) -> TableCallbacks<Table> {
        TableCallbacks {
            on_insert: CallbackMap::spawn(runtime),
            on_delete: CallbackMap::spawn(runtime),
            on_update: CallbackMap::spawn(runtime),
        }
    }

    /// Register an `on_update` callback for when an inserted row overwrites an existing
    /// row.
    ///
    /// The callback takes two arguments:
    /// 1. `old: &T`, the previous row value which has been replaced in the database.
    /// 2. `new: &T`, the updated row value which is now resident in the database.
    ///
    /// Each call to `register_on_update` will return a fresh `CallbackId` which can later
    /// be passed to `unregister_on_update` to remove the callback.
    ///
    /// Update callbacks are only meaningful for tables with primary keys.
    /// If `T` is not `TableWithPrimaryKey`, the registered callback will never be invoked.
    //
    // TODO: reduce monomorphization by accepting a `Box<Callback>` instead of an `impl
    //       Callback`.
    pub(crate) fn register_on_update(
        &mut self,
        on_update: impl FnMut(&Table, &Table, Option<&Table::ReducerEvent>) + 'static + Send,
    ) -> CallbackId<(Table, Table, Option<Arc<AnyReducerEvent>>)> {
        self.on_update.insert(Box::new(uncurry_update_callback(on_update)))
    }

    /// Unregister an on-update callback with the given `id`.
    ///
    /// Update callbacks are only meaningful for tables with primary keys.
    pub(crate) fn unregister_on_update(&mut self, id: CallbackId<(Table, Table, Option<Arc<AnyReducerEvent>>)>) {
        self.on_update.remove(id);
    }

    pub(crate) fn invoke_on_update(
        &mut self,
        old: Table,
        new: Table,
        reducer_event: Option<Arc<AnyReducerEvent>>,
        db_state: ClientCacheView,
    ) {
        self.on_update.invoke((old, new, reducer_event), db_state);
    }
}

pub struct DbCallbacks {
    /// "keyed" on the type `TableCallbacks<T> where T: TableType`.
    table_callbacks: Map<dyn Any + Send>,

    /// A handle on the Tokio runtime, used to spawn `CallbackMap` workers
    /// for specific reducer types in `ClientCache::find_table`.
    runtime: runtime::Handle,
}

impl DbCallbacks {
    pub(crate) fn find_table<T: TableType>(&mut self) -> &mut TableCallbacks<T> {
        self.table_callbacks
            .entry::<TableCallbacks<T>>()
            .or_insert_with(|| TableCallbacks::new(&self.runtime))
    }

    pub(crate) fn new(runtime: runtime::Handle) -> DbCallbacks {
        DbCallbacks {
            table_callbacks: Map::new(),
            runtime,
        }
    }
}

/// A function autogenerated by the CLI's codegen which dispatches on the `reducer: &str`
/// field of the `Event` to determine the `R: Reducer` type contained in the
/// `Event`.
///
/// Users should not interact with this type directly.
pub type HandleEventFn =
    fn(client_api_messages::Event, &mut ReducerCallbacks, ClientCacheView) -> Option<Arc<AnyReducerEvent>>;

/// A collection of reducer callbacks.
///
/// References to this struct are autogenerated in the `handle_event`
/// function. Users should not reference this struct directly.
pub struct ReducerCallbacks {
    /// "keyed" on the type `CallbackMap<ReducerCallback<R>> where R: Reducer`.
    callbacks: Map<dyn Any + Send>,

    /// Contains functions autogenerated by the CLI,
    /// which handle dispatching on reducer names
    /// to select appropriate type parameters for various methods.
    module: Option<Arc<dyn SpacetimeModule>>,

    /// A handle on the Tokio runtime, used to spawn `CallbackMap` workers
    /// for specific reducer types in `ReducerCallbacks::find_callbacks`.
    runtime: runtime::Handle,
}

// In order to be resilient against future extensions to the protocol,
// Protobuf/Prost does not deserialize `enum` fields directly into a Rust `enum`.
// Instead, it leaves the message field as an `i32`,
// which we must then compare against the enum variants.
// This helper function does that comparison.

fn parse_status(status: i32, message: String) -> Option<Status> {
    if status == client_api_messages::event::Status::Committed as i32 {
        debug_assert!(message.is_empty());
        Some(Status::Committed)
    } else if status == client_api_messages::event::Status::Failed as i32 {
        Some(Status::Failed(message))
    } else if status == client_api_messages::event::Status::OutOfEnergy as i32 {
        debug_assert!(message.is_empty());
        Some(Status::OutOfEnergy)
    } else {
        None
    }
}

impl ReducerCallbacks {
    pub(crate) fn without_handle_event(runtime: runtime::Handle) -> ReducerCallbacks {
        ReducerCallbacks {
            callbacks: Map::new(),
            module: None,
            runtime,
        }
    }

    pub(crate) fn set_module(&mut self, module: Arc<dyn SpacetimeModule>) {
        self.module = Some(module);
    }

    pub(crate) fn find_callbacks<R: Reducer>(&mut self) -> &mut CallbackMap<(Identity, Option<Address>, Status, R)> {
        self.callbacks
            .entry::<CallbackMap<(Identity, Option<Address>, Status, R)>>()
            .or_insert_with(|| CallbackMap::spawn(&self.runtime))
    }

    /// Parse the reducer arguments, caller identity and status
    /// of the reducer run described by `event`, and invoke any on-reducer callbacks
    /// registered for that reducer.
    ///
    /// Calls to this method are autogenerated in the `handle_event` function, which
    /// handles dispatching on the reducer's name to find the appropriate type `R` to
    /// `handle_event_of_type`. Users should not call this method directly.
    pub fn handle_event_of_type<R: Reducer, ReducerEvent: Any + Send + Sync>(
        &mut self,
        event: client_api_messages::Event,
        state: ClientCacheView,
        wrap: fn(R) -> ReducerEvent,
    ) -> Option<Arc<AnyReducerEvent>> {
        let client_api_messages::Event {
            caller_identity,
            caller_address,
            function_call: Some(function_call),
            status,
            message,
            ..
        } = event
        else {
            log::warn!("Received Event with function_call of None");
            return None;
        };
        let identity = Identity::from_bytes(caller_identity);
        let address = Address::from_slice(caller_address);
        let address = if address == Address::zero() {
            None
        } else {
            Some(address)
        };
        let Some(status) = parse_status(status, message) else {
            log::warn!("Received Event with unknown status {:?}", status);
            return None;
        };
        match bsatn::from_slice::<R>(&function_call.arg_bytes) {
            Err(e) => {
                log::error!("Error while deserializing reducer args from FunctionCall: {:?}", e);
                None
            }
            Ok(instance) => {
                // TODO: should reducer callbacks' `OwnedArgs` impl take an `Arc<R>` rather than an `R`?
                self.find_callbacks::<R>()
                    .invoke((identity, address, status, instance.clone()), state);
                Some(Arc::new(wrap(instance)))
            }
        }
    }

    /// Register an on-reducer callback to run whenever we receive an `Event` message
    /// describing a run of this reducer.
    // TODO: reduce monomorphization by accepting `Box<Callback>` instead of `impl Callback`
    pub(crate) fn register_on_reducer<R: Reducer>(
        &mut self,
        callback: impl FnMut(&Identity, Option<Address>, &Status, &R) + Send + 'static,
    ) -> CallbackId<(Identity, Option<Address>, Status, R)> {
        self.find_callbacks::<R>()
            .insert(Box::new(uncurry_reducer_callback(callback)))
    }

    /// Register an on-reducer callback to run at most once
    /// when we receive an `Event` message describing a run of this reducer.
    //
    // Unlike `register_on_reducer`, accepting a `Box` is undesirable here;
    // it would reduce monomorphization, but would also allocate an additional time,
    // since [`CallbackMap::insert_oneshot`] boxes its wrapper callback.
    pub(crate) fn register_on_reducer_oneshot<R: Reducer>(
        &mut self,
        callback: impl FnOnce(&Identity, Option<Address>, &Status, &R) + Send + 'static,
    ) -> CallbackId<(Identity, Option<Address>, Status, R)> {
        self.find_callbacks::<R>()
            .insert_oneshot(move |(identity, address, status, args)| callback(identity, address, status, args))
    }

    /// Unregister a previously-registered on-reducer callback identified by `id`.
    pub(crate) fn unregister_on_reducer<R: Reducer>(&mut self, id: CallbackId<(Identity, Option<Address>, Status, R)>) {
        self.find_callbacks::<R>().remove(id);
    }

    /// Invoke the autogenerated `handle_event` function
    /// to dispatch on the reducer named by `event`,
    /// and invoke `handle_event_of_type` with an appropriate type arg.
    ///
    /// Panics if invoked before the `handle_event` function is set with `set_handle_event`.
    /// This would mean that we received an `Event` before connecting,
    /// which should be impossible.
    pub(crate) fn handle_event(
        &mut self,
        event: client_api_messages::Event,
        state: ClientCacheView,
    ) -> Option<Arc<AnyReducerEvent>> {
        self.module.clone().unwrap().handle_event(event, self, state)
    }
}

/// Holds the client's `Credentials`, if we have them,
/// and manages running on-connect callbacks when `Credentials` become available.
pub(crate) struct CredentialStore {
    /// The client's credentials.
    ///
    /// If credentials are passed to `connect`, they will be stored in the `CredentialStore`,
    /// and later checked against the credentials received from the database.
    ///
    /// If credentials are not passed to `connect`, this field will initially be `None`,
    /// and will be set to `Some` upon receiving a freshly-generated set of credentials
    /// from the database.
    credentials: Option<Credentials>,

    address: Option<Address>,

    /// Any `on_connect` callbacks to run when credentials become available.
    callbacks: CallbackMap<(Credentials, Address)>,
}

impl CredentialStore {
    pub(crate) fn use_saved_address(&mut self, file: &str) -> anyhow::Result<Address> {
        if let Some(address) = self.address {
            panic!(
                "Cannot use_saved_address when an address has already been generated. Generated address: {:?}",
                address
            );
        }
        match std::fs::read(file) {
            Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
                let file = AsRef::<std::path::Path>::as_ref(file);
                let addr = Address::from_arr(&rand::random());
                let addr_bytes = bsatn::to_vec(&addr).context("Error serializing Address")?;

                if let Some(parent) = file.parent() {
                    if parent != AsRef::<std::path::Path>::as_ref("") {
                        std::fs::create_dir_all(parent).context("Error creating parent directory for address file")?;
                    }
                }

                std::fs::write(file, addr_bytes).context("Error writing Address to file")?;

                self.address = Some(addr);
                Ok(addr)
            }
            Err(e) => Err(e).context("Error reading BSATN-encoded Address from file"),
            Ok(file_contents) => {
                let addr = bsatn::from_slice::<Address>(&file_contents)
                    .context("Error decoding BSATN-encoded Address from file")?;
                self.address = Some(addr);
                Ok(addr)
            }
        }
    }
    /// Construct a `CredentialStore` for a not-yet-connected `BackgroundDbConnection`
    /// containing no credentials.
    ///
    /// The background worker for on-connect callbacks will be spawned in `runtime`.
    pub(crate) fn without_credentials(runtime: &runtime::Handle) -> Self {
        CredentialStore {
            credentials: None,
            address: None,
            callbacks: CallbackMap::spawn(runtime),
        }
    }

    /// Set the stored credentials to the ones passed to `connect`.
    ///
    /// Do not invoke on-connect callbacks.
    pub(crate) fn maybe_set_credentials(&mut self, credentials: Option<Credentials>) {
        self.credentials = credentials;
    }

    pub(crate) fn get_or_init_address(&mut self) -> Address {
        if let Some(addr) = self.address {
            addr
        } else {
            let addr = Address::from_arr(&rand::random());
            self.address = Some(addr);
            addr
        }
    }

    /// Register an on-connect callback to run when the client's `Credentials` become available.
    // TODO: reduce monomorphization by accepting `Box<Callback>` instead of `impl Callback`
    pub(crate) fn register_on_connect(
        &mut self,
        mut callback: impl FnMut(&Credentials, Address) + Send + 'static,
    ) -> CallbackId<(Credentials, Address)> {
        self.callbacks
            .insert(Box::new(move |(creds, addr)| callback(creds, addr)))
    }

    /// Register an on-connect callback which will run at most once,
    /// then unregister itself.
    pub(crate) fn register_on_connect_oneshot(
        &mut self,
        callback: impl FnOnce(&Credentials, Address) + Send + 'static,
    ) -> CallbackId<(Credentials, Address)> {
        self.callbacks
            .insert_oneshot(move |(creds, addr)| callback(creds, addr))
    }

    /// Unregister a previously-registered on-connect callback identified by `id`.
    pub(crate) fn unregister_on_connect(&mut self, id: CallbackId<(Credentials, Address)>) {
        self.callbacks.remove(id);
    }

    /// Handle a `client_api_messages::IdentityToken` message received from the database.
    ///
    /// If we connected anonymously, store our new credentials.
    ///
    /// If we connected with existing `Credentials`, compare them to the ones provided by the database,
    /// and log an error if they don't match.
    ///
    /// Either way, invoke any on-connect callbacks with the received credentials.
    pub(crate) fn handle_identity_token(&mut self, msg: client_api_messages::IdentityToken, state: ClientCacheView) {
        let client_api_messages::IdentityToken {
            identity,
            token,
            address,
        } = msg;
        if identity.is_empty() || token.is_empty() || address.is_empty() {
            // TODO: panic?
            log::warn!("Received IdentityToken message with emtpy identity, token and/or address");
            return;
        }

        let creds = Credentials {
            identity: Identity::from_bytes(identity),
            token: Token { string: token },
        };

        let address = Address::from_slice(&address);

        if Some(address) != self.address {
            log::error!(
                "Address provided by the server does not match local record. Server: {:?} Local: {:?}",
                address,
                self.address,
            );
        }

        self.callbacks.invoke((creds.clone(), address), state);

        if let Some(existing_creds) = &self.credentials {
            // If we already have credentials, make sure that they match. Log an error if
            // they don't.
            //
            // TODO: Should we panic in this case? If we're wrong about our creds,
            //       something has gone very very wrong.
            if *existing_creds != creds {
                log::error!(
                    "Credentials provided by the server do not match local record. Server: {:?} Local: {:?}",
                    creds,
                    existing_creds,
                );
            }
        } else {
            self.credentials = Some(creds);
        }
    }

    /// Return the current connection's `Identity`, if one is stored.
    pub(crate) fn identity(&self) -> Option<Identity> {
        self.credentials.as_ref().map(|creds| creds.identity.clone())
    }

    /// Return the current connection's private `Token`, if one is stored.
    pub(crate) fn token(&self) -> Option<Token> {
        self.credentials.as_ref().map(|creds| creds.token.clone())
    }

    /// Return the current connection's `Credentials`, if they are stored.
    pub(crate) fn credentials(&self) -> Option<Credentials> {
        self.credentials.clone()
    }

    /// Return the current connection's `Address`, if it is stored.
    pub(crate) fn address(&self) -> Option<Address> {
        self.address
    }
}

/// Manages running `on_subscription_applied` callbacks after `subscribe` calls.
pub(crate) struct SubscriptionAppliedCallbacks {
    /// Any `on_subscription_applied` callbacks to run after a successful `subscribe` call.
    callbacks: CallbackMap<()>,
}

impl SubscriptionAppliedCallbacks {
    /// Construct a `SubscriptionAppliedCallbacks` for a connection.
    ///
    /// The background worker will be spawned in `runtime`.
    pub(crate) fn new(runtime: &runtime::Handle) -> Self {
        SubscriptionAppliedCallbacks {
            callbacks: CallbackMap::spawn(runtime),
        }
    }

    /// Register an on-subscription-applied callback
    /// to run when the initial rows matching a subscription become available.
    pub(crate) fn register_on_subscription_applied(
        &mut self,
        mut callback: impl FnMut() + Send + 'static,
    ) -> CallbackId<()> {
        self.callbacks.insert(Box::new(move |()| callback()))
    }

    /// Register an on-subscription-applied callback which will run at most once,
    /// then unregister itself.
    pub(crate) fn register_on_subscription_applied_oneshot(
        &mut self,
        callback: impl FnOnce() + Send + 'static,
    ) -> CallbackId<()> {
        self.callbacks.insert_oneshot(move |()| callback())
    }

    /// Unregister a previously-registered on-subscription-applied callback identified by `id`.
    pub(crate) fn unregister_on_subscription_applied(&mut self, id: CallbackId<()>) {
        self.callbacks.remove(id);
    }

    /// Invoke any on-subscription-applied callbacks within the cache state
    /// upon receiving the initial matching rows for a subscription.
    pub(crate) fn handle_subscription_applied(&mut self, state: ClientCacheView) {
        self.callbacks.invoke((), state);
    }
}

/// Manages running `on_disconnect` callbacks when a connection closes.
pub(crate) struct DisconnectCallbacks {
    /// Any `on_disconnect` callbacks to run after a connection closes.
    callbacks: CallbackMap<()>,
}

impl DisconnectCallbacks {
    /// Construct a `DisconnectCallbacks` for a connection.
    ///
    /// The background worker will be spawned in `runtime`.
    pub(crate) fn new(runtime: &runtime::Handle) -> Self {
        DisconnectCallbacks {
            callbacks: CallbackMap::spawn(runtime),
        }
    }

    /// Register an on-disconnect callback to run when a connection ends.
    pub(crate) fn register_on_disconnect(&mut self, mut callback: impl FnMut() + Send + 'static) -> CallbackId<()> {
        self.callbacks.insert(Box::new(move |()| callback()))
    }

    /// Register an on-disconnect callback which will run at most once,
    /// then de-register itself.
    pub(crate) fn register_on_disconnect_oneshot(
        &mut self,
        callback: impl FnOnce() + Send + 'static,
    ) -> CallbackId<()> {
        self.callbacks.insert_oneshot(move |()| callback())
    }

    /// Unregister a previously-registered on-disconnect callback identified by `id`.
    pub(crate) fn unregister_on_disconnect(&mut self, id: CallbackId<()>) {
        self.callbacks.remove(id);
    }

    /// Invoke any on-disconnect callbacks within the final cache state
    /// before the connection ended.
    pub(crate) fn handle_disconnect(&mut self, state: ClientCacheView) {
        self.callbacks.invoke((), state);
    }
}
