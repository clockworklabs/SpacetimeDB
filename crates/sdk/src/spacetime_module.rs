//! Interfaces used by per-module codegen.
//!
//! This module is internal, and may incompatibly change without warning.

use crate::{
    callbacks::DbCallbacks,
    client_cache::ClientCache,
    db_connection::DbContextImpl,
    subscription::{OnEndedCallback, SubscriptionHandleImpl},
    Event,
};
use anyhow::Context;
use bytes::Bytes;
use spacetimedb_client_api_messages::websocket::{self as ws, RowListLen as _};
use spacetimedb_data_structures::map::{DefaultHashBuilder, HashCollectionExt, HashMap};
use spacetimedb_lib::{bsatn, de::DeserializeOwned};
use std::{fmt::Debug, hash::Hash};

/// Marker trait for any item defined in a module,
/// to conveniently get the types of various per-module things.
pub trait InModule {
    /// Unit type which represents the module itself.
    type Module: SpacetimeModule;
}

/// Each module's codegen will define a unit struct which implements this trait,
/// with associated type links to various other generated types.
pub trait SpacetimeModule: Send + Sync + 'static {
    /// [`crate::DbContext`] implementor which exists in the global scope.
    type DbConnection: DbConnection<Module = Self>;

    /// [`crate::DbContext`] implementor passed to callbacks.
    type EventContext: EventContext<Module = Self>;

    /// Enum with variants for each reducer's args; will be contained in [`crate::ReducerEvent`].
    type Reducer: Reducer<Module = Self>;

    /// Return type of [`crate::DbContext::db`].
    type DbView: InModule<Module = Self> + Send + 'static;

    /// Return type of [`crate::DbContext::reducers`].
    type Reducers: InModule<Module = Self> + Send + 'static;

    /// Return type of [`crate::DbContext::set_reducer_flags`].
    type SetReducerFlags: InModule<Module = Self> + Send + 'static;

    /// Parsed and typed analogue of [`crate::ws::DatabaseUpdate`].
    type DbUpdate: DbUpdate<Module = Self>;

    /// Module-specific `SubscriptionHandle` type, representing an ongoing incremental subscription to a query.
    type SubscriptionHandle: SubscriptionHandle<Module = Self>;

    /// Called when constructing a [`Self::DbConnection`] on the new connection's [`ClientCache`]
    /// to pre-register tables defined by the module, including their indices.
    fn register_tables(client_cache: &mut ClientCache<Self>);
}

/// Implemented by the autogenerated `DbUpdate` type,
/// which is a parsed and typed analogue of [`crate::ws::DatabaseUpdate`].
pub trait DbUpdate:
    TryFrom<ws::DatabaseUpdate<ws::BsatnFormat>, Error = anyhow::Error> + InModule + Send + 'static
where
    Self::Module: SpacetimeModule<DbUpdate = Self>,
{
    fn apply_to_client_cache(&self, cache: &mut ClientCache<Self::Module>);
    fn invoke_row_callbacks(
        &self,
        event: &<<Self as InModule>::Module as SpacetimeModule>::EventContext,
        callbacks: &mut DbCallbacks<Self::Module>,
    );

    fn parse_update(update: ws::DatabaseUpdate<ws::BsatnFormat>) -> anyhow::Result<Self> {
        Self::try_from(update).context("Failed to parse DatabaseUpdate from UpdateStatus")
    }
}

/// Implemented by the autogenerated `DbConnection` type,
/// which is a [`crate::DbContext`] implementor that SDK users construct.
pub trait DbConnection: InModule + Send + 'static
where
    Self::Module: SpacetimeModule<DbConnection = Self>,
{
    /// Called by [`crate::db_connection::DbConnectionBuilder::build`]
    /// to wrap a `DbConnectionImpl` into the codegen-defined type.
    fn new(imp: DbContextImpl<Self::Module>) -> Self;
}

/// Implemented by the autogenerated `EventContext` type,
/// which is a [`crate::DbContext`] implementor automatically passed to many callbacks.
pub trait EventContext: InModule + Send + 'static
where
    Self::Module: SpacetimeModule<EventContext = Self>,
{
    /// Get a reference to the [`Event`] contained in this `EventContext`.
    fn event(&self) -> &Event<<<Self as InModule>::Module as SpacetimeModule>::Reducer>;

    /// Used to construct an `EventContext` which can be passed to callbacks.
    fn new(imp: DbContextImpl<Self::Module>, event: Event<<Self::Module as SpacetimeModule>::Reducer>) -> Self;
}

/// Implemented by the autogenerated `Reducer` enum,
/// which has a variant for each reducer defined by the module.
/// This will be the type parameter to [`Event`] and [`crate::ReducerEvent`].
pub trait Reducer:
    InModule + TryFrom<ws::ReducerCallInfo<ws::BsatnFormat>, Error = anyhow::Error> + std::fmt::Debug + Send + 'static
where
    Self::Module: SpacetimeModule<Reducer = Self>,
{
    /// Get the string name of the reducer variant stored in this instance.
    ///
    /// Used by [`crate::callbacks::ReducerCallbacks::invoke_on_reducer`] to determine which callback to run.
    fn reducer_name(&self) -> &'static str;
}

pub trait SubscriptionHandle: InModule + Clone + Send + 'static
where
    Self::Module: SpacetimeModule<SubscriptionHandle = Self>,
{
    // type EC = <<Self as InModule>::Module as SpacetimeModule>::EventContext;
    // type EventContext = Self::Module::EventContext;
    // type EventContext = <<Self as InModule>::Module as SpacetimeModule>::EventContext;

    fn new(imp: SubscriptionHandleImpl<Self::Module>) -> Self;
    fn is_ended(&self) -> bool;

    fn is_active(&self) -> bool;

    /// Called by the `SubscriptionHandle` method of the same name.
    // TODO: requires the new subscription interface and WS protocol.
    fn unsubscribe_then(
        self,
        // on_end: OnEndedCallback<Self::Module>,
        // on_end: impl FnOnce(&<Self::Module as SpacetimeModule>::EventContext) + Send + 'static,
        on_end: OnEndedCallback<Self::Module>, // on_end: impl OnEndedCallback2<Self::Module>,
                                               // on_end: impl FnOnce(&<Self as InModule>::Module::EventContext) + Send + 'static,
    ) -> anyhow::Result<()>;
}

pub struct WithBsatn<Row> {
    pub bsatn: Bytes,
    pub row: Row,
}

pub struct RowUpdate<Row> {
    pub delete: WithBsatn<Row>,
    pub insert: WithBsatn<Row>,
}

pub struct TableUpdate<Row> {
    pub inserts: Vec<WithBsatn<Row>>,
    pub deletes: Vec<WithBsatn<Row>>,
    pub updates: Vec<RowUpdate<Row>>,
}

impl<Row> Default for TableUpdate<Row> {
    fn default() -> Self {
        Self {
            inserts: Default::default(),
            deletes: Default::default(),
            updates: Default::default(),
        }
    }
}

impl<Row> TableUpdate<Row> {
    pub(crate) fn is_empty(&self) -> bool {
        self.inserts.is_empty() && self.deletes.is_empty() && self.updates.is_empty()
    }
}

impl<Row: DeserializeOwned + Debug> TableUpdate<Row> {
    /// Parse `raw_updates` from the raw websocket table update into a [`TableUpdate`],
    /// merging pairs delete and insert pairs with matching values returned by `get_pk` into updates.
    // TODO: Weaker bound on `Pk`: must admit all SATS types.
    pub fn parse_table_update_with_primary_key<Pk: Eq + Hash + Clone>(
        raw_updates: ws::TableUpdate<ws::BsatnFormat>,
        get_pk: fn(&Row) -> &Pk,
    ) -> anyhow::Result<TableUpdate<Row>> {
        enum DiffEntry<Row> {
            Insert(WithBsatn<Row>),
            Delete(WithBsatn<Row>),
            Update { old: WithBsatn<Row>, new: WithBsatn<Row> },
        }

        fn merge_diff_entries<Row: Debug>(left: DiffEntry<Row>, right: Option<DiffEntry<Row>>) -> DiffEntry<Row> {
            match (left, right) {
                (left, None) => left,
                (_, Some(u @ DiffEntry::Update { .. })) => {
                    log::warn!("Received a third `TableRowOperation` for a row which already has an `Update` within one `TableUpdate`");
                    u
                }
                (DiffEntry::Insert(new), Some(DiffEntry::Delete(old)))
                | (DiffEntry::Delete(old), Some(DiffEntry::Insert(new))) => DiffEntry::Update { old, new },
                (DiffEntry::Insert(left), Some(DiffEntry::Insert(right))) => {
                    log::warn!(
                        "Received duplicate insert operations for a row within one `TableUpdate`: {:?}; {:?}",
                        left.row,
                        right.row,
                    );
                    DiffEntry::Insert(left)
                }
                (DiffEntry::Delete(left), Some(DiffEntry::Delete(right))) => {
                    log::warn!(
                        "Received duplicate delete operations for a row within one `TableUpdate`: {:?}; {:?}",
                        left.row,
                        right.row,
                    );
                    DiffEntry::Delete(left)
                }
                (DiffEntry::Update { .. }, _) => unreachable!(),
            }
        }

        let diff_entry_primary_key = |entry: &DiffEntry<Row>| -> Pk {
            get_pk(match entry {
                DiffEntry::Insert(new) => &new.row,
                DiffEntry::Delete(old) => &old.row,
                DiffEntry::Update { new, .. } => &new.row,
            })
            .clone()
        };

        // Pre-allocate plenty of space to minimize hash collisions.
        let mut diff: HashMap<Pk, DiffEntry<Row>> =
            HashMap::<_, _, DefaultHashBuilder>::with_capacity(raw_updates.num_rows() * 2);

        // Traverse the `table_update` to construct a diff, merging duplicated `Insert`
        // and `Delete` into `Update`.
        let mut traverse_rows =
            |diff_ctor: fn(WithBsatn<Row>) -> DiffEntry<Row>, rows: &ws::BsatnRowList| -> anyhow::Result<()> {
                for raw_row in rows {
                    let row = Self::parse_row(raw_row)?;
                    let diff_entry = diff_ctor(row);
                    let pk = diff_entry_primary_key(&diff_entry);
                    let existing_entry = diff.remove(&pk);
                    let new_entry = merge_diff_entries(diff_entry, existing_entry);
                    diff.insert(pk, new_entry);
                }
                Ok(())
            };

        for update in raw_updates.updates {
            let update = update.maybe_decompress();
            traverse_rows(DiffEntry::Delete, &update.deletes)?;
            traverse_rows(DiffEntry::Insert, &update.inserts)?;
        }

        // Pull the rows out of `diff` and put them into a `TableUpdate`.

        let mut inserts = Vec::new();
        let mut deletes = Vec::new();
        let mut updates = Vec::new();

        for diff_entry in diff.into_values() {
            match diff_entry {
                DiffEntry::Insert(new) => inserts.push(new),
                DiffEntry::Delete(old) => deletes.push(old),
                DiffEntry::Update { old, new } => updates.push(RowUpdate {
                    delete: old,
                    insert: new,
                }),
            }
        }

        Ok(TableUpdate {
            inserts,
            deletes,
            updates,
        })
    }

    /// Parse `raw_updates` into a [`TableUpdate`] whose `updates` will always be empty.
    pub fn parse_table_update_no_primary_key(
        raw_updates: ws::TableUpdate<ws::BsatnFormat>,
    ) -> anyhow::Result<TableUpdate<Row>> {
        let mut inserts = Vec::new();
        let mut deletes = Vec::new();
        for update in raw_updates.updates {
            let update = update.maybe_decompress();
            Self::parse_from_row_list(&mut deletes, &update.deletes)?;
            Self::parse_from_row_list(&mut inserts, &update.inserts)?;
        }
        Ok(Self {
            inserts,
            deletes,
            updates: Vec::new(),
        })
    }

    fn parse_from_row_list(sink: &mut Vec<WithBsatn<Row>>, raw_rows: &ws::BsatnRowList) -> anyhow::Result<()> {
        sink.reserve(raw_rows.len());
        for raw_row in raw_rows {
            sink.push(Self::parse_row(raw_row)?);
        }
        Ok(())
    }

    fn parse_row(bytes: Bytes) -> anyhow::Result<WithBsatn<Row>> {
        let parsed = bsatn::from_slice::<Row>(&bytes).with_context(|| {
            format!(
                "Failed to parse row of type {} from BSATN",
                std::any::type_name::<Row>()
            )
        })?;
        Ok(WithBsatn {
            bsatn: bytes,
            row: parsed,
        })
    }
}

pub fn parse_reducer_args<Args: DeserializeOwned>(reducer_name: &'static str, args: &[u8]) -> anyhow::Result<Args> {
    bsatn::from_slice::<Args>(args).with_context(|| {
        format!(
            "Failed to deserialize {} args for reducer {:?}",
            std::any::type_name::<Args>(),
            reducer_name
        )
    })
}
