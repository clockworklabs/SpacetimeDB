//! Interfaces used by per-module codegen.
//!
//! This module is internal, and may incompatibly change without warning.

use spacetimedb_client_api_messages::websocket::BsatnFormat;

use crate::{
    callbacks::DbCallbacks, client_cache::ClientCache, db_connection::DbContextImpl,
    subscription::SubscriptionHandleImpl, ws_messages as ws, Event,
};
use anyhow::{bail, Context};
use bytes::Bytes;
use spacetimedb_data_structures::map::HashMap;
use spacetimedb_lib::{bsatn, de::DeserializeOwned};
use std::{any::Any, fmt::Debug, hash::Hash};

/// Marker trait for any item defined in a module,
/// to conveniently get the types of various per-module things.
pub trait InModule {
    /// Unit type which represents the module itself.
    type Module: SpacetimeModule;
}

/// Each module's codegen will define a unit struct which implements this trait,
/// with associated type links to various other generated types.
pub trait SpacetimeModule: Send + Sync + 'static {
    /// [`crate::DbContext`] implementor which exists in the global scope.
    type DbConnection: DbConnection<Module = Self>;

    /// [`crate::DbContext`] implementor passed to callbacks.
    type EventContext: EventContext<Module = Self>;

    /// Enum with variants for each reducer's args; will be contained in [`crate::ReducerEvent`].
    type Reducer: Reducer<Module = Self>;

    /// Return type of [`crate::DbContext::db`].
    type DbView: InModule<Module = Self> + Send + 'static;

    /// Return type of [`crate::DbContext::reducers`].
    type Reducers: InModule<Module = Self> + Send + 'static;

    /// Parsed and typed analogue of [`crate::ws::DatabaseUpdate`].
    type DbUpdate: DbUpdate<Module = Self>;

    /// Module-specific `SubscriptionHandle` type, representing an ongoing incremental subscription to a query.
    type SubscriptionHandle: SubscriptionHandle<Module = Self>;
}

/// Implemented by the autogenerated `DbUpdate` type,
/// which is a parsed and typed analogue of [`crate::ws::DatabaseUpdate`].
pub trait DbUpdate: TryFrom<ws::DatabaseUpdate, Error = anyhow::Error> + InModule + Send + 'static
where
    Self::Module: SpacetimeModule<DbUpdate = Self>,
{
    fn apply_to_client_cache(&self, cache: &mut ClientCache<Self::Module>);
    fn invoke_row_callbacks(
        &self,
        event: &<<Self as InModule>::Module as SpacetimeModule>::EventContext,
        callbacks: &mut DbCallbacks<Self::Module>,
    );
}

/// Implemented by the autogenerated `DbConnection` type,
/// which is a [`crate::DbContext`] implementor that SDK users construct.
pub trait DbConnection: InModule + Send + 'static
where
    Self::Module: SpacetimeModule<DbConnection = Self>,
{
    /// Called by [`crate::db_connection::DbConnectionBuilder::build`]
    /// to wrap a `DbConnectionImpl` into the codegen-defined type.
    fn new(imp: DbContextImpl<Self::Module>) -> Self;
}

/// Implemented by the autogenerated `EventContext` type,
/// which is a [`crate::DbContext`] implementor automatically passed to many callbacks.
pub trait EventContext: InModule + Send + 'static
where
    Self::Module: SpacetimeModule<EventContext = Self>,
{
    /// Get a reference to the [`Event`] contained in this `EventContext`.
    fn event(&self) -> &Event<<<Self as InModule>::Module as SpacetimeModule>::Reducer>;

    /// Used to construct an `EventContext` which can be passed to callbacks.
    fn new(imp: DbContextImpl<Self::Module>, event: Event<<Self::Module as SpacetimeModule>::Reducer>) -> Self;
}

/// Implemented by the autogenerated `Reducer` enum,
/// which has a variant for each reducer defined by the module.
/// This will be the type parameter to [`Event`] and [`crate::ReducerEvent`].
pub trait Reducer:
    InModule + TryFrom<ws::ReducerCallInfo, Error = anyhow::Error> + std::fmt::Debug + Send + 'static
where
    Self::Module: SpacetimeModule<Reducer = Self>,
{
    /// Get the string name of the reducer variant stored in this instance.
    ///
    /// Used by [`crate::callbacks::ReducerCallbacks::invoke_on_reducer`] to determine which callback to run.
    fn reducer_name(&self) -> &'static str;
    /// Get a reference to the reducer argument struct for the variant stored in this instance.
    ///
    /// Used by [`crate::callbacks::ReducerCallbacks::invoke_on_reducer`]
    /// to pass the reducer arguments to the callback.
    fn reducer_args(&self) -> &dyn Any;
}

pub trait SubscriptionHandle: InModule + Send + 'static
where
    Self::Module: SpacetimeModule<SubscriptionHandle = Self>,
{
    fn new(imp: SubscriptionHandleImpl<Self::Module>) -> Self;
}

pub struct WithBsatn<Row> {
    pub bsatn: Bytes,
    pub row: Row,
}

pub struct RowUpdate<Row> {
    pub delete: WithBsatn<Row>,
    pub insert: WithBsatn<Row>,
}

pub struct TableUpdate<Row> {
    pub inserts: Vec<WithBsatn<Row>>,
    pub deletes: Vec<WithBsatn<Row>>,
    pub updates: Vec<RowUpdate<Row>>,
}

impl<Row> Default for TableUpdate<Row> {
    fn default() -> Self {
        Self {
            inserts: Default::default(),
            deletes: Default::default(),
            updates: Default::default(),
        }
    }
}

impl<Row> TableUpdate<Row> {
    pub(crate) fn is_empty(&self) -> bool {
        self.inserts.is_empty() && self.deletes.is_empty() && self.updates.is_empty()
    }
}

impl<Row: DeserializeOwned + Debug> TableUpdate<Row> {
    /// Parse `deletes` and `inserts` into a [`TableUpdate`],
    /// merging pairs from `deletes` and `inserts` which have matching values returned by `get_pk` into updates.
    // TODO: Weaker bound on `Pk`: must admit all SATS types.
    pub fn parse_table_update_with_primary_key<Pk: Eq + Hash + Clone>(
        deletes: Vec<ws::EncodedValue>,
        inserts: Vec<ws::EncodedValue>,
        get_pk: fn(&Row) -> &Pk,
    ) -> anyhow::Result<TableUpdate<Row>> {
        enum DiffEntry<Row> {
            Insert(WithBsatn<Row>),
            Delete(WithBsatn<Row>),
            Update { old: WithBsatn<Row>, new: WithBsatn<Row> },
        }

        fn merge_diff_entries<Row: Debug>(left: DiffEntry<Row>, right: Option<DiffEntry<Row>>) -> DiffEntry<Row> {
            match (left, right) {
                (left, None) => left,
                (_, Some(u @ DiffEntry::Update { .. })) => {
                    log::warn!("Received a third `TableRowOperation` for a row which already has an `Update` within one `TableUpdate`");
                    u
                }
                (DiffEntry::Insert(new), Some(DiffEntry::Delete(old)))
                | (DiffEntry::Delete(old), Some(DiffEntry::Insert(new))) => DiffEntry::Update { old, new },
                (DiffEntry::Insert(left), Some(DiffEntry::Insert(right))) => {
                    log::warn!(
                        "Received duplicate insert operations for a row within one `TableUpdate`: {:?}; {:?}",
                        left.row,
                        right.row,
                    );
                    DiffEntry::Insert(left)
                }
                (DiffEntry::Delete(left), Some(DiffEntry::Delete(right))) => {
                    log::warn!(
                        "Received duplicate delete operations for a row within one `TableUpdate`: {:?}; {:?}",
                        left.row,
                        right.row,
                    );
                    DiffEntry::Delete(left)
                }
                (DiffEntry::Update { .. }, _) => unreachable!(),
            }
        }

        let diff_entry_primary_key = |entry: &DiffEntry<Row>| -> Pk {
            get_pk(match entry {
                DiffEntry::Insert(new) => &new.row,
                DiffEntry::Delete(old) => &old.row,
                DiffEntry::Update { new, .. } => &new.row,
            })
            .clone()
        };

        let mut diff: HashMap<Pk, DiffEntry<Row>> = HashMap::with_capacity(
            // Pre-allocate plenty of space to minimize hash collisions.
            (inserts.len() + deletes.len()) * 2,
        );

        // Traverse the `table_update` to construct a diff, merging duplicated `Insert`
        // and `Delete` into `Update`.
        let mut traverse_rows =
            |diff_ctor: fn(WithBsatn<Row>) -> DiffEntry<Row>, rows: Vec<ws::EncodedValue>| -> anyhow::Result<()> {
                for raw_row in rows {
                    let row = Self::parse_row(raw_row)?;
                    let diff_entry = diff_ctor(row);
                    let pk = diff_entry_primary_key(&diff_entry);
                    let existing_entry = diff.remove(&pk);
                    let new_entry = merge_diff_entries(diff_entry, existing_entry);
                    diff.insert(pk, new_entry);
                }
                Ok(())
            };

        traverse_rows(DiffEntry::Delete, deletes)?;
        traverse_rows(DiffEntry::Insert, inserts)?;

        // Pull the rows out of `diff` and put them into a `TableUpdate`.

        let mut inserts = Vec::new();
        let mut deletes = Vec::new();
        let mut updates = Vec::new();

        for diff_entry in diff.into_values() {
            match diff_entry {
                DiffEntry::Insert(new) => inserts.push(new),
                DiffEntry::Delete(old) => deletes.push(old),
                DiffEntry::Update { old, new } => updates.push(RowUpdate {
                    delete: old,
                    insert: new,
                }),
            }
        }

        Ok(TableUpdate {
            inserts,
            deletes,
            updates,
        })
    }

    /// Parse `raw_deletes` and `raw_inserts` into a [`TableUpdate`] whose `updates` will always be empty.
    pub fn parse_table_update_no_primary_key(
        raw_deletes: Vec<ws::EncodedValue>,
        raw_inserts: Vec<ws::EncodedValue>,
    ) -> anyhow::Result<TableUpdate<Row>> {
        Ok(Self {
            inserts: Self::parse_row_vec(raw_inserts)?,
            deletes: Self::parse_row_vec(raw_deletes)?,
            updates: Default::default(),
        })
    }

    fn parse_row_vec(raw_rows: Vec<ws::EncodedValue>) -> anyhow::Result<Vec<WithBsatn<Row>>> {
        raw_rows.into_iter().map(Self::parse_row).collect()
    }

    fn parse_row(raw_row: ws::EncodedValue) -> anyhow::Result<WithBsatn<Row>> {
        let ws::EncodedValue::Binary(bytes) = raw_row else {
            bail!("Don't know how to handle non-BSATN encoded raw row {raw_row:?}");
        };
        let parsed = bsatn::from_slice::<Row>(&bytes).with_context(|| {
            format!(
                "Failed to parse row of type {} from BSATN",
                std::any::type_name::<Row>()
            )
        })?;
        Ok(WithBsatn {
            bsatn: bytes,
            row: parsed,
        })
    }
}

pub fn parse_reducer_args<Args: DeserializeOwned>(
    reducer_name: &'static str,
    args: &ws::EncodedValue,
) -> anyhow::Result<Args> {
    let ws::EncodedValue::Binary(bytes) = args else {
        anyhow::bail!("Don't know how to handle non-BSATN encoded args {args:?} to reducer {reducer_name:?}");
    };
    bsatn::from_slice::<Args>(bytes).with_context(|| {
        format!(
            "Failed to deserialize {} args for reducer {:?}",
            std::any::type_name::<Args>(),
            reducer_name
        )
    })
}
