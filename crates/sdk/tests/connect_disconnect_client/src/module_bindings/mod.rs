// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused_imports)]
use spacetimedb_sdk::callbacks::{DbCallbacks, ReducerCallbacks};
use spacetimedb_sdk::client_cache::{ClientCache, RowCallbackReminders};
use spacetimedb_sdk::global_connection::with_connection_mut;
use spacetimedb_sdk::identity::Credentials;
use spacetimedb_sdk::reducer::AnyReducerEvent;
use spacetimedb_sdk::spacetime_module::SpacetimeModule;
use spacetimedb_sdk::ws_messages::{TableUpdate, TransactionUpdate};
use spacetimedb_sdk::{
    anyhow::{anyhow, Result},
    identity::Identity,
    reducer::{Reducer, ReducerCallbackId, Status},
    sats::{de::Deserialize, ser::Serialize},
    spacetimedb_lib,
    table::{TableIter, TableType, TableWithPrimaryKey},
    websocket::DbCodec,
    Address,
};
use std::sync::Arc;

pub mod connected;
pub mod disconnected;

pub use connected::*;
pub use disconnected::*;

#[allow(unused)]
#[derive(Serialize, Deserialize, Clone, PartialEq, Debug)]
pub enum ReducerEvent {}

#[allow(unused)]
pub struct Module;
impl SpacetimeModule for Module {
    fn handle_table_update(
        &self,
        table_update: TableUpdate,
        client_cache: &mut ClientCache,
        callbacks: &mut RowCallbackReminders,
    ) {
        let table_name = &table_update.table_name[..];
        match table_name {
            "Connected" => {
                client_cache.handle_table_update_no_primary_key::<connected::Connected>(callbacks, table_update)
            }
            "Disconnected" => {
                client_cache.handle_table_update_no_primary_key::<disconnected::Disconnected>(callbacks, table_update)
            }
            _ => spacetimedb_sdk::log::error!("TableRowOperation on unknown table {:?}", table_name),
        }
    }
    fn invoke_row_callbacks(
        &self,
        reminders: &mut RowCallbackReminders,
        worker: &mut DbCallbacks,
        reducer_event: Option<Arc<AnyReducerEvent>>,
        state: &Arc<ClientCache>,
    ) {
        reminders.invoke_callbacks::<connected::Connected>(worker, &reducer_event, state);
        reminders.invoke_callbacks::<disconnected::Disconnected>(worker, &reducer_event, state);
    }
    fn handle_event(
        &self,
        event: TransactionUpdate,
        _reducer_callbacks: &mut ReducerCallbacks,
        _state: Arc<ClientCache>,
    ) -> Option<Arc<AnyReducerEvent>> {
        let reducer_call = &event.reducer_call;
        #[allow(clippy::match_single_binding)]
        match &reducer_call.reducer_name[..] {
            unknown => {
                spacetimedb_sdk::log::error!("Event on an unknown reducer: {:?}", unknown);
                None
            }
        }
    }
    fn handle_resubscribe(
        &self,
        new_subs: TableUpdate,
        client_cache: &mut ClientCache,
        callbacks: &mut RowCallbackReminders,
    ) {
        let table_name = &new_subs.table_name[..];
        match table_name {
            "Connected" => client_cache.handle_resubscribe_for_type::<connected::Connected>(callbacks, new_subs),
            "Disconnected" => {
                client_cache.handle_resubscribe_for_type::<disconnected::Disconnected>(callbacks, new_subs)
            }
            _ => spacetimedb_sdk::log::error!("TableRowOperation on unknown table {:?}", table_name),
        }
    }
}

/// Connect to a database named `db_name` accessible over the internet at the URI `spacetimedb_uri`.
///
/// If `credentials` are supplied, they will be passed to the new connection to
/// identify and authenticate the user. Otherwise, a set of `Credentials` will be
/// generated by the server.
pub fn connect<IntoUri>(
    spacetimedb_uri: IntoUri,
    db_name: &str,
    credentials: Option<Credentials>,
    codec: Option<DbCodec>,
) -> Result<()>
where
    IntoUri: TryInto<spacetimedb_sdk::http::Uri>,
    <IntoUri as TryInto<spacetimedb_sdk::http::Uri>>::Error: std::error::Error + Send + Sync + 'static,
{
    with_connection_mut(|connection| {
        connection.connect(
            spacetimedb_uri,
            db_name,
            credentials,
            Arc::new(Module),
            codec.unwrap_or(DbCodec::Brotli),
        )?;
        Ok(())
    })
}
