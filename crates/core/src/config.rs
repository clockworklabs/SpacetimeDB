use std::path::Path;
use std::{fmt, io};

use spacetimedb_lib::ConnectionId;
use spacetimedb_paths::cli::{ConfigDir, PrivKeyPath, PubKeyPath};
use spacetimedb_paths::server::{ConfigToml, MetadataTomlPath};

/// Parse a TOML file at the given path, returning `None` if the file does not exist.
///
/// **WARNING**: Comments and formatting in the file will be lost.
pub fn parse_config<T: serde::de::DeserializeOwned>(path: &Path) -> anyhow::Result<Option<T>> {
    match std::fs::read_to_string(path) {
        Ok(contents) => Ok(Some(toml::from_str(&contents)?)),
        Err(e) if e.kind() == io::ErrorKind::NotFound => Ok(None),
        Err(e) => Err(e.into()),
    }
}

#[derive(serde::Serialize, serde::Deserialize, Debug)]
pub struct MetadataFile {
    pub version: semver::Version,
    pub edition: String,

    #[serde(skip_serializing_if = "Option::is_none")]
    /// Unused and always `None` in SpacetimeDB-standalone,
    /// but used by SpacetimeDB-cloud.
    pub client_connection_id: Option<ConnectionId>,
}

impl MetadataFile {
    pub fn new(edition: &str) -> Self {
        let mut current_version: semver::Version = env!("CARGO_PKG_VERSION").parse().unwrap();
        // set the patch version of newly-created metadata files to 0 -- v1.0.0
        // set `cmp.patch = Some(file_version.patch)` when checking version
        // compatibility, meaning it won't be forwards-compatible with a
        // database claiming to be created on v1.0.1, even though that should
        // work. This can be changed once we release v1.1.0, since we don't
        // care about its DBs being backwards-compatible with v1.0.0 anyway.
        if let semver::Version { major: 1, minor: 0, .. } = current_version {
            current_version.patch = 0;
        }
        Self {
            version: current_version,
            edition: edition.to_owned(),
            client_connection_id: None,
        }
    }

    pub fn read(path: &MetadataTomlPath) -> anyhow::Result<Option<Self>> {
        parse_config(path.as_ref())
    }

    pub fn write(&self, path: &MetadataTomlPath) -> io::Result<()> {
        path.write(self.to_string())
    }

    fn check_compatibility(previous: &Self, current: &Self) -> anyhow::Result<()> {
        anyhow::ensure!(
            previous.edition == current.edition,
            "metadata.toml indicates that this database is from a different \
            edition of SpacetimeDB (running {:?}, but this database is {:?})",
            current.edition,
            previous.edition,
        );

        if previous.version == current.version {
            return Ok(());
        }

        // Special-case: SpacetimeDB 2.x can run 1.x databases.
        if previous.version.major == 1 && current.version.major == 2 {
            return Ok(());
        }

        let cmp = semver::Comparator {
            op: semver::Op::Caret,
            major: previous.version.major,
            minor: Some(previous.version.minor),
            // Note: We can only do exact matching for pre-releases; there's no partial ordering.
            // Exceptions will essentially have to be created for each pair of pre-release versions
            // that need to be compatible.
            patch: (!previous.version.pre.is_empty()).then_some(previous.version.patch),
            pre: previous.version.pre.clone(),
        };

        if cmp.matches(&current.version) {
            return Ok(());
        }

        let relation = if previous.version > current.version {
            "a newer, incompatible"
        } else if previous.version < current.version {
            "an older, incompatible"
        } else {
            "an incompatible"
        };
        anyhow::bail!(
            "metadata.toml indicates that you are running {relation} database. Your running version is {:?}, but the database on disk is from {:?}.",
            current.version,
            previous.version,
        );
    }

    /// Check if this meta file is compatible with the default meta
    /// file of a just-started database, and if so return the metadata
    /// to write back to the file.
    ///
    /// `self` is the metadata file read from a database, and current is
    /// the default metadata file that the active database version would
    /// right to a new database.
    pub fn check_compatibility_and_update(mut self, current: Self) -> anyhow::Result<Self> {
        Self::check_compatibility(&self, &current)?;
        // bump the version in the file only if it's being run in a newer database.
        self.version = std::cmp::max(self.version, current.version);
        Ok(self)
    }
}

impl fmt::Display for MetadataFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "# THIS FILE IS GENERATED BY SPACETIMEDB, DO NOT MODIFY!")?;
        writeln!(f)?;
        f.write_str(&toml::to_string(self).unwrap())
    }
}

#[derive(serde::Deserialize, Default)]
#[serde(rename_all = "kebab-case")]
pub struct ConfigFile {
    #[serde(default)]
    pub certificate_authority: Option<CertificateAuthority>,
    #[serde(default)]
    pub logs: LogConfig,
}

impl ConfigFile {
    pub fn read(path: &ConfigToml) -> anyhow::Result<Option<Self>> {
        parse_config(path.as_ref())
    }
}

#[derive(serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct CertificateAuthority {
    pub jwt_priv_key_path: PrivKeyPath,
    pub jwt_pub_key_path: PubKeyPath,
}

impl CertificateAuthority {
    pub fn in_cli_config_dir(dir: &ConfigDir) -> Self {
        Self {
            jwt_priv_key_path: dir.jwt_priv_key(),
            jwt_pub_key_path: dir.jwt_pub_key(),
        }
    }

    pub fn get_or_create_keys(&self) -> anyhow::Result<crate::auth::JwtKeys> {
        crate::auth::get_or_create_keys(self)
    }
}

#[serde_with::serde_as]
#[derive(Clone, serde::Deserialize, Default)]
#[serde(rename_all = "kebab-case")]
pub struct LogConfig {
    #[serde_as(as = "Option<serde_with::DisplayFromStr>")]
    pub level: Option<tracing_core::LevelFilter>,
    #[serde(default)]
    pub directives: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    fn mkver(major: u64, minor: u64, patch: u64) -> semver::Version {
        semver::Version::new(major, minor, patch)
    }

    fn mkver_pre(major: u64, minor: u64, patch: u64, pre: &str) -> semver::Version {
        semver::Version {
            major,
            minor,
            patch,
            pre: semver::Prerelease::new(pre).unwrap(),
            build: semver::BuildMetadata::EMPTY,
        }
    }

    fn mkmeta(major: u64, minor: u64, patch: u64) -> MetadataFile {
        MetadataFile {
            version: mkver(major, minor, patch),
            edition: "standalone".to_owned(),
            client_connection_id: None,
        }
    }

    fn mkmeta_pre(major: u64, minor: u64, patch: u64, pre: &str) -> MetadataFile {
        MetadataFile {
            version: mkver_pre(major, minor, patch, pre),
            edition: "standalone".to_owned(),
            client_connection_id: None,
        }
    }

    #[test]
    fn check_metadata_compatibility_checking() {
        assert_eq!(
            mkmeta(1, 0, 0)
                .check_compatibility_and_update(mkmeta(1, 0, 1))
                .unwrap()
                .version,
            mkver(1, 0, 1)
        );
        assert_eq!(
            mkmeta(1, 0, 1)
                .check_compatibility_and_update(mkmeta(1, 0, 0))
                .unwrap()
                .version,
            mkver(1, 0, 1)
        );

        mkmeta(1, 1, 0)
            .check_compatibility_and_update(mkmeta(1, 0, 5))
            .unwrap_err();
        mkmeta(2, 0, 0)
            .check_compatibility_and_update(mkmeta(1, 3, 5))
            .unwrap_err();
        assert_eq!(
            mkmeta(1, 12, 0)
                .check_compatibility_and_update(mkmeta(2, 0, 0))
                .unwrap()
                .version,
            mkver(2, 0, 0)
        );
        mkmeta(2, 0, 0)
            .check_compatibility_and_update(mkmeta(3, 0, 0))
            .unwrap_err();
    }

    #[test]
    fn check_metadata_compatibility_prerelease() {
        mkmeta(1, 9, 0)
            .check_compatibility_and_update(mkmeta_pre(2, 0, 0, "rc1"))
            .unwrap();

        mkmeta_pre(2, 0, 0, "rc1")
            .check_compatibility_and_update(mkmeta_pre(2, 0, 0, "rc1"))
            .unwrap();

        mkmeta_pre(2, 0, 0, "rc1")
            .check_compatibility_and_update(mkmeta(2, 0, 1))
            .unwrap();

        mkmeta_pre(2, 0, 0, "rc1")
            .check_compatibility_and_update(mkmeta(2, 0, 0))
            .unwrap();

        mkmeta_pre(2, 0, 0, "rc1")
            .check_compatibility_and_update(mkmeta_pre(2, 0, 0, "rc2"))
            .unwrap_err();

        mkmeta(2, 0, 0)
            .check_compatibility_and_update(mkmeta_pre(2, 1, 0, "rc1"))
            .unwrap();
    }
}
