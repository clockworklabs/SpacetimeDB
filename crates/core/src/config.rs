use std::path::Path;
use std::{fmt, io};

use toml;
use toml_edit;

use spacetimedb_lib::Address;
use spacetimedb_paths::cli::{ConfigDir, PrivKeyPath, PubKeyPath};
use spacetimedb_paths::server::{ConfigToml, MetadataTomlPath};

pub fn current_version() -> semver::Version {
    env!("CARGO_PKG_VERSION").parse().unwrap()
}

/// Parse a TOML file at the given path, returning `None` if the file does not exist.
///
/// **WARNING**: Comments and formatting in the file will be lost.
pub fn parse_config<T: serde::de::DeserializeOwned>(path: &Path) -> anyhow::Result<Option<T>> {
    match std::fs::read_to_string(path) {
        Ok(contents) => Ok(Some(toml::from_str(&contents)?)),
        Err(e) if e.kind() == io::ErrorKind::NotFound => Ok(None),
        Err(e) => Err(e.into()),
    }
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct MetadataFile {
    pub version: semver::Version,
    pub edition: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub client_address: Option<Address>,
}

impl MetadataFile {
    pub fn read(path: &MetadataTomlPath) -> anyhow::Result<Option<Self>> {
        parse_config(path.as_ref())
    }

    pub fn write(&self, path: &MetadataTomlPath) -> io::Result<()> {
        path.write(self.to_string())
    }

    pub fn version_compatible_with(&self, version: &semver::Version) -> bool {
        semver::Comparator {
            op: semver::Op::Caret,
            major: self.version.major,
            minor: Some(self.version.minor),
            patch: Some(self.version.patch),
            pre: self.version.pre.clone(),
        }
        .matches(version)
    }
}

impl fmt::Display for MetadataFile {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "# THIS FILE IS GENERATED BY SPACETIMEDB, DO NOT MODIFY!")?;
        writeln!(f)?;
        f.write_str(&toml::to_string(self).unwrap())
    }
}

#[derive(serde::Deserialize, Default)]
#[serde(rename_all = "kebab-case")]
pub struct ConfigFile {
    #[serde(default)]
    pub certificate_authority: Option<CertificateAuthority>,
    #[serde(default)]
    pub logs: LogConfig,
}

impl ConfigFile {
    pub fn read(path: &ConfigToml) -> anyhow::Result<Option<Self>> {
        parse_config(path.as_ref())
    }
}

#[derive(serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct CertificateAuthority {
    pub jwt_priv_key_path: PrivKeyPath,
    pub jwt_pub_key_path: PubKeyPath,
}

impl CertificateAuthority {
    pub fn in_cli_config_dir(dir: &ConfigDir) -> Self {
        Self {
            jwt_priv_key_path: dir.jwt_priv_key(),
            jwt_pub_key_path: dir.jwt_pub_key(),
        }
    }

    pub fn get_or_create_keys(&self) -> anyhow::Result<crate::auth::JwtKeys> {
        crate::auth::get_or_create_keys(self)
    }
}

#[serde_with::serde_as]
#[derive(serde::Deserialize, Default)]
#[serde(rename_all = "kebab-case")]
pub struct LogConfig {
    #[serde_as(as = "Option<serde_with::DisplayFromStr>")]
    pub level: Option<tracing_core::LevelFilter>,
    #[serde(default)]
    pub directives: Vec<String>,
}

/// Update the value of a key in a `TOML` document, preserving the formatting and comments of the original value.
///
/// ie:
///
/// ```toml;no_run
/// # Moving key = value to key = new_value
/// old = "value" # Comment
/// new = "new_value" # Comment
/// ```
fn copy_value_with_decor(old_value: Option<&toml_edit::Item>, new_value: &str) -> toml_edit::Item {
    match old_value {
        Some(toml_edit::Item::Value(toml_edit::Value::String(old_value))) => {
            // Creates a new `toml_edit::Value` with the same formatting as the old value.
            let mut new = toml_edit::Value::String(toml_edit::Formatted::new(new_value.to_string()));
            let decor = new.decor_mut();
            // Copy the comments and formatting from the old value.
            *decor = old_value.decor().clone();
            new.into()
        }
        _ => new_value.into(),
    }
}

/// Set the value of a key in a `TOML` document, removing the key if the value is `None`.
///
/// **NOTE**: This function will preserve the formatting and comments of the original value.
pub fn set_opt_value(doc: &mut toml_edit::DocumentMut, key: &str, value: Option<&str>) {
    let old_value = doc.get(key);
    if let Some(new) = value {
        doc[key] = copy_value_with_decor(old_value, new);
    } else {
        doc.remove(key);
    }
}

/// Set the value of a key in a `TOML` table, removing the key if the value is `None`.
///
/// **NOTE**: This function will preserve the formatting and comments of the original value.
pub fn set_table_opt_value(table: &mut toml_edit::Table, key: &str, value: Option<&str>) {
    let old_value = table.get(key);
    if let Some(new) = value {
        table[key] = copy_value_with_decor(old_value, new);
    } else {
        table.remove(key);
    }
}
