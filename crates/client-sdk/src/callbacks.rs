//! `CallbackMap`, a set of callbacks which run asynchronously in response to messages.
//!
//! The SpacetimeDB Rust Client SDK embraces a callback-driven API,
//! where client authors register callbacks to later run in response to some event.
//!
//! Client authors may want to register multiple callbacks on the same event,
//! and then to remove specific callbacks while leaving others,
//! so we define a `CallbackId` type which uniquely identifies a registered callback,
//! and can be used to remove it.
//!
//! Callbacks may access the global `CONNECTION`, individual `TableCache`s,
//! or register or remove other callbacks. This means that the event source,
//! e.g. a `TableCache`, cannot hold its callbacks directly; doing so would require
//! a `Mutex` or `RwLock` and cause deadlocks when the callbacks attempted to re-acquire it.
//! Instead, a `CallbackMap` holds a channel to a background worker,
//! which runs the callbacks without a lock held.

use crate::{
    client_api_messages,
    client_cache::ClientCacheView,
    global_connection::CurrentStateGuard,
    identity::{Credentials, Identity, Token},
    reducer::{Reducer, Status},
    table::TableType,
};
use anymap::{any::Any, Map};
use futures::stream::StreamExt;
use futures_channel::mpsc;
use spacetimedb_sats::bsatn;
use std::{
    collections::HashMap,
    marker::PhantomData,
    sync::atomic::{AtomicUsize, Ordering},
};
use tokio::{runtime, task::JoinHandle};

/// An owned tuple which can be sent to a `CallbackMap` worker,
/// then converted to a borrowed form to be passed to any number of callbacks.
///
/// We handle callbacks by having a background worker (i.e. a Tokio future) maintain a set
/// of callbacks,
/// each of which takes as its sole argument a tuple of borrowed `Copy`-able types.
/// To invoke callbacks, a callee sends a tuple of owned, `'static` types
/// through a queue to the callback worker.
/// The worker then uses `OwnedArgs::borrow` to pass a reference to the arguments to each
/// registered callback.
///
/// To avoid trait coherence gotchas, implementors of `OwnedArgs` will always be a tuple.
/// This leads to the somewhat unforunate type `(T,)`, but is important because otherwise
/// we would write `impl<T: Send + 'static> OwnedArgs for T { type Borrowed<'a> = &'a T; }`,
/// which would prevent any other implementations.
///
/// This trait is exported to allow the export of `TableCallbacks`,
/// which is itself exported to allow autogenerated functions
/// in the `mod.rs` generated for a Spacetime module
/// to reference it.
/// Users should not refer to, depend on, or otherwise interact with this trait.
pub trait OwnedArgs: Send + 'static {
    type Borrowed<'a>: Copy;
    fn borrow(&self) -> Self::Borrowed<'_>;
}

/// A function from one argument, a tuple, which returns no values,
/// used as a callback on some event.
///
/// The `Args` type parameter must be a tuple which implements `OwnedArgs`.
/// The actual function will take `Args::Borrowed`, i.e. a tuple of references to its arguments.
/// A `CallbackMap` will receive `Args` as a tuple, borrow it via `OwnedArgs::borrow`,
/// then pass that tuple of references to all of the `Callback<Args>` that it holds.
pub(crate) type Callback<Args> = dyn for<'a> FnMut(<Args as OwnedArgs>::Borrowed<'a>) + Send + 'static;

/// An identifier for a registered callback of type `Callback<Args>`.
///
/// Registering a callback returns a `CallbackId`,
/// which can later be used to de-register the callback.
///
/// The type `Args` will be an implementor of `OwnedArgs`,
/// refering to the callback's tuple of arguments.
//
// Tagged with type information sufficient to identify the type of the callback in
// question in order to statically detect bugs,
// e.g. where a client registers a callback with `Foo::on_insert`,
// then passes the returned callback id to `Bar::remove_on_reducer`,
// thereby deregistering an unrelated callback.
pub(crate) struct CallbackId<Args> {
    id: usize,

    // Making `Args` invariant here is probably a bit overzealous,
    // since we're referring effectively to a `fn(Args)`,
    // but `Args` must always be `'static`,
    // so subtyping shouldn't come into play at all.
    _phantom: PhantomData<fn(Args) -> Args>,
}

// Putting `PhantomData` in a type pretty thoroughly breaks
// Rust's ability to derive traits for it,
// so we manually implement `Clone`, `Copy`, `PartialEq`, `Eq`, `Hash` and `Debug`.
//
// More specifically, Rust will not derive traits for a type
// unless all of that type's parameters also implement that trait,
// so we have to manually implement e.g. `Hash` for `CallbackId<Args> where Args: !Hash`.

impl<Args> Clone for CallbackId<Args> {
    fn clone(&self) -> Self {
        *self
    }
}

impl<Args> Copy for CallbackId<Args> {}

impl<Args> PartialEq for CallbackId<Args> {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}

impl<Args> Eq for CallbackId<Args> {}

impl<Args> std::hash::Hash for CallbackId<Args> {
    fn hash<H: std::hash::Hasher>(&self, hasher: &mut H) {
        self.id.hash(hasher);
    }
}

// We want to print `CallbackId`s in log messages in response to errors,
// but there isn't a terribly useful way to do that which expresses the `Args` type,
// so we'll just print the integer id.
impl<Args> std::fmt::Debug for CallbackId<Args> {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "CallbackId {{ id: {:?} }}", self.id)
    }
}

// We'll implement `OwnedArgs` only for (generalizations of) the arguments to callbacks
// exposed by the client SDK. These are:
//
// - `(T,)` -> `(&T,)`, for `Reducer::on_reducer`, `TableType::on_insert`,
//                      `TableType::on_delete`, and `on_connect`.
//                      Trait coherence requires that this be `(T,)` (one-element tuple),
//                      and not `T` directly.
// - `(T, T)` -> `(&T, &T)`, for `TableWithPrimaryKey::on_update`.
// - `(Identity, Status, R)` -> `(&Identity, Status, &R)`, for `Reducer::on_reducer`.
//                               Note that `Status` is `Copy`.

impl<T: Send + 'static> OwnedArgs for (T,) {
    type Borrowed<'a> = (&'a T,);
    fn borrow(&self) -> (&T,) {
        (&self.0,)
    }
}

impl<T: Send + 'static> OwnedArgs for (T, T) {
    type Borrowed<'a> = (&'a T, &'a T);
    fn borrow(&self) -> (&T, &T) {
        (&self.0, &self.1)
    }
}

impl<R> OwnedArgs for (Identity, Status, R)
where
    R: Send + 'static,
{
    type Borrowed<'a> = (&'a Identity, Status, &'a R);
    fn borrow(&self) -> (&Identity, Status, &R) {
        (&self.0, self.1, &self.2)
    }
}

/// A message sent by a `CallbackMap` to its background worker to request some action,
/// either adding a new callback, removing a previous callback,
/// or invoking all registered callbacks.
enum CallbackMessage<Args>
where
    // Trait bounds on types are generally undesirable, but this one is necessary
    // because the `Callback<Args>` alias requires `Args: OwnedArgs`
    Args: OwnedArgs,
{
    /// Register `callback` into the map, and identify it by `id`.
    ///
    /// The `id` will be chosen by `CallbackMap::insert` using a monotonically increasing
    /// `AtomicUsize` counter. This guarantees that it will be unique.
    ///
    /// The `id` must be chosen prior to sending the message so that it can be immediately
    /// returned from `insert`.
    /// The actual insertion happens asynchronously in the background.
    Register {
        id: CallbackId<Args>,
        callback: Box<Callback<Args>>,
    },

    /// Remove the callback identified by `id` from the map.
    ///
    /// If `id` does not refer to a currently-registered callback,
    /// either because it has already been removed,
    /// or a caller has violated our encapsulation and fabricated a dangling `CallbackId`,
    /// the background worker will log a warning, but otherwise the remove operation
    /// will silently no-op.
    Remove { id: CallbackId<Args> },

    /// Invoke all currently-registered callbacks with `args` as an argument.
    ///
    /// The worker will use `OwnedArgs::borrow` to convert `args` into a `Copy`-able tuple
    /// suitable for passing to each of the callbacks.
    ///
    /// The `db_state` should be the `ClientCache` state
    /// associated with the event that caused this callback to be invoked.
    /// It will be bound around the callback's invocation with a `CurrentStateGuard`
    /// in order to give callback a consistent view of that state.
    Invoke { args: Args, db_state: ClientCacheView },
}

/// A handle on a background worker which maintains a set of `Callback<Args>` callbacks.
///
/// This type is responsible for generating `CallbackId`s and for message passing.
///
/// Note that `CallbackMap` does not directly contain a map; the map is constructed within
/// `CallbackMap::callback_handler_loop`, which runs asynchronously and handles messages.
pub(crate) struct CallbackMap<Args>
where
    // Trait bounds on types are generally undesirable, but this one is necessary
    // because the `Callback<Args>` alias (through `CallbackMessage`) requires `Args: OwnedArgs`
    Args: OwnedArgs,
{
    /// A counter used to create unique `CallbackId`s.
    ///
    /// Because the range of `usize` is quite large, and `HashMap`s are sparse, we have no
    /// need to ever reclaim old `CallbackId`s. A client would have to run for a very long
    /// time, and register and remove a lot of events, in order to overflow this counter,
    /// even on a 32-bit machine.
    next_id: AtomicUsize,

    /// Channel for communicating with the background worker, for sending requests like,
    /// - Register a new callback.
    /// - Remove a previously-registered callback.
    /// - Invoke all currently-registered callbacks.
    send: mpsc::UnboundedSender<CallbackMessage<Args>>,

    /// The Tokio handle for the handler loop.
    #[allow(unused)]
    handle: JoinHandle<()>,
}

impl<Args: OwnedArgs> CallbackMap<Args> {
    /// Constructs a `HashMap` to store callbacks,
    /// and handles `CallbackMessage`s received via `recv`, which are sent from the `CallbackMap`.
    ///
    /// Upon constructing a `CallbackMap` via `spawn`, it will spawn a future which runs this loop.
    async fn callback_handler_loop(mut recv: mpsc::UnboundedReceiver<CallbackMessage<Args>>) {
        let mut callbacks = HashMap::new();
        while let Some(msg) = recv.next().await {
            match msg {
                CallbackMessage::Register { id, callback } => {
                    if callbacks.insert(id, callback).is_some() {
                        log::error!("Overwriting callback with id {:?}", id);
                    }
                }
                CallbackMessage::Remove { id } => {
                    if callbacks.remove(&id).is_none() {
                        log::warn!("Attempt to remove non-registered callback with id {:?}", id);
                    }
                }
                CallbackMessage::Invoke { args, db_state } => {
                    // Enter a dynamic context where `CURRENT_STATE`
                    // is the state which caused this callback invocation.
                    let _guard = CurrentStateGuard::with_current_state(db_state);

                    // We're invoking several callbacks, so none of them may consume `args`.
                    let borrowed = args.borrow();

                    // The callbacks are `FnMut`, so we need the `values_mut` iterator.
                    for callback in callbacks.values_mut() {
                        callback(borrowed);
                    }
                }
            }
        }
    }

    /// Construct a new `CallbackMap` with a background worker running in `Runtime`.
    ///
    /// This will create an unbounded channel, with the returned `CallbackMap` holding
    /// the sender, and the background handler loop holding the receiver.
    fn spawn(runtime: &runtime::Handle) -> Self {
        let (send, recv) = mpsc::unbounded();
        let handle = runtime.spawn(Self::callback_handler_loop(recv));
        CallbackMap {
            next_id: AtomicUsize::from(0),
            send,
            handle,
        }
    }

    fn fresh_id(&self) -> CallbackId<Args> {
        // `self.next_id` is not used for any additional synchronization;
        // it only needs to be a monotonically-increasing thread-safe counter.
        // So long as data dependencies are preserved, which they always are,
        // both the compiler and the CPU are free to re-order accesses to `next_id`
        // with respect to other memory accesses.
        let id = self.next_id.fetch_add(1, Ordering::Relaxed);
        CallbackId {
            id,
            _phantom: PhantomData,
        }
    }

    /// Register `callback` to be run on future `CallbackMap::invoke` calls.
    ///
    /// The returned `CallbackId` uniquely identifies the registered callback,
    /// and can be passed to `CallbackMap::remove` to un-register it.
    ///
    /// This operation happens asynchronously, and the `CallbackMap` processes events
    /// in FIFO order. That means that `callback` will not be called for any previous
    /// `CallbackMap::invoke`s, even if the worker has not executed those invocations yet;
    /// but `callback` will be called for any future `CallbackMap::invoke`s,
    /// even if the background worker has not fully inserted it yet.
    fn insert(&self, callback: Box<Callback<Args>>) -> CallbackId<Args> {
        let id = self.fresh_id();
        self.send
            .unbounded_send(CallbackMessage::Register { id, callback })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");

        id
    }

    /// Register a `FnOnce` callback to run once on an event.
    ///
    /// `callback` should be a function which accepts a tuple of borrowed args,
    ///            like `Callback<Args>`,
    ///            except that it need only be `FnOnce`, not `FnMut`.
    ///            It will be wrapped in a closure which arranges to call it
    ///            at most once, then unregisters it.
    fn insert_oneshot(&self, callback: impl for<'a> FnOnce(Args::Borrowed<'a>) + Send + 'static) -> CallbackId<Args> {
        // Store the inner callback in an `Option`, and `take` it to invoke it.
        let mut callback = Some(callback);
        let id = self.fresh_id();

        // `wrapper` holds a handle on the `send` end of the message queue
        // so that it can `Remove` itself upon running.
        let unsub_handle = self.send.clone();

        let wrapper = move |args: Args::Borrowed<'_>| {
            // Async-ness means that we can't count on `wrapper` being invoked at most once:
            // a second `Invoke` may be placed in the message queue before `wrapper` has a chance
            // to `Remove` itself.
            // So, check if we've already run the `callback`, and if we have, do nothing.
            if let Some(callback) = callback.take() {
                // `Remove` ourselves as soon as possible,
                // to reduce the odds of a second `Invoke` sneaking into the queue beforehand.
                unsub_handle
                    .unbounded_send(CallbackMessage::Remove { id })
                    // This should never fail; the channel will remain open as long as the
                    // handler loop is running, and the callback will be invoked in the
                    // handler loop.
                    .expect("CallbackMap handler loop panicked, but we are somehow in it?");

                // Actually invoke the inner callback.
                callback(args);
            }
        };

        self.send
            .unbounded_send(CallbackMessage::Register {
                id,
                callback: Box::new(wrapper),
            })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");

        id
    }

    /// Unregister a previously-registered callback identified by `id`.
    ///
    /// This operation happens asynchronously, and the `CallbackMap` processes events
    /// in FIFO order. This means that `callback` will still be called for any previous
    /// `CallbackMap::invoke`s, even if the worker has not executed those invocations yet.
    fn remove(&self, id: CallbackId<Args>) {
        self.send
            .unbounded_send(CallbackMessage::Remove { id })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");
    }

    /// Invoke each currently-registered callback in `self` with `args`.
    fn invoke(&self, args: Args, db_state: ClientCacheView) {
        self.send
            .unbounded_send(CallbackMessage::Invoke { args, db_state })
            // TODO: properly handle this error somehow
            .expect("CallbackMap handler loop panicked");
    }
}

// These `uncurry_N` functions take a function of N arguments
// and convert it into a function which takes an N-tuple.
// APIs which wrap a `CallbackMap` will accept a function of N arguments,
// e.g. a `FnMut(&Identity, Status, &R)` for `R::on_reducer`,
// and "uncurry" it to produce e.g. a `FnMut((&Identity, Status, &R))`
// suitable for use as a `Callback`.

/// Convert a function of one argument into a function of a one-tuple
/// suitable for use as a `Callback`.
///
/// See the documentation of [OwnedArgs] regarding trait coherence
/// for a description of why one-argument callbacks accept one-tuples
/// instead of bare elements.
fn uncurry_1<Arg>(
    mut f: impl for<'a> FnMut(&'a Arg) + Send + 'static,
) -> impl for<'a> FnMut((&'a Arg,)) + Send + 'static {
    move |(arg,)| f(arg)
}

/// Convert a function of two arguments into a function of a 2-tuple
/// suitable for use as a `Callback`.
///
/// This function is intended specifically for `TableWithPrimaryKey::on_update` callbacks,
/// where both arguments are (references to) the `TableWithPrimaryKey` type.
/// A more general `uncurry_2<Arg1, Arg2>` is possible but unnecessary.
fn uncurry_update_callback<Arg>(
    mut f: impl for<'a> FnMut(&'a Arg, &'a Arg) + Send + 'static,
) -> impl for<'a> FnMut((&'a Arg, &'a Arg)) + Send + 'static {
    move |(arg_1, arg_2)| f(arg_1, arg_2)
}

/// Convert a function of 3 arguments into a function of a 3-tuple
/// suitable for use as a `Callback`.
///
/// This function is intended specifically for `Reducer::on_reducer` callbacks.
/// A more general `uncurry_3_copy_middle<Arg1, Arg2: Copy, Arg3>` is possible but unnecessary.
fn uncurry_reducer_callback<R>(
    mut f: impl for<'a> FnMut(&'a Identity, Status, &'a R) + Send + 'static,
) -> impl for<'a> FnMut((&'a Identity, Status, &'a R)) + Send + 'static {
    move |(arg_1, arg_2, arg_3)| f(arg_1, arg_2, arg_3)
}

/// A collection of registered callbacks for `on_insert`, `on_delete` and `on_update` events
/// for a particular table.
///
/// References to this type are autogenerated in the `handle_table_update` and `handle_resubscribe`
/// functions in the `mod.rs` corresponding to a Spacetime module.
/// Users should not reference this type directly.
pub struct TableCallbacks<T>
where
    (T,): OwnedArgs,
    (T, T): OwnedArgs,
{
    /// Callbacks to be invoked upon inserting a new row into the table.
    on_insert: CallbackMap<(T,)>,

    /// Callbacks to be invoked upon removing a row from the table.
    on_delete: CallbackMap<(T,)>,

    /// Callbacks to be invoked upon updating a row which is already resident in the table.
    ///
    /// Update events are only meaningful for tables with a column annotated as `#[primarykey]`.
    /// For tables with primary key columns, a delete followed by an insert
    /// where the altered rows have the same primary key is treated as an update.
    ///
    /// In order to prevent client authors from registering `on_update` callbacks
    /// which can never fire, public interfaces for `on_update` are exposed
    /// through the trait `TableWithPrimaryKey`, which is implemented
    /// only for tables which have a column annotated `#[primarykey]`.
    // TODO: split `on_update` into its own map, to avoid spawning a `CallbackMap`
    //       for tables without primary keys.
    //       In fact, consider splitting all three fields into separate `Map`s in the `DbCallbacks`,
    //       In order to lazily allocate the `CallbackMap`s.
    on_update: CallbackMap<(T, T)>,
}

impl<T> TableCallbacks<T>
where
    T: TableType,
    (T,): for<'a> OwnedArgs<Borrowed<'a> = (&'a T,)>,
    (T, T): for<'a> OwnedArgs<Borrowed<'a> = (&'a T, &'a T)>,
{
    /// Register an `on_insert` callback for when a row is newly inserted into the
    /// database.
    ///
    /// The callback takes one argument, `row: &T`, the newly-inserted row value.
    ///
    /// Each call to `register_on_insert` will return a fresh `CallbackId` which can later
    /// be passed to `unregister_on_insert` to remove the callback.
    // TODO: reduce monomorphization by having this take a `Box<Callback>` instead of an
    //       `impl Callback`.
    pub(crate) fn register_on_insert(&mut self, on_insert: impl FnMut(&T) + Send + 'static) -> CallbackId<(T,)> {
        self.on_insert.insert(Box::new(uncurry_1(on_insert)))
    }

    /// Unregister an on-insert callback with the given `id`.
    pub(crate) fn unregister_on_insert(&mut self, id: CallbackId<(T,)>) {
        self.on_insert.remove(id);
    }

    pub(crate) fn invoke_on_insert(&mut self, inserted: T, db_state: ClientCacheView) {
        self.on_insert.invoke((inserted,), db_state);
    }

    /// Register an `on_delete` callback for when a row is removed from the database.
    ///
    /// The callback takes one argument, `row: &T`, the previously-present row which is no
    /// longer resident in the database.
    ///
    /// Each call to `register_on_delete` will return a fresh `CallbackId` which can later
    /// be passed to `unregister_on_delete` to remove the callback.
    //
    // TODO: reduce monomorphization by having this take a `Box<Callback>` instead of an
    //       `impl Callback`.
    pub(crate) fn register_on_delete(&mut self, on_delete: impl FnMut(&T) + Send + 'static) -> CallbackId<(T,)> {
        self.on_delete.insert(Box::new(uncurry_1(on_delete)))
    }

    /// Unregister an on-delete callback with the given `id`.
    pub(crate) fn unregister_on_delete(&mut self, id: CallbackId<(T,)>) {
        self.on_delete.remove(id);
    }

    pub(crate) fn invoke_on_delete(&mut self, deleted: T, db_state: ClientCacheView) {
        self.on_delete.invoke((deleted,), db_state);
    }

    pub(crate) fn new(runtime: &runtime::Handle) -> TableCallbacks<T> {
        TableCallbacks {
            on_insert: CallbackMap::spawn(runtime),
            on_delete: CallbackMap::spawn(runtime),
            on_update: CallbackMap::spawn(runtime),
        }
    }

    /// Register an `on_update` callback for when an inserted row overwrites an existing
    /// row.
    ///
    /// The callback takes two arguments:
    /// 1. `old: &T`, the previous row value which has been replaced in the database.
    /// 2. `new: &T`, the updated row value which is now resident in the database.
    ///
    /// Each call to `register_on_update` will return a fresh `CallbackId` which can later
    /// be passed to `unregister_on_update` to remove the callback.
    ///
    /// Update callbacks are only meaningful for tables with primary keys.
    /// If `T` is not `TableWithPrimaryKey`, the registered callback will never be invoked.
    //
    // TODO: reduce monomorphization by accepting a `Box<Callback>` instead of an `impl
    //       Callback`.
    pub(crate) fn register_on_update(&mut self, on_update: impl FnMut(&T, &T) + 'static + Send) -> CallbackId<(T, T)> {
        self.on_update.insert(Box::new(uncurry_update_callback(on_update)))
    }

    /// Unregister an on-update callback with the given `id`.
    ///
    /// Update callbacks are only meaningful for tables with primary keys.
    pub(crate) fn unregister_on_update(&mut self, id: CallbackId<(T, T)>) {
        self.on_update.remove(id);
    }

    pub(crate) fn invoke_on_update(&mut self, old: T, new: T, db_state: ClientCacheView) {
        self.on_update.invoke((old, new), db_state);
    }
}

pub struct DbCallbacks {
    /// "keyed" on the type `TableCallbacks<T> where T: TableType`.
    table_callbacks: Map<dyn Any + Send>,

    /// A handle on the Tokio runtime, used to spawn `CallbackMap` workers
    /// for specific reducer types in `ClientCache::find_table`.
    runtime: runtime::Handle,
}

impl DbCallbacks {
    pub(crate) fn find_table<T: TableType>(&mut self) -> &mut TableCallbacks<T> {
        self.table_callbacks
            .entry::<TableCallbacks<T>>()
            .or_insert_with(|| TableCallbacks::new(&self.runtime))
    }

    pub(crate) fn new(runtime: runtime::Handle) -> DbCallbacks {
        DbCallbacks {
            table_callbacks: Map::new(),
            runtime,
        }
    }
}

/// A function autogenerated by the CLI's codegen which dispatches on the `reducer: &str`
/// field of the `Event` to determine the `R: Reducer` type contained in the
/// `Event`.
///
/// Users should not interact with this type directly.
pub type HandleEventFn = fn(client_api_messages::Event, &mut ReducerCallbacks, ClientCacheView);

/// A collection of reducer callbacks.
///
/// References to this struct are autogenerated in the `handle_event`
/// function. Users should not reference this struct directly.
pub struct ReducerCallbacks {
    /// "keyed" on the type `CallbackMap<ReducerCallback<R>> where R: Reducer`.
    callbacks: Map<dyn Any + Send>,

    /// The `handle_event` function autogenerated by the CLI, which dispatches on
    /// reducer name to call `get_callback` and `invoke_callback` with an appropriate type
    /// arg.
    handle_event: HandleEventFn,

    /// A handle on the Tokio runtime, used to spawn `CallbackMap` workers
    /// for specific reducer types in `ReducerCallbacks::find_callbacks`.
    runtime: runtime::Handle,
}

// In order to be resilient against future extensions to the protocol,
// Protobuf/Prost does not deserialize `enum` fields directly into a Rust `enum`.
// Instead, it leaves the message field as an `i32`,
// which we must then compare against the enum variants.
// This helper function does that comparison.

fn parse_status(status: i32) -> Option<Status> {
    if status == client_api_messages::event::Status::Committed as i32 {
        Some(Status::Committed)
    } else if status == client_api_messages::event::Status::Failed as i32 {
        Some(Status::Failed)
    } else if status == client_api_messages::event::Status::OutOfEnergy as i32 {
        Some(Status::OutOfEnergy)
    } else {
        None
    }
}

impl ReducerCallbacks {
    pub(crate) fn new(handle_event: HandleEventFn, runtime: runtime::Handle) -> ReducerCallbacks {
        ReducerCallbacks {
            callbacks: Map::new(),
            handle_event,
            runtime,
        }
    }

    pub(crate) fn find_callbacks<R: Reducer>(&mut self) -> &mut CallbackMap<(Identity, Status, R)> {
        self.callbacks
            .entry::<CallbackMap<(Identity, Status, R)>>()
            .or_insert_with(|| CallbackMap::spawn(&self.runtime))
    }

    /// Parse the reducer arguments, caller identity and status
    /// of the reducer run described by `event`, and invoke any on-reducer callbacks
    /// registered for that reducer.
    ///
    /// Calls to this method are autogenerated in the `handle_event` function, which
    /// handles dispatching on the reducer's name to find the appropriate type `R` to
    /// `handle_event_of_type`. Users should not call this method directly.
    pub fn handle_event_of_type<R: Reducer>(&mut self, event: client_api_messages::Event, state: ClientCacheView) {
        let client_api_messages::Event {
            caller_identity,
            function_call: Some(function_call),
            status,
            ..
        } = event else {
            log::warn!("Received Event with function_call of None");
            return;
        };
        let identity = Identity { bytes: caller_identity };
        let Some(status) = parse_status(status) else {
            log::warn!("Received Event with unknown status {:?}", status);
            return;
        };
        match bsatn::from_slice(&function_call.arg_bytes) {
            Err(e) => log::error!("Error while deserializing reducer args from FunctionCall: {:?}", e),
            Ok(instance) => self.find_callbacks::<R>().invoke((identity, status, instance), state),
        }
    }

    /// Register an on-reducer callback to run whenever we receive an `Event` message
    /// describing a run of this reducer.
    // TODO: reduce monomorphization by accepting `Box<Callback>` instead of `impl Callback`
    pub(crate) fn register_on_reducer<R: Reducer>(
        &mut self,
        callback: impl FnMut(&Identity, Status, &R) + Send + 'static,
    ) -> CallbackId<(Identity, Status, R)> {
        self.find_callbacks::<R>()
            .insert(Box::new(uncurry_reducer_callback(callback)))
    }

    /// Register an on-reducer callback to run at most once
    /// when we receive an `Event` message describing a run of this reducer.
    //
    // Unlike `register_on_reducer`, accepting a `Box` is undesirable here;
    // it would reduce monomorphization, but would also allocate an additional time,
    // since [`CallbackMap::insert_oneshot`] boxes its wrapper callback.
    pub(crate) fn register_on_reducer_oneshot<R: Reducer>(
        &mut self,
        callback: impl FnOnce(&Identity, Status, &R) + Send + 'static,
    ) -> CallbackId<(Identity, Status, R)> {
        self.find_callbacks::<R>()
            .insert_oneshot(move |(identity, status, args)| callback(identity, status, args))
    }

    /// Unregister a previously-registered on-reducer callback identified by `id`.
    pub(crate) fn unregister_on_reducer<R: Reducer>(&mut self, id: CallbackId<(Identity, Status, R)>) {
        self.find_callbacks::<R>().remove(id);
    }

    /// Invoke the autogenerated `handle_event` function
    /// to dispatch on the reducer named by `event`,
    /// and invoke `handle_event_of_type` with an appropriate type arg.
    pub(crate) fn handle_event(&mut self, event: client_api_messages::Event, state: ClientCacheView) {
        (self.handle_event)(event, self, state);
    }
}

/// Holds the client's `Credentials`, if we have them,
/// and manages running on-connect callbacks when `Credentials` become available.
pub(crate) struct CredentialStore {
    /// The client's credentials.
    ///
    /// If credentials are passed to `connect`, they will be stored in the `CredentialStore`,
    /// and later checked against the credentials received from the database.
    ///
    /// If credentials are not passed to `connect`, this field will initially be `None`,
    /// and will be set to `Some` upon receiving a freshly-generated set of credentials
    /// from the database.
    credentials: Option<Credentials>,

    /// Any `on_connect` callbacks to run when credentials become available.
    callbacks: CallbackMap<(Credentials,)>,
}

impl CredentialStore {
    /// Construct a `CredentialStore` for a connection
    /// where `credentials` were passed to `connect`.
    ///
    /// The background worker for on-connect callbacks will be spawned in `runtime`.
    pub(crate) fn maybe_with_credentials(credentials: Option<Credentials>, runtime: &runtime::Handle) -> Self {
        CredentialStore {
            credentials,
            callbacks: CallbackMap::spawn(runtime),
        }
    }

    /// Register an on-connect callback to run when the client's `Credentials` become available.
    // TODO: reduce monomorphization by accepting `Box<Callback>` instead of `impl Callback`
    pub(crate) fn register_on_connect(
        &mut self,
        callback: impl FnMut(&Credentials) + Send + 'static,
    ) -> CallbackId<(Credentials,)> {
        self.callbacks.insert(Box::new(uncurry_1(callback)))
    }

    /// Register an on-connect callback which will run at most once,
    /// then unregister itself.
    pub(crate) fn register_on_connect_oneshot(
        &mut self,
        callback: impl FnOnce(&Credentials) + Send + 'static,
    ) -> CallbackId<(Credentials,)> {
        self.callbacks.insert_oneshot(move |(arg,)| callback(arg))
    }

    /// Unregister a previously-registered on-connect callback identified by `id`.
    pub(crate) fn unregister_on_connect(&mut self, id: CallbackId<(Credentials,)>) {
        self.callbacks.remove(id);
    }

    /// Handle a `client_api_messages::IdentityToken` message received from the database.
    ///
    /// If we connected anonymously, store our new credentials.
    ///
    /// If we connected with existing `Credentials`, compare them to the ones provided by the database,
    /// and log an error if they don't match.
    ///
    /// Either way, invoke any on-connect callbacks with the received credentials.
    pub(crate) fn handle_identity_token(&mut self, msg: client_api_messages::IdentityToken, state: ClientCacheView) {
        let client_api_messages::IdentityToken { identity, token } = msg;
        if identity.is_empty() || token.is_empty() {
            log::warn!("Received IdentityToken message with emtpy identity and/or empty token");
            return;
        }

        let creds = Credentials {
            identity: Identity { bytes: identity },
            token: Token { string: token },
        };

        self.callbacks.invoke((creds.clone(),), state);

        if let Some(existing_creds) = &self.credentials {
            // If we already have credentials, make sure that they match. Log an error if
            // they don't.
            //
            // TODO: Should we panic in this case? If we're wrong about our creds,
            //       something has gone very very wrong.
            if *existing_creds != creds {
                log::error!(
                    "Credentials provided by the server do not match local record. Server: {:?} Local: {:?}",
                    creds,
                    existing_creds,
                );
            }
        } else {
            self.credentials = Some(creds);
        }
    }
}
