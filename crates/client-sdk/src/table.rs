use crate::callbacks::{CallbackId, TableCallbacks};
use crate::client_cache::TableCache;
use crate::global_connection::{try_with_client_cache, try_with_db_callbacks};
use anyhow::{anyhow, Result};
use spacetimedb_sats::{de::DeserializeOwned, ser::Serialize};
use std::any::Any;

/// A unique identifier for an `on_insert` callback registered with a table.
///
/// `TableType::on_insert` returns an `InsertCallbackId`, which can later be passed to
/// `TableType::remove_on_insert` to remove the callback.
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct InsertCallbackId<T> {
    id: CallbackId<(T,)>,
}

/// A unique identifier for an `on_delete` callback registered with a table.
///
/// `TableType::on_delete` returns a `DeleteCallbackId`, which can later be passed to
/// `TableType::remove_on_delete` to remove the callback.
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct DeleteCallbackId<T> {
    id: CallbackId<(T,)>,
}

/// An iterator over all of the rows in `Table`.
// Defined here, rather than in `client_cache`, for documentation generation; that file is
// `#[doc(hidden)]`.
pub struct TableIter<Table> {
    // The specific iterator type here should remain opaque to users, so that we can
    // change the implementation of `TableCache`.
    iter: std::vec::IntoIter<Table>,
}

impl<Table> Iterator for TableIter<Table> {
    type Item = Table;

    fn next(&mut self) -> Option<Table> {
        self.iter.next()
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.iter.size_hint()
    }
}

/// Because `Result::flatten` is unstable as of Rust 1.70.
fn flatten_result<T>(res: Result<Result<T>>) -> Result<T> {
    res.and_then(|x| x)
}

fn try_with_table<T: TableType, Res>(f: impl FnOnce(&TableCache<T>) -> Res) -> Result<Res> {
    flatten_result(try_with_client_cache(|client_cache| {
        client_cache
            .get_table::<T>()
            .map(f)
            .ok_or_else(|| anyhow!("TableCache does not exist"))
    }))
}

fn try_with_callbacks<T: TableType, Res>(f: impl FnOnce(&mut TableCallbacks<T>) -> Res) -> Result<Res> {
    try_with_db_callbacks(|db_callbacks| f(db_callbacks.find_table::<T>()))
}

// Any bound so these can go into an `AnyMap` in the `ClientCache`.
/// A type representing rows in a table in the database.
///
/// Types which implement `TableType` are autogenerated by the SpacetimeDB CLI's
/// `generate` command. Users should not `impl TableType`.
pub trait TableType: DeserializeOwned + Serialize + Any + Send + Sync + Clone + std::fmt::Debug {
    const TABLE_NAME: &'static str;

    // TODO: Should we have COLUMN_ATTRS and INDEXES associated constants, like the
    //       module-side `TableType` does? I'm not sure how they'd be useful
    //       here. Commented out for now.
    // const COLUMN_ATTRS:&'static [ColumnIndexAttribute];
    // const INDEXES:&'static [IndexDef];

    // TODO: Are table ids a reliable part of a module's api, or are they liable to
    //       change?  If the former, we could expose them here, and then use more
    //       efficient integer compares during dispatch rather than string compares, but
    //       obviously if they're liable to change we don't want to embed them. Commented
    //       out for now.

    // This feels like it should be an associated constant, but it's a function in
    // [bindings' `TableType`](../../bindings/src/lib.rs#239), so for consistency it is
    // here too.
    // fn table_id() -> u32;

    /// Return the number of subscribed rows in the table, or 0 if there is no active
    /// connection.
    ///
    /// This method acquires a global lock.
    fn count() -> usize {
        try_with_table::<Self, _>(|table_cache| table_cache.count_subscribed_rows()).unwrap_or(0)
    }

    /// Iterate over all the subscribed rows in the table.
    ///
    /// This method acquires a global lock, but the iterator does not hold it.
    ///
    /// This method must heap-allocate enough memory to hold all of the rows being
    /// iterated over. `TableType::filter` allocates significantly less, so prefer it when
    /// possible.
    fn iter() -> TableIter<Self> {
        TableIter {
            iter: try_with_table::<Self, _>(|table_cache| table_cache.values())
                .unwrap_or_else(|_| Vec::new())
                .into_iter(),
        }
    }

    /// Iterate over the subscribed rows in the table for which `predicate` returns `true`.
    ///
    /// This method acquires a global lock, and the `predicate` runs while the lock is
    /// held. The returned iterator does not hold the lock.
    ///
    /// The `predicate` is called eagerly for each subscribed row in the table, even if
    /// the returned iterator is never consumed.
    ///
    /// This method must heap-allocate enough memory to hold all of the matching rows, but
    /// does not allocate space for subscribed rows which do not match the `predicate`.
    fn filter(predicate: impl FnMut(&Self) -> bool) -> TableIter<Self> {
        TableIter {
            iter: try_with_table::<Self, _>(|table_cache| table_cache.filter(predicate))
                .unwrap_or_else(|_| Vec::new())
                .into_iter(),
        }
    }

    /// Locate a subscribed row for which `predicate` returns `true`, if one exists.
    ///
    /// This method acquires a global lock.
    ///
    /// If multiple subscribed rows match `predicate`, one is chosen arbitrarily. The
    /// choice may not be stable across different calls to `find` with the same
    /// `predicate`.
    fn find(predicate: impl FnMut(&Self) -> bool) -> Option<Self> {
        try_with_table::<Self, _>(|table_cache| table_cache.find(predicate)).unwrap_or(None)
    }

    /// Register an `on_insert` callback for when a row is newly inserted into the
    /// database.
    ///
    /// The callback takes one argument, `row: &T`, the newly-inserted row value.
    ///
    /// The returned `InsertCallbackId` can be passed to `remove_on_insert` to remove the
    /// callback.
    ///
    /// `on_insert` will return an error if called without an active database
    /// connection. In that case, the callback is not registered.
    // TODO: Should it be possible to register callbacks before connecting? This would
    //       require `CONNECTION` to always be a `BackgroundDbConnection` and to hold some
    //       of its internal state in `Option`s.
    fn on_insert(callback: impl FnMut(&Self) + Send + 'static) -> Result<InsertCallbackId<Self>> {
        try_with_callbacks::<Self, _>(|table_cache| table_cache.register_on_insert(callback))
            .map(|id| InsertCallbackId { id })
    }

    /// Unregister a previously-registered `on_insert` callback.
    ///
    /// `remove_on_insert` will return an error if called without an active database
    /// connection.
    ///
    /// If `id` does not refer to a currently-registered callback, this operation does
    /// nothing.
    fn remove_on_insert(id: InsertCallbackId<Self>) -> Result<()> {
        try_with_callbacks::<Self, _>(|table_cache| table_cache.unregister_on_insert(id.id))
    }

    /// Register an `on_delete` callback for when a row is removed from the database.
    ///
    /// The callback takes one argument, `row: &T`, the previously-present row which is no
    /// longer resident in the database.
    ///
    /// The returned `DeleteCallbackId` can be passed to `remove_on_delete` to remove the
    /// callback.
    ///
    /// `on_delete` will return an error if called without an active database
    /// connection. In that case, the callback is not registered.
    fn on_delete(callback: impl FnMut(&Self) + Send + 'static) -> Result<DeleteCallbackId<Self>> {
        try_with_callbacks::<Self, _>(|table_cache| table_cache.register_on_delete(callback))
            .map(|id| DeleteCallbackId { id })
    }

    /// Unregister a previously-registered `on_delete` callback.
    ///
    /// `remove_on_delete` will return an error if called without an active database
    /// connection.
    ///
    /// If `id` does not refer to a currently-registered callback, this operation does
    /// nothing.
    fn remove_on_delete(id: DeleteCallbackId<Self>) -> Result<()> {
        try_with_callbacks::<Self, _>(|table_cache| table_cache.unregister_on_delete(id.id))
    }
}

/// A unique identifier for an `on_update` callback registered with a table.
///
/// `TableWithPrimaryKey::on_update` returns an `UpdateCallbackId`, which can later be passed to
/// `TableWithPrimaryKey::remove_on_update` to remove the callback.
#[derive(Copy, Clone, PartialEq, Eq)]
pub struct UpdateCallbackId<T> {
    id: CallbackId<(T, T)>,
}

/// A `TableType` with a column annotated `#[primarykey]`, allowing `on_update` callbacks.
pub trait TableWithPrimaryKey: TableType {
    type PrimaryKey: std::hash::Hash + Eq + Clone + 'static;

    fn primary_key(&self) -> &Self::PrimaryKey;

    /// Register an `on_update` callback for when an existing row is modified.
    ///
    /// The callback takes two arguments:
    /// 1. `old: &T`, the previous row value which has been replaced in the database.
    /// 2. `new: &T`, the updated row value which is now resident in the database.
    ///
    /// The returned `UpdateCallbackId` can be passed to `remove_on_update` to remove the
    /// callback.
    ///
    /// `on_update` will return an error if called without an active database
    /// connection. In that case, the callback is not registered.
    fn on_update(callback: impl FnMut(&Self, &Self) + Send + 'static) -> Result<UpdateCallbackId<Self>> {
        try_with_callbacks::<Self, _>(|table_cache| table_cache.register_on_update(callback))
            .map(|id| UpdateCallbackId { id })
    }

    /// Unregister a previously-registered `on_update` callback.
    ///
    /// `remove_on_update` will return an error if called without an active database
    /// connection.
    ///
    /// If `id` does not refer to a currently-registered callback, this operation does
    /// nothing.
    fn remove_on_update(id: UpdateCallbackId<Self>) -> Result<()> {
        try_with_callbacks::<Self, _>(|table_cache| table_cache.unregister_on_update(id.id))
    }
}
