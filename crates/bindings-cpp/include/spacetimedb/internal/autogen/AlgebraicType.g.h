// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb codegen.

#pragma once

#include <cstdint>
#include <string>
#include <vector>
#include <optional>
#include <memory>
#include <variant>
#include "spacetimedb/bsatn/bsatn.h"
#include "../forward_declarations.h"

namespace SpacetimeDB::Internal {

// AlgebraicType is special - it uses pointers to break circular dependencies
// This is a custom implementation due to circular references between:
// AlgebraicType -> SumType -> SumTypeVariant -> AlgebraicType
// AlgebraicType -> ProductType -> ProductTypeElement -> AlgebraicType
class AlgebraicType {
public:
    enum class Tag : uint8_t {
        Ref = 0,
        Sum = 1, 
        Product = 2,
        Array = 3,
        String = 4,
        Bool = 5,
        I8 = 6,
        U8 = 7,
        I16 = 8,
        U16 = 9,
        I32 = 10,
        U32 = 11,
        I64 = 12,
        U64 = 13,
        I128 = 14,
        U128 = 15,
        I256 = 16,
        U256 = 17,
        F32 = 18,
        F64 = 19
    };

    using DataType = std::variant<
        uint32_t,                                          // Ref
        std::unique_ptr<SpacetimeDB::Internal::SumType>,   // Sum
        std::unique_ptr<SpacetimeDB::Internal::ProductType>, // Product 
        std::unique_ptr<SpacetimeDB::Internal::AlgebraicType>, // Array element type
        std::monostate  // All primitive types (String, Bool, I8, U8, etc.)
    >;

private:
    Tag tag_;
    DataType data_;

public:
    AlgebraicType();
    AlgebraicType(Tag primitive_tag);
    AlgebraicType(const AlgebraicType& other);
    AlgebraicType& operator=(const AlgebraicType& other);
    
    Tag get_tag() const { return tag_; }
    
    template<size_t Index>
    const auto& get() const { return std::get<Index>(data_); }

    template<size_t Index>
    auto& get() { return std::get<Index>(data_); }

    template<size_t Index, typename T>
    void set(T&& value);

    template<size_t Index>
    bool is() const { return tag_ == static_cast<Tag>(Index); }

    template<typename Visitor>
    auto visit(Visitor&& visitor) const -> decltype(auto) {
        return std::visit(std::forward<Visitor>(visitor), data_);
    }

    template<typename Visitor>  
    auto visit(Visitor&& visitor) -> decltype(auto) {
        return std::visit(std::forward<Visitor>(visitor), data_);
    }

    void bsatn_serialize(::SpacetimeDB::bsatn::Writer& writer) const;

    bool operator==(const AlgebraicType& other) const;
    bool operator!=(const AlgebraicType& other) const { return !(*this == other); }
};

} // namespace SpacetimeDB::Internal
