#pragma once

// Autogenerated Type Support
// This file provides base classes and macros exclusively for the autogenerated
// internal types used in the V9 module definition system.

#include <variant>
#include <cstdint>
#include <tuple>
#include "../bsatn/bsatn.h"

namespace SpacetimeDb::Internal {

// =============================================================================
// TAGGED ENUM BASE CLASS (for autogenerated sum types)
// =============================================================================

template<typename... Variants>
class TaggedEnumBase {
    static_assert(sizeof...(Variants) > 0, "TaggedEnum must have at least one variant");

protected:
    std::variant<Variants...> data_;

public:
    // Default constructor - initializes to first variant
    TaggedEnumBase() : data_{} {}

    // Get current tag (variant index)
    uint8_t get_tag() const noexcept {
        return static_cast<uint8_t>(data_.index());
    }

    // Get variant by index (const)
    template<size_t Index>
    const auto& get() const {
        return std::get<Index>(data_);
    }

    // Get variant by index (mutable)  
    template<size_t Index>
    auto& get() {
        return std::get<Index>(data_);
    }

    // Set variant by index
    template<size_t Index, typename T>
    void set(T&& value) {
        data_.template emplace<Index>(std::forward<T>(value));
    }

    // Check if currently holds specific index
    template<size_t Index>
    bool is() const noexcept {
        return data_.index() == Index;
    }

    // Visit pattern - used for serialization
    template<typename Visitor>
    auto visit(Visitor&& visitor) const {
        return std::visit(std::forward<Visitor>(visitor), data_);
    }

    // Equality
    bool operator==(const TaggedEnumBase& other) const noexcept {
        return data_ == other.data_;
    }

    bool operator!=(const TaggedEnumBase& other) const noexcept {
        return !(*this == other);
    }
};

} // namespace SpacetimeDb::Internal

// =============================================================================
// MACROS FOR AUTOGENERATED INTERNAL TYPES
// =============================================================================

// Macro for internal tagged enums (sum types)
// Generates a class that inherits from TaggedEnumBase and adds BSATN serialization
#define SPACETIMEDB_INTERNAL_TAGGED_ENUM(TypeName, ...) \
    class TypeName : public ::SpacetimeDb::Internal::TaggedEnumBase<__VA_ARGS__> { \
    private: \
        using Base = ::SpacetimeDb::Internal::TaggedEnumBase<__VA_ARGS__>; \
    public: \
        using Base::Base; \
        using Base::get_tag; \
        using Base::get; \
        using Base::set; \
        using Base::is; \
        using Base::visit; \
        using Base::operator==; \
        using Base::operator!=; \
        \
        void bsatn_serialize(::SpacetimeDb::bsatn::Writer& writer) const { \
            /* Write tag (variant index) */ \
            writer.write_u8(this->get_tag()); \
            /* Write variant data based on current tag */ \
            this->visit([&writer](const auto& variant) { \
                using VariantType = std::decay_t<decltype(variant)>; \
                if constexpr (!std::is_same_v<VariantType, std::monostate>) { \
                    /* Non-unit variant - serialize the data */ \
                    ::SpacetimeDb::bsatn::serialize(writer, variant); \
                } \
                /* Unit variant - write nothing */ \
            }); \
        } \
    };

// Macro for internal product types (structs)
// Just creates a simple struct - no base class needed
#define SPACETIMEDB_INTERNAL_PRODUCT_TYPE(TypeName) \
    struct TypeName

// Macro for product type equality - generates == and != operators
// This generates a simple equality comparison using std::tie
#define SPACETIMEDB_PRODUCT_TYPE_EQUALITY(...) \
    bool operator==(const auto& other) const noexcept { \
        return std::tie(__VA_ARGS__) == std::tie(other.__VA_ARGS__); \
    } \
    bool operator!=(const auto& other) const noexcept { \
        return !(*this == other); \
    }