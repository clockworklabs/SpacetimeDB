//HintName: FFI.cs
// <auto-generated />
#nullable enable
// The runtime already defines SpacetimeDB.Internal.LocalReadOnly in Runtime\Internal\Module.cs as an empty partial type.
// This is needed so every module build doesn't generate a full LocalReadOnly type, but just adds on to the existing.
// We extend it here with generated table accessors, and just need to suppress the duplicate-type warning.
#pragma warning disable CS0436
#pragma warning disable STDB_UNSTABLE

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Internal = SpacetimeDB.Internal;
using TxContext = SpacetimeDB.Internal.TxContext;

namespace SpacetimeDB
{
    public sealed record ReducerContext : DbContext<Local>, Internal.IReducerContext
    {
        public readonly Identity Sender;
        public readonly ConnectionId? ConnectionId;
        public readonly Random Rng;
        public readonly Timestamp Timestamp;
        public readonly AuthCtx SenderAuth;

        // **Note:** must be 0..=u32::MAX
        internal int CounterUuid;

        // We need this property to be non-static for parity with client SDK.
        public Identity Identity => Internal.IReducerContext.GetIdentity();

        internal ReducerContext(
            Identity identity,
            ConnectionId? connectionId,
            Random random,
            Timestamp time,
            AuthCtx? senderAuth = null
        )
        {
            Sender = identity;
            ConnectionId = connectionId;
            Rng = random;
            Timestamp = time;
            SenderAuth = senderAuth ?? AuthCtx.BuildFromSystemTables(connectionId, identity);
            CounterUuid = 0;
        }

        /// <summary>
        /// Create a new random <see cref="Uuid"/> `v4` using the built-in RNG.
        /// </summary>
        /// <remarks>
        /// This method fills the random bytes using the context RNG.
        /// </remarks>
        /// <example>
        /// <code>
        /// var uuid = ctx.NewUuidV4();
        /// Log.Info(uuid);
        /// </code>
        /// </example>
        public Uuid NewUuidV4()
        {
            var bytes = new byte[16];
            Rng.NextBytes(bytes);
            return Uuid.FromRandomBytesV4(bytes);
        }

        /// <summary>
        /// Create a new sortable <see cref="Uuid"/> `v7` using the built-in RNG, monotonic counter,
        /// and timestamp.
        /// </summary>
        /// <returns>
        /// A newly generated <see cref="Uuid"/> `v7` that is monotonically ordered
        /// and suitable for use as a primary key or for ordered storage.
        /// </returns>
        /// <exception cref="Exception">
        /// Thrown if <see cref="Uuid"/> generation fails.
        /// </exception>
        /// <example>
        /// <code>
        /// [SpacetimeDB.Reducer]
        /// public static Guid GenerateUuidV7(ReducerContext ctx)
        /// {
        ///     Guid uuid = ctx.NewUuidV7();
        ///     Log.Info(uuid);
        /// }
        /// </code>
        /// </example>
        public Uuid NewUuidV7()
        {
            var bytes = new byte[4];
            Rng.NextBytes(bytes);
            return Uuid.FromCounterV7(ref CounterUuid, Timestamp, bytes);
        }
    }

    public sealed partial class ProcedureContext : global::SpacetimeDB.ProcedureContextBase
    {
        private readonly Local _db = new();

        internal ProcedureContext(
            Identity identity,
            ConnectionId? connectionId,
            Random random,
            Timestamp time
        )
            : base(identity, connectionId, random, time) { }

        protected override global::SpacetimeDB.LocalBase CreateLocal() => _db;

        protected override global::SpacetimeDB.ProcedureTxContextBase CreateTxContext(
            Internal.TxContext inner
        ) => _cached ??= new ProcedureTxContext(inner);

        private ProcedureTxContext? _cached;

        [Experimental("STDB_UNSTABLE")]
        public Local Db => _db;

        [Experimental("STDB_UNSTABLE")]
        public TResult WithTx<TResult>(Func<ProcedureTxContext, TResult> body) =>
            base.WithTx(tx => body((ProcedureTxContext)tx));

        [Experimental("STDB_UNSTABLE")]
        public TxOutcome<TResult> TryWithTx<TResult, TError>(
            Func<ProcedureTxContext, Result<TResult, TError>> body
        )
            where TError : Exception => base.TryWithTx(tx => body((ProcedureTxContext)tx));

        /// <summary>
        /// Create a new random <see cref="Uuid"/> `v4` using the built-in RNG.
        /// </summary>
        /// <remarks>
        /// This method fills the random bytes using the context RNG.
        /// </remarks>
        /// <example>
        /// <code>
        /// var uuid = ctx.NewUuidV4();
        /// Log.Info(uuid);
        /// </code>
        /// </example>
        public Uuid NewUuidV4()
        {
            var bytes = new byte[16];
            Rng.NextBytes(bytes);
            return Uuid.FromRandomBytesV4(bytes);
        }

        /// <summary>
        /// Create a new sortable <see cref="Uuid"/> `v7` using the built-in RNG, monotonic counter,
        /// and timestamp.
        /// </summary>
        /// <returns>
        /// A newly generated <see cref="Uuid"/> `v7` that is monotonically ordered
        /// and suitable for use as a primary key or for ordered storage.
        /// </returns>
        /// <exception cref="Exception">
        /// Thrown if UUID generation fails.
        /// </exception>
        /// <example>
        /// <code>
        /// [SpacetimeDB.Procedure]
        /// public static Guid GenerateUuidV7(ReducerContext ctx)
        /// {
        ///     Guid uuid = ctx.NewUuidV7();
        ///     Log.Info(uuid);
        /// }
        /// </code>
        /// </example>
        public Uuid NewUuidV7()
        {
            var bytes = new byte[4];
            Rng.NextBytes(bytes);
            return Uuid.FromCounterV7(ref CounterUuid, Timestamp, bytes);
        }
    }

    [Experimental("STDB_UNSTABLE")]
    public sealed class ProcedureTxContext : global::SpacetimeDB.ProcedureTxContextBase
    {
        internal ProcedureTxContext(Internal.TxContext inner)
            : base(inner) { }

        public new Local Db => (Local)base.Db;
    }

    public sealed class Local : global::SpacetimeDB.LocalBase
    {
        internal global::SpacetimeDB.Internal.TableHandles.BTreeMultiColumn BTreeMultiColumn =>
            new();
        internal global::SpacetimeDB.Internal.TableHandles.BTreeViews BTreeViews => new();
        public global::SpacetimeDB.Internal.TableHandles.MultiTable1 MultiTable1 => new();
        public global::SpacetimeDB.Internal.TableHandles.MultiTable2 MultiTable2 => new();
        public global::SpacetimeDB.Internal.TableHandles.PrivateTable PrivateTable => new();
        public global::SpacetimeDB.Internal.TableHandles.PublicTable PublicTable => new();
        internal global::SpacetimeDB.Internal.TableHandles.RegressionMultipleUniqueIndexesHadSameName RegressionMultipleUniqueIndexesHadSameName =>
            new();
        public global::SpacetimeDB.Internal.TableHandles.SendMessageTimer SendMessageTimer => new();
    }

    public sealed record ViewContext : DbContext<Internal.LocalReadOnly>, Internal.IViewContext
    {
        public Identity Sender { get; }

        internal ViewContext(Identity sender, Internal.LocalReadOnly db)
            : base(db)
        {
            Sender = sender;
        }
    }

    public sealed record AnonymousViewContext
        : DbContext<Internal.LocalReadOnly>,
            Internal.IAnonymousViewContext
    {
        internal AnonymousViewContext(Internal.LocalReadOnly db)
            : base(db) { }
    }
}

namespace SpacetimeDB.Internal.TableHandles
{
    internal readonly struct BTreeMultiColumn
        : global::SpacetimeDB.Internal.ITableView<BTreeMultiColumn, global::BTreeMultiColumn>
    {
        public static global::BTreeMultiColumn ReadGenFields(
            System.IO.BinaryReader reader,
            global::BTreeMultiColumn row
        )
        {
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(BTreeMultiColumn),
                ProductTypeRef: (uint)
                    new global::BTreeMultiColumn.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "Location",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0, 1, 2])
                    )
                ],
                Constraints: [],
                Sequences: [],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Private
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<
                BTreeMultiColumn,
                global::BTreeMultiColumn
            >.DoCount();

        public IEnumerable<global::BTreeMultiColumn> Iter() =>
            global::SpacetimeDB.Internal.ITableView<
                BTreeMultiColumn,
                global::BTreeMultiColumn
            >.DoIter();

        public global::BTreeMultiColumn Insert(global::BTreeMultiColumn row) =>
            global::SpacetimeDB.Internal.ITableView<
                BTreeMultiColumn,
                global::BTreeMultiColumn
            >.DoInsert(row);

        public bool Delete(global::BTreeMultiColumn row) =>
            global::SpacetimeDB.Internal.ITableView<
                BTreeMultiColumn,
                global::BTreeMultiColumn
            >.DoDelete(row);

        internal sealed class LocationIndex()
            : SpacetimeDB.Internal.IndexBase<global::BTreeMultiColumn>(
                "BTreeMultiColumn_X_Y_Z_idx_btree"
            )
        {
            public IEnumerable<global::BTreeMultiColumn> Filter(uint X) =>
                DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public ulong Delete(uint X) =>
                DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public IEnumerable<global::BTreeMultiColumn> Filter(
                global::SpacetimeDB.Bound<uint> X
            ) =>
                DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public ulong Delete(global::SpacetimeDB.Bound<uint> X) =>
                DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public IEnumerable<global::BTreeMultiColumn> Filter((uint X, uint Y) f) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public ulong Delete((uint X, uint Y) f) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeMultiColumn> Filter(
                (uint X, global::SpacetimeDB.Bound<uint> Y) f
            ) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public ulong Delete((uint X, global::SpacetimeDB.Bound<uint> Y) f) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeMultiColumn> Filter((uint X, uint Y, uint Z) f) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public ulong Delete((uint X, uint Y, uint Z) f) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeMultiColumn> Filter(
                (uint X, uint Y, global::SpacetimeDB.Bound<uint> Z) f
            ) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public ulong Delete((uint X, uint Y, global::SpacetimeDB.Bound<uint> Z) f) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );
        }

        internal LocationIndex Location => new();
    }

    internal readonly struct BTreeViews
        : global::SpacetimeDB.Internal.ITableView<BTreeViews, global::BTreeViews>
    {
        public static global::BTreeViews ReadGenFields(
            System.IO.BinaryReader reader,
            global::BTreeViews row
        )
        {
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(BTreeViews),
                ProductTypeRef: (uint)
                    new global::BTreeViews.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [0],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "Id",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
                    ),
                    new(
                        Name: null,
                        AccessorName: "Location",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([1, 2])
                    ),
                    new(
                        Name: null,
                        AccessorName: "Faction",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([3])
                    )
                ],
                Constraints:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        BTreeViews,
                        global::BTreeViews
                    >.MakeUniqueConstraint(0)
                ],
                Sequences: [],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Private
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<BTreeViews, global::BTreeViews>.DoCount();

        public IEnumerable<global::BTreeViews> Iter() =>
            global::SpacetimeDB.Internal.ITableView<BTreeViews, global::BTreeViews>.DoIter();

        public global::BTreeViews Insert(global::BTreeViews row) =>
            global::SpacetimeDB.Internal.ITableView<BTreeViews, global::BTreeViews>.DoInsert(row);

        public bool Delete(global::BTreeViews row) =>
            global::SpacetimeDB.Internal.ITableView<BTreeViews, global::BTreeViews>.DoDelete(row);

        internal sealed class IdUniqueIndex
            : UniqueIndex<
                BTreeViews,
                global::BTreeViews,
                SpacetimeDB.Identity,
                SpacetimeDB.Identity.BSATN
            >
        {
            internal IdUniqueIndex()
                : base("BTreeViews_Id_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::BTreeViews? Find(SpacetimeDB.Identity key) => FindSingle(key);

            public global::BTreeViews Update(global::BTreeViews row) => DoUpdate(row);
        }

        internal IdUniqueIndex Id => new();

        internal sealed class LocationIndex()
            : SpacetimeDB.Internal.IndexBase<global::BTreeViews>("BTreeViews_X_Y_idx_btree")
        {
            public IEnumerable<global::BTreeViews> Filter(uint X) =>
                DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public ulong Delete(uint X) =>
                DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public IEnumerable<global::BTreeViews> Filter(global::SpacetimeDB.Bound<uint> X) =>
                DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public ulong Delete(global::SpacetimeDB.Bound<uint> X) =>
                DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(X));

            public IEnumerable<global::BTreeViews> Filter((uint X, uint Y) f) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public ulong Delete((uint X, uint Y) f) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeViews> Filter(
                (uint X, global::SpacetimeDB.Bound<uint> Y) f
            ) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public ulong Delete((uint X, global::SpacetimeDB.Bound<uint> Y) f) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );
        }

        internal LocationIndex Location => new();

        internal sealed class FactionIndex()
            : SpacetimeDB.Internal.IndexBase<global::BTreeViews>("BTreeViews_Faction_idx_btree")
        {
            public IEnumerable<global::BTreeViews> Filter(string Faction) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Faction
                    )
                );

            public ulong Delete(string Faction) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Faction
                    )
                );

            public IEnumerable<global::BTreeViews> Filter(
                global::SpacetimeDB.Bound<string> Faction
            ) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Faction
                    )
                );

            public ulong Delete(global::SpacetimeDB.Bound<string> Faction) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Faction
                    )
                );
        }

        internal FactionIndex Faction => new();
    }

    public readonly struct MultiTable1
        : global::SpacetimeDB.Internal.ITableView<MultiTable1, global::MultiTableRow>
    {
        public static global::MultiTableRow ReadGenFields(
            System.IO.BinaryReader reader,
            global::MultiTableRow row
        )
        {
            if (row.Foo == default)
            {
                row.Foo = global::MultiTableRow.BSATN.FooRW.Read(reader);
            }
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(MultiTable1),
                ProductTypeRef: (uint)
                    new global::MultiTableRow.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [1],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "Foo",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([1])
                    ),
                    new(
                        Name: null,
                        AccessorName: "Name",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
                    )
                ],
                Constraints:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        MultiTable1,
                        global::MultiTableRow
                    >.MakeUniqueConstraint(1)
                ],
                Sequences:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        MultiTable1,
                        global::MultiTableRow
                    >.MakeSequence(1)
                ],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Public
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<MultiTable1, global::MultiTableRow>.DoCount();

        public IEnumerable<global::MultiTableRow> Iter() =>
            global::SpacetimeDB.Internal.ITableView<MultiTable1, global::MultiTableRow>.DoIter();

        public global::MultiTableRow Insert(global::MultiTableRow row) =>
            global::SpacetimeDB.Internal.ITableView<MultiTable1, global::MultiTableRow>.DoInsert(
                row
            );

        public bool Delete(global::MultiTableRow row) =>
            global::SpacetimeDB.Internal.ITableView<MultiTable1, global::MultiTableRow>.DoDelete(
                row
            );

        public sealed class FooUniqueIndex
            : UniqueIndex<MultiTable1, global::MultiTableRow, uint, SpacetimeDB.BSATN.U32>
        {
            internal FooUniqueIndex()
                : base("MultiTable1_Foo_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::MultiTableRow? Find(uint key) => FindSingle(key);

            public global::MultiTableRow Update(global::MultiTableRow row) => DoUpdate(row);
        }

        public FooUniqueIndex Foo => new();

        public sealed class NameIndex()
            : SpacetimeDB.Internal.IndexBase<global::MultiTableRow>("MultiTable1_Name_idx_btree")
        {
            public IEnumerable<global::MultiTableRow> Filter(string Name) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Name
                    )
                );

            public ulong Delete(string Name) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Name
                    )
                );

            public IEnumerable<global::MultiTableRow> Filter(
                global::SpacetimeDB.Bound<string> Name
            ) =>
                DoFilter(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Name
                    )
                );

            public ulong Delete(global::SpacetimeDB.Bound<string> Name) =>
                DoDelete(
                    new SpacetimeDB.Internal.BTreeIndexBounds<string, SpacetimeDB.BSATN.String>(
                        Name
                    )
                );
        }

        public NameIndex Name => new();
    }

    public readonly struct MultiTable2
        : global::SpacetimeDB.Internal.ITableView<MultiTable2, global::MultiTableRow>
    {
        public static global::MultiTableRow ReadGenFields(
            System.IO.BinaryReader reader,
            global::MultiTableRow row
        )
        {
            if (row.Foo == default)
            {
                row.Foo = global::MultiTableRow.BSATN.FooRW.Read(reader);
            }
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(MultiTable2),
                ProductTypeRef: (uint)
                    new global::MultiTableRow.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "Bar",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([2])
                    )
                ],
                Constraints:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        MultiTable2,
                        global::MultiTableRow
                    >.MakeUniqueConstraint(2)
                ],
                Sequences:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        MultiTable2,
                        global::MultiTableRow
                    >.MakeSequence(1)
                ],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Private
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<MultiTable2, global::MultiTableRow>.DoCount();

        public IEnumerable<global::MultiTableRow> Iter() =>
            global::SpacetimeDB.Internal.ITableView<MultiTable2, global::MultiTableRow>.DoIter();

        public global::MultiTableRow Insert(global::MultiTableRow row) =>
            global::SpacetimeDB.Internal.ITableView<MultiTable2, global::MultiTableRow>.DoInsert(
                row
            );

        public bool Delete(global::MultiTableRow row) =>
            global::SpacetimeDB.Internal.ITableView<MultiTable2, global::MultiTableRow>.DoDelete(
                row
            );

        public sealed class BarUniqueIndex
            : UniqueIndex<MultiTable2, global::MultiTableRow, uint, SpacetimeDB.BSATN.U32>
        {
            internal BarUniqueIndex()
                : base("MultiTable2_Bar_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::MultiTableRow? Find(uint key) => FindSingle(key);

            public global::MultiTableRow Update(global::MultiTableRow row) => DoUpdate(row);
        }

        public BarUniqueIndex Bar => new();
    }

    public readonly struct PrivateTable
        : global::SpacetimeDB.Internal.ITableView<PrivateTable, global::PrivateTable>
    {
        public static global::PrivateTable ReadGenFields(
            System.IO.BinaryReader reader,
            global::PrivateTable row
        )
        {
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(PrivateTable),
                ProductTypeRef: (uint)
                    new global::PrivateTable.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [],
                Indexes: [],
                Constraints: [],
                Sequences: [],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Private
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<PrivateTable, global::PrivateTable>.DoCount();

        public IEnumerable<global::PrivateTable> Iter() =>
            global::SpacetimeDB.Internal.ITableView<PrivateTable, global::PrivateTable>.DoIter();

        public global::PrivateTable Insert(global::PrivateTable row) =>
            global::SpacetimeDB.Internal.ITableView<PrivateTable, global::PrivateTable>.DoInsert(
                row
            );

        public bool Delete(global::PrivateTable row) =>
            global::SpacetimeDB.Internal.ITableView<PrivateTable, global::PrivateTable>.DoDelete(
                row
            );
    }

    public readonly struct PublicTable
        : global::SpacetimeDB.Internal.ITableView<PublicTable, global::PublicTable>
    {
        public static global::PublicTable ReadGenFields(
            System.IO.BinaryReader reader,
            global::PublicTable row
        )
        {
            if (row.Id == default)
            {
                row.Id = global::PublicTable.BSATN.IdRW.Read(reader);
            }
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(PublicTable),
                ProductTypeRef: (uint)
                    new global::PublicTable.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [0],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "Id",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
                    )
                ],
                Constraints:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        PublicTable,
                        global::PublicTable
                    >.MakeUniqueConstraint(0)
                ],
                Sequences:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        PublicTable,
                        global::PublicTable
                    >.MakeSequence(0)
                ],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Public
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<PublicTable, global::PublicTable>.DoCount();

        public IEnumerable<global::PublicTable> Iter() =>
            global::SpacetimeDB.Internal.ITableView<PublicTable, global::PublicTable>.DoIter();

        public global::PublicTable Insert(global::PublicTable row) =>
            global::SpacetimeDB.Internal.ITableView<PublicTable, global::PublicTable>.DoInsert(row);

        public bool Delete(global::PublicTable row) =>
            global::SpacetimeDB.Internal.ITableView<PublicTable, global::PublicTable>.DoDelete(row);

        public sealed class IdUniqueIndex
            : UniqueIndex<PublicTable, global::PublicTable, int, SpacetimeDB.BSATN.I32>
        {
            internal IdUniqueIndex()
                : base("PublicTable_Id_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::PublicTable? Find(int key) => FindSingle(key);

            public global::PublicTable Update(global::PublicTable row) => DoUpdate(row);
        }

        public IdUniqueIndex Id => new();
    }

    internal readonly struct RegressionMultipleUniqueIndexesHadSameName
        : global::SpacetimeDB.Internal.ITableView<
            RegressionMultipleUniqueIndexesHadSameName,
            global::RegressionMultipleUniqueIndexesHadSameName
        >
    {
        public static global::RegressionMultipleUniqueIndexesHadSameName ReadGenFields(
            System.IO.BinaryReader reader,
            global::RegressionMultipleUniqueIndexesHadSameName row
        )
        {
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(RegressionMultipleUniqueIndexesHadSameName),
                ProductTypeRef: (uint)
                    new global::RegressionMultipleUniqueIndexesHadSameName.BSATN()
                        .GetAlgebraicType(registrar)
                        .Ref_,
                PrimaryKey: [],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "Unique1",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
                    ),
                    new(
                        Name: null,
                        AccessorName: "Unique2",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([1])
                    )
                ],
                Constraints:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        RegressionMultipleUniqueIndexesHadSameName,
                        global::RegressionMultipleUniqueIndexesHadSameName
                    >.MakeUniqueConstraint(0),
                    global::SpacetimeDB.Internal.ITableView<
                        RegressionMultipleUniqueIndexesHadSameName,
                        global::RegressionMultipleUniqueIndexesHadSameName
                    >.MakeUniqueConstraint(1)
                ],
                Sequences: [],
                Schedule: null,
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Private
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<
                RegressionMultipleUniqueIndexesHadSameName,
                global::RegressionMultipleUniqueIndexesHadSameName
            >.DoCount();

        public IEnumerable<global::RegressionMultipleUniqueIndexesHadSameName> Iter() =>
            global::SpacetimeDB.Internal.ITableView<
                RegressionMultipleUniqueIndexesHadSameName,
                global::RegressionMultipleUniqueIndexesHadSameName
            >.DoIter();

        public global::RegressionMultipleUniqueIndexesHadSameName Insert(
            global::RegressionMultipleUniqueIndexesHadSameName row
        ) =>
            global::SpacetimeDB.Internal.ITableView<
                RegressionMultipleUniqueIndexesHadSameName,
                global::RegressionMultipleUniqueIndexesHadSameName
            >.DoInsert(row);

        public bool Delete(global::RegressionMultipleUniqueIndexesHadSameName row) =>
            global::SpacetimeDB.Internal.ITableView<
                RegressionMultipleUniqueIndexesHadSameName,
                global::RegressionMultipleUniqueIndexesHadSameName
            >.DoDelete(row);

        internal sealed class Unique1UniqueIndex
            : UniqueIndex<
                RegressionMultipleUniqueIndexesHadSameName,
                global::RegressionMultipleUniqueIndexesHadSameName,
                uint,
                SpacetimeDB.BSATN.U32
            >
        {
            internal Unique1UniqueIndex()
                : base("RegressionMultipleUniqueIndexesHadSameName_Unique1_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::RegressionMultipleUniqueIndexesHadSameName? Find(uint key) =>
                FindSingle(key);

            public global::RegressionMultipleUniqueIndexesHadSameName Update(
                global::RegressionMultipleUniqueIndexesHadSameName row
            ) => DoUpdate(row);
        }

        internal Unique1UniqueIndex Unique1 => new();

        internal sealed class Unique2UniqueIndex
            : UniqueIndex<
                RegressionMultipleUniqueIndexesHadSameName,
                global::RegressionMultipleUniqueIndexesHadSameName,
                uint,
                SpacetimeDB.BSATN.U32
            >
        {
            internal Unique2UniqueIndex()
                : base("RegressionMultipleUniqueIndexesHadSameName_Unique2_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::RegressionMultipleUniqueIndexesHadSameName? Find(uint key) =>
                FindSingle(key);

            public global::RegressionMultipleUniqueIndexesHadSameName Update(
                global::RegressionMultipleUniqueIndexesHadSameName row
            ) => DoUpdate(row);
        }

        internal Unique2UniqueIndex Unique2 => new();
    }

    public readonly struct SendMessageTimer
        : global::SpacetimeDB.Internal.ITableView<SendMessageTimer, global::Timers.SendMessageTimer>
    {
        public static global::Timers.SendMessageTimer ReadGenFields(
            System.IO.BinaryReader reader,
            global::Timers.SendMessageTimer row
        )
        {
            if (row.ScheduledId == default)
            {
                row.ScheduledId = global::Timers.SendMessageTimer.BSATN.ScheduledIdRW.Read(reader);
            }
            return row;
        }

        public static SpacetimeDB.Internal.RawTableDefV9 MakeTableDesc(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                Name: nameof(SendMessageTimer),
                ProductTypeRef: (uint)
                    new global::Timers.SendMessageTimer.BSATN().GetAlgebraicType(registrar).Ref_,
                PrimaryKey: [0],
                Indexes:
                [
                    new(
                        Name: null,
                        AccessorName: "ScheduledId",
                        Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
                    )
                ],
                Constraints:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        SendMessageTimer,
                        global::Timers.SendMessageTimer
                    >.MakeUniqueConstraint(0)
                ],
                Sequences:
                [
                    global::SpacetimeDB.Internal.ITableView<
                        SendMessageTimer,
                        global::Timers.SendMessageTimer
                    >.MakeSequence(0)
                ],
                Schedule: global::SpacetimeDB.Internal.ITableView<
                    SendMessageTimer,
                    global::Timers.SendMessageTimer
                >.MakeSchedule("SendScheduledMessage", 1),
                TableType: SpacetimeDB.Internal.TableType.User,
                TableAccess: SpacetimeDB.Internal.TableAccess.Private
            );

        public ulong Count =>
            global::SpacetimeDB.Internal.ITableView<
                SendMessageTimer,
                global::Timers.SendMessageTimer
            >.DoCount();

        public IEnumerable<global::Timers.SendMessageTimer> Iter() =>
            global::SpacetimeDB.Internal.ITableView<
                SendMessageTimer,
                global::Timers.SendMessageTimer
            >.DoIter();

        public global::Timers.SendMessageTimer Insert(global::Timers.SendMessageTimer row) =>
            global::SpacetimeDB.Internal.ITableView<
                SendMessageTimer,
                global::Timers.SendMessageTimer
            >.DoInsert(row);

        public bool Delete(global::Timers.SendMessageTimer row) =>
            global::SpacetimeDB.Internal.ITableView<
                SendMessageTimer,
                global::Timers.SendMessageTimer
            >.DoDelete(row);

        public sealed class ScheduledIdUniqueIndex
            : UniqueIndex<
                SendMessageTimer,
                global::Timers.SendMessageTimer,
                ulong,
                SpacetimeDB.BSATN.U64
            >
        {
            internal ScheduledIdUniqueIndex()
                : base("SendMessageTimer_ScheduledId_idx_btree") { }

            // Important: don't move this to the base class.
            // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
            // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
            public global::Timers.SendMessageTimer? Find(ulong key) => FindSingle(key);

            public global::Timers.SendMessageTimer Update(global::Timers.SendMessageTimer row) =>
                DoUpdate(row);
        }

        public ScheduledIdUniqueIndex ScheduledId => new();
    }
}

sealed class public_table_viewViewDispatcher : global::SpacetimeDB.Internal.IView
{
    public SpacetimeDB.Internal.RawViewDefV9 MakeViewDef(
        SpacetimeDB.BSATN.ITypeRegistrar registrar
    ) =>
        new global::SpacetimeDB.Internal.RawViewDefV9(
            Name: "public_table_view",
            Index: 0,
            IsPublic: true,
            IsAnonymous: false,
            Params: [],
            ReturnType: new SpacetimeDB.BSATN.ValueOption<
                PublicTable,
                PublicTable.BSATN
            >().GetAlgebraicType(registrar)
        );

    public byte[] Invoke(
        System.IO.BinaryReader reader,
        global::SpacetimeDB.Internal.IViewContext ctx
    )
    {
        try
        {
            var returnValue = Module.PublicTableByIdentity((SpacetimeDB.ViewContext)ctx);
            var listSerializer = SpacetimeDB.BSATN.ValueOption<
                PublicTable,
                PublicTable.BSATN
            >.GetListSerializer();
            var listValue = ModuleRegistration.ToListOrEmpty(returnValue);
            using var output = new System.IO.MemoryStream();
            using var writer = new System.IO.BinaryWriter(output);
            listSerializer.Write(writer, listValue);
            return output.ToArray();
        }
        catch (System.Exception e)
        {
            global::SpacetimeDB.Log.Error("Error in view 'public_table_view': " + e);
            throw;
        }
    }
}

sealed class find_public_table__by_identityViewDispatcher
    : global::SpacetimeDB.Internal.IAnonymousView
{
    public SpacetimeDB.Internal.RawViewDefV9 MakeAnonymousViewDef(
        SpacetimeDB.BSATN.ITypeRegistrar registrar
    ) =>
        new global::SpacetimeDB.Internal.RawViewDefV9(
            Name: "find_public_table__by_identity",
            Index: 0,
            IsPublic: true,
            IsAnonymous: true,
            Params: [],
            ReturnType: new SpacetimeDB.BSATN.ValueOption<
                PublicTable,
                PublicTable.BSATN
            >().GetAlgebraicType(registrar)
        );

    public byte[] Invoke(
        System.IO.BinaryReader reader,
        global::SpacetimeDB.Internal.IAnonymousViewContext ctx
    )
    {
        try
        {
            var returnValue = Module.FindPublicTableByIdentity(
                (SpacetimeDB.AnonymousViewContext)ctx
            );
            var listSerializer = SpacetimeDB.BSATN.ValueOption<
                PublicTable,
                PublicTable.BSATN
            >.GetListSerializer();
            var listValue = ModuleRegistration.ToListOrEmpty(returnValue);
            using var output = new System.IO.MemoryStream();
            using var writer = new System.IO.BinaryWriter(output);
            listSerializer.Write(writer, listValue);
            return output.ToArray();
        }
        catch (System.Exception e)
        {
            global::SpacetimeDB.Log.Error("Error in view 'find_public_table__by_identity': " + e);
            throw;
        }
    }
}

namespace SpacetimeDB.Internal.ViewHandles
{
    internal sealed class BTreeMultiColumnReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::BTreeMultiColumn>
    {
        internal BTreeMultiColumnReadOnly()
            : base("BTreeMultiColumn") { }

        public ulong Count => DoCount();

        public sealed class LocationIndex
            : global::SpacetimeDB.Internal.ReadOnlyIndexBase<global::BTreeMultiColumn>
        {
            internal LocationIndex()
                : base("BTreeMultiColumn_X_Y_Z_idx_btree") { }

            public IEnumerable<global::BTreeMultiColumn> Filter(uint X) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(
                        X
                    )
                );

            public IEnumerable<global::BTreeMultiColumn> Filter(
                global::SpacetimeDB.Bound<uint> X
            ) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(
                        X
                    )
                );

            public IEnumerable<global::BTreeMultiColumn> Filter((uint X, uint Y) f) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeMultiColumn> Filter(
                (uint X, global::SpacetimeDB.Bound<uint> Y) f
            ) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeMultiColumn> Filter((uint X, uint Y, uint Z) f) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeMultiColumn> Filter(
                (uint X, uint Y, global::SpacetimeDB.Bound<uint> Z) f
            ) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );
        }

        internal LocationIndex Location => new();
    }

    internal sealed class BTreeViewsReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::BTreeViews>
    {
        internal BTreeViewsReadOnly()
            : base("BTreeViews") { }

        public ulong Count => DoCount();

        public sealed class IdIndex
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.BTreeViewsReadOnly,
                global::BTreeViews,
                SpacetimeDB.Identity,
                SpacetimeDB.Identity.BSATN
            >
        {
            internal IdIndex()
                : base("BTreeViews_Id_idx_btree") { }

            public global::BTreeViews? Find(SpacetimeDB.Identity key) => FindSingle(key);
        }

        public IdIndex Id => new();

        public sealed class LocationIndex
            : global::SpacetimeDB.Internal.ReadOnlyIndexBase<global::BTreeViews>
        {
            internal LocationIndex()
                : base("BTreeViews_X_Y_idx_btree") { }

            public IEnumerable<global::BTreeViews> Filter(uint X) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(
                        X
                    )
                );

            public IEnumerable<global::BTreeViews> Filter(global::SpacetimeDB.Bound<uint> X) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(
                        X
                    )
                );

            public IEnumerable<global::BTreeViews> Filter((uint X, uint Y) f) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );

            public IEnumerable<global::BTreeViews> Filter(
                (uint X, global::SpacetimeDB.Bound<uint> Y) f
            ) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        uint,
                        SpacetimeDB.BSATN.U32,
                        uint,
                        SpacetimeDB.BSATN.U32
                    >(f)
                );
        }

        internal LocationIndex Location => new();

        public sealed class FactionIndex
            : global::SpacetimeDB.Internal.ReadOnlyIndexBase<global::BTreeViews>
        {
            internal FactionIndex()
                : base("BTreeViews_Faction_idx_btree") { }

            public IEnumerable<global::BTreeViews> Filter(string Faction) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        string,
                        SpacetimeDB.BSATN.String
                    >(Faction)
                );

            public IEnumerable<global::BTreeViews> Filter(
                global::SpacetimeDB.Bound<string> Faction
            ) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        string,
                        SpacetimeDB.BSATN.String
                    >(Faction)
                );
        }

        internal FactionIndex Faction => new();
    }

    public sealed class MultiTable1ReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::MultiTableRow>
    {
        internal MultiTable1ReadOnly()
            : base("MultiTable1") { }

        public ulong Count => DoCount();

        public sealed class FooIndex
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.MultiTable1ReadOnly,
                global::MultiTableRow,
                uint,
                SpacetimeDB.BSATN.U32
            >
        {
            internal FooIndex()
                : base("MultiTable1_Foo_idx_btree") { }

            public global::MultiTableRow? Find(uint key) => FindSingle(key);
        }

        public FooIndex Foo => new();

        public sealed class NameIndex
            : global::SpacetimeDB.Internal.ReadOnlyIndexBase<global::MultiTableRow>
        {
            internal NameIndex()
                : base("MultiTable1_Name_idx_btree") { }

            public IEnumerable<global::MultiTableRow> Filter(string Name) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        string,
                        SpacetimeDB.BSATN.String
                    >(Name)
                );

            public IEnumerable<global::MultiTableRow> Filter(
                global::SpacetimeDB.Bound<string> Name
            ) =>
                DoFilter(
                    new global::SpacetimeDB.Internal.BTreeIndexBounds<
                        string,
                        SpacetimeDB.BSATN.String
                    >(Name)
                );
        }

        public NameIndex Name => new();
    }

    public sealed class MultiTable2ReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::MultiTableRow>
    {
        internal MultiTable2ReadOnly()
            : base("MultiTable2") { }

        public ulong Count => DoCount();

        public sealed class BarIndex
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.MultiTable2ReadOnly,
                global::MultiTableRow,
                uint,
                SpacetimeDB.BSATN.U32
            >
        {
            internal BarIndex()
                : base("MultiTable2_Bar_idx_btree") { }

            public global::MultiTableRow? Find(uint key) => FindSingle(key);
        }

        public BarIndex Bar => new();
    }

    public sealed class PrivateTableReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::PrivateTable>
    {
        internal PrivateTableReadOnly()
            : base("PrivateTable") { }

        public ulong Count => DoCount();
    }

    public sealed class PublicTableReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::PublicTable>
    {
        internal PublicTableReadOnly()
            : base("PublicTable") { }

        public ulong Count => DoCount();

        public sealed class IdIndex
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.PublicTableReadOnly,
                global::PublicTable,
                int,
                SpacetimeDB.BSATN.I32
            >
        {
            internal IdIndex()
                : base("PublicTable_Id_idx_btree") { }

            public global::PublicTable? Find(int key) => FindSingle(key);
        }

        public IdIndex Id => new();
    }

    internal sealed class RegressionMultipleUniqueIndexesHadSameNameReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::RegressionMultipleUniqueIndexesHadSameName>
    {
        internal RegressionMultipleUniqueIndexesHadSameNameReadOnly()
            : base("RegressionMultipleUniqueIndexesHadSameName") { }

        public ulong Count => DoCount();

        public sealed class Unique1Index
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.RegressionMultipleUniqueIndexesHadSameNameReadOnly,
                global::RegressionMultipleUniqueIndexesHadSameName,
                uint,
                SpacetimeDB.BSATN.U32
            >
        {
            internal Unique1Index()
                : base("RegressionMultipleUniqueIndexesHadSameName_Unique1_idx_btree") { }

            public global::RegressionMultipleUniqueIndexesHadSameName? Find(uint key) =>
                FindSingle(key);
        }

        public Unique1Index Unique1 => new();

        public sealed class Unique2Index
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.RegressionMultipleUniqueIndexesHadSameNameReadOnly,
                global::RegressionMultipleUniqueIndexesHadSameName,
                uint,
                SpacetimeDB.BSATN.U32
            >
        {
            internal Unique2Index()
                : base("RegressionMultipleUniqueIndexesHadSameName_Unique2_idx_btree") { }

            public global::RegressionMultipleUniqueIndexesHadSameName? Find(uint key) =>
                FindSingle(key);
        }

        public Unique2Index Unique2 => new();
    }

    public sealed class SendMessageTimerReadOnly
        : global::SpacetimeDB.Internal.ReadOnlyTableView<global::Timers.SendMessageTimer>
    {
        internal SendMessageTimerReadOnly()
            : base("SendMessageTimer") { }

        public ulong Count => DoCount();

        public sealed class ScheduledIdIndex
            : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
                global::SpacetimeDB.Internal.ViewHandles.SendMessageTimerReadOnly,
                global::Timers.SendMessageTimer,
                ulong,
                SpacetimeDB.BSATN.U64
            >
        {
            internal ScheduledIdIndex()
                : base("SendMessageTimer_ScheduledId_idx_btree") { }

            public global::Timers.SendMessageTimer? Find(ulong key) => FindSingle(key);
        }

        public ScheduledIdIndex ScheduledId => new();
    }
}

namespace SpacetimeDB.Internal
{
    public sealed partial class LocalReadOnly
    {
        internal global::SpacetimeDB.Internal.ViewHandles.BTreeMultiColumnReadOnly BTreeMultiColumn =>
            new();
        internal global::SpacetimeDB.Internal.ViewHandles.BTreeViewsReadOnly BTreeViews => new();
        public global::SpacetimeDB.Internal.ViewHandles.MultiTable1ReadOnly MultiTable1 => new();
        public global::SpacetimeDB.Internal.ViewHandles.MultiTable2ReadOnly MultiTable2 => new();
        public global::SpacetimeDB.Internal.ViewHandles.PrivateTableReadOnly PrivateTable => new();
        public global::SpacetimeDB.Internal.ViewHandles.PublicTableReadOnly PublicTable => new();
        internal global::SpacetimeDB.Internal.ViewHandles.RegressionMultipleUniqueIndexesHadSameNameReadOnly RegressionMultipleUniqueIndexesHadSameName =>
            new();
        public global::SpacetimeDB.Internal.ViewHandles.SendMessageTimerReadOnly SendMessageTimer =>
            new();
    }
}

static class ModuleRegistration
{
    class Init : SpacetimeDB.Internal.IReducer
    {
        public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) => new(nameof(Init), [], SpacetimeDB.Internal.Lifecycle.Init);

        public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx)
        {
            Timers.Init((SpacetimeDB.ReducerContext)ctx);
        }
    }

    class InsertData : SpacetimeDB.Internal.IReducer
    {
        private static readonly PublicTable.BSATN dataRW = new();

        public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) => new(nameof(InsertData), [new("data", dataRW.GetAlgebraicType(registrar))], null);

        public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx)
        {
            Reducers.InsertData((SpacetimeDB.ReducerContext)ctx, dataRW.Read(reader));
        }
    }

    class InsertData2 : SpacetimeDB.Internal.IReducer
    {
        private static readonly PublicTable.BSATN dataRW = new();

        public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) => new(nameof(InsertData2), [new("data", dataRW.GetAlgebraicType(registrar))], null);

        public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx)
        {
            Test.NestingNamespaces.AndClasses.InsertData2(
                (SpacetimeDB.ReducerContext)ctx,
                dataRW.Read(reader)
            );
        }
    }

    class InsertMultiData : SpacetimeDB.Internal.IReducer
    {
        private static readonly MultiTableRow.BSATN dataRW = new();

        public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) => new(nameof(InsertMultiData), [new("data", dataRW.GetAlgebraicType(registrar))], null);

        public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx)
        {
            MultiTableRow.InsertMultiData((SpacetimeDB.ReducerContext)ctx, dataRW.Read(reader));
        }
    }

    class ScheduleImmediate : SpacetimeDB.Internal.IReducer
    {
        private static readonly PublicTable.BSATN dataRW = new();

        public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(nameof(ScheduleImmediate), [new("data", dataRW.GetAlgebraicType(registrar))], null);

        public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx)
        {
            Reducers.ScheduleImmediate((SpacetimeDB.ReducerContext)ctx, dataRW.Read(reader));
        }
    }

    class SendScheduledMessage : SpacetimeDB.Internal.IReducer
    {
        private static readonly Timers.SendMessageTimer.BSATN argRW = new();

        public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(
            SpacetimeDB.BSATN.ITypeRegistrar registrar
        ) =>
            new(
                nameof(SendScheduledMessage),
                [new("arg", argRW.GetAlgebraicType(registrar))],
                null
            );

        public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx)
        {
            Timers.SendScheduledMessage((SpacetimeDB.ReducerContext)ctx, argRW.Read(reader));
        }
    }

    public static List<T> ToListOrEmpty<T>(T? value)
        where T : struct => value is null ? new List<T>() : new List<T> { value.Value };

    public static List<T> ToListOrEmpty<T>(T? value)
        where T : class => value is null ? new List<T>() : new List<T> { value };

#if EXPERIMENTAL_WASM_AOT
    // In AOT mode we're building a library.
    // Main method won't be called automatically, so we need to export it as a preinit function.
    [UnmanagedCallersOnly(EntryPoint = "__preinit__10_init_csharp")]
#else
    // Prevent trimming of FFI exports that are invoked from C and not visible to C# trimmer.
    [DynamicDependency(
        DynamicallyAccessedMemberTypes.PublicMethods,
        typeof(SpacetimeDB.Internal.Module)
    )]
#endif
    public static void Main()
    {
        SpacetimeDB.Internal.Module.SetReducerContextConstructor(
            (identity, connectionId, random, time) =>
                new SpacetimeDB.ReducerContext(identity, connectionId, random, time)
        );
        SpacetimeDB.Internal.Module.SetViewContextConstructor(
            identity => new SpacetimeDB.ViewContext(
                identity,
                new SpacetimeDB.Internal.LocalReadOnly()
            )
        );
        SpacetimeDB.Internal.Module.SetAnonymousViewContextConstructor(
            () => new SpacetimeDB.AnonymousViewContext(new SpacetimeDB.Internal.LocalReadOnly())
        );
        SpacetimeDB.Internal.Module.SetProcedureContextConstructor(
            (identity, connectionId, random, time) =>
                new SpacetimeDB.ProcedureContext(identity, connectionId, random, time)
        );
        var __memoryStream = new MemoryStream();
        var __writer = new BinaryWriter(__memoryStream);

        SpacetimeDB.Internal.Module.RegisterReducer<Init>();
        SpacetimeDB.Internal.Module.RegisterReducer<InsertData>();
        SpacetimeDB.Internal.Module.RegisterReducer<InsertData2>();
        SpacetimeDB.Internal.Module.RegisterReducer<InsertMultiData>();
        SpacetimeDB.Internal.Module.RegisterReducer<ScheduleImmediate>();
        SpacetimeDB.Internal.Module.RegisterReducer<SendScheduledMessage>();

        // IMPORTANT: The order in which we register views matters.
        // It must correspond to the order in which we call `GenerateDispatcherClass`.
        // See the comment on `GenerateDispatcherClass` for more explanation.
        SpacetimeDB.Internal.Module.RegisterView<public_table_viewViewDispatcher>();
        SpacetimeDB.Internal.Module.RegisterAnonymousView<find_public_table__by_identityViewDispatcher>();

        SpacetimeDB.Internal.Module.RegisterTable<
            global::BTreeMultiColumn,
            SpacetimeDB.Internal.TableHandles.BTreeMultiColumn
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::BTreeViews,
            SpacetimeDB.Internal.TableHandles.BTreeViews
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::MultiTableRow,
            SpacetimeDB.Internal.TableHandles.MultiTable1
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::MultiTableRow,
            SpacetimeDB.Internal.TableHandles.MultiTable2
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::PrivateTable,
            SpacetimeDB.Internal.TableHandles.PrivateTable
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::PublicTable,
            SpacetimeDB.Internal.TableHandles.PublicTable
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::RegressionMultipleUniqueIndexesHadSameName,
            SpacetimeDB.Internal.TableHandles.RegressionMultipleUniqueIndexesHadSameName
        >();
        SpacetimeDB.Internal.Module.RegisterTable<
            global::Timers.SendMessageTimer,
            SpacetimeDB.Internal.TableHandles.SendMessageTimer
        >();
        SpacetimeDB.Internal.Module.RegisterClientVisibilityFilter(
            global::Module.ALL_PUBLIC_TABLES
        );
    }

    // Exports only work from the main assembly, so we need to generate forwarding methods.
#if EXPERIMENTAL_WASM_AOT
    [UnmanagedCallersOnly(EntryPoint = "__describe_module__")]
    public static void __describe_module__(SpacetimeDB.Internal.BytesSink d) =>
        SpacetimeDB.Internal.Module.__describe_module__(d);

    [UnmanagedCallersOnly(EntryPoint = "__call_reducer__")]
    public static SpacetimeDB.Internal.Errno __call_reducer__(
        uint id,
        ulong sender_0,
        ulong sender_1,
        ulong sender_2,
        ulong sender_3,
        ulong conn_id_0,
        ulong conn_id_1,
        SpacetimeDB.Timestamp timestamp,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink error
    ) =>
        SpacetimeDB.Internal.Module.__call_reducer__(
            id,
            sender_0,
            sender_1,
            sender_2,
            sender_3,
            conn_id_0,
            conn_id_1,
            timestamp,
            args,
            error
        );

    [UnmanagedCallersOnly(EntryPoint = "__call_procedure__")]
    public static SpacetimeDB.Internal.Errno __call_procedure__(
        uint id,
        ulong sender_0,
        ulong sender_1,
        ulong sender_2,
        ulong sender_3,
        ulong conn_id_0,
        ulong conn_id_1,
        SpacetimeDB.Timestamp timestamp,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink result_sink
    ) =>
        SpacetimeDB.Internal.Module.__call_procedure__(
            id,
            sender_0,
            sender_1,
            sender_2,
            sender_3,
            conn_id_0,
            conn_id_1,
            timestamp,
            args,
            result_sink
        );

    [UnmanagedCallersOnly(EntryPoint = "__call_view__")]
    public static SpacetimeDB.Internal.Errno __call_view__(
        uint id,
        ulong sender_0,
        ulong sender_1,
        ulong sender_2,
        ulong sender_3,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink sink
    ) =>
        SpacetimeDB.Internal.Module.__call_view__(
            id,
            sender_0,
            sender_1,
            sender_2,
            sender_3,
            args,
            sink
        );

    [UnmanagedCallersOnly(EntryPoint = "__call_view_anon__")]
    public static SpacetimeDB.Internal.Errno __call_view_anon__(
        uint id,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink sink
    ) => SpacetimeDB.Internal.Module.__call_view_anon__(id, args, sink);
#endif
}

#pragma warning restore STDB_UNSTABLE
#pragma warning restore CS0436
