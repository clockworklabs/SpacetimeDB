use crate::timestamp::ClockGenerator;
use crate::{de::Deserialize, impl_st, ser::Serialize, AlgebraicType, AlgebraicValue};
use std::fmt;
use uuid::{Builder, Uuid as UUID};

#[derive(Debug, Clone, Copy, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
#[sats(crate = crate)]
pub struct Uuid {
    __uuid__: u128,
}

impl Uuid {
    /// The nil UUID (all zeros).
    ///
    /// Example:
    ///
    /// ```
    /// # use spacetimedb_sats::uuid::Uuid;
    /// let uuid = Uuid::NIL;
    ///
    /// assert_eq!(
    ///     "00000000-0000-0000-0000-000000000000",
    ///     uuid.to_string(),
    /// );
    /// ```
    pub const NIL: Self = Self {
        __uuid__: UUID::nil().as_u128(),
    };

    /// Create a UUIDv4 from explicit random bytes.
    ///
    /// This method assumes the bytes are already sufficiently random, it will only
    /// set the appropriate bits for the UUID version and variant.
    ///
    /// # Example
    /// ```
    /// # use spacetimedb_sats::uuid::Uuid;
    /// // Use the `ReducerContext::rng()` method to generate random bytes in reducers,
    /// // or call `ReducerContext::new_uuid_v4`
    /// let random_bytes = [0u8; 16];
    /// let uuid = Uuid::from_random_bytes_v4(random_bytes);
    ///
    /// assert_eq!(
    ///     "00000000-0000-4000-8000-000000000000",
    ///     uuid.to_string(),
    /// );
    /// ```
    pub fn from_random_bytes_v4(counter_random_bytes: [u8; 16]) -> Self {
        Self {
            __uuid__: Builder::from_random_bytes(counter_random_bytes).into_uuid().as_u128(),
        }
    }

    /// Create a UUIDv7 from a UNIX timestamp (milliseconds) and 10 random bytes.
    ///
    /// This method will set the variant field within the counter bytes without attempting to shift
    /// the data around it. Callers using the counter as a monotonic value should be careful not to
    /// store significant data in the 2 least significant bits of the 3rd byte.
    ///
    /// # Example
    ///
    /// ```
    /// # use spacetimedb_sats::uuid::Uuid;
    /// let millis = 1_686_000_000_000u64;
    /// // Use the `ReducerContext::rng()` method to generate random bytes in reducers,
    /// // or call `ReducerContext::new_uuid_v7`
    /// let random_bytes = [0u8; 10];
    /// let uuid = Uuid::from_unix_millis_v7(millis, &random_bytes);
    ///
    /// assert_eq!(
    ///     "01888d6e-5c00-7000-8000-000000000000",
    ///     uuid.to_string(),
    /// );
    /// ```
    pub fn from_unix_millis_v7(millis: u64, counter_random_bytes: &[u8; 10]) -> Self {
        Self {
            __uuid__: Builder::from_unix_timestamp_millis(millis, counter_random_bytes)
                .into_uuid()
                .as_u128(),
        }
    }

    /// Generate a UUIDv7 using a monotonic clock generator.
    ///
    /// This method will set the variant field within the counter bytes without attempting to shift
    /// the data around it. Callers using the counter as a monotonic value should be careful not to
    /// store significant data in the 2 least significant bits of the 3rd byte.
    ///
    /// # Example
    /// ```
    /// # use spacetimedb_sats::uuid::Uuid;
    /// # use spacetimedb_sats::timestamp::{Timestamp, ClockGenerator};
    /// let mut clock = ClockGenerator::new(Timestamp::from_micros_since_unix_epoch(1_686_000_000_000));
    /// // Use the `ReducerContext::rng()` method to generate random bytes in reducers,
    /// // or call `ReducerContext::new_uuid_v7`
    /// let random_bytes = [0u8; 10];
    /// let uuid = Uuid::from_clock_v7(&mut clock, &random_bytes).unwrap();
    ///
    /// assert_eq!(
    ///     "0000647e-5181-7000-8000-000000000000",
    ///     uuid.to_string(),
    /// );
    /// ```
    pub fn from_clock_v7(clock: &mut ClockGenerator, counter_random_bytes: &[u8; 10]) -> anyhow::Result<Self> {
        let timestamp = clock.tick();
        let millis = timestamp
            .to_duration_since_unix_epoch()
            .map_err(|err| anyhow::anyhow!("cannot create v7 UUID from timestamp before Unix epoch: {err:?}"))?
            .as_millis()
            .try_into()?;
        Ok(Uuid::from_unix_millis_v7(millis, counter_random_bytes))
    }

    /// Parse a UUID from a string representation.
    ///
    /// Any of the formats generated by this module (simple, hyphenated, urn,
    /// Microsoft GUID) are supported by this parsing function.
    ///
    /// # Example
    /// ```
    /// # use spacetimedb_sats::uuid::Uuid;
    /// let s = "01888d6e-5c00-7000-8000-000000000000";
    /// let uuid = Uuid::parse_str(s).unwrap();
    ///
    /// assert_eq!(
    ///     s,
    ///     uuid.to_string(),
    /// );
    /// ```
    pub fn parse_str(s: &str) -> Result<Self, uuid::Error> {
        Ok(Self {
            __uuid__: UUID::parse_str(s)?.as_u128(),
        })
    }

    /// Convert to the `uuid` crate's `Uuid` type.
    pub fn to_uuid(self) -> UUID {
        UUID::from_u128(self.__uuid__)
    }

    pub fn from_u128(u: u128) -> Self {
        Self { __uuid__: u }
    }

    pub fn as_u128(&self) -> u128 {
        self.__uuid__
    }
}

impl_st!([] Uuid, AlgebraicType::uuid());

impl fmt::Display for Uuid {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_uuid())
    }
}

impl From<Uuid> for AlgebraicValue {
    fn from(value: Uuid) -> Self {
        AlgebraicValue::product([value.as_u128().into()])
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::timestamp::Timestamp;
    use crate::GroundSpacetimeType;
    use rand::RngCore;

    #[test]
    fn uuid_type_matches() {
        assert_eq!(AlgebraicType::uuid(), Uuid::get_type());
        assert!(Uuid::get_type().is_uuid());
        assert!(Uuid::get_type().is_special());
    }

    #[test]
    fn round_trip_uuid() {
        let u1 = Uuid::NIL;
        let s = u1.to_string();
        let u2 = Uuid::parse_str(&s).unwrap();
        assert_eq!(u1, u2);
        assert_eq!(u1.as_u128(), u2.as_u128());
        assert_eq!(u1.to_uuid(), u2.to_uuid());
        assert_eq!(s, u2.to_string());
    }

    #[test]
    fn ordered_uuids() {
        let u1 = Uuid::from_u128(1);
        let u2 = Uuid::from_u128(2);
        assert!(u1 < u2);
        assert!(u2 > u1);
        assert_eq!(u1, u1);
        assert_ne!(u1, u2);

        let mut clock = ClockGenerator::new(Timestamp::now());
        let uuids = (0..1000)
            .map(|_| {
                let mut bytes = [0u8; 10];
                rand::rng().fill_bytes(&mut bytes);
                Uuid::from_clock_v7(&mut clock, &bytes).unwrap()
            })
            .collect::<Vec<Uuid>>();

        for (pos, pair) in uuids.windows(2).enumerate() {
            assert!(
                pair[0] < pair[1],
                "UUIDs are not ordered at {pos}: {} !< {}",
                pair[0],
                pair[1]
            );
        }
    }
}
