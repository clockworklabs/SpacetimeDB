import { describe, expect, test } from 'vitest';
import {
  AlgebraicType,
  BinaryReader,
  BinaryWriter,
  ConnectionId,
  TimeDuration,
  Timestamp,
} from '../src/index';
import * as ws from '../src/sdk/client_api';
import {
  anIdentity,
  bobIdentity,
  encodeCreatePlayerArgs,
  encodeUser,
  sallyIdentity,
} from './utils';
import { ServerMessage } from '../src/sdk/client_api';

/*
// Generated by the following Rust code:

#[cfg(test)]
mod tests {
    use rand::{thread_rng, Rng};
    use spacetimedb_sats::{bsatn, i256, u256};

    #[test]
    fn make_some_numbers() {
        let mut rng = thread_rng();
        let v_u8: u8 = rng.gen();
        let v_u16: u16 = rng.gen();
        let v_u32: u32 = rng.gen();
        let v_u64: u64 = rng.gen();
        let v_u128: u128 = rng.gen();
        let v_u256: u256 = u256::from_words(rng.gen(), rng.gen());
        let v_i8: i8 = rng.gen();
        let v_i16: i16 = rng.gen();
        let v_i32: i32 = rng.gen();
        let v_i64: i64 = rng.gen();
        let v_i128: i128 = rng.gen();
        let v_i256: i256 = i256::from_words(rng.gen(), rng.gen());

        println!("['I8', {}, {:?}],", v_i8, bsatn::to_vec(&v_i8).unwrap());
        println!("['I16', {}, {:?}],", v_i16, bsatn::to_vec(&v_i16).unwrap());
        println!("['I32', {}, {:?}],", v_i32, bsatn::to_vec(&v_i32).unwrap());
        println!("['I64', BigInt('{}'), {:?}],", v_i64, bsatn::to_vec(&v_i64).unwrap());
        println!("['I128', BigInt('{}'), {:?}],", v_i128, bsatn::to_vec(&v_i128).unwrap());
        println!("['I256', BigInt('{}'), {:?}],", v_i256, bsatn::to_vec(&v_i256).unwrap());

        println!("['U8', {}, {:?}],", v_u8, bsatn::to_vec(&v_u8).unwrap());
        println!("['U16', {}, {:?}],", v_u16, bsatn::to_vec(&v_u16).unwrap());
        println!("['U32', {}, {:?}],", v_u32, bsatn::to_vec(&v_u32).unwrap());
        println!("['U64', BigInt('{}'), {:?}],", v_u64, bsatn::to_vec(&v_u64).unwrap());
        println!("['U128', BigInt('{}'), {:?}],", v_u128, bsatn::to_vec(&v_u128).unwrap());
        println!("['U256', BigInt('{}'), {:?}],", v_u256, bsatn::to_vec(&v_u256).unwrap());
        panic!();
    }
}
*/

const testCases: Array<[string, bigint | number, Array<number>]> = [
  ['I8', 48, [48]],
  ['I16', 2910, [94, 11]],
  ['I32', -799760706, [190, 158, 84, 208]],
  [
    'I64',
    BigInt('-1541553498090056195'),
    [253, 213, 20, 208, 66, 77, 155, 234],
  ],
  [
    'I128',
    BigInt('12547586996680216771838914786222604020'),
    [244, 254, 202, 102, 17, 36, 114, 210, 182, 88, 120, 98, 205, 147, 112, 9],
  ],
  [
    'I256',
    BigInt(
      '35334490670013506332541201493144667192747188790291257662501378603950330458369'
    ),
    [
      1, 177, 117, 147, 65, 153, 110, 71, 110, 80, 45, 231, 208, 112, 149, 150,
      251, 157, 51, 25, 129, 124, 13, 154, 238, 225, 7, 63, 237, 156, 30, 78,
    ],
  ],
  ['U8', 63, [63]],
  ['U16', 14776, [184, 57]],
  ['U32', 2260346643, [19, 39, 186, 134]],
  [
    'U64',
    BigInt('6355943419584016569'),
    [185, 112, 201, 104, 221, 216, 52, 88],
  ],
  [
    'U128',
    BigInt('190443100270131819986139062814080853012'),
    [20, 100, 201, 134, 99, 82, 196, 32, 34, 79, 25, 142, 199, 1, 70, 143],
  ],
  [
    'U256',
    BigInt(
      '58716185326733447174109779681509939791568291171619953995835894271369692835957'
    ),
    [
      117, 240, 99, 239, 213, 99, 55, 201, 2, 145, 4, 24, 0, 173, 62, 27, 124,
      53, 44, 244, 71, 1, 156, 30, 111, 187, 149, 150, 229, 46, 208, 129,
    ],
  ],
];

describe('BinaryReader/Writer', () => {
  test('correctly reads/writes little endian values', () => {
    for (const [name, int, buf] of testCases) {
      const arr = new Uint8Array(buf);
      const reader = new BinaryReader(arr);

      const read = (reader as any)['read' + name]();
      expect(read).toEqual(int);

      const writer = new BinaryWriter(0);
      (writer as any)['write' + name](int);

      expect(writer.getBuffer()).toEqual(arr);
    }
  });

  test('correctly serializes and then deserializes a complicated web socket message', () => {
    const user1 = { identity: bobIdentity, username: 'bob' };
    const user2 = {
      identity: sallyIdentity,
      username: 'sally',
    };
    const binary = [...encodeUser(user1)].concat([...encodeUser(user2)]);
    const transactionUpdate = ws.ServerMessage.TransactionUpdate({
      status: ws.UpdateStatus.Committed({
        tables: [
          {
            tableId: 35,
            tableName: 'user',
            numRows: BigInt(1),
            updates: [
              ws.CompressableQueryUpdate.Uncompressed({
                deletes: {
                  sizeHint: ws.RowSizeHint.FixedSize(0), // not used
                  rowsData: new Uint8Array([]),
                },
                // FIXME: this test is evil: an initial subscription can never contain deletes or updates.
                inserts: {
                  sizeHint: ws.RowSizeHint.FixedSize(0), // not used
                  rowsData: new Uint8Array(binary),
                },
              }),
            ],
          },
        ],
      }),
      timestamp: new Timestamp(1681391805281203n),
      callerIdentity: anIdentity,
      callerConnectionId: ConnectionId.random(),
      reducerCall: {
        reducerName: 'create_player',
        reducerId: 0,
        args: encodeCreatePlayerArgs('A Player', { x: 2, y: 3 }),
        requestId: 0,
      },
      energyQuantaUsed: { quanta: BigInt(33841000) },
      totalHostExecutionDuration: new TimeDuration(BigInt(1234567890)),
    });
    const writer = new BinaryWriter(1024);
    AlgebraicType.serializeValue(
      writer,
      ServerMessage.getTypeScriptAlgebraicType(),
      transactionUpdate
    );
    const rawBytes = writer.getBuffer();

    const deserializedTransactionUpdate = AlgebraicType.deserializeValue(
      new BinaryReader(rawBytes),
      ServerMessage.getTypeScriptAlgebraicType()
    );
    expect(deserializedTransactionUpdate).toEqual(transactionUpdate);
  });
});
