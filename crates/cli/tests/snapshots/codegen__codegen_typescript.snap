---
source: crates/cli/tests/codegen.rs
expression: outfiles
---
"add_player_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type AddPlayer = {
  name: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace AddPlayer {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("name", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: AddPlayer): void {
    AddPlayer.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): AddPlayer {
    return AddPlayer.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"add_private_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type AddPrivate = {
  name: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace AddPrivate {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("name", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: AddPrivate): void {
    AddPrivate.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): AddPrivate {
    return AddPrivate.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"baz_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type Baz = {
  field: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace Baz {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("field", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: Baz): void {
    Baz.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): Baz {
    return Baz.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"delete_player_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type DeletePlayer = {
  id: bigint,
};

/**
 * A namespace for generated helper functions.
 */
export namespace DeletePlayer {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("id", AlgebraicType.createU64Type()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: DeletePlayer): void {
    DeletePlayer.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): DeletePlayer {
    return DeletePlayer.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"delete_players_by_name_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type DeletePlayersByName = {
  name: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace DeletePlayersByName {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("name", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: DeletePlayersByName): void {
    DeletePlayersByName.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): DeletePlayersByName {
    return DeletePlayersByName.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"foobar_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
// @ts-ignore
import { Baz as __Baz } from "./baz_type";

// A namespace for generated variants and helper functions.
export namespace Foobar {
  // These are the generated variant types for each variant of the tagged union.
  // One type is generated per variant and will be used in the `value` field of
  // the tagged union.
  export type Baz = { tag: "Baz", value: __Baz };
  export type Bar = { tag: "Bar" };
  export type Har = { tag: "Har", value: number };

  // Helper functions for constructing each variant of the tagged union.
  // ```
  // const foo = Foo.A(42);
  // assert!(foo.tag === "A");
  // assert!(foo.value === 42);
  // ```
  export const Baz = (value: __Baz): Foobar => ({ tag: "Baz", value });
  export const Bar = { tag: "Bar" };
  export const Har = (value: number): Foobar => ({ tag: "Har", value });

  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createSumType([
      new SumTypeVariant("Baz", __Baz.getTypeScriptAlgebraicType()),
      new SumTypeVariant("Bar", AlgebraicType.createProductType([])),
      new SumTypeVariant("Har", AlgebraicType.createU32Type()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: Foobar): void {
      Foobar.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): Foobar {
      return Foobar.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

// The tagged union or sum type for the algebraic type `Foobar`.
export type Foobar = Foobar.Baz | Foobar.Bar | Foobar.Har;

export default Foobar;

'''
"has_special_stuff_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { HasSpecialStuff } from "./has_special_stuff_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `has_special_stuff`.
 *
 * Obtain a handle from the [`hasSpecialStuff`] property on [`RemoteTables`],
 * like `ctx.db.hasSpecialStuff`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.hasSpecialStuff.on_insert(...)`.
 */
export class HasSpecialStuffTableHandle {
  tableCache: TableCache<HasSpecialStuff>;

  constructor(tableCache: TableCache<HasSpecialStuff>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<HasSpecialStuff> {
    return this.tableCache.iter();
  }

  onInsert = (cb: (ctx: EventContext, row: HasSpecialStuff) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: HasSpecialStuff) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: HasSpecialStuff) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: HasSpecialStuff) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }
}
'''
"has_special_stuff_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type HasSpecialStuff = {
  identity: Identity,
  address: Address,
};

/**
 * A namespace for generated helper functions.
 */
export namespace HasSpecialStuff {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("identity", AlgebraicType.createIdentityType()),
      new ProductTypeElement("address", AlgebraicType.createAddressType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: HasSpecialStuff): void {
    HasSpecialStuff.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): HasSpecialStuff {
    return HasSpecialStuff.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"identity_connected_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type IdentityConnected = {};

/**
 * A namespace for generated helper functions.
 */
export namespace IdentityConnected {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
    ]);
  }

  export function serialize(writer: BinaryWriter, value: IdentityConnected): void {
    IdentityConnected.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): IdentityConnected {
    return IdentityConnected.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"index.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

// Import and reexport all reducer arg types
import { IdentityConnected } from "./identity_connected_reducer.ts";
export { IdentityConnected };
import { Init } from "./init_reducer.ts";
export { Init };
import { AddPlayer } from "./add_player_reducer.ts";
export { AddPlayer };
import { AddPrivate } from "./add_private_reducer.ts";
export { AddPrivate };
import { DeletePlayer } from "./delete_player_reducer.ts";
export { DeletePlayer };
import { DeletePlayersByName } from "./delete_players_by_name_reducer.ts";
export { DeletePlayersByName };
import { QueryPrivate } from "./query_private_reducer.ts";
export { QueryPrivate };
import { RepeatingTest } from "./repeating_test_reducer.ts";
export { RepeatingTest };
import { Test } from "./test_reducer.ts";
export { Test };
import { TestBtreeIndexArgs } from "./test_btree_index_args_reducer.ts";
export { TestBtreeIndexArgs };

// Import and reexport all table handle types
import { HasSpecialStuffTableHandle } from "./has_special_stuff_table.ts";
export { HasSpecialStuffTableHandle };
import { PkMultiIdentityTableHandle } from "./pk_multi_identity_table.ts";
export { PkMultiIdentityTableHandle };
import { PointsTableHandle } from "./points_table.ts";
export { PointsTableHandle };
import { PrivateTableHandle } from "./private_table.ts";
export { PrivateTableHandle };
import { RepeatingTestArgTableHandle } from "./repeating_test_arg_table.ts";
export { RepeatingTestArgTableHandle };
import { TestATableHandle } from "./test_a_table.ts";
export { TestATableHandle };
import { TestDTableHandle } from "./test_d_table.ts";
export { TestDTableHandle };
import { TestETableHandle } from "./test_e_table.ts";
export { TestETableHandle };
import { TestFTableHandle } from "./test_f_table.ts";
export { TestFTableHandle };

// Import and reexport all types
import { Baz } from "./baz_type.ts";
export { Baz };
import { Foobar } from "./foobar_type.ts";
export { Foobar };
import { HasSpecialStuff } from "./has_special_stuff_type.ts";
export { HasSpecialStuff };
import { PkMultiIdentity } from "./pk_multi_identity_type.ts";
export { PkMultiIdentity };
import { Point } from "./point_type.ts";
export { Point };
import { Private } from "./private_type.ts";
export { Private };
import { RepeatingTestArg } from "./repeating_test_arg_type.ts";
export { RepeatingTestArg };
import { TestA } from "./test_a_type.ts";
export { TestA };
import { TestB } from "./test_b_type.ts";
export { TestB };
import { TestD } from "./test_d_type.ts";
export { TestD };
import { TestE } from "./test_e_type.ts";
export { TestE };
import { TestFoobar } from "./test_foobar_type.ts";
export { TestFoobar };
import { NamespaceTestC } from "./namespace_test_c_type.ts";
export { NamespaceTestC };
import { NamespaceTestF } from "./namespace_test_f_type.ts";
export { NamespaceTestF };

const REMOTE_MODULE = {
  tables: {
    has_special_stuff: {
      tableName: "has_special_stuff",
      rowType: HasSpecialStuff.getTypeScriptAlgebraicType(),
    },
    pk_multi_identity: {
      tableName: "pk_multi_identity",
      rowType: PkMultiIdentity.getTypeScriptAlgebraicType(),
      primaryKey: "id",
    },
    points: {
      tableName: "points",
      rowType: Point.getTypeScriptAlgebraicType(),
    },
    private: {
      tableName: "private",
      rowType: Private.getTypeScriptAlgebraicType(),
    },
    repeating_test_arg: {
      tableName: "repeating_test_arg",
      rowType: RepeatingTestArg.getTypeScriptAlgebraicType(),
      primaryKey: "scheduled_id",
    },
    test_a: {
      tableName: "test_a",
      rowType: TestA.getTypeScriptAlgebraicType(),
    },
    test_d: {
      tableName: "test_d",
      rowType: TestD.getTypeScriptAlgebraicType(),
    },
    test_e: {
      tableName: "test_e",
      rowType: TestE.getTypeScriptAlgebraicType(),
      primaryKey: "id",
    },
    test_f: {
      tableName: "test_f",
      rowType: TestFoobar.getTypeScriptAlgebraicType(),
    },
  },
  reducers: {
    __identity_connected__: {
      reducerName: "__identity_connected__",
      argsType: IdentityConnected.getTypeScriptAlgebraicType(),
    },
    __init__: {
      reducerName: "__init__",
      argsType: Init.getTypeScriptAlgebraicType(),
    },
    add_player: {
      reducerName: "add_player",
      argsType: AddPlayer.getTypeScriptAlgebraicType(),
    },
    add_private: {
      reducerName: "add_private",
      argsType: AddPrivate.getTypeScriptAlgebraicType(),
    },
    delete_player: {
      reducerName: "delete_player",
      argsType: DeletePlayer.getTypeScriptAlgebraicType(),
    },
    delete_players_by_name: {
      reducerName: "delete_players_by_name",
      argsType: DeletePlayersByName.getTypeScriptAlgebraicType(),
    },
    query_private: {
      reducerName: "query_private",
      argsType: QueryPrivate.getTypeScriptAlgebraicType(),
    },
    repeating_test: {
      reducerName: "repeating_test",
      argsType: RepeatingTest.getTypeScriptAlgebraicType(),
    },
    test: {
      reducerName: "test",
      argsType: Test.getTypeScriptAlgebraicType(),
    },
    test_btree_index_args: {
      reducerName: "test_btree_index_args",
      argsType: TestBtreeIndexArgs.getTypeScriptAlgebraicType(),
    },
  },
  // Constructors which are used by the DBConnectionImpl to
  // extract type information from the generated RemoteModule.
  eventContextConstructor: (imp: DBConnectionImpl, event: Event<Reducer>) => {
    return {
      ...(imp as DBConnection),
      event
    }
  },
  dbViewConstructor: (imp: DBConnectionImpl) => {
    return new RemoteTables(imp);
  },
  reducersConstructor: (imp: DBConnectionImpl, setReducerFlags: SetReducerFlags) => {
    return new RemoteReducers(imp, setReducerFlags);
  },
  setReducerFlagsConstructor: () => {
    return new SetReducerFlags();
  }
}

// A type representing all the possible variants of a reducer.
export type Reducer = never
| { name: "IdentityConnected", args: IdentityConnected }
| { name: "Init", args: Init }
| { name: "AddPlayer", args: AddPlayer }
| { name: "AddPrivate", args: AddPrivate }
| { name: "DeletePlayer", args: DeletePlayer }
| { name: "DeletePlayersByName", args: DeletePlayersByName }
| { name: "QueryPrivate", args: QueryPrivate }
| { name: "RepeatingTest", args: RepeatingTest }
| { name: "Test", args: Test }
| { name: "TestBtreeIndexArgs", args: TestBtreeIndexArgs }
;

export class RemoteReducers {
  constructor(private connection: DBConnectionImpl, private setCallReducerFlags: SetReducerFlags) {}

  identityConnected() {
    this.connection.callReducer("__identity_connected__", new Uint8Array(0), this.setCallReducerFlags.identityConnectedFlags);
  }

  onIdentityConnected(callback: (ctx: EventContext) => void) {
    this.connection.onReducer("__identity_connected__", callback);
  }

  removeOnIdentityConnected(callback: (ctx: EventContext) => void) {
    this.connection.offReducer("__identity_connected__", callback);
  }

  init() {
    this.connection.callReducer("__init__", new Uint8Array(0), this.setCallReducerFlags.initFlags);
  }

  onInit(callback: (ctx: EventContext) => void) {
    this.connection.onReducer("__init__", callback);
  }

  removeOnInit(callback: (ctx: EventContext) => void) {
    this.connection.offReducer("__init__", callback);
  }

  addPlayer(name: string) {
    const __args = { name };
    let __writer = new BinaryWriter(1024);
    AddPlayer.getTypeScriptAlgebraicType().serialize(__writer, __args);
    let __argsBuffer = __writer.getBuffer();
    this.connection.callReducer("add_player", __argsBuffer, this.setCallReducerFlags.addPlayerFlags);
  }

  onAddPlayer(callback: (ctx: EventContext, name: string) => void) {
    this.connection.onReducer("add_player", callback);
  }

  removeOnAddPlayer(callback: (ctx: EventContext, name: string) => void) {
    this.connection.offReducer("add_player", callback);
  }

  addPrivate(name: string) {
    const __args = { name };
    let __writer = new BinaryWriter(1024);
    AddPrivate.getTypeScriptAlgebraicType().serialize(__writer, __args);
    let __argsBuffer = __writer.getBuffer();
    this.connection.callReducer("add_private", __argsBuffer, this.setCallReducerFlags.addPrivateFlags);
  }

  onAddPrivate(callback: (ctx: EventContext, name: string) => void) {
    this.connection.onReducer("add_private", callback);
  }

  removeOnAddPrivate(callback: (ctx: EventContext, name: string) => void) {
    this.connection.offReducer("add_private", callback);
  }

  deletePlayer(id: bigint) {
    const __args = { id };
    let __writer = new BinaryWriter(1024);
    DeletePlayer.getTypeScriptAlgebraicType().serialize(__writer, __args);
    let __argsBuffer = __writer.getBuffer();
    this.connection.callReducer("delete_player", __argsBuffer, this.setCallReducerFlags.deletePlayerFlags);
  }

  onDeletePlayer(callback: (ctx: EventContext, id: bigint) => void) {
    this.connection.onReducer("delete_player", callback);
  }

  removeOnDeletePlayer(callback: (ctx: EventContext, id: bigint) => void) {
    this.connection.offReducer("delete_player", callback);
  }

  deletePlayersByName(name: string) {
    const __args = { name };
    let __writer = new BinaryWriter(1024);
    DeletePlayersByName.getTypeScriptAlgebraicType().serialize(__writer, __args);
    let __argsBuffer = __writer.getBuffer();
    this.connection.callReducer("delete_players_by_name", __argsBuffer, this.setCallReducerFlags.deletePlayersByNameFlags);
  }

  onDeletePlayersByName(callback: (ctx: EventContext, name: string) => void) {
    this.connection.onReducer("delete_players_by_name", callback);
  }

  removeOnDeletePlayersByName(callback: (ctx: EventContext, name: string) => void) {
    this.connection.offReducer("delete_players_by_name", callback);
  }

  queryPrivate() {
    this.connection.callReducer("query_private", new Uint8Array(0), this.setCallReducerFlags.queryPrivateFlags);
  }

  onQueryPrivate(callback: (ctx: EventContext) => void) {
    this.connection.onReducer("query_private", callback);
  }

  removeOnQueryPrivate(callback: (ctx: EventContext) => void) {
    this.connection.offReducer("query_private", callback);
  }

  repeatingTest(arg: RepeatingTestArg) {
    const __args = { arg };
    let __writer = new BinaryWriter(1024);
    RepeatingTest.getTypeScriptAlgebraicType().serialize(__writer, __args);
    let __argsBuffer = __writer.getBuffer();
    this.connection.callReducer("repeating_test", __argsBuffer, this.setCallReducerFlags.repeatingTestFlags);
  }

  onRepeatingTest(callback: (ctx: EventContext, arg: RepeatingTestArg) => void) {
    this.connection.onReducer("repeating_test", callback);
  }

  removeOnRepeatingTest(callback: (ctx: EventContext, arg: RepeatingTestArg) => void) {
    this.connection.offReducer("repeating_test", callback);
  }

  test(arg: TestA, arg2: TestB, arg3: NamespaceTestC, arg4: NamespaceTestF) {
    const __args = { arg, arg2, arg3, arg4 };
    let __writer = new BinaryWriter(1024);
    Test.getTypeScriptAlgebraicType().serialize(__writer, __args);
    let __argsBuffer = __writer.getBuffer();
    this.connection.callReducer("test", __argsBuffer, this.setCallReducerFlags.testFlags);
  }

  onTest(callback: (ctx: EventContext, arg: TestA, arg2: TestB, arg3: NamespaceTestC, arg4: NamespaceTestF) => void) {
    this.connection.onReducer("test", callback);
  }

  removeOnTest(callback: (ctx: EventContext, arg: TestA, arg2: TestB, arg3: NamespaceTestC, arg4: NamespaceTestF) => void) {
    this.connection.offReducer("test", callback);
  }

  testBtreeIndexArgs() {
    this.connection.callReducer("test_btree_index_args", new Uint8Array(0), this.setCallReducerFlags.testBtreeIndexArgsFlags);
  }

  onTestBtreeIndexArgs(callback: (ctx: EventContext) => void) {
    this.connection.onReducer("test_btree_index_args", callback);
  }

  removeOnTestBtreeIndexArgs(callback: (ctx: EventContext) => void) {
    this.connection.offReducer("test_btree_index_args", callback);
  }

}

export class SetReducerFlags {
  identityConnectedFlags: CallReducerFlags = 'FullUpdate';
  identityConnected(flags: CallReducerFlags) {
    this.identityConnectedFlags = flags;
  }

  initFlags: CallReducerFlags = 'FullUpdate';
  init(flags: CallReducerFlags) {
    this.initFlags = flags;
  }

  addPlayerFlags: CallReducerFlags = 'FullUpdate';
  addPlayer(flags: CallReducerFlags) {
    this.addPlayerFlags = flags;
  }

  addPrivateFlags: CallReducerFlags = 'FullUpdate';
  addPrivate(flags: CallReducerFlags) {
    this.addPrivateFlags = flags;
  }

  deletePlayerFlags: CallReducerFlags = 'FullUpdate';
  deletePlayer(flags: CallReducerFlags) {
    this.deletePlayerFlags = flags;
  }

  deletePlayersByNameFlags: CallReducerFlags = 'FullUpdate';
  deletePlayersByName(flags: CallReducerFlags) {
    this.deletePlayersByNameFlags = flags;
  }

  queryPrivateFlags: CallReducerFlags = 'FullUpdate';
  queryPrivate(flags: CallReducerFlags) {
    this.queryPrivateFlags = flags;
  }

  repeatingTestFlags: CallReducerFlags = 'FullUpdate';
  repeatingTest(flags: CallReducerFlags) {
    this.repeatingTestFlags = flags;
  }

  testFlags: CallReducerFlags = 'FullUpdate';
  test(flags: CallReducerFlags) {
    this.testFlags = flags;
  }

  testBtreeIndexArgsFlags: CallReducerFlags = 'FullUpdate';
  testBtreeIndexArgs(flags: CallReducerFlags) {
    this.testBtreeIndexArgsFlags = flags;
  }

}

export class RemoteTables {
  constructor(private connection: DBConnectionImpl) {}

  get hasSpecialStuff(): HasSpecialStuffTableHandle {
    return new HasSpecialStuffTableHandle(this.connection.clientCache.getOrCreateTable<HasSpecialStuff>(REMOTE_MODULE.tables.has_special_stuff));
  }

  get pkMultiIdentity(): PkMultiIdentityTableHandle {
    return new PkMultiIdentityTableHandle(this.connection.clientCache.getOrCreateTable<PkMultiIdentity>(REMOTE_MODULE.tables.pk_multi_identity));
  }

  get points(): PointsTableHandle {
    return new PointsTableHandle(this.connection.clientCache.getOrCreateTable<Point>(REMOTE_MODULE.tables.points));
  }

  get private(): PrivateTableHandle {
    return new PrivateTableHandle(this.connection.clientCache.getOrCreateTable<Private>(REMOTE_MODULE.tables.private));
  }

  get repeatingTestArg(): RepeatingTestArgTableHandle {
    return new RepeatingTestArgTableHandle(this.connection.clientCache.getOrCreateTable<RepeatingTestArg>(REMOTE_MODULE.tables.repeating_test_arg));
  }

  get testA(): TestATableHandle {
    return new TestATableHandle(this.connection.clientCache.getOrCreateTable<TestA>(REMOTE_MODULE.tables.test_a));
  }

  get testD(): TestDTableHandle {
    return new TestDTableHandle(this.connection.clientCache.getOrCreateTable<TestD>(REMOTE_MODULE.tables.test_d));
  }

  get testE(): TestETableHandle {
    return new TestETableHandle(this.connection.clientCache.getOrCreateTable<TestE>(REMOTE_MODULE.tables.test_e));
  }

  get testF(): TestFTableHandle {
    return new TestFTableHandle(this.connection.clientCache.getOrCreateTable<TestFoobar>(REMOTE_MODULE.tables.test_f));
  }
}

export class DBConnection extends DBConnectionImpl<RemoteTables, RemoteReducers, SetReducerFlags>  {
  static builder = (): DBConnectionBuilder<DBConnection>  => {
    return new DBConnectionBuilder<DBConnection>(REMOTE_MODULE, (imp: DBConnectionImpl) => imp as DBConnection);
  }
}

export type EventContext = EventContextInterface<RemoteTables, RemoteReducers, SetReducerFlags, Reducer>;
'''
"init_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type Init = {};

/**
 * A namespace for generated helper functions.
 */
export namespace Init {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
    ]);
  }

  export function serialize(writer: BinaryWriter, value: Init): void {
    Init.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): Init {
    return Init.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"namespace_test_c_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
// A namespace for generated variants and helper functions.
export namespace NamespaceTestC {
  // These are the generated variant types for each variant of the tagged union.
  // One type is generated per variant and will be used in the `value` field of
  // the tagged union.
  export type Foo = { tag: "Foo" };
  export type Bar = { tag: "Bar" };

  // Helper functions for constructing each variant of the tagged union.
  // ```
  // const foo = Foo.A(42);
  // assert!(foo.tag === "A");
  // assert!(foo.value === 42);
  // ```
  export const Foo = { tag: "Foo" };
  export const Bar = { tag: "Bar" };

  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createSumType([
      new SumTypeVariant("Foo", AlgebraicType.createProductType([])),
      new SumTypeVariant("Bar", AlgebraicType.createProductType([])),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: NamespaceTestC): void {
      NamespaceTestC.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): NamespaceTestC {
      return NamespaceTestC.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

// The tagged union or sum type for the algebraic type `NamespaceTestC`.
export type NamespaceTestC = NamespaceTestC.Foo | NamespaceTestC.Bar;

export default NamespaceTestC;

'''
"namespace_test_f_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
// A namespace for generated variants and helper functions.
export namespace NamespaceTestF {
  // These are the generated variant types for each variant of the tagged union.
  // One type is generated per variant and will be used in the `value` field of
  // the tagged union.
  export type Foo = { tag: "Foo" };
  export type Bar = { tag: "Bar" };
  export type Baz = { tag: "Baz", value: string };

  // Helper functions for constructing each variant of the tagged union.
  // ```
  // const foo = Foo.A(42);
  // assert!(foo.tag === "A");
  // assert!(foo.value === 42);
  // ```
  export const Foo = { tag: "Foo" };
  export const Bar = { tag: "Bar" };
  export const Baz = (value: string): NamespaceTestF => ({ tag: "Baz", value });

  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createSumType([
      new SumTypeVariant("Foo", AlgebraicType.createProductType([])),
      new SumTypeVariant("Bar", AlgebraicType.createProductType([])),
      new SumTypeVariant("Baz", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: NamespaceTestF): void {
      NamespaceTestF.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): NamespaceTestF {
      return NamespaceTestF.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

// The tagged union or sum type for the algebraic type `NamespaceTestF`.
export type NamespaceTestF = NamespaceTestF.Foo | NamespaceTestF.Bar | NamespaceTestF.Baz;

export default NamespaceTestF;

'''
"pk_multi_identity_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { PkMultiIdentity } from "./pk_multi_identity_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `pk_multi_identity`.
 *
 * Obtain a handle from the [`pkMultiIdentity`] property on [`RemoteTables`],
 * like `ctx.db.pkMultiIdentity`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.pkMultiIdentity.on_insert(...)`.
 */
export class PkMultiIdentityTableHandle {
  tableCache: TableCache<PkMultiIdentity>;

  constructor(tableCache: TableCache<PkMultiIdentity>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<PkMultiIdentity> {
    return this.tableCache.iter();
  }
  /**
   * Access to the `id` unique index on the table `pk_multi_identity`,
   * which allows point queries on the field of the same name
   * via the [`PkMultiIdentityIdUnique.find`] method.
   *
   * Users are encouraged not to explicitly reference this type,
   * but to directly chain method calls,
   * like `ctx.db.pkMultiIdentity.id().find(...)`.
   *
   * Get a handle on the `id` unique index on the table `pk_multi_identity`.
   */
  id = {
    // Find the subscribed row whose `id` column value is equal to `col_val`,
    // if such a row is present in the client cache.
    find: (col_val: number): PkMultiIdentity | undefined => {
      for (let row of this.tableCache.iter()) {
        if (deepEqual(row.id, col_val)) {
          return row;
        }
      }
    },
  };
  /**
   * Access to the `other` unique index on the table `pk_multi_identity`,
   * which allows point queries on the field of the same name
   * via the [`PkMultiIdentityOtherUnique.find`] method.
   *
   * Users are encouraged not to explicitly reference this type,
   * but to directly chain method calls,
   * like `ctx.db.pkMultiIdentity.other().find(...)`.
   *
   * Get a handle on the `other` unique index on the table `pk_multi_identity`.
   */
  other = {
    // Find the subscribed row whose `other` column value is equal to `col_val`,
    // if such a row is present in the client cache.
    find: (col_val: number): PkMultiIdentity | undefined => {
      for (let row of this.tableCache.iter()) {
        if (deepEqual(row.other, col_val)) {
          return row;
        }
      }
    },
  };

  onInsert = (cb: (ctx: EventContext, row: PkMultiIdentity) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: PkMultiIdentity) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: PkMultiIdentity) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: PkMultiIdentity) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }

  // Updates are only defined for tables with primary keys.
  onUpdate = (cb: (ctx: EventContext, oldRow: PkMultiIdentity, newRow: PkMultiIdentity) => void) => {
    return this.tableCache.onUpdate(cb);
  }

  removeOnUpdate = (cb: (ctx: EventContext, onRow: PkMultiIdentity, newRow: PkMultiIdentity) => void) => {
    return this.tableCache.removeOnUpdate(cb);
  }}
'''
"pk_multi_identity_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type PkMultiIdentity = {
  id: number,
  other: number,
};

/**
 * A namespace for generated helper functions.
 */
export namespace PkMultiIdentity {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("id", AlgebraicType.createU32Type()),
      new ProductTypeElement("other", AlgebraicType.createU32Type()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: PkMultiIdentity): void {
    PkMultiIdentity.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): PkMultiIdentity {
    return PkMultiIdentity.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"point_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type Point = {
  x: bigint,
  y: bigint,
};

/**
 * A namespace for generated helper functions.
 */
export namespace Point {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("x", AlgebraicType.createI64Type()),
      new ProductTypeElement("y", AlgebraicType.createI64Type()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: Point): void {
    Point.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): Point {
    return Point.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"points_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { Point } from "./point_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `points`.
 *
 * Obtain a handle from the [`points`] property on [`RemoteTables`],
 * like `ctx.db.points`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.points.on_insert(...)`.
 */
export class PointsTableHandle {
  tableCache: TableCache<Point>;

  constructor(tableCache: TableCache<Point>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<Point> {
    return this.tableCache.iter();
  }

  onInsert = (cb: (ctx: EventContext, row: Point) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: Point) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: Point) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: Point) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }
}
'''
"private_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { Private } from "./private_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `private`.
 *
 * Obtain a handle from the [`private`] property on [`RemoteTables`],
 * like `ctx.db.private`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.private.on_insert(...)`.
 */
export class PrivateTableHandle {
  tableCache: TableCache<Private>;

  constructor(tableCache: TableCache<Private>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<Private> {
    return this.tableCache.iter();
  }

  onInsert = (cb: (ctx: EventContext, row: Private) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: Private) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: Private) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: Private) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }
}
'''
"private_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type Private = {
  name: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace Private {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("name", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: Private): void {
    Private.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): Private {
    return Private.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"query_private_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type QueryPrivate = {};

/**
 * A namespace for generated helper functions.
 */
export namespace QueryPrivate {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
    ]);
  }

  export function serialize(writer: BinaryWriter, value: QueryPrivate): void {
    QueryPrivate.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): QueryPrivate {
    return QueryPrivate.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"repeating_test_arg_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { RepeatingTestArg } from "./repeating_test_arg_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `repeating_test_arg`.
 *
 * Obtain a handle from the [`repeatingTestArg`] property on [`RemoteTables`],
 * like `ctx.db.repeatingTestArg`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.repeatingTestArg.on_insert(...)`.
 */
export class RepeatingTestArgTableHandle {
  tableCache: TableCache<RepeatingTestArg>;

  constructor(tableCache: TableCache<RepeatingTestArg>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<RepeatingTestArg> {
    return this.tableCache.iter();
  }
  /**
   * Access to the `scheduled_id` unique index on the table `repeating_test_arg`,
   * which allows point queries on the field of the same name
   * via the [`RepeatingTestArgScheduledIdUnique.find`] method.
   *
   * Users are encouraged not to explicitly reference this type,
   * but to directly chain method calls,
   * like `ctx.db.repeatingTestArg.scheduled_id().find(...)`.
   *
   * Get a handle on the `scheduled_id` unique index on the table `repeating_test_arg`.
   */
  scheduled_id = {
    // Find the subscribed row whose `scheduled_id` column value is equal to `col_val`,
    // if such a row is present in the client cache.
    find: (col_val: bigint): RepeatingTestArg | undefined => {
      for (let row of this.tableCache.iter()) {
        if (deepEqual(row.scheduled_id, col_val)) {
          return row;
        }
      }
    },
  };

  onInsert = (cb: (ctx: EventContext, row: RepeatingTestArg) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: RepeatingTestArg) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: RepeatingTestArg) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: RepeatingTestArg) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }

  // Updates are only defined for tables with primary keys.
  onUpdate = (cb: (ctx: EventContext, oldRow: RepeatingTestArg, newRow: RepeatingTestArg) => void) => {
    return this.tableCache.onUpdate(cb);
  }

  removeOnUpdate = (cb: (ctx: EventContext, onRow: RepeatingTestArg, newRow: RepeatingTestArg) => void) => {
    return this.tableCache.removeOnUpdate(cb);
  }}
'''
"repeating_test_arg_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type RepeatingTestArg = {
  prevTime: bigint,
  scheduledId: bigint,
  scheduledAt: { tag: "Interval", value: bigint } | { tag: "Time", value: bigint },
};

/**
 * A namespace for generated helper functions.
 */
export namespace RepeatingTestArg {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("prevTime", AlgebraicType.createU64Type()),
      new ProductTypeElement("scheduledId", AlgebraicType.createU64Type()),
      new ProductTypeElement("scheduledAt", AlgebraicType.createScheduleAtType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: RepeatingTestArg): void {
    RepeatingTestArg.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): RepeatingTestArg {
    return RepeatingTestArg.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"repeating_test_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

// @ts-ignore
import { RepeatingTestArg as __RepeatingTestArg } from "./repeating_test_arg_type";

export type RepeatingTest = {
  arg: __RepeatingTestArg,
};

/**
 * A namespace for generated helper functions.
 */
export namespace RepeatingTest {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("arg", __RepeatingTestArg.getTypeScriptAlgebraicType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: RepeatingTest): void {
    RepeatingTest.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): RepeatingTest {
    return RepeatingTest.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"test_a_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { TestA } from "./test_a_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `test_a`.
 *
 * Obtain a handle from the [`testA`] property on [`RemoteTables`],
 * like `ctx.db.testA`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.testA.on_insert(...)`.
 */
export class TestATableHandle {
  tableCache: TableCache<TestA>;

  constructor(tableCache: TableCache<TestA>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<TestA> {
    return this.tableCache.iter();
  }

  onInsert = (cb: (ctx: EventContext, row: TestA) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: TestA) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: TestA) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: TestA) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }
}
'''
"test_a_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type TestA = {
  x: number,
  y: number,
  z: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace TestA {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("x", AlgebraicType.createU32Type()),
      new ProductTypeElement("y", AlgebraicType.createU32Type()),
      new ProductTypeElement("z", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: TestA): void {
    TestA.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): TestA {
    return TestA.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"test_b_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type TestB = {
  foo: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace TestB {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("foo", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: TestB): void {
    TestB.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): TestB {
    return TestB.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"test_btree_index_args_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

export type TestBtreeIndexArgs = {};

/**
 * A namespace for generated helper functions.
 */
export namespace TestBtreeIndexArgs {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
    ]);
  }

  export function serialize(writer: BinaryWriter, value: TestBtreeIndexArgs): void {
    TestBtreeIndexArgs.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): TestBtreeIndexArgs {
    return TestBtreeIndexArgs.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
"test_d_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { TestD } from "./test_d_type";
// @ts-ignore
import { NamespaceTestC as __NamespaceTestC } from "./namespace_test_c_type";

// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `test_d`.
 *
 * Obtain a handle from the [`testD`] property on [`RemoteTables`],
 * like `ctx.db.testD`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.testD.on_insert(...)`.
 */
export class TestDTableHandle {
  tableCache: TableCache<TestD>;

  constructor(tableCache: TableCache<TestD>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<TestD> {
    return this.tableCache.iter();
  }

  onInsert = (cb: (ctx: EventContext, row: TestD) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: TestD) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: TestD) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: TestD) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }
}
'''
"test_d_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
// @ts-ignore
import { NamespaceTestC as __NamespaceTestC } from "./namespace_test_c_type";

export type TestD = {
  testC: __NamespaceTestC | undefined,
};

/**
 * A namespace for generated helper functions.
 */
export namespace TestD {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("testC", AlgebraicType.createOptionType(__NamespaceTestC.getTypeScriptAlgebraicType())),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: TestD): void {
    TestD.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): TestD {
    return TestD.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"test_e_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { TestE } from "./test_e_type";
// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `test_e`.
 *
 * Obtain a handle from the [`testE`] property on [`RemoteTables`],
 * like `ctx.db.testE`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.testE.on_insert(...)`.
 */
export class TestETableHandle {
  tableCache: TableCache<TestE>;

  constructor(tableCache: TableCache<TestE>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<TestE> {
    return this.tableCache.iter();
  }
  /**
   * Access to the `id` unique index on the table `test_e`,
   * which allows point queries on the field of the same name
   * via the [`TestEIdUnique.find`] method.
   *
   * Users are encouraged not to explicitly reference this type,
   * but to directly chain method calls,
   * like `ctx.db.testE.id().find(...)`.
   *
   * Get a handle on the `id` unique index on the table `test_e`.
   */
  id = {
    // Find the subscribed row whose `id` column value is equal to `col_val`,
    // if such a row is present in the client cache.
    find: (col_val: bigint): TestE | undefined => {
      for (let row of this.tableCache.iter()) {
        if (deepEqual(row.id, col_val)) {
          return row;
        }
      }
    },
  };

  onInsert = (cb: (ctx: EventContext, row: TestE) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: TestE) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: TestE) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: TestE) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }

  // Updates are only defined for tables with primary keys.
  onUpdate = (cb: (ctx: EventContext, oldRow: TestE, newRow: TestE) => void) => {
    return this.tableCache.onUpdate(cb);
  }

  removeOnUpdate = (cb: (ctx: EventContext, onRow: TestE, newRow: TestE) => void) => {
    return this.tableCache.removeOnUpdate(cb);
  }}
'''
"test_e_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
export type TestE = {
  id: bigint,
  name: string,
};

/**
 * A namespace for generated helper functions.
 */
export namespace TestE {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("id", AlgebraicType.createU64Type()),
      new ProductTypeElement("name", AlgebraicType.createStringType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: TestE): void {
    TestE.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): TestE {
    return TestE.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"test_f_table.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
import { TestFoobar } from "./test_foobar_type";
// @ts-ignore
import { Foobar as __Foobar } from "./foobar_type";

// @ts-ignore
import { EventContext, Reducer, RemoteReducers, RemoteTables } from ".";

/**
 * Table handle for the table `test_f`.
 *
 * Obtain a handle from the [`testF`] property on [`RemoteTables`],
 * like `ctx.db.testF`.
 *
 * Users are encouraged not to explicitly reference this type,
 * but to directly chain method calls,
 * like `ctx.db.testF.on_insert(...)`.
 */
export class TestFTableHandle {
  tableCache: TableCache<TestFoobar>;

  constructor(tableCache: TableCache<TestFoobar>) {
    this.tableCache = tableCache;
  }

  count(): number {
    return this.tableCache.count();
  }

  iter(): Iterable<TestFoobar> {
    return this.tableCache.iter();
  }

  onInsert = (cb: (ctx: EventContext, row: TestFoobar) => void) => {
    return this.tableCache.onInsert(cb);
  }

  removeOnInsert = (cb: (ctx: EventContext, row: TestFoobar) => void) => {
    return this.tableCache.removeOnInsert(cb);
  }

  onDelete = (cb: (ctx: EventContext, row: TestFoobar) => void) => {
    return this.tableCache.onDelete(cb);
  }

  removeOnDelete = (cb: (ctx: EventContext, row: TestFoobar) => void) => {
    return this.tableCache.removeOnDelete(cb);
  }
}
'''
"test_foobar_type.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";
// @ts-ignore
import { Foobar as __Foobar } from "./foobar_type";

export type TestFoobar = {
  field: __Foobar,
};

/**
 * A namespace for generated helper functions.
 */
export namespace TestFoobar {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("field", __Foobar.getTypeScriptAlgebraicType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: TestFoobar): void {
    TestFoobar.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): TestFoobar {
    return TestFoobar.getTypeScriptAlgebraicType().deserialize(reader);
  }

}


'''
"test_reducer.ts" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

import {
  // @ts-ignore
  Address,
  // @ts-ignore
  AlgebraicType,
  // @ts-ignore
  AlgebraicValue,
  // @ts-ignore
  BinaryReader,
  // @ts-ignore
  BinaryWriter,
  // @ts-ignore
  CallReducerFlags,
  // @ts-ignore
  DBConnectionBuilder,
  // @ts-ignore
  DBConnectionImpl,
  // @ts-ignore
  DBContext,
  // @ts-ignore
  Event,
  // @ts-ignore
  EventContextInterface,
  // @ts-ignore
  Identity,
  // @ts-ignore
  ProductType,
  // @ts-ignore
  ProductTypeElement,
  // @ts-ignore
  SumType,
  // @ts-ignore
  SumTypeVariant,
  // @ts-ignore
  TableCache,
  // @ts-ignore
  deepEqual,
} from "@clockworklabs/spacetimedb-sdk";

// @ts-ignore
import { TestA as __TestA } from "./test_a_type";
// @ts-ignore
import { TestB as __TestB } from "./test_b_type";
// @ts-ignore
import { NamespaceTestC as __NamespaceTestC } from "./namespace_test_c_type";
// @ts-ignore
import { NamespaceTestF as __NamespaceTestF } from "./namespace_test_f_type";

export type Test = {
  arg: __TestA,
  arg2: __TestB,
  arg3: __NamespaceTestC,
  arg4: __NamespaceTestF,
};

/**
 * A namespace for generated helper functions.
 */
export namespace Test {
  /**
  * A function which returns this type represented as an AlgebraicType.
  * This function is derived from the AlgebraicType used to generate this type.
  */
  export function getTypeScriptAlgebraicType(): AlgebraicType {
    return AlgebraicType.createProductType([
      new ProductTypeElement("arg", __TestA.getTypeScriptAlgebraicType()),
      new ProductTypeElement("arg2", __TestB.getTypeScriptAlgebraicType()),
      new ProductTypeElement("arg3", __NamespaceTestC.getTypeScriptAlgebraicType()),
      new ProductTypeElement("arg4", __NamespaceTestF.getTypeScriptAlgebraicType()),
    ]);
  }

  export function serialize(writer: BinaryWriter, value: Test): void {
    Test.getTypeScriptAlgebraicType().serialize(writer, value);
  }

  export function deserialize(reader: BinaryReader): Test {
    return Test.getTypeScriptAlgebraicType().deserialize(reader);
  }

}

'''
