---
source: crates/cli/tests/codegen.rs
expression: outfiles
---
"add_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddPlayerArgs {
    pub name: String,
}

impl From<AddPlayerArgs> for super::Reducer {
    fn from(args: AddPlayerArgs) -> Self {
        Self::AddPlayer {
            name: args.name,
}
}
}

impl __sdk::InModule for AddPlayerArgs {
    type Module = super::RemoteModule;
}

pub struct AddPlayerCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_player {
    /// Request that the remote module invoke the reducer `add_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add_player`] callbacks.
    fn add_player(&self, name: String,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add_player`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddPlayerCallbackId`] can be passed to [`Self::remove_on_add_player`]
    /// to cancel the callback.
    fn on_add_player(&self, callback: impl FnMut(&super::ReducerEventContext, &String, ) + Send + 'static) -> AddPlayerCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add_player`],
    /// causing it not to run in the future.
    fn remove_on_add_player(&self, callback: AddPlayerCallbackId);
}

impl add_player for super::RemoteReducers {
    fn add_player(&self, name: String,
) -> __sdk::Result<()> {
        self.imp.call_reducer("add_player", AddPlayerArgs { name,  })
    }
    fn on_add_player(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &String, ) + Send + 'static,
    ) -> AddPlayerCallbackId {
        AddPlayerCallbackId(self.imp.on_reducer(
            "add_player",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::AddPlayer {
                            name, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, )
            }),
        ))
    }
    fn remove_on_add_player(&self, callback: AddPlayerCallbackId) {
        self.imp.remove_on_reducer("add_player", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `add_player`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_add_player {
    /// Set the call-reducer flags for the reducer `add_player` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn add_player(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_add_player for super::SetReducerFlags {
    fn add_player(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("add_player", flags);
    }
}

'''
"add_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddPrivateArgs {
    pub name: String,
}

impl From<AddPrivateArgs> for super::Reducer {
    fn from(args: AddPrivateArgs) -> Self {
        Self::AddPrivate {
            name: args.name,
}
}
}

impl __sdk::InModule for AddPrivateArgs {
    type Module = super::RemoteModule;
}

pub struct AddPrivateCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_private {
    /// Request that the remote module invoke the reducer `add_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add_private`] callbacks.
    fn add_private(&self, name: String,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add_private`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddPrivateCallbackId`] can be passed to [`Self::remove_on_add_private`]
    /// to cancel the callback.
    fn on_add_private(&self, callback: impl FnMut(&super::ReducerEventContext, &String, ) + Send + 'static) -> AddPrivateCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add_private`],
    /// causing it not to run in the future.
    fn remove_on_add_private(&self, callback: AddPrivateCallbackId);
}

impl add_private for super::RemoteReducers {
    fn add_private(&self, name: String,
) -> __sdk::Result<()> {
        self.imp.call_reducer("add_private", AddPrivateArgs { name,  })
    }
    fn on_add_private(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &String, ) + Send + 'static,
    ) -> AddPrivateCallbackId {
        AddPrivateCallbackId(self.imp.on_reducer(
            "add_private",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::AddPrivate {
                            name, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, )
            }),
        ))
    }
    fn remove_on_add_private(&self, callback: AddPrivateCallbackId) {
        self.imp.remove_on_reducer("add_private", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `add_private`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_add_private {
    /// Set the call-reducer flags for the reducer `add_private` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn add_private(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_add_private for super::SetReducerFlags {
    fn add_private(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("add_private", flags);
    }
}

'''
"add_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddArgs {
    pub name: String,
    pub age: u8,
}

impl From<AddArgs> for super::Reducer {
    fn from(args: AddArgs) -> Self {
        Self::Add {
            name: args.name,
            age: args.age,
}
}
}

impl __sdk::InModule for AddArgs {
    type Module = super::RemoteModule;
}

pub struct AddCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add {
    /// Request that the remote module invoke the reducer `add` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add`] callbacks.
    fn add(&self, name: String,
age: u8,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddCallbackId`] can be passed to [`Self::remove_on_add`]
    /// to cancel the callback.
    fn on_add(&self, callback: impl FnMut(&super::ReducerEventContext, &String, &u8, ) + Send + 'static) -> AddCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add`],
    /// causing it not to run in the future.
    fn remove_on_add(&self, callback: AddCallbackId);
}

impl add for super::RemoteReducers {
    fn add(&self, name: String,
age: u8,
) -> __sdk::Result<()> {
        self.imp.call_reducer("add", AddArgs { name, age,  })
    }
    fn on_add(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &String, &u8, ) + Send + 'static,
    ) -> AddCallbackId {
        AddCallbackId(self.imp.on_reducer(
            "add",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::Add {
                            name, age, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, age, )
            }),
        ))
    }
    fn remove_on_add(&self, callback: AddCallbackId) {
        self.imp.remove_on_reducer("add", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `add`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_add {
    /// Set the call-reducer flags for the reducer `add` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn add(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_add for super::SetReducerFlags {
    fn add(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("add", flags);
    }
}

'''
"assert_caller_identity_is_module_identity_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AssertCallerIdentityIsModuleIdentityArgs {
    }

impl From<AssertCallerIdentityIsModuleIdentityArgs> for super::Reducer {
    fn from(args: AssertCallerIdentityIsModuleIdentityArgs) -> Self {
        Self::AssertCallerIdentityIsModuleIdentity
}
}

impl __sdk::InModule for AssertCallerIdentityIsModuleIdentityArgs {
    type Module = super::RemoteModule;
}

pub struct AssertCallerIdentityIsModuleIdentityCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `assert_caller_identity_is_module_identity`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait assert_caller_identity_is_module_identity {
    /// Request that the remote module invoke the reducer `assert_caller_identity_is_module_identity` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_assert_caller_identity_is_module_identity`] callbacks.
    fn assert_caller_identity_is_module_identity(&self, ) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `assert_caller_identity_is_module_identity`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AssertCallerIdentityIsModuleIdentityCallbackId`] can be passed to [`Self::remove_on_assert_caller_identity_is_module_identity`]
    /// to cancel the callback.
    fn on_assert_caller_identity_is_module_identity(&self, callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static) -> AssertCallerIdentityIsModuleIdentityCallbackId;
    /// Cancel a callback previously registered by [`Self::on_assert_caller_identity_is_module_identity`],
    /// causing it not to run in the future.
    fn remove_on_assert_caller_identity_is_module_identity(&self, callback: AssertCallerIdentityIsModuleIdentityCallbackId);
}

impl assert_caller_identity_is_module_identity for super::RemoteReducers {
    fn assert_caller_identity_is_module_identity(&self, ) -> __sdk::Result<()> {
        self.imp.call_reducer("assert_caller_identity_is_module_identity", AssertCallerIdentityIsModuleIdentityArgs {  })
    }
    fn on_assert_caller_identity_is_module_identity(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static,
    ) -> AssertCallerIdentityIsModuleIdentityCallbackId {
        AssertCallerIdentityIsModuleIdentityCallbackId(self.imp.on_reducer(
            "assert_caller_identity_is_module_identity",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::AssertCallerIdentityIsModuleIdentity {
                            
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_assert_caller_identity_is_module_identity(&self, callback: AssertCallerIdentityIsModuleIdentityCallbackId) {
        self.imp.remove_on_reducer("assert_caller_identity_is_module_identity", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `assert_caller_identity_is_module_identity`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_assert_caller_identity_is_module_identity {
    /// Set the call-reducer flags for the reducer `assert_caller_identity_is_module_identity` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn assert_caller_identity_is_module_identity(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_assert_caller_identity_is_module_identity for super::SetReducerFlags {
    fn assert_caller_identity_is_module_identity(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("assert_caller_identity_is_module_identity", flags);
    }
}

'''
"baz_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Baz {
    pub field: String,
}


impl __sdk::InModule for Baz {
    type Module = super::RemoteModule;
}

'''
"client_connected_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct ClientConnectedArgs {
    }

impl From<ClientConnectedArgs> for super::Reducer {
    fn from(args: ClientConnectedArgs) -> Self {
        Self::ClientConnected
}
}

impl __sdk::InModule for ClientConnectedArgs {
    type Module = super::RemoteModule;
}

pub struct ClientConnectedCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `client_connected`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait client_connected {
    /// Request that the remote module invoke the reducer `client_connected` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_client_connected`] callbacks.
    fn client_connected(&self, ) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `client_connected`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`ClientConnectedCallbackId`] can be passed to [`Self::remove_on_client_connected`]
    /// to cancel the callback.
    fn on_client_connected(&self, callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static) -> ClientConnectedCallbackId;
    /// Cancel a callback previously registered by [`Self::on_client_connected`],
    /// causing it not to run in the future.
    fn remove_on_client_connected(&self, callback: ClientConnectedCallbackId);
}

impl client_connected for super::RemoteReducers {
    fn client_connected(&self, ) -> __sdk::Result<()> {
        self.imp.call_reducer("client_connected", ClientConnectedArgs {  })
    }
    fn on_client_connected(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static,
    ) -> ClientConnectedCallbackId {
        ClientConnectedCallbackId(self.imp.on_reducer(
            "client_connected",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::ClientConnected {
                            
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_client_connected(&self, callback: ClientConnectedCallbackId) {
        self.imp.remove_on_reducer("client_connected", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `client_connected`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_client_connected {
    /// Set the call-reducer flags for the reducer `client_connected` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn client_connected(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_client_connected for super::SetReducerFlags {
    fn client_connected(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("client_connected", flags);
    }
}

'''
"delete_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct DeletePlayerArgs {
    pub id: u64,
}

impl From<DeletePlayerArgs> for super::Reducer {
    fn from(args: DeletePlayerArgs) -> Self {
        Self::DeletePlayer {
            id: args.id,
}
}
}

impl __sdk::InModule for DeletePlayerArgs {
    type Module = super::RemoteModule;
}

pub struct DeletePlayerCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_player {
    /// Request that the remote module invoke the reducer `delete_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_delete_player`] callbacks.
    fn delete_player(&self, id: u64,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `delete_player`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`DeletePlayerCallbackId`] can be passed to [`Self::remove_on_delete_player`]
    /// to cancel the callback.
    fn on_delete_player(&self, callback: impl FnMut(&super::ReducerEventContext, &u64, ) + Send + 'static) -> DeletePlayerCallbackId;
    /// Cancel a callback previously registered by [`Self::on_delete_player`],
    /// causing it not to run in the future.
    fn remove_on_delete_player(&self, callback: DeletePlayerCallbackId);
}

impl delete_player for super::RemoteReducers {
    fn delete_player(&self, id: u64,
) -> __sdk::Result<()> {
        self.imp.call_reducer("delete_player", DeletePlayerArgs { id,  })
    }
    fn on_delete_player(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &u64, ) + Send + 'static,
    ) -> DeletePlayerCallbackId {
        DeletePlayerCallbackId(self.imp.on_reducer(
            "delete_player",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::DeletePlayer {
                            id, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, id, )
            }),
        ))
    }
    fn remove_on_delete_player(&self, callback: DeletePlayerCallbackId) {
        self.imp.remove_on_reducer("delete_player", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `delete_player`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_delete_player {
    /// Set the call-reducer flags for the reducer `delete_player` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn delete_player(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_delete_player for super::SetReducerFlags {
    fn delete_player(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("delete_player", flags);
    }
}

'''
"delete_players_by_name_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct DeletePlayersByNameArgs {
    pub name: String,
}

impl From<DeletePlayersByNameArgs> for super::Reducer {
    fn from(args: DeletePlayersByNameArgs) -> Self {
        Self::DeletePlayersByName {
            name: args.name,
}
}
}

impl __sdk::InModule for DeletePlayersByNameArgs {
    type Module = super::RemoteModule;
}

pub struct DeletePlayersByNameCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_players_by_name`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_players_by_name {
    /// Request that the remote module invoke the reducer `delete_players_by_name` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_delete_players_by_name`] callbacks.
    fn delete_players_by_name(&self, name: String,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `delete_players_by_name`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`DeletePlayersByNameCallbackId`] can be passed to [`Self::remove_on_delete_players_by_name`]
    /// to cancel the callback.
    fn on_delete_players_by_name(&self, callback: impl FnMut(&super::ReducerEventContext, &String, ) + Send + 'static) -> DeletePlayersByNameCallbackId;
    /// Cancel a callback previously registered by [`Self::on_delete_players_by_name`],
    /// causing it not to run in the future.
    fn remove_on_delete_players_by_name(&self, callback: DeletePlayersByNameCallbackId);
}

impl delete_players_by_name for super::RemoteReducers {
    fn delete_players_by_name(&self, name: String,
) -> __sdk::Result<()> {
        self.imp.call_reducer("delete_players_by_name", DeletePlayersByNameArgs { name,  })
    }
    fn on_delete_players_by_name(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &String, ) + Send + 'static,
    ) -> DeletePlayersByNameCallbackId {
        DeletePlayersByNameCallbackId(self.imp.on_reducer(
            "delete_players_by_name",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::DeletePlayersByName {
                            name, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, )
            }),
        ))
    }
    fn remove_on_delete_players_by_name(&self, callback: DeletePlayersByNameCallbackId) {
        self.imp.remove_on_reducer("delete_players_by_name", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `delete_players_by_name`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_delete_players_by_name {
    /// Set the call-reducer flags for the reducer `delete_players_by_name` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn delete_players_by_name(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_delete_players_by_name for super::SetReducerFlags {
    fn delete_players_by_name(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("delete_players_by_name", flags);
    }
}

'''
"foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::baz_type::Baz;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum Foobar {
    Baz(Baz),

    Bar,

    Har(u32),

}



impl __sdk::InModule for Foobar {
    type Module = super::RemoteModule;
}

'''
"has_special_stuff_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::has_special_stuff_type::HasSpecialStuff;

/// Table handle for the table `has_special_stuff`.
///
/// Obtain a handle from the [`HasSpecialStuffTableAccess::has_special_stuff`] method on [`super::RemoteTables`],
/// like `ctx.db.has_special_stuff()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.has_special_stuff().on_insert(...)`.
pub struct HasSpecialStuffTableHandle<'ctx> {
    imp: __sdk::TableHandle<HasSpecialStuff>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `has_special_stuff`.
///
/// Implemented for [`super::RemoteTables`].
pub trait HasSpecialStuffTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`HasSpecialStuffTableHandle`], which mediates access to the table `has_special_stuff`.
    fn has_special_stuff(&self) -> HasSpecialStuffTableHandle<'_>;
}

impl HasSpecialStuffTableAccess for super::RemoteTables {
    fn has_special_stuff(&self) -> HasSpecialStuffTableHandle<'_> {
        HasSpecialStuffTableHandle {
            imp: self.imp.get_table::<HasSpecialStuff>("has_special_stuff"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct HasSpecialStuffInsertCallbackId(__sdk::CallbackId);
pub struct HasSpecialStuffDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for HasSpecialStuffTableHandle<'ctx> {
    type Row = HasSpecialStuff;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = HasSpecialStuff> + '_ { self.imp.iter() }

    type InsertCallbackId = HasSpecialStuffInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> HasSpecialStuffInsertCallbackId {
        HasSpecialStuffInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: HasSpecialStuffInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = HasSpecialStuffDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> HasSpecialStuffDeleteCallbackId {
        HasSpecialStuffDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: HasSpecialStuffDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<HasSpecialStuff>("has_special_stuff");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<HasSpecialStuff>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<HasSpecialStuff>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}
'''
"has_special_stuff_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct HasSpecialStuff {
    pub identity: __sdk::Identity,
    pub connection_id: __sdk::ConnectionId,
}


impl __sdk::InModule for HasSpecialStuff {
    type Module = super::RemoteModule;
}

'''
"list_over_age_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct ListOverAgeArgs {
    pub age: u8,
}

impl From<ListOverAgeArgs> for super::Reducer {
    fn from(args: ListOverAgeArgs) -> Self {
        Self::ListOverAge {
            age: args.age,
}
}
}

impl __sdk::InModule for ListOverAgeArgs {
    type Module = super::RemoteModule;
}

pub struct ListOverAgeCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `list_over_age`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait list_over_age {
    /// Request that the remote module invoke the reducer `list_over_age` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_list_over_age`] callbacks.
    fn list_over_age(&self, age: u8,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `list_over_age`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`ListOverAgeCallbackId`] can be passed to [`Self::remove_on_list_over_age`]
    /// to cancel the callback.
    fn on_list_over_age(&self, callback: impl FnMut(&super::ReducerEventContext, &u8, ) + Send + 'static) -> ListOverAgeCallbackId;
    /// Cancel a callback previously registered by [`Self::on_list_over_age`],
    /// causing it not to run in the future.
    fn remove_on_list_over_age(&self, callback: ListOverAgeCallbackId);
}

impl list_over_age for super::RemoteReducers {
    fn list_over_age(&self, age: u8,
) -> __sdk::Result<()> {
        self.imp.call_reducer("list_over_age", ListOverAgeArgs { age,  })
    }
    fn on_list_over_age(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &u8, ) + Send + 'static,
    ) -> ListOverAgeCallbackId {
        ListOverAgeCallbackId(self.imp.on_reducer(
            "list_over_age",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::ListOverAge {
                            age, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, age, )
            }),
        ))
    }
    fn remove_on_list_over_age(&self, callback: ListOverAgeCallbackId) {
        self.imp.remove_on_reducer("list_over_age", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `list_over_age`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_list_over_age {
    /// Set the call-reducer flags for the reducer `list_over_age` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn list_over_age(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_list_over_age for super::SetReducerFlags {
    fn list_over_age(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("list_over_age", flags);
    }
}

'''
"log_module_identity_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct LogModuleIdentityArgs {
    }

impl From<LogModuleIdentityArgs> for super::Reducer {
    fn from(args: LogModuleIdentityArgs) -> Self {
        Self::LogModuleIdentity
}
}

impl __sdk::InModule for LogModuleIdentityArgs {
    type Module = super::RemoteModule;
}

pub struct LogModuleIdentityCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `log_module_identity`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait log_module_identity {
    /// Request that the remote module invoke the reducer `log_module_identity` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_log_module_identity`] callbacks.
    fn log_module_identity(&self, ) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `log_module_identity`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`LogModuleIdentityCallbackId`] can be passed to [`Self::remove_on_log_module_identity`]
    /// to cancel the callback.
    fn on_log_module_identity(&self, callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static) -> LogModuleIdentityCallbackId;
    /// Cancel a callback previously registered by [`Self::on_log_module_identity`],
    /// causing it not to run in the future.
    fn remove_on_log_module_identity(&self, callback: LogModuleIdentityCallbackId);
}

impl log_module_identity for super::RemoteReducers {
    fn log_module_identity(&self, ) -> __sdk::Result<()> {
        self.imp.call_reducer("log_module_identity", LogModuleIdentityArgs {  })
    }
    fn on_log_module_identity(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static,
    ) -> LogModuleIdentityCallbackId {
        LogModuleIdentityCallbackId(self.imp.on_reducer(
            "log_module_identity",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::LogModuleIdentity {
                            
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_log_module_identity(&self, callback: LogModuleIdentityCallbackId) {
        self.imp.remove_on_reducer("log_module_identity", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `log_module_identity`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_log_module_identity {
    /// Set the call-reducer flags for the reducer `log_module_identity` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn log_module_identity(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_log_module_identity for super::SetReducerFlags {
    fn log_module_identity(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("log_module_identity", flags);
    }
}

'''
"logged_out_player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `logged_out_player`.
///
/// Obtain a handle from the [`LoggedOutPlayerTableAccess::logged_out_player`] method on [`super::RemoteTables`],
/// like `ctx.db.logged_out_player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.logged_out_player().on_insert(...)`.
pub struct LoggedOutPlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `logged_out_player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait LoggedOutPlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`LoggedOutPlayerTableHandle`], which mediates access to the table `logged_out_player`.
    fn logged_out_player(&self) -> LoggedOutPlayerTableHandle<'_>;
}

impl LoggedOutPlayerTableAccess for super::RemoteTables {
    fn logged_out_player(&self) -> LoggedOutPlayerTableHandle<'_> {
        LoggedOutPlayerTableHandle {
            imp: self.imp.get_table::<Player>("logged_out_player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct LoggedOutPlayerInsertCallbackId(__sdk::CallbackId);
pub struct LoggedOutPlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for LoggedOutPlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = LoggedOutPlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerInsertCallbackId {
        LoggedOutPlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: LoggedOutPlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = LoggedOutPlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerDeleteCallbackId {
        LoggedOutPlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: LoggedOutPlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<Player>("logged_out_player");
    _table.add_unique_constraint::<__sdk::Identity>("identity", |row| &row.identity);
    _table.add_unique_constraint::<u64>("player_id", |row| &row.player_id);
    _table.add_unique_constraint::<String>("name", |row| &row.name);
}
pub struct LoggedOutPlayerUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for LoggedOutPlayerTableHandle<'ctx> {
    type UpdateCallbackId = LoggedOutPlayerUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerUpdateCallbackId {
        LoggedOutPlayerUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: LoggedOutPlayerUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}


#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Player>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        /// Access to the `identity` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerIdentityUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().identity().find(...)`.
        pub struct LoggedOutPlayerIdentityUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, __sdk::Identity>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `identity` unique index on the table `logged_out_player`.
            pub fn identity(&self) -> LoggedOutPlayerIdentityUnique<'ctx> {
                LoggedOutPlayerIdentityUnique {
                    imp: self.imp.get_unique_constraint::<__sdk::Identity>("identity"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerIdentityUnique<'ctx> {
            /// Find the subscribed row whose `identity` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &__sdk::Identity) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `player_id` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerPlayerIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().player_id().find(...)`.
        pub struct LoggedOutPlayerPlayerIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `player_id` unique index on the table `logged_out_player`.
            pub fn player_id(&self) -> LoggedOutPlayerPlayerIdUnique<'ctx> {
                LoggedOutPlayerPlayerIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("player_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerPlayerIdUnique<'ctx> {
            /// Find the subscribed row whose `player_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `name` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerNameUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().name().find(...)`.
        pub struct LoggedOutPlayerNameUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, String>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `name` unique index on the table `logged_out_player`.
            pub fn name(&self) -> LoggedOutPlayerNameUnique<'ctx> {
                LoggedOutPlayerNameUnique {
                    imp: self.imp.get_unique_constraint::<String>("name"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerNameUnique<'ctx> {
            /// Find the subscribed row whose `name` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &String) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        '''
"mod.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

pub mod baz_type;
pub mod foobar_type;
pub mod has_special_stuff_type;
pub mod person_type;
pub mod pk_multi_identity_type;
pub mod player_type;
pub mod point_type;
pub mod private_table_type;
pub mod repeating_test_arg_type;
pub mod test_a_type;
pub mod test_b_type;
pub mod test_d_type;
pub mod test_e_type;
pub mod test_foobar_type;
pub mod namespace_test_c_type;
pub mod namespace_test_f_type;
pub mod add_reducer;
pub mod add_player_reducer;
pub mod add_private_reducer;
pub mod assert_caller_identity_is_module_identity_reducer;
pub mod client_connected_reducer;
pub mod delete_player_reducer;
pub mod delete_players_by_name_reducer;
pub mod list_over_age_reducer;
pub mod log_module_identity_reducer;
pub mod query_private_reducer;
pub mod repeating_test_reducer;
pub mod say_hello_reducer;
pub mod test_reducer;
pub mod test_btree_index_args_reducer;
pub mod has_special_stuff_table;
pub mod logged_out_player_table;
pub mod person_table;
pub mod pk_multi_identity_table;
pub mod player_table;
pub mod points_table;
pub mod private_table_table;
pub mod repeating_test_arg_table;
pub mod test_a_table;
pub mod test_d_table;
pub mod test_e_table;
pub mod test_f_table;

pub use baz_type::Baz;
pub use foobar_type::Foobar;
pub use has_special_stuff_type::HasSpecialStuff;
pub use person_type::Person;
pub use pk_multi_identity_type::PkMultiIdentity;
pub use player_type::Player;
pub use point_type::Point;
pub use private_table_type::PrivateTable;
pub use repeating_test_arg_type::RepeatingTestArg;
pub use test_a_type::TestA;
pub use test_b_type::TestB;
pub use test_d_type::TestD;
pub use test_e_type::TestE;
pub use test_foobar_type::TestFoobar;
pub use namespace_test_c_type::NamespaceTestC;
pub use namespace_test_f_type::NamespaceTestF;
pub use has_special_stuff_table::*;
pub use logged_out_player_table::*;
pub use person_table::*;
pub use pk_multi_identity_table::*;
pub use player_table::*;
pub use points_table::*;
pub use private_table_table::*;
pub use repeating_test_arg_table::*;
pub use test_a_table::*;
pub use test_d_table::*;
pub use test_e_table::*;
pub use test_f_table::*;
pub use add_reducer::{add, set_flags_for_add, AddCallbackId};
pub use add_player_reducer::{add_player, set_flags_for_add_player, AddPlayerCallbackId};
pub use add_private_reducer::{add_private, set_flags_for_add_private, AddPrivateCallbackId};
pub use assert_caller_identity_is_module_identity_reducer::{assert_caller_identity_is_module_identity, set_flags_for_assert_caller_identity_is_module_identity, AssertCallerIdentityIsModuleIdentityCallbackId};
pub use client_connected_reducer::{client_connected, set_flags_for_client_connected, ClientConnectedCallbackId};
pub use delete_player_reducer::{delete_player, set_flags_for_delete_player, DeletePlayerCallbackId};
pub use delete_players_by_name_reducer::{delete_players_by_name, set_flags_for_delete_players_by_name, DeletePlayersByNameCallbackId};
pub use list_over_age_reducer::{list_over_age, set_flags_for_list_over_age, ListOverAgeCallbackId};
pub use log_module_identity_reducer::{log_module_identity, set_flags_for_log_module_identity, LogModuleIdentityCallbackId};
pub use query_private_reducer::{query_private, set_flags_for_query_private, QueryPrivateCallbackId};
pub use repeating_test_reducer::{repeating_test, set_flags_for_repeating_test, RepeatingTestCallbackId};
pub use say_hello_reducer::{say_hello, set_flags_for_say_hello, SayHelloCallbackId};
pub use test_reducer::{test, set_flags_for_test, TestCallbackId};
pub use test_btree_index_args_reducer::{test_btree_index_args, set_flags_for_test_btree_index_args, TestBtreeIndexArgsCallbackId};

#[derive(Clone, PartialEq, Debug)]

/// One of the reducers defined by this module.
///
/// Contained within a [`__sdk::ReducerEvent`] in [`EventContext`]s for reducer events
/// to indicate which reducer caused the event.

pub enum Reducer {
        Add {
        name: String,
        age: u8,
}    ,
    AddPlayer {
        name: String,
}    ,
    AddPrivate {
        name: String,
}    ,
    AssertCallerIdentityIsModuleIdentity ,
    ClientConnected ,
    DeletePlayer {
        id: u64,
}    ,
    DeletePlayersByName {
        name: String,
}    ,
    ListOverAge {
        age: u8,
}    ,
    LogModuleIdentity ,
    QueryPrivate ,
    RepeatingTest {
        arg: RepeatingTestArg,
}    ,
    SayHello ,
    Test {
        arg: TestA,
        arg_2: TestB,
        arg_3: NamespaceTestC,
        arg_4: NamespaceTestF,
}    ,
    TestBtreeIndexArgs ,
}


impl __sdk::InModule for Reducer {
    type Module = RemoteModule;
}

impl __sdk::Reducer for Reducer {
    fn reducer_name(&self) -> &'static str {
        match self {
                        Reducer::Add { .. } => "add",
            Reducer::AddPlayer { .. } => "add_player",
            Reducer::AddPrivate { .. } => "add_private",
            Reducer::AssertCallerIdentityIsModuleIdentity => "assert_caller_identity_is_module_identity",
            Reducer::ClientConnected => "client_connected",
            Reducer::DeletePlayer { .. } => "delete_player",
            Reducer::DeletePlayersByName { .. } => "delete_players_by_name",
            Reducer::ListOverAge { .. } => "list_over_age",
            Reducer::LogModuleIdentity => "log_module_identity",
            Reducer::QueryPrivate => "query_private",
            Reducer::RepeatingTest { .. } => "repeating_test",
            Reducer::SayHello => "say_hello",
            Reducer::Test { .. } => "test",
            Reducer::TestBtreeIndexArgs => "test_btree_index_args",
}
}
}
impl TryFrom<__ws::ReducerCallInfo<__ws::BsatnFormat>> for Reducer {
        type Error = __sdk::Error;
fn try_from(value: __ws::ReducerCallInfo<__ws::BsatnFormat>) -> __sdk::Result<Self> {
        match &value.reducer_name[..] {
                        "add" => Ok(__sdk::parse_reducer_args::<add_reducer::AddArgs>("add", &value.args)?.into()),
            "add_player" => Ok(__sdk::parse_reducer_args::<add_player_reducer::AddPlayerArgs>("add_player", &value.args)?.into()),
            "add_private" => Ok(__sdk::parse_reducer_args::<add_private_reducer::AddPrivateArgs>("add_private", &value.args)?.into()),
            "assert_caller_identity_is_module_identity" => Ok(__sdk::parse_reducer_args::<assert_caller_identity_is_module_identity_reducer::AssertCallerIdentityIsModuleIdentityArgs>("assert_caller_identity_is_module_identity", &value.args)?.into()),
            "client_connected" => Ok(__sdk::parse_reducer_args::<client_connected_reducer::ClientConnectedArgs>("client_connected", &value.args)?.into()),
            "delete_player" => Ok(__sdk::parse_reducer_args::<delete_player_reducer::DeletePlayerArgs>("delete_player", &value.args)?.into()),
            "delete_players_by_name" => Ok(__sdk::parse_reducer_args::<delete_players_by_name_reducer::DeletePlayersByNameArgs>("delete_players_by_name", &value.args)?.into()),
            "list_over_age" => Ok(__sdk::parse_reducer_args::<list_over_age_reducer::ListOverAgeArgs>("list_over_age", &value.args)?.into()),
            "log_module_identity" => Ok(__sdk::parse_reducer_args::<log_module_identity_reducer::LogModuleIdentityArgs>("log_module_identity", &value.args)?.into()),
            "query_private" => Ok(__sdk::parse_reducer_args::<query_private_reducer::QueryPrivateArgs>("query_private", &value.args)?.into()),
            "repeating_test" => Ok(__sdk::parse_reducer_args::<repeating_test_reducer::RepeatingTestArgs>("repeating_test", &value.args)?.into()),
            "say_hello" => Ok(__sdk::parse_reducer_args::<say_hello_reducer::SayHelloArgs>("say_hello", &value.args)?.into()),
            "test" => Ok(__sdk::parse_reducer_args::<test_reducer::TestArgs>("test", &value.args)?.into()),
            "test_btree_index_args" => Ok(__sdk::parse_reducer_args::<test_btree_index_args_reducer::TestBtreeIndexArgsArgs>("test_btree_index_args", &value.args)?.into()),
            unknown => Err(__sdk::InternalError::unknown_name("reducer", unknown, "ReducerCallInfo").into()),
}
}
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct DbUpdate {
        has_special_stuff: __sdk::TableUpdate<HasSpecialStuff>,
    logged_out_player: __sdk::TableUpdate<Player>,
    person: __sdk::TableUpdate<Person>,
    pk_multi_identity: __sdk::TableUpdate<PkMultiIdentity>,
    player: __sdk::TableUpdate<Player>,
    points: __sdk::TableUpdate<Point>,
    private_table: __sdk::TableUpdate<PrivateTable>,
    repeating_test_arg: __sdk::TableUpdate<RepeatingTestArg>,
    test_a: __sdk::TableUpdate<TestA>,
    test_d: __sdk::TableUpdate<TestD>,
    test_e: __sdk::TableUpdate<TestE>,
    test_f: __sdk::TableUpdate<TestFoobar>,
}


impl TryFrom<__ws::DatabaseUpdate<__ws::BsatnFormat>> for DbUpdate {
    type Error = __sdk::Error;
    fn try_from(raw: __ws::DatabaseUpdate<__ws::BsatnFormat>) -> Result<Self, Self::Error> {
        let mut db_update = DbUpdate::default();
        for table_update in raw.tables {
            match &table_update.table_name[..] {

        "has_special_stuff" => db_update.has_special_stuff = has_special_stuff_table::parse_table_update(table_update)?,
    "logged_out_player" => db_update.logged_out_player = logged_out_player_table::parse_table_update(table_update)?,
    "person" => db_update.person = person_table::parse_table_update(table_update)?,
    "pk_multi_identity" => db_update.pk_multi_identity = pk_multi_identity_table::parse_table_update(table_update)?,
    "player" => db_update.player = player_table::parse_table_update(table_update)?,
    "points" => db_update.points = points_table::parse_table_update(table_update)?,
    "private_table" => db_update.private_table = private_table_table::parse_table_update(table_update)?,
    "repeating_test_arg" => db_update.repeating_test_arg = repeating_test_arg_table::parse_table_update(table_update)?,
    "test_a" => db_update.test_a = test_a_table::parse_table_update(table_update)?,
    "test_d" => db_update.test_d = test_d_table::parse_table_update(table_update)?,
    "test_e" => db_update.test_e = test_e_table::parse_table_update(table_update)?,
    "test_f" => db_update.test_f = test_f_table::parse_table_update(table_update)?,

                unknown => {
                    return Err(__sdk::InternalError::unknown_name(
                        "table",
                        unknown,
                        "DatabaseUpdate",
                    ).into());
                }
            }
        }
        Ok(db_update)
    }
}

impl __sdk::InModule for DbUpdate {
    type Module = RemoteModule;
}

impl __sdk::DbUpdate for DbUpdate {
    fn apply_to_client_cache(&self, cache: &mut __sdk::ClientCache<RemoteModule>) -> AppliedDiff<'_> {
                    let mut diff = AppliedDiff::default();
                
                diff.has_special_stuff = cache.apply_diff_to_table::<HasSpecialStuff>("has_special_stuff", &self.has_special_stuff);
        diff.logged_out_player = cache.apply_diff_to_table::<Player>("logged_out_player", &self.logged_out_player).with_updates_by_pk(|row| &row.identity);
        diff.person = cache.apply_diff_to_table::<Person>("person", &self.person).with_updates_by_pk(|row| &row.id);
        diff.pk_multi_identity = cache.apply_diff_to_table::<PkMultiIdentity>("pk_multi_identity", &self.pk_multi_identity).with_updates_by_pk(|row| &row.id);
        diff.player = cache.apply_diff_to_table::<Player>("player", &self.player).with_updates_by_pk(|row| &row.identity);
        diff.points = cache.apply_diff_to_table::<Point>("points", &self.points);
        diff.private_table = cache.apply_diff_to_table::<PrivateTable>("private_table", &self.private_table);
        diff.repeating_test_arg = cache.apply_diff_to_table::<RepeatingTestArg>("repeating_test_arg", &self.repeating_test_arg).with_updates_by_pk(|row| &row.scheduled_id);
        diff.test_a = cache.apply_diff_to_table::<TestA>("test_a", &self.test_a);
        diff.test_d = cache.apply_diff_to_table::<TestD>("test_d", &self.test_d);
        diff.test_e = cache.apply_diff_to_table::<TestE>("test_e", &self.test_e).with_updates_by_pk(|row| &row.id);
        diff.test_f = cache.apply_diff_to_table::<TestFoobar>("test_f", &self.test_f);

                    diff
                }
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct AppliedDiff<'r> {
        has_special_stuff: __sdk::TableAppliedDiff<'r, HasSpecialStuff>,
    logged_out_player: __sdk::TableAppliedDiff<'r, Player>,
    person: __sdk::TableAppliedDiff<'r, Person>,
    pk_multi_identity: __sdk::TableAppliedDiff<'r, PkMultiIdentity>,
    player: __sdk::TableAppliedDiff<'r, Player>,
    points: __sdk::TableAppliedDiff<'r, Point>,
    private_table: __sdk::TableAppliedDiff<'r, PrivateTable>,
    repeating_test_arg: __sdk::TableAppliedDiff<'r, RepeatingTestArg>,
    test_a: __sdk::TableAppliedDiff<'r, TestA>,
    test_d: __sdk::TableAppliedDiff<'r, TestD>,
    test_e: __sdk::TableAppliedDiff<'r, TestE>,
    test_f: __sdk::TableAppliedDiff<'r, TestFoobar>,
}


impl __sdk::InModule for AppliedDiff<'_> {
    type Module = RemoteModule;
}

impl<'r> __sdk::AppliedDiff<'r> for AppliedDiff<'r> {
    fn invoke_row_callbacks(&self, event: &EventContext, callbacks: &mut __sdk::DbCallbacks<RemoteModule>) {
                callbacks.invoke_table_row_callbacks::<HasSpecialStuff>("has_special_stuff", &self.has_special_stuff, event);
        callbacks.invoke_table_row_callbacks::<Player>("logged_out_player", &self.logged_out_player, event);
        callbacks.invoke_table_row_callbacks::<Person>("person", &self.person, event);
        callbacks.invoke_table_row_callbacks::<PkMultiIdentity>("pk_multi_identity", &self.pk_multi_identity, event);
        callbacks.invoke_table_row_callbacks::<Player>("player", &self.player, event);
        callbacks.invoke_table_row_callbacks::<Point>("points", &self.points, event);
        callbacks.invoke_table_row_callbacks::<PrivateTable>("private_table", &self.private_table, event);
        callbacks.invoke_table_row_callbacks::<RepeatingTestArg>("repeating_test_arg", &self.repeating_test_arg, event);
        callbacks.invoke_table_row_callbacks::<TestA>("test_a", &self.test_a, event);
        callbacks.invoke_table_row_callbacks::<TestD>("test_d", &self.test_d, event);
        callbacks.invoke_table_row_callbacks::<TestE>("test_e", &self.test_e, event);
        callbacks.invoke_table_row_callbacks::<TestFoobar>("test_f", &self.test_f, event);
}
}


#[doc(hidden)]
pub struct RemoteModule;

impl __sdk::InModule for RemoteModule {
    type Module = Self;
}

/// The `reducers` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
pub struct RemoteReducers {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteReducers {
    type Module = RemoteModule;
}

#[doc(hidden)]
/// The `set_reducer_flags` field of [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
/// Each method sets the flags for the reducer with the same name.
///
/// This type is currently unstable and may be removed without a major version bump.
pub struct SetReducerFlags {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for SetReducerFlags {
    type Module = RemoteModule;
}

/// The `db` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each table defined by the module.
pub struct RemoteTables {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteTables {
    type Module = RemoteModule;
}

/// A connection to a remote module, including a materialized view of a subset of the database.
///
/// Connect to a remote module by calling [`DbConnection::builder`]
/// and using the [`__sdk::DbConnectionBuilder`] builder-pattern constructor.
///
/// You must explicitly advance the connection by calling any one of:
///
/// - [`DbConnection::frame_tick`].
/// - [`DbConnection::run_threaded`].
/// - [`DbConnection::run_async`].
/// - [`DbConnection::advance_one_message`].
/// - [`DbConnection::advance_one_message_blocking`].
/// - [`DbConnection::advance_one_message_async`].
///
/// Which of these methods you should call depends on the specific needs of your application,
/// but you must call one of them, or else the connection will never progress.
pub struct DbConnection {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    #[doc(hidden)]
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,

    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for DbConnection {
    type Module = RemoteModule;
}

impl __sdk::DbContext for DbConnection {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl DbConnection {
    /// Builder-pattern constructor for a connection to a remote module.
    ///
    /// See [`__sdk::DbConnectionBuilder`] for required and optional configuration for the new connection.
    pub fn builder() -> __sdk::DbConnectionBuilder<RemoteModule> {
        __sdk::DbConnectionBuilder::new()
    }

    /// If any WebSocket messages are waiting, process one of them.
    ///
    /// Returns `true` if a message was processed, or `false` if the queue is empty.
    /// Callers should invoke this message in a loop until it returns `false`
    /// or for as much time is available to process messages.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::frame_tick`] each frame
    /// to fully exhaust the queue whenever time is available.
    pub fn advance_one_message(&self) -> __sdk::Result<bool> {
        self.imp.advance_one_message()
    }

    /// Process one WebSocket message, potentially blocking the current thread until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_threaded`] to spawn a thread
    /// which advances the connection automatically.
    pub fn advance_one_message_blocking(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_blocking()
    }

    /// Process one WebSocket message, `await`ing until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_async`] to run an `async` loop
    /// which advances the connection when polled.
    pub async fn advance_one_message_async(&self) -> __sdk::Result<()> {
        self.imp.advance_one_message_async().await
    }

    /// Process all WebSocket messages waiting in the queue,
    /// then return without `await`ing or blocking the current thread.
    pub fn frame_tick(&self) -> __sdk::Result<()> {
        self.imp.frame_tick()
    }

    /// Spawn a thread which processes WebSocket messages as they are received.
    pub fn run_threaded(&self) -> std::thread::JoinHandle<()> {
        self.imp.run_threaded()
    }

    /// Run an `async` loop which processes WebSocket messages when polled.
    pub async fn run_async(&self) -> __sdk::Result<()> {
        self.imp.run_async().await
    }
}

impl __sdk::DbConnection for DbConnection {
    fn new(imp: __sdk::DbContextImpl<RemoteModule>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

/// A handle on a subscribed query.
// TODO: Document this better after implementing the new subscription API.
#[derive(Clone)]
pub struct SubscriptionHandle {
    imp: __sdk::SubscriptionHandleImpl<RemoteModule>,
}

impl __sdk::InModule for SubscriptionHandle {
    type Module = RemoteModule;
}

impl __sdk::SubscriptionHandle for SubscriptionHandle {
    fn new(imp: __sdk::SubscriptionHandleImpl<RemoteModule>) -> Self {
        Self { imp }
    }

    /// Returns true if this subscription has been terminated due to an unsubscribe call or an error.
    fn is_ended(&self) -> bool {
        self.imp.is_ended()
    }

    /// Returns true if this subscription has been applied and has not yet been unsubscribed.
    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    /// Unsubscribe from the query controlled by this `SubscriptionHandle`,
    /// then run `on_end` when its rows are removed from the client cache.
    fn unsubscribe_then(self, on_end: __sdk::OnEndedCallback<RemoteModule>) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(Some(on_end))
    }

    fn unsubscribe(self) -> __sdk::Result<()> {
        self.imp.unsubscribe_then(None)
    }

}

/// Alias trait for a [`__sdk::DbContext`] connected to this module,
/// with that trait's associated types bounded to this module's concrete types.
///
/// Users can use this trait as a boundary on definitions which should accept
/// either a [`DbConnection`] or an [`EventContext`] and operate on either.
pub trait RemoteDbContext: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SetReducerFlags = SetReducerFlags,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
> {}
impl<Ctx: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SetReducerFlags = SetReducerFlags,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
>> RemoteDbContext for Ctx {}


/// An [`__sdk::DbContext`] augmented with a [`__sdk::Event`],
/// passed to [`__sdk::Table::on_insert`], [`__sdk::Table::on_delete`] and [`__sdk::TableWithPrimaryKey::on_update`] callbacks.
pub struct EventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::Event<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for EventContext {
    type Event = __sdk::Event<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for EventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for EventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::EventContext for EventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::ReducerEvent`],
/// passed to on-reducer callbacks.
pub struct ReducerEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::ReducerEvent<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ReducerEventContext {
    type Event = __sdk::ReducerEvent<Reducer>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ReducerEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ReducerEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::ReducerEventContext for ReducerEventContext {}

/// An [`__sdk::DbContext`] passed to [`__sdk::SubscriptionBuilder::on_applied`] and [`SubscriptionHandle::unsubscribe_then`] callbacks.
pub struct SubscriptionEventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for SubscriptionEventContext {
    type Event = ();
    fn event(&self) -> &Self::Event {
        &()
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, _event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

impl __sdk::InModule for SubscriptionEventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for SubscriptionEventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::SubscriptionEventContext for SubscriptionEventContext {}

/// An [`__sdk::DbContext`] augmented with a [`__sdk::Error`],
/// passed to [`__sdk::DbConnectionBuilder::on_disconnect`], [`__sdk::DbConnectionBuilder::on_connect_error`] and [`__sdk::SubscriptionBuilder::on_error`] callbacks.
pub struct ErrorContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: Option<__sdk::Error>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::AbstractEventContext for ErrorContext {
    type Event = Option<__sdk::Error>;
    fn event(&self) -> &Self::Event {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: Self::Event) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

impl __sdk::InModule for ErrorContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for ErrorContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __sdk::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn connection_id(&self) -> __sdk::ConnectionId {
        self.imp.connection_id()
    }
}

impl __sdk::ErrorContext for ErrorContext {}

impl __sdk::SpacetimeModule for RemoteModule {
    
    type DbConnection = DbConnection;
    type EventContext = EventContext;
    type ReducerEventContext = ReducerEventContext;
    type SubscriptionEventContext = SubscriptionEventContext;
    type ErrorContext = ErrorContext;
    type Reducer = Reducer;
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;
    type DbUpdate = DbUpdate;
    type AppliedDiff<'r> = AppliedDiff<'r>;
    type SubscriptionHandle = SubscriptionHandle;

fn register_tables(client_cache: &mut __sdk::ClientCache<Self>) {
                has_special_stuff_table::register_table(client_cache);
        logged_out_player_table::register_table(client_cache);
        person_table::register_table(client_cache);
        pk_multi_identity_table::register_table(client_cache);
        player_table::register_table(client_cache);
        points_table::register_table(client_cache);
        private_table_table::register_table(client_cache);
        repeating_test_arg_table::register_table(client_cache);
        test_a_table::register_table(client_cache);
        test_d_table::register_table(client_cache);
        test_e_table::register_table(client_cache);
        test_f_table::register_table(client_cache);
}
}
'''
"namespace_test_c_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestC {
    Foo,

    Bar,

}



impl __sdk::InModule for NamespaceTestC {
    type Module = super::RemoteModule;
}

'''
"namespace_test_f_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestF {
    Foo,

    Bar,

    Baz(String),

}



impl __sdk::InModule for NamespaceTestF {
    type Module = super::RemoteModule;
}

'''
"person_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::person_type::Person;

/// Table handle for the table `person`.
///
/// Obtain a handle from the [`PersonTableAccess::person`] method on [`super::RemoteTables`],
/// like `ctx.db.person()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.person().on_insert(...)`.
pub struct PersonTableHandle<'ctx> {
    imp: __sdk::TableHandle<Person>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `person`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PersonTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PersonTableHandle`], which mediates access to the table `person`.
    fn person(&self) -> PersonTableHandle<'_>;
}

impl PersonTableAccess for super::RemoteTables {
    fn person(&self) -> PersonTableHandle<'_> {
        PersonTableHandle {
            imp: self.imp.get_table::<Person>("person"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PersonInsertCallbackId(__sdk::CallbackId);
pub struct PersonDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PersonTableHandle<'ctx> {
    type Row = Person;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Person> + '_ { self.imp.iter() }

    type InsertCallbackId = PersonInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PersonInsertCallbackId {
        PersonInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PersonInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PersonDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PersonDeleteCallbackId {
        PersonDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PersonDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<Person>("person");
    _table.add_unique_constraint::<u32>("id", |row| &row.id);
}
pub struct PersonUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PersonTableHandle<'ctx> {
    type UpdateCallbackId = PersonUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PersonUpdateCallbackId {
        PersonUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PersonUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}


#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<Person>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Person>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        /// Access to the `id` unique index on the table `person`,
        /// which allows point queries on the field of the same name
        /// via the [`PersonIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.person().id().find(...)`.
        pub struct PersonIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Person, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PersonTableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `person`.
            pub fn id(&self) -> PersonIdUnique<'ctx> {
                PersonIdUnique {
                    imp: self.imp.get_unique_constraint::<u32>("id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PersonIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<Person> {
                self.imp.find(col_val)
            }
        }
        '''
"person_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Person {
    pub id: u32,
    pub name: String,
    pub age: u8,
}


impl __sdk::InModule for Person {
    type Module = super::RemoteModule;
}

'''
"pk_multi_identity_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::pk_multi_identity_type::PkMultiIdentity;

/// Table handle for the table `pk_multi_identity`.
///
/// Obtain a handle from the [`PkMultiIdentityTableAccess::pk_multi_identity`] method on [`super::RemoteTables`],
/// like `ctx.db.pk_multi_identity()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.pk_multi_identity().on_insert(...)`.
pub struct PkMultiIdentityTableHandle<'ctx> {
    imp: __sdk::TableHandle<PkMultiIdentity>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `pk_multi_identity`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PkMultiIdentityTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PkMultiIdentityTableHandle`], which mediates access to the table `pk_multi_identity`.
    fn pk_multi_identity(&self) -> PkMultiIdentityTableHandle<'_>;
}

impl PkMultiIdentityTableAccess for super::RemoteTables {
    fn pk_multi_identity(&self) -> PkMultiIdentityTableHandle<'_> {
        PkMultiIdentityTableHandle {
            imp: self.imp.get_table::<PkMultiIdentity>("pk_multi_identity"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PkMultiIdentityInsertCallbackId(__sdk::CallbackId);
pub struct PkMultiIdentityDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PkMultiIdentityTableHandle<'ctx> {
    type Row = PkMultiIdentity;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = PkMultiIdentity> + '_ { self.imp.iter() }

    type InsertCallbackId = PkMultiIdentityInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityInsertCallbackId {
        PkMultiIdentityInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PkMultiIdentityInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PkMultiIdentityDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityDeleteCallbackId {
        PkMultiIdentityDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PkMultiIdentityDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<PkMultiIdentity>("pk_multi_identity");
    _table.add_unique_constraint::<u32>("id", |row| &row.id);
    _table.add_unique_constraint::<u32>("other", |row| &row.other);
}
pub struct PkMultiIdentityUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PkMultiIdentityTableHandle<'ctx> {
    type UpdateCallbackId = PkMultiIdentityUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityUpdateCallbackId {
        PkMultiIdentityUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PkMultiIdentityUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}


#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<PkMultiIdentity>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<PkMultiIdentity>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        /// Access to the `id` unique index on the table `pk_multi_identity`,
        /// which allows point queries on the field of the same name
        /// via the [`PkMultiIdentityIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.pk_multi_identity().id().find(...)`.
        pub struct PkMultiIdentityIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<PkMultiIdentity, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PkMultiIdentityTableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `pk_multi_identity`.
            pub fn id(&self) -> PkMultiIdentityIdUnique<'ctx> {
                PkMultiIdentityIdUnique {
                    imp: self.imp.get_unique_constraint::<u32>("id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PkMultiIdentityIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<PkMultiIdentity> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `other` unique index on the table `pk_multi_identity`,
        /// which allows point queries on the field of the same name
        /// via the [`PkMultiIdentityOtherUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.pk_multi_identity().other().find(...)`.
        pub struct PkMultiIdentityOtherUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<PkMultiIdentity, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PkMultiIdentityTableHandle<'ctx> {
            /// Get a handle on the `other` unique index on the table `pk_multi_identity`.
            pub fn other(&self) -> PkMultiIdentityOtherUnique<'ctx> {
                PkMultiIdentityOtherUnique {
                    imp: self.imp.get_unique_constraint::<u32>("other"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PkMultiIdentityOtherUnique<'ctx> {
            /// Find the subscribed row whose `other` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<PkMultiIdentity> {
                self.imp.find(col_val)
            }
        }
        '''
"pk_multi_identity_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct PkMultiIdentity {
    pub id: u32,
    pub other: u32,
}


impl __sdk::InModule for PkMultiIdentity {
    type Module = super::RemoteModule;
}

'''
"player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `player`.
///
/// Obtain a handle from the [`PlayerTableAccess::player`] method on [`super::RemoteTables`],
/// like `ctx.db.player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.player().on_insert(...)`.
pub struct PlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PlayerTableHandle`], which mediates access to the table `player`.
    fn player(&self) -> PlayerTableHandle<'_>;
}

impl PlayerTableAccess for super::RemoteTables {
    fn player(&self) -> PlayerTableHandle<'_> {
        PlayerTableHandle {
            imp: self.imp.get_table::<Player>("player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PlayerInsertCallbackId(__sdk::CallbackId);
pub struct PlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = PlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PlayerInsertCallbackId {
        PlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PlayerDeleteCallbackId {
        PlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<Player>("player");
    _table.add_unique_constraint::<__sdk::Identity>("identity", |row| &row.identity);
    _table.add_unique_constraint::<u64>("player_id", |row| &row.player_id);
    _table.add_unique_constraint::<String>("name", |row| &row.name);
}
pub struct PlayerUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PlayerTableHandle<'ctx> {
    type UpdateCallbackId = PlayerUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PlayerUpdateCallbackId {
        PlayerUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PlayerUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}


#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Player>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        /// Access to the `identity` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerIdentityUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().identity().find(...)`.
        pub struct PlayerIdentityUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, __sdk::Identity>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `identity` unique index on the table `player`.
            pub fn identity(&self) -> PlayerIdentityUnique<'ctx> {
                PlayerIdentityUnique {
                    imp: self.imp.get_unique_constraint::<__sdk::Identity>("identity"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerIdentityUnique<'ctx> {
            /// Find the subscribed row whose `identity` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &__sdk::Identity) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `player_id` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerPlayerIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().player_id().find(...)`.
        pub struct PlayerPlayerIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `player_id` unique index on the table `player`.
            pub fn player_id(&self) -> PlayerPlayerIdUnique<'ctx> {
                PlayerPlayerIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("player_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerPlayerIdUnique<'ctx> {
            /// Find the subscribed row whose `player_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `name` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerNameUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().name().find(...)`.
        pub struct PlayerNameUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, String>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `name` unique index on the table `player`.
            pub fn name(&self) -> PlayerNameUnique<'ctx> {
                PlayerNameUnique {
                    imp: self.imp.get_unique_constraint::<String>("name"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerNameUnique<'ctx> {
            /// Find the subscribed row whose `name` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &String) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        '''
"player_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Player {
    pub identity: __sdk::Identity,
    pub player_id: u64,
    pub name: String,
}


impl __sdk::InModule for Player {
    type Module = super::RemoteModule;
}

'''
"point_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Point {
    pub x: i64,
    pub y: i64,
}


impl __sdk::InModule for Point {
    type Module = super::RemoteModule;
}

'''
"points_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::point_type::Point;

/// Table handle for the table `points`.
///
/// Obtain a handle from the [`PointsTableAccess::points`] method on [`super::RemoteTables`],
/// like `ctx.db.points()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.points().on_insert(...)`.
pub struct PointsTableHandle<'ctx> {
    imp: __sdk::TableHandle<Point>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `points`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PointsTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PointsTableHandle`], which mediates access to the table `points`.
    fn points(&self) -> PointsTableHandle<'_>;
}

impl PointsTableAccess for super::RemoteTables {
    fn points(&self) -> PointsTableHandle<'_> {
        PointsTableHandle {
            imp: self.imp.get_table::<Point>("points"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PointsInsertCallbackId(__sdk::CallbackId);
pub struct PointsDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PointsTableHandle<'ctx> {
    type Row = Point;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Point> + '_ { self.imp.iter() }

    type InsertCallbackId = PointsInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PointsInsertCallbackId {
        PointsInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PointsInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PointsDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PointsDeleteCallbackId {
        PointsDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PointsDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<Point>("points");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<Point>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<Point>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}
'''
"private_table_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::private_table_type::PrivateTable;

/// Table handle for the table `private_table`.
///
/// Obtain a handle from the [`PrivateTableTableAccess::private_table`] method on [`super::RemoteTables`],
/// like `ctx.db.private_table()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.private_table().on_insert(...)`.
pub struct PrivateTableTableHandle<'ctx> {
    imp: __sdk::TableHandle<PrivateTable>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `private_table`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PrivateTableTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PrivateTableTableHandle`], which mediates access to the table `private_table`.
    fn private_table(&self) -> PrivateTableTableHandle<'_>;
}

impl PrivateTableTableAccess for super::RemoteTables {
    fn private_table(&self) -> PrivateTableTableHandle<'_> {
        PrivateTableTableHandle {
            imp: self.imp.get_table::<PrivateTable>("private_table"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PrivateTableInsertCallbackId(__sdk::CallbackId);
pub struct PrivateTableDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PrivateTableTableHandle<'ctx> {
    type Row = PrivateTable;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = PrivateTable> + '_ { self.imp.iter() }

    type InsertCallbackId = PrivateTableInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PrivateTableInsertCallbackId {
        PrivateTableInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PrivateTableInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PrivateTableDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PrivateTableDeleteCallbackId {
        PrivateTableDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PrivateTableDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<PrivateTable>("private_table");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<PrivateTable>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<PrivateTable>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}
'''
"private_table_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct PrivateTable {
    pub name: String,
}


impl __sdk::InModule for PrivateTable {
    type Module = super::RemoteModule;
}

'''
"query_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct QueryPrivateArgs {
    }

impl From<QueryPrivateArgs> for super::Reducer {
    fn from(args: QueryPrivateArgs) -> Self {
        Self::QueryPrivate
}
}

impl __sdk::InModule for QueryPrivateArgs {
    type Module = super::RemoteModule;
}

pub struct QueryPrivateCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `query_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait query_private {
    /// Request that the remote module invoke the reducer `query_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_query_private`] callbacks.
    fn query_private(&self, ) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `query_private`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`QueryPrivateCallbackId`] can be passed to [`Self::remove_on_query_private`]
    /// to cancel the callback.
    fn on_query_private(&self, callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static) -> QueryPrivateCallbackId;
    /// Cancel a callback previously registered by [`Self::on_query_private`],
    /// causing it not to run in the future.
    fn remove_on_query_private(&self, callback: QueryPrivateCallbackId);
}

impl query_private for super::RemoteReducers {
    fn query_private(&self, ) -> __sdk::Result<()> {
        self.imp.call_reducer("query_private", QueryPrivateArgs {  })
    }
    fn on_query_private(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static,
    ) -> QueryPrivateCallbackId {
        QueryPrivateCallbackId(self.imp.on_reducer(
            "query_private",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::QueryPrivate {
                            
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_query_private(&self, callback: QueryPrivateCallbackId) {
        self.imp.remove_on_reducer("query_private", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `query_private`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_query_private {
    /// Set the call-reducer flags for the reducer `query_private` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn query_private(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_query_private for super::SetReducerFlags {
    fn query_private(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("query_private", flags);
    }
}

'''
"repeating_test_arg_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::repeating_test_arg_type::RepeatingTestArg;

/// Table handle for the table `repeating_test_arg`.
///
/// Obtain a handle from the [`RepeatingTestArgTableAccess::repeating_test_arg`] method on [`super::RemoteTables`],
/// like `ctx.db.repeating_test_arg()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.repeating_test_arg().on_insert(...)`.
pub struct RepeatingTestArgTableHandle<'ctx> {
    imp: __sdk::TableHandle<RepeatingTestArg>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `repeating_test_arg`.
///
/// Implemented for [`super::RemoteTables`].
pub trait RepeatingTestArgTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`RepeatingTestArgTableHandle`], which mediates access to the table `repeating_test_arg`.
    fn repeating_test_arg(&self) -> RepeatingTestArgTableHandle<'_>;
}

impl RepeatingTestArgTableAccess for super::RemoteTables {
    fn repeating_test_arg(&self) -> RepeatingTestArgTableHandle<'_> {
        RepeatingTestArgTableHandle {
            imp: self.imp.get_table::<RepeatingTestArg>("repeating_test_arg"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct RepeatingTestArgInsertCallbackId(__sdk::CallbackId);
pub struct RepeatingTestArgDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for RepeatingTestArgTableHandle<'ctx> {
    type Row = RepeatingTestArg;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = RepeatingTestArg> + '_ { self.imp.iter() }

    type InsertCallbackId = RepeatingTestArgInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgInsertCallbackId {
        RepeatingTestArgInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: RepeatingTestArgInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = RepeatingTestArgDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgDeleteCallbackId {
        RepeatingTestArgDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: RepeatingTestArgDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<RepeatingTestArg>("repeating_test_arg");
    _table.add_unique_constraint::<u64>("scheduled_id", |row| &row.scheduled_id);
}
pub struct RepeatingTestArgUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for RepeatingTestArgTableHandle<'ctx> {
    type UpdateCallbackId = RepeatingTestArgUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgUpdateCallbackId {
        RepeatingTestArgUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: RepeatingTestArgUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}


#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<RepeatingTestArg>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<RepeatingTestArg>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        /// Access to the `scheduled_id` unique index on the table `repeating_test_arg`,
        /// which allows point queries on the field of the same name
        /// via the [`RepeatingTestArgScheduledIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.repeating_test_arg().scheduled_id().find(...)`.
        pub struct RepeatingTestArgScheduledIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<RepeatingTestArg, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> RepeatingTestArgTableHandle<'ctx> {
            /// Get a handle on the `scheduled_id` unique index on the table `repeating_test_arg`.
            pub fn scheduled_id(&self) -> RepeatingTestArgScheduledIdUnique<'ctx> {
                RepeatingTestArgScheduledIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("scheduled_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> RepeatingTestArgScheduledIdUnique<'ctx> {
            /// Find the subscribed row whose `scheduled_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<RepeatingTestArg> {
                self.imp.find(col_val)
            }
        }
        '''
"repeating_test_arg_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct RepeatingTestArg {
    pub scheduled_id: u64,
    pub scheduled_at: __sdk::ScheduleAt,
    pub prev_time: __sdk::Timestamp,
}


impl __sdk::InModule for RepeatingTestArg {
    type Module = super::RemoteModule;
}

'''
"repeating_test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::repeating_test_arg_type::RepeatingTestArg;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct RepeatingTestArgs {
    pub arg: RepeatingTestArg,
}

impl From<RepeatingTestArgs> for super::Reducer {
    fn from(args: RepeatingTestArgs) -> Self {
        Self::RepeatingTest {
            arg: args.arg,
}
}
}

impl __sdk::InModule for RepeatingTestArgs {
    type Module = super::RemoteModule;
}

pub struct RepeatingTestCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `repeating_test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait repeating_test {
    /// Request that the remote module invoke the reducer `repeating_test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_repeating_test`] callbacks.
    fn repeating_test(&self, arg: RepeatingTestArg,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `repeating_test`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`RepeatingTestCallbackId`] can be passed to [`Self::remove_on_repeating_test`]
    /// to cancel the callback.
    fn on_repeating_test(&self, callback: impl FnMut(&super::ReducerEventContext, &RepeatingTestArg, ) + Send + 'static) -> RepeatingTestCallbackId;
    /// Cancel a callback previously registered by [`Self::on_repeating_test`],
    /// causing it not to run in the future.
    fn remove_on_repeating_test(&self, callback: RepeatingTestCallbackId);
}

impl repeating_test for super::RemoteReducers {
    fn repeating_test(&self, arg: RepeatingTestArg,
) -> __sdk::Result<()> {
        self.imp.call_reducer("repeating_test", RepeatingTestArgs { arg,  })
    }
    fn on_repeating_test(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &RepeatingTestArg, ) + Send + 'static,
    ) -> RepeatingTestCallbackId {
        RepeatingTestCallbackId(self.imp.on_reducer(
            "repeating_test",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::RepeatingTest {
                            arg, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, arg, )
            }),
        ))
    }
    fn remove_on_repeating_test(&self, callback: RepeatingTestCallbackId) {
        self.imp.remove_on_reducer("repeating_test", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `repeating_test`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_repeating_test {
    /// Set the call-reducer flags for the reducer `repeating_test` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn repeating_test(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_repeating_test for super::SetReducerFlags {
    fn repeating_test(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("repeating_test", flags);
    }
}

'''
"say_hello_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct SayHelloArgs {
    }

impl From<SayHelloArgs> for super::Reducer {
    fn from(args: SayHelloArgs) -> Self {
        Self::SayHello
}
}

impl __sdk::InModule for SayHelloArgs {
    type Module = super::RemoteModule;
}

pub struct SayHelloCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `say_hello`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait say_hello {
    /// Request that the remote module invoke the reducer `say_hello` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_say_hello`] callbacks.
    fn say_hello(&self, ) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `say_hello`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`SayHelloCallbackId`] can be passed to [`Self::remove_on_say_hello`]
    /// to cancel the callback.
    fn on_say_hello(&self, callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static) -> SayHelloCallbackId;
    /// Cancel a callback previously registered by [`Self::on_say_hello`],
    /// causing it not to run in the future.
    fn remove_on_say_hello(&self, callback: SayHelloCallbackId);
}

impl say_hello for super::RemoteReducers {
    fn say_hello(&self, ) -> __sdk::Result<()> {
        self.imp.call_reducer("say_hello", SayHelloArgs {  })
    }
    fn on_say_hello(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static,
    ) -> SayHelloCallbackId {
        SayHelloCallbackId(self.imp.on_reducer(
            "say_hello",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::SayHello {
                            
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_say_hello(&self, callback: SayHelloCallbackId) {
        self.imp.remove_on_reducer("say_hello", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `say_hello`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_say_hello {
    /// Set the call-reducer flags for the reducer `say_hello` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn say_hello(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_say_hello for super::SetReducerFlags {
    fn say_hello(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("say_hello", flags);
    }
}

'''
"test_a_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::test_a_type::TestA;

/// Table handle for the table `test_a`.
///
/// Obtain a handle from the [`TestATableAccess::test_a`] method on [`super::RemoteTables`],
/// like `ctx.db.test_a()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_a().on_insert(...)`.
pub struct TestATableHandle<'ctx> {
    imp: __sdk::TableHandle<TestA>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_a`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestATableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestATableHandle`], which mediates access to the table `test_a`.
    fn test_a(&self) -> TestATableHandle<'_>;
}

impl TestATableAccess for super::RemoteTables {
    fn test_a(&self) -> TestATableHandle<'_> {
        TestATableHandle {
            imp: self.imp.get_table::<TestA>("test_a"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestAInsertCallbackId(__sdk::CallbackId);
pub struct TestADeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestATableHandle<'ctx> {
    type Row = TestA;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestA> + '_ { self.imp.iter() }

    type InsertCallbackId = TestAInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestAInsertCallbackId {
        TestAInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestAInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestADeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestADeleteCallbackId {
        TestADeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestADeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<TestA>("test_a");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<TestA>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<TestA>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}
'''
"test_a_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestA {
    pub x: u32,
    pub y: u32,
    pub z: String,
}


impl __sdk::InModule for TestA {
    type Module = super::RemoteModule;
}

'''
"test_b_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestB {
    pub foo: String,
}


impl __sdk::InModule for TestB {
    type Module = super::RemoteModule;
}

'''
"test_btree_index_args_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct TestBtreeIndexArgsArgs {
    }

impl From<TestBtreeIndexArgsArgs> for super::Reducer {
    fn from(args: TestBtreeIndexArgsArgs) -> Self {
        Self::TestBtreeIndexArgs
}
}

impl __sdk::InModule for TestBtreeIndexArgsArgs {
    type Module = super::RemoteModule;
}

pub struct TestBtreeIndexArgsCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test_btree_index_args`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test_btree_index_args {
    /// Request that the remote module invoke the reducer `test_btree_index_args` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_test_btree_index_args`] callbacks.
    fn test_btree_index_args(&self, ) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `test_btree_index_args`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`TestBtreeIndexArgsCallbackId`] can be passed to [`Self::remove_on_test_btree_index_args`]
    /// to cancel the callback.
    fn on_test_btree_index_args(&self, callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static) -> TestBtreeIndexArgsCallbackId;
    /// Cancel a callback previously registered by [`Self::on_test_btree_index_args`],
    /// causing it not to run in the future.
    fn remove_on_test_btree_index_args(&self, callback: TestBtreeIndexArgsCallbackId);
}

impl test_btree_index_args for super::RemoteReducers {
    fn test_btree_index_args(&self, ) -> __sdk::Result<()> {
        self.imp.call_reducer("test_btree_index_args", TestBtreeIndexArgsArgs {  })
    }
    fn on_test_btree_index_args(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, ) + Send + 'static,
    ) -> TestBtreeIndexArgsCallbackId {
        TestBtreeIndexArgsCallbackId(self.imp.on_reducer(
            "test_btree_index_args",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::TestBtreeIndexArgs {
                            
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_test_btree_index_args(&self, callback: TestBtreeIndexArgsCallbackId) {
        self.imp.remove_on_reducer("test_btree_index_args", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `test_btree_index_args`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_test_btree_index_args {
    /// Set the call-reducer flags for the reducer `test_btree_index_args` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn test_btree_index_args(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_test_btree_index_args for super::SetReducerFlags {
    fn test_btree_index_args(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("test_btree_index_args", flags);
    }
}

'''
"test_d_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::test_d_type::TestD;
use super::namespace_test_c_type::NamespaceTestC;

/// Table handle for the table `test_d`.
///
/// Obtain a handle from the [`TestDTableAccess::test_d`] method on [`super::RemoteTables`],
/// like `ctx.db.test_d()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_d().on_insert(...)`.
pub struct TestDTableHandle<'ctx> {
    imp: __sdk::TableHandle<TestD>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_d`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestDTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestDTableHandle`], which mediates access to the table `test_d`.
    fn test_d(&self) -> TestDTableHandle<'_>;
}

impl TestDTableAccess for super::RemoteTables {
    fn test_d(&self) -> TestDTableHandle<'_> {
        TestDTableHandle {
            imp: self.imp.get_table::<TestD>("test_d"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestDInsertCallbackId(__sdk::CallbackId);
pub struct TestDDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestDTableHandle<'ctx> {
    type Row = TestD;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestD> + '_ { self.imp.iter() }

    type InsertCallbackId = TestDInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDInsertCallbackId {
        TestDInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestDInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestDDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDDeleteCallbackId {
        TestDDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestDDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<TestD>("test_d");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<TestD>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<TestD>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}
'''
"test_d_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::namespace_test_c_type::NamespaceTestC;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestD {
    pub test_c: Option::<NamespaceTestC>,
}


impl __sdk::InModule for TestD {
    type Module = super::RemoteModule;
}

'''
"test_e_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::test_e_type::TestE;

/// Table handle for the table `test_e`.
///
/// Obtain a handle from the [`TestETableAccess::test_e`] method on [`super::RemoteTables`],
/// like `ctx.db.test_e()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_e().on_insert(...)`.
pub struct TestETableHandle<'ctx> {
    imp: __sdk::TableHandle<TestE>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_e`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestETableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestETableHandle`], which mediates access to the table `test_e`.
    fn test_e(&self) -> TestETableHandle<'_>;
}

impl TestETableAccess for super::RemoteTables {
    fn test_e(&self) -> TestETableHandle<'_> {
        TestETableHandle {
            imp: self.imp.get_table::<TestE>("test_e"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestEInsertCallbackId(__sdk::CallbackId);
pub struct TestEDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestETableHandle<'ctx> {
    type Row = TestE;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestE> + '_ { self.imp.iter() }

    type InsertCallbackId = TestEInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestEInsertCallbackId {
        TestEInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestEInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestEDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestEDeleteCallbackId {
        TestEDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestEDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<TestE>("test_e");
    _table.add_unique_constraint::<u64>("id", |row| &row.id);
}
pub struct TestEUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for TestETableHandle<'ctx> {
    type UpdateCallbackId = TestEUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> TestEUpdateCallbackId {
        TestEUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: TestEUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}


#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<TestE>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<TestE>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}

        /// Access to the `id` unique index on the table `test_e`,
        /// which allows point queries on the field of the same name
        /// via the [`TestEIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.test_e().id().find(...)`.
        pub struct TestEIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<TestE, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> TestETableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `test_e`.
            pub fn id(&self) -> TestEIdUnique<'ctx> {
                TestEIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> TestEIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<TestE> {
                self.imp.find(col_val)
            }
        }
        '''
"test_e_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestE {
    pub id: u64,
    pub name: String,
}


impl __sdk::InModule for TestE {
    type Module = super::RemoteModule;
}

'''
"test_f_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};
use super::test_foobar_type::TestFoobar;
use super::foobar_type::Foobar;

/// Table handle for the table `test_f`.
///
/// Obtain a handle from the [`TestFTableAccess::test_f`] method on [`super::RemoteTables`],
/// like `ctx.db.test_f()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_f().on_insert(...)`.
pub struct TestFTableHandle<'ctx> {
    imp: __sdk::TableHandle<TestFoobar>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_f`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestFTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestFTableHandle`], which mediates access to the table `test_f`.
    fn test_f(&self) -> TestFTableHandle<'_>;
}

impl TestFTableAccess for super::RemoteTables {
    fn test_f(&self) -> TestFTableHandle<'_> {
        TestFTableHandle {
            imp: self.imp.get_table::<TestFoobar>("test_f"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestFInsertCallbackId(__sdk::CallbackId);
pub struct TestFDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestFTableHandle<'ctx> {
    type Row = TestFoobar;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestFoobar> + '_ { self.imp.iter() }

    type InsertCallbackId = TestFInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFInsertCallbackId {
        TestFInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestFInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestFDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFDeleteCallbackId {
        TestFDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestFDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

        let _table = client_cache.get_or_make_table::<TestFoobar>("test_f");
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __sdk::Result<__sdk::TableUpdate<TestFoobar>> {
    __sdk::TableUpdate::parse_table_update(raw_updates).map_err(|e| {
        __sdk::InternalError::failed_parse(
            "TableUpdate<TestFoobar>",
            "TableUpdate",
        ).with_cause(e).into()
    })
}
'''
"test_foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::foobar_type::Foobar;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestFoobar {
    pub field: Foobar,
}


impl __sdk::InModule for TestFoobar {
    type Module = super::RemoteModule;
}

'''
"test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#![allow(unused, clippy::all)]
use spacetimedb_sdk::__codegen::{
	self as __sdk,
	__lib,
	__sats,
	__ws,
};

use super::test_a_type::TestA;
use super::test_b_type::TestB;
use super::namespace_test_c_type::NamespaceTestC;
use super::namespace_test_f_type::NamespaceTestF;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct TestArgs {
    pub arg: TestA,
    pub arg_2: TestB,
    pub arg_3: NamespaceTestC,
    pub arg_4: NamespaceTestF,
}

impl From<TestArgs> for super::Reducer {
    fn from(args: TestArgs) -> Self {
        Self::Test {
            arg: args.arg,
            arg_2: args.arg_2,
            arg_3: args.arg_3,
            arg_4: args.arg_4,
}
}
}

impl __sdk::InModule for TestArgs {
    type Module = super::RemoteModule;
}

pub struct TestCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test {
    /// Request that the remote module invoke the reducer `test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_test`] callbacks.
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __sdk::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `test`.
    ///
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::ReducerEventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`TestCallbackId`] can be passed to [`Self::remove_on_test`]
    /// to cancel the callback.
    fn on_test(&self, callback: impl FnMut(&super::ReducerEventContext, &TestA, &TestB, &NamespaceTestC, &NamespaceTestF, ) + Send + 'static) -> TestCallbackId;
    /// Cancel a callback previously registered by [`Self::on_test`],
    /// causing it not to run in the future.
    fn remove_on_test(&self, callback: TestCallbackId);
}

impl test for super::RemoteReducers {
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __sdk::Result<()> {
        self.imp.call_reducer("test", TestArgs { arg, arg_2, arg_3, arg_4,  })
    }
    fn on_test(
        &self,
        mut callback: impl FnMut(&super::ReducerEventContext, &TestA, &TestB, &NamespaceTestC, &NamespaceTestF, ) + Send + 'static,
    ) -> TestCallbackId {
        TestCallbackId(self.imp.on_reducer(
            "test",
            Box::new(move |ctx: &super::ReducerEventContext| {
                let super::ReducerEventContext {
                    event: __sdk::ReducerEvent {
                        reducer: super::Reducer::Test {
                            arg, arg_2, arg_3, arg_4, 
                        },
                        ..
                    },
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, arg, arg_2, arg_3, arg_4, )
            }),
        ))
    }
    fn remove_on_test(&self, callback: TestCallbackId) {
        self.imp.remove_on_reducer("test", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `test`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_test {
    /// Set the call-reducer flags for the reducer `test` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn test(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_test for super::SetReducerFlags {
    fn test(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("test", flags);
    }
}

'''
