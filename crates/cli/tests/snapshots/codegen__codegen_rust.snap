---
source: crates/cli/tests/codegen.rs
expression: outfiles
---
"add_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct AddPlayer {
	pub name: String,
}


impl __sdk::spacetime_module::InModule for AddPlayer {
    type Module = super::RemoteModule;
}

pub struct AddPlayerCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_player {
    /// Request that the remote module invoke the reducer `add_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add_player`] callbacks.
    fn add_player(&self, name: String,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add_player`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddPlayerCallbackId`] can be passed to [`Self::remove_on_add_player`]
    /// to cancel the callback.
    fn on_add_player(&self, callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static) -> AddPlayerCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add_player`],
    /// causing it not to run in the future.
    fn remove_on_add_player(&self, callback: AddPlayerCallbackId);
}

impl add_player for super::RemoteReducers {
    fn add_player(&self, name: String,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("add_player", AddPlayer { name,  })
    }
    fn on_add_player(
        &self,
        mut callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static,
    ) -> AddPlayerCallbackId {
        AddPlayerCallbackId(self.imp.on_reducer::<AddPlayer>(
            "add_player",
            Box::new(move |ctx: &super::EventContext, args: &AddPlayer| callback(ctx, &args.name, )),
        ))
    }
    fn remove_on_add_player(&self, callback: AddPlayerCallbackId) {
        self.imp.remove_on_reducer::<AddPlayer>("add_player", callback.0)
    }
}

'''
"add_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct AddPrivate {
	pub name: String,
}


impl __sdk::spacetime_module::InModule for AddPrivate {
    type Module = super::RemoteModule;
}

pub struct AddPrivateCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_private {
    /// Request that the remote module invoke the reducer `add_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add_private`] callbacks.
    fn add_private(&self, name: String,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add_private`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddPrivateCallbackId`] can be passed to [`Self::remove_on_add_private`]
    /// to cancel the callback.
    fn on_add_private(&self, callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static) -> AddPrivateCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add_private`],
    /// causing it not to run in the future.
    fn remove_on_add_private(&self, callback: AddPrivateCallbackId);
}

impl add_private for super::RemoteReducers {
    fn add_private(&self, name: String,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("add_private", AddPrivate { name,  })
    }
    fn on_add_private(
        &self,
        mut callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static,
    ) -> AddPrivateCallbackId {
        AddPrivateCallbackId(self.imp.on_reducer::<AddPrivate>(
            "add_private",
            Box::new(move |ctx: &super::EventContext, args: &AddPrivate| callback(ctx, &args.name, )),
        ))
    }
    fn remove_on_add_private(&self, callback: AddPrivateCallbackId) {
        self.imp.remove_on_reducer::<AddPrivate>("add_private", callback.0)
    }
}

'''
"baz_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Baz {
	pub field: String,
}


impl __sdk::spacetime_module::InModule for Baz {
    type Module = super::RemoteModule;
}

'''
"delete_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct DeletePlayer {
	pub id: u64,
}


impl __sdk::spacetime_module::InModule for DeletePlayer {
    type Module = super::RemoteModule;
}

pub struct DeletePlayerCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_player {
    /// Request that the remote module invoke the reducer `delete_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_delete_player`] callbacks.
    fn delete_player(&self, id: u64,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `delete_player`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`DeletePlayerCallbackId`] can be passed to [`Self::remove_on_delete_player`]
    /// to cancel the callback.
    fn on_delete_player(&self, callback: impl FnMut(&super::EventContext, &u64, ) + Send + 'static) -> DeletePlayerCallbackId;
    /// Cancel a callback previously registered by [`Self::on_delete_player`],
    /// causing it not to run in the future.
    fn remove_on_delete_player(&self, callback: DeletePlayerCallbackId);
}

impl delete_player for super::RemoteReducers {
    fn delete_player(&self, id: u64,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("delete_player", DeletePlayer { id,  })
    }
    fn on_delete_player(
        &self,
        mut callback: impl FnMut(&super::EventContext, &u64, ) + Send + 'static,
    ) -> DeletePlayerCallbackId {
        DeletePlayerCallbackId(self.imp.on_reducer::<DeletePlayer>(
            "delete_player",
            Box::new(move |ctx: &super::EventContext, args: &DeletePlayer| callback(ctx, &args.id, )),
        ))
    }
    fn remove_on_delete_player(&self, callback: DeletePlayerCallbackId) {
        self.imp.remove_on_reducer::<DeletePlayer>("delete_player", callback.0)
    }
}

'''
"delete_players_by_name_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct DeletePlayersByName {
	pub name: String,
}


impl __sdk::spacetime_module::InModule for DeletePlayersByName {
    type Module = super::RemoteModule;
}

pub struct DeletePlayersByNameCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_players_by_name`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_players_by_name {
    /// Request that the remote module invoke the reducer `delete_players_by_name` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_delete_players_by_name`] callbacks.
    fn delete_players_by_name(&self, name: String,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `delete_players_by_name`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`DeletePlayersByNameCallbackId`] can be passed to [`Self::remove_on_delete_players_by_name`]
    /// to cancel the callback.
    fn on_delete_players_by_name(&self, callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static) -> DeletePlayersByNameCallbackId;
    /// Cancel a callback previously registered by [`Self::on_delete_players_by_name`],
    /// causing it not to run in the future.
    fn remove_on_delete_players_by_name(&self, callback: DeletePlayersByNameCallbackId);
}

impl delete_players_by_name for super::RemoteReducers {
    fn delete_players_by_name(&self, name: String,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("delete_players_by_name", DeletePlayersByName { name,  })
    }
    fn on_delete_players_by_name(
        &self,
        mut callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static,
    ) -> DeletePlayersByNameCallbackId {
        DeletePlayersByNameCallbackId(self.imp.on_reducer::<DeletePlayersByName>(
            "delete_players_by_name",
            Box::new(move |ctx: &super::EventContext, args: &DeletePlayersByName| callback(ctx, &args.name, )),
        ))
    }
    fn remove_on_delete_players_by_name(&self, callback: DeletePlayersByNameCallbackId) {
        self.imp.remove_on_reducer::<DeletePlayersByName>("delete_players_by_name", callback.0)
    }
}

'''
"foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

use super::baz_type::Baz;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum Foobar {
	Baz(Baz),

	Bar,

	Har(u32),

}



impl __sdk::spacetime_module::InModule for Foobar {
    type Module = super::RemoteModule;
}

'''
"has_special_stuff_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::has_special_stuff_type::HasSpecialStuff;

/// Table handle for the table `has_special_stuff`.
///
/// Obtain a handle from the [`HasSpecialStuffTableAccess::has_special_stuff`] method on [`super::RemoteTables`],
/// like `ctx.db.has_special_stuff()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.has_special_stuff().on_insert(...)`.
pub struct HasSpecialStuffTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<HasSpecialStuff>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `has_special_stuff`.
///
/// Implemented for [`super::RemoteTables`].
pub trait HasSpecialStuffTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`HasSpecialStuffTableHandle`], which mediates access to the table `has_special_stuff`.
    fn has_special_stuff(&self) -> HasSpecialStuffTableHandle<'_>;
}

impl HasSpecialStuffTableAccess for super::RemoteTables {
    fn has_special_stuff(&self) -> HasSpecialStuffTableHandle<'_> {
        HasSpecialStuffTableHandle {
            imp: self.imp.get_table::<HasSpecialStuff>("has_special_stuff"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct HasSpecialStuffInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct HasSpecialStuffDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for HasSpecialStuffTableHandle<'ctx> {
    type Row = HasSpecialStuff;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = HasSpecialStuff> + '_ { self.imp.iter() }

    type InsertCallbackId = HasSpecialStuffInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> HasSpecialStuffInsertCallbackId {
        HasSpecialStuffInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: HasSpecialStuffInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = HasSpecialStuffDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> HasSpecialStuffDeleteCallbackId {
        HasSpecialStuffDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: HasSpecialStuffDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<HasSpecialStuff>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"has_special_stuff\"")
}
'''
"has_special_stuff_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct HasSpecialStuff {
	pub identity: __sdk::Identity,
	pub address: __sdk::Address,
}


impl __sdk::spacetime_module::InModule for HasSpecialStuff {
    type Module = super::RemoteModule;
}

'''
"identity_connected_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct IdentityConnected {
	}


impl __sdk::spacetime_module::InModule for IdentityConnected {
    type Module = super::RemoteModule;
}

pub struct IdentityConnectedCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `__identity_connected__`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait identity_connected {
    /// Request that the remote module invoke the reducer `__identity_connected__` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_identity_connected`] callbacks.
    fn identity_connected(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `__identity_connected__`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`IdentityConnectedCallbackId`] can be passed to [`Self::remove_on_identity_connected`]
    /// to cancel the callback.
    fn on_identity_connected(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> IdentityConnectedCallbackId;
    /// Cancel a callback previously registered by [`Self::on_identity_connected`],
    /// causing it not to run in the future.
    fn remove_on_identity_connected(&self, callback: IdentityConnectedCallbackId);
}

impl identity_connected for super::RemoteReducers {
    fn identity_connected(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("__identity_connected__", IdentityConnected {  })
    }
    fn on_identity_connected(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> IdentityConnectedCallbackId {
        IdentityConnectedCallbackId(self.imp.on_reducer::<IdentityConnected>(
            "__identity_connected__",
            Box::new(move |ctx: &super::EventContext, args: &IdentityConnected| callback(ctx, )),
        ))
    }
    fn remove_on_identity_connected(&self, callback: IdentityConnectedCallbackId) {
        self.imp.remove_on_reducer::<IdentityConnected>("__identity_connected__", callback.0)
    }
}

'''
"init_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Init {
	}


impl __sdk::spacetime_module::InModule for Init {
    type Module = super::RemoteModule;
}

pub struct InitCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `__init__`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait init {
    /// Request that the remote module invoke the reducer `__init__` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_init`] callbacks.
    fn init(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `__init__`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`InitCallbackId`] can be passed to [`Self::remove_on_init`]
    /// to cancel the callback.
    fn on_init(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> InitCallbackId;
    /// Cancel a callback previously registered by [`Self::on_init`],
    /// causing it not to run in the future.
    fn remove_on_init(&self, callback: InitCallbackId);
}

impl init for super::RemoteReducers {
    fn init(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("__init__", Init {  })
    }
    fn on_init(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> InitCallbackId {
        InitCallbackId(self.imp.on_reducer::<Init>(
            "__init__",
            Box::new(move |ctx: &super::EventContext, args: &Init| callback(ctx, )),
        ))
    }
    fn remove_on_init(&self, callback: InitCallbackId) {
        self.imp.remove_on_reducer::<Init>("__init__", callback.0)
    }
}

'''
"mod.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

pub mod baz_type;
pub mod foobar_type;
pub mod has_special_stuff_type;
pub mod namespace_test_c_type;
pub mod namespace_test_f_type;
pub mod pk_multi_identity_type;
pub mod point_type;
pub mod private_type;
pub mod repeating_test_arg_type;
pub mod test_a_type;
pub mod test_b_type;
pub mod test_d_type;
pub mod test_e_type;
pub mod test_foobar_type;
pub mod add_player_reducer;
pub mod add_private_reducer;
pub mod delete_player_reducer;
pub mod delete_players_by_name_reducer;
pub mod identity_connected_reducer;
pub mod init_reducer;
pub mod query_private_reducer;
pub mod repeating_test_reducer;
pub mod test_reducer;
pub mod has_special_stuff_table;
pub mod pk_multi_identity_table;
pub mod points_table;
pub mod private_table;
pub mod repeating_test_arg_table;
pub mod test_a_table;
pub mod test_d_table;
pub mod test_e_table;
pub mod test_f_table;

pub use baz_type::*;
pub use foobar_type::*;
pub use has_special_stuff_type::*;
pub use namespace_test_c_type::*;
pub use namespace_test_f_type::*;
pub use pk_multi_identity_type::*;
pub use point_type::*;
pub use private_type::*;
pub use repeating_test_arg_type::*;
pub use test_a_type::*;
pub use test_b_type::*;
pub use test_d_type::*;
pub use test_e_type::*;
pub use test_foobar_type::*;
pub use add_player_reducer::*;
pub use add_private_reducer::*;
pub use delete_player_reducer::*;
pub use delete_players_by_name_reducer::*;
pub use identity_connected_reducer::*;
pub use init_reducer::*;
pub use query_private_reducer::*;
pub use repeating_test_reducer::*;
pub use test_reducer::*;
pub use has_special_stuff_table::*;
pub use pk_multi_identity_table::*;
pub use points_table::*;
pub use private_table::*;
pub use repeating_test_arg_table::*;
pub use test_a_table::*;
pub use test_d_table::*;
pub use test_e_table::*;
pub use test_f_table::*;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]

/// One of the reducers defined by this module.
///
/// Contained within a [`__sdk::ReducerEvent`] in [`EventContext`]s for reducer events
/// to indicate which reducer caused the event.

pub enum Reducer {
		IdentityConnected(identity_connected_reducer::IdentityConnected),
	Init(init_reducer::Init),
	AddPlayer(add_player_reducer::AddPlayer),
	AddPrivate(add_private_reducer::AddPrivate),
	DeletePlayer(delete_player_reducer::DeletePlayer),
	DeletePlayersByName(delete_players_by_name_reducer::DeletePlayersByName),
	QueryPrivate(query_private_reducer::QueryPrivate),
	RepeatingTest(repeating_test_reducer::RepeatingTest),
	Test(test_reducer::Test),
}


impl __sdk::spacetime_module::InModule for Reducer {
    type Module = RemoteModule;
}

impl __sdk::spacetime_module::Reducer for Reducer {
	fn reducer_name(&self) -> &'static str {
		match self {
						Reducer::IdentityConnected(_) => "__identity_connected__",
			Reducer::Init(_) => "__init__",
			Reducer::AddPlayer(_) => "add_player",
			Reducer::AddPrivate(_) => "add_private",
			Reducer::DeletePlayer(_) => "delete_player",
			Reducer::DeletePlayersByName(_) => "delete_players_by_name",
			Reducer::QueryPrivate(_) => "query_private",
			Reducer::RepeatingTest(_) => "repeating_test",
			Reducer::Test(_) => "test",
}
}
fn reducer_args(&self) -> &dyn std::any::Any {
		match self {
						Reducer::IdentityConnected(args) => args,
			Reducer::Init(args) => args,
			Reducer::AddPlayer(args) => args,
			Reducer::AddPrivate(args) => args,
			Reducer::DeletePlayer(args) => args,
			Reducer::DeletePlayersByName(args) => args,
			Reducer::QueryPrivate(args) => args,
			Reducer::RepeatingTest(args) => args,
			Reducer::Test(args) => args,
}
}
}
impl TryFrom<__ws::ReducerCallInfo<__ws::BsatnFormat>> for Reducer {
		type Error = __anyhow::Error;
fn try_from(value: __ws::ReducerCallInfo<__ws::BsatnFormat>) -> __anyhow::Result<Self> {
		match &value.reducer_name[..] {
						"__identity_connected__" => Ok(Reducer::IdentityConnected(__sdk::spacetime_module::parse_reducer_args("__identity_connected__", &value.args)?)),
			"__init__" => Ok(Reducer::Init(__sdk::spacetime_module::parse_reducer_args("__init__", &value.args)?)),
			"add_player" => Ok(Reducer::AddPlayer(__sdk::spacetime_module::parse_reducer_args("add_player", &value.args)?)),
			"add_private" => Ok(Reducer::AddPrivate(__sdk::spacetime_module::parse_reducer_args("add_private", &value.args)?)),
			"delete_player" => Ok(Reducer::DeletePlayer(__sdk::spacetime_module::parse_reducer_args("delete_player", &value.args)?)),
			"delete_players_by_name" => Ok(Reducer::DeletePlayersByName(__sdk::spacetime_module::parse_reducer_args("delete_players_by_name", &value.args)?)),
			"query_private" => Ok(Reducer::QueryPrivate(__sdk::spacetime_module::parse_reducer_args("query_private", &value.args)?)),
			"repeating_test" => Ok(Reducer::RepeatingTest(__sdk::spacetime_module::parse_reducer_args("repeating_test", &value.args)?)),
			"test" => Ok(Reducer::Test(__sdk::spacetime_module::parse_reducer_args("test", &value.args)?)),
			_ => Err(__anyhow::anyhow!("Unknown reducer {:?}", value.reducer_name)),
}
}
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct DbUpdate {
		has_special_stuff: __sdk::spacetime_module::TableUpdate<HasSpecialStuff>,
	pk_multi_identity: __sdk::spacetime_module::TableUpdate<PkMultiIdentity>,
	points: __sdk::spacetime_module::TableUpdate<Point>,
	private: __sdk::spacetime_module::TableUpdate<Private>,
	repeating_test_arg: __sdk::spacetime_module::TableUpdate<RepeatingTestArg>,
	test_a: __sdk::spacetime_module::TableUpdate<TestA>,
	test_d: __sdk::spacetime_module::TableUpdate<TestD>,
	test_e: __sdk::spacetime_module::TableUpdate<TestE>,
	test_f: __sdk::spacetime_module::TableUpdate<TestFoobar>,
}


impl TryFrom<__ws::DatabaseUpdate<__ws::BsatnFormat>> for DbUpdate {
    type Error = __anyhow::Error;
    fn try_from(raw: __ws::DatabaseUpdate<__ws::BsatnFormat>) -> Result<Self, Self::Error> {
        let mut db_update = DbUpdate::default();
        for table_update in raw.tables {
            match &table_update.table_name[..] {

		"has_special_stuff" => db_update.has_special_stuff = has_special_stuff_table::parse_table_update(table_update)?,
	"pk_multi_identity" => db_update.pk_multi_identity = pk_multi_identity_table::parse_table_update(table_update)?,
	"points" => db_update.points = points_table::parse_table_update(table_update)?,
	"private" => db_update.private = private_table::parse_table_update(table_update)?,
	"repeating_test_arg" => db_update.repeating_test_arg = repeating_test_arg_table::parse_table_update(table_update)?,
	"test_a" => db_update.test_a = test_a_table::parse_table_update(table_update)?,
	"test_d" => db_update.test_d = test_d_table::parse_table_update(table_update)?,
	"test_e" => db_update.test_e = test_e_table::parse_table_update(table_update)?,
	"test_f" => db_update.test_f = test_f_table::parse_table_update(table_update)?,

                unknown => __anyhow::bail!("Unknown table {unknown:?} in DatabaseUpdate"),
            }
        }
        Ok(db_update)
    }
}

impl __sdk::spacetime_module::InModule for DbUpdate {
    type Module = RemoteModule;
}

impl __sdk::spacetime_module::DbUpdate for DbUpdate {
	fn apply_to_client_cache(&self, cache: &mut __sdk::client_cache::ClientCache<RemoteModule>) {
				cache.apply_diff_to_table::<HasSpecialStuff>("has_special_stuff", &self.has_special_stuff);
		cache.apply_diff_to_table::<PkMultiIdentity>("pk_multi_identity", &self.pk_multi_identity);
		cache.apply_diff_to_table::<Point>("points", &self.points);
		cache.apply_diff_to_table::<Private>("private", &self.private);
		cache.apply_diff_to_table::<RepeatingTestArg>("repeating_test_arg", &self.repeating_test_arg);
		cache.apply_diff_to_table::<TestA>("test_a", &self.test_a);
		cache.apply_diff_to_table::<TestD>("test_d", &self.test_d);
		cache.apply_diff_to_table::<TestE>("test_e", &self.test_e);
		cache.apply_diff_to_table::<TestFoobar>("test_f", &self.test_f);
}
fn invoke_row_callbacks(&self, event: &EventContext, callbacks: &mut __sdk::callbacks::DbCallbacks<RemoteModule>) {
				callbacks.invoke_table_row_callbacks::<HasSpecialStuff>("has_special_stuff", &self.has_special_stuff, event);
		callbacks.invoke_table_row_callbacks::<PkMultiIdentity>("pk_multi_identity", &self.pk_multi_identity, event);
		callbacks.invoke_table_row_callbacks::<Point>("points", &self.points, event);
		callbacks.invoke_table_row_callbacks::<Private>("private", &self.private, event);
		callbacks.invoke_table_row_callbacks::<RepeatingTestArg>("repeating_test_arg", &self.repeating_test_arg, event);
		callbacks.invoke_table_row_callbacks::<TestA>("test_a", &self.test_a, event);
		callbacks.invoke_table_row_callbacks::<TestD>("test_d", &self.test_d, event);
		callbacks.invoke_table_row_callbacks::<TestE>("test_e", &self.test_e, event);
		callbacks.invoke_table_row_callbacks::<TestFoobar>("test_f", &self.test_f, event);
}
}


#[doc(hidden)]
pub struct RemoteModule;

impl __sdk::spacetime_module::InModule for RemoteModule {
    type Module = Self;
}

impl __sdk::spacetime_module::SpacetimeModule for RemoteModule {
    type DbConnection = DbConnection;
    type EventContext = EventContext;
    type Reducer = Reducer;
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type DbUpdate = DbUpdate;
    type SubscriptionHandle = SubscriptionHandle;
}

/// The `reducers` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
pub struct RemoteReducers {
    imp: __sdk::db_connection::DbContextImpl<RemoteModule>,
}

impl __sdk::spacetime_module::InModule for RemoteReducers {
    type Module = RemoteModule;
}

/// The `db` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each table defined by the module.
pub struct RemoteTables {
    imp: __sdk::db_connection::DbContextImpl<RemoteModule>,
}

impl __sdk::spacetime_module::InModule for RemoteTables {
    type Module = RemoteModule;
}

/// A connection to a remote module, including a materialized view of a subset of the database.
///
/// Connect to a remote module by calling [`DbConnection::builder`]
/// and using the [`__sdk::DbConnectionBuilder`] builder-pattern constructor.
///
/// You must explicitly advance the connection by calling any one of:
///
/// - [`DbConnection::frame_tick`].
/// - [`DbConnection::run_threaded`].
/// - [`DbConnection::run_async`].
/// - [`DbConnection::advance_one_message`].
/// - [`DbConnection::advance_one_message_blocking`].
/// - [`DbConnection::advance_one_message_async`].
///
/// Which of these methods you should call depends on the specific needs of your application,
/// but you must call one of them, or else the connection will never progress.
pub struct DbConnection {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,

    imp: __sdk::db_connection::DbContextImpl<RemoteModule>,
}

impl __sdk::spacetime_module::InModule for DbConnection {
    type Module = RemoteModule;
}

impl __sdk::db_context::DbContext for DbConnection {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __anyhow::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::subscription::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::subscription::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn address(&self) -> __sdk::Address {
        self.imp.address()
    }
}

impl DbConnection {
    /// Builder-pattern constructor for a connection to a remote module.
    ///
    /// See [`__sdk::DbConnectionBuilder`] for required and optional configuration for the new connection.
    pub fn builder() -> __sdk::DbConnectionBuilder<RemoteModule> {
        __sdk::db_connection::DbConnectionBuilder::new()
    }

    /// If any WebSocket messages are waiting, process one of them.
    ///
    /// Returns `true` if a message was processed, or `false` if the queue is empty.
    /// Callers should invoke this message in a loop until it returns `false`
    /// or for as much time is available to process messages.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::frame_tick`] each frame
    /// to fully exhaust the queue whenever time is available.
    pub fn advance_one_message(&self) -> __anyhow::Result<bool> {
        self.imp.advance_one_message()
    }

    /// Process one WebSocket message, potentially blocking the current thread until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_threaded`] to spawn a thread
    /// which advances the connection automatically.
    pub fn advance_one_message_blocking(&self) -> __anyhow::Result<()> {
        self.imp.advance_one_message_blocking()
    }

    /// Process one WebSocket message, `await`ing until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_async`] to run an `async` loop
    /// which advances the connection when polled.
    pub async fn advance_one_message_async(&self) -> __anyhow::Result<()> {
        self.imp.advance_one_message_async().await
    }

    /// Process all WebSocket messages waiting in the queue,
    /// then return without `await`ing or blocking the current thread.
    pub fn frame_tick(&self) -> __anyhow::Result<()> {
        self.imp.frame_tick()
    }

    /// Spawn a thread which processes WebSocket messages as they are received.
    pub fn run_threaded(&self) -> std::thread::JoinHandle<()> {
        self.imp.run_threaded()
    }

    /// Run an `async` loop which processes WebSocket messages when polled.
    pub async fn run_async(&self) -> __anyhow::Result<()> {
        self.imp.run_async().await
    }
}

impl __sdk::spacetime_module::DbConnection for DbConnection {
    fn new(imp: __sdk::db_connection::DbContextImpl<RemoteModule>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            imp,
        }
    }
}

/// A [`DbConnection`] augmented with an [`__sdk::Event`],
/// passed to various callbacks invoked by the SDK.
pub struct EventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// The event which caused these callbacks to run.
    pub event: __sdk::event::Event<Reducer>,
    imp: __sdk::db_connection::DbContextImpl<RemoteModule>,
}

impl __sdk::spacetime_module::InModule for EventContext {
    type Module = RemoteModule;
}

impl __sdk::db_context::DbContext for EventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> spacetimedb_sdk::anyhow::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::subscription::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::subscription::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn address(&self) -> __sdk::Address {
        self.imp.address()
    }
}

impl __sdk::spacetime_module::EventContext for EventContext {
    fn event(&self) -> &__sdk::event::Event<Reducer> {
        &self.event
    }
    fn new(imp: __sdk::db_connection::DbContextImpl<RemoteModule>, event: __sdk::event::Event<Reducer>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            event,
            imp,
        }
    }
}

/// A handle on a subscribed query.
// TODO: Document this better after implementing the new subscription API.
pub struct SubscriptionHandle {
    imp: __sdk::subscription::SubscriptionHandleImpl<RemoteModule>,
}

impl __sdk::spacetime_module::InModule for SubscriptionHandle {
    type Module = RemoteModule;
}

impl __sdk::spacetime_module::SubscriptionHandle for SubscriptionHandle {
    fn new(imp: __sdk::subscription::SubscriptionHandleImpl<RemoteModule>) -> Self {
        Self { imp }
    }
}

/// Alias trait for a [`__sdk::DbContext`] connected to this module,
/// with that trait's associated types bounded to this module's concrete types.
///
/// Users can use this trait as a boundary on definitions which should accept
/// either a [`DbConnection`] or an [`EventContext`] and operate on either.
pub trait RemoteDbContext: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SubscriptionBuilder = __sdk::subscription::SubscriptionBuilder<RemoteModule>,
> {}
impl<Ctx: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SubscriptionBuilder = __sdk::subscription::SubscriptionBuilder<RemoteModule>,
>> RemoteDbContext for Ctx {}

'''
"namespace_test_c_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestC {
	Foo,

	Bar,

}



impl __sdk::spacetime_module::InModule for NamespaceTestC {
    type Module = super::RemoteModule;
}

'''
"namespace_test_f_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestF {
	Foo,

	Bar,

	Baz(String),

}



impl __sdk::spacetime_module::InModule for NamespaceTestF {
    type Module = super::RemoteModule;
}

'''
"pk_multi_identity_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::pk_multi_identity_type::PkMultiIdentity;

/// Table handle for the table `pk_multi_identity`.
///
/// Obtain a handle from the [`PkMultiIdentityTableAccess::pk_multi_identity`] method on [`super::RemoteTables`],
/// like `ctx.db.pk_multi_identity()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.pk_multi_identity().on_insert(...)`.
pub struct PkMultiIdentityTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<PkMultiIdentity>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `pk_multi_identity`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PkMultiIdentityTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PkMultiIdentityTableHandle`], which mediates access to the table `pk_multi_identity`.
    fn pk_multi_identity(&self) -> PkMultiIdentityTableHandle<'_>;
}

impl PkMultiIdentityTableAccess for super::RemoteTables {
    fn pk_multi_identity(&self) -> PkMultiIdentityTableHandle<'_> {
        PkMultiIdentityTableHandle {
            imp: self.imp.get_table::<PkMultiIdentity>("pk_multi_identity"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PkMultiIdentityInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct PkMultiIdentityDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for PkMultiIdentityTableHandle<'ctx> {
    type Row = PkMultiIdentity;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = PkMultiIdentity> + '_ { self.imp.iter() }

    type InsertCallbackId = PkMultiIdentityInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityInsertCallbackId {
        PkMultiIdentityInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PkMultiIdentityInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PkMultiIdentityDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityDeleteCallbackId {
        PkMultiIdentityDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PkMultiIdentityDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

pub struct PkMultiIdentityUpdateCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::TableWithPrimaryKey for PkMultiIdentityTableHandle<'ctx> {
    type UpdateCallbackId = PkMultiIdentityUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityUpdateCallbackId {
        PkMultiIdentityUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PkMultiIdentityUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<PkMultiIdentity>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_with_primary_key::<u32>(
        raw_updates,
        |row: &PkMultiIdentity| &row.id,
    ).context("Failed to parse table update for table \"pk_multi_identity\"")
}

        /// Access to the `id` unique index on the table `pk_multi_identity`,
        /// which allows point queries on the field of the same name
        /// via the [`PkMultiIdentityIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.pk_multi_identity().id().find(...)`.
        pub struct PkMultiIdentityIdUnique<'ctx> {
            imp: __sdk::client_cache::UniqueConstraint<PkMultiIdentity, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PkMultiIdentityTableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `pk_multi_identity`.
            pub fn id(&self) -> PkMultiIdentityIdUnique<'ctx> {
                PkMultiIdentityIdUnique {
                    imp: self.imp.get_unique_constraint::<u32>("id", |row| &row.id),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PkMultiIdentityIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<PkMultiIdentity> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `other` unique index on the table `pk_multi_identity`,
        /// which allows point queries on the field of the same name
        /// via the [`PkMultiIdentityOtherUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.pk_multi_identity().other().find(...)`.
        pub struct PkMultiIdentityOtherUnique<'ctx> {
            imp: __sdk::client_cache::UniqueConstraint<PkMultiIdentity, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PkMultiIdentityTableHandle<'ctx> {
            /// Get a handle on the `other` unique index on the table `pk_multi_identity`.
            pub fn other(&self) -> PkMultiIdentityOtherUnique<'ctx> {
                PkMultiIdentityOtherUnique {
                    imp: self.imp.get_unique_constraint::<u32>("other", |row| &row.other),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PkMultiIdentityOtherUnique<'ctx> {
            /// Find the subscribed row whose `other` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<PkMultiIdentity> {
                self.imp.find(col_val)
            }
        }
        '''
"pk_multi_identity_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct PkMultiIdentity {
	pub id: u32,
	pub other: u32,
}


impl __sdk::spacetime_module::InModule for PkMultiIdentity {
    type Module = super::RemoteModule;
}

'''
"point_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Point {
	pub x: i64,
	pub y: i64,
}


impl __sdk::spacetime_module::InModule for Point {
    type Module = super::RemoteModule;
}

'''
"points_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::point_type::Point;

/// Table handle for the table `points`.
///
/// Obtain a handle from the [`PointsTableAccess::points`] method on [`super::RemoteTables`],
/// like `ctx.db.points()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.points().on_insert(...)`.
pub struct PointsTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<Point>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `points`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PointsTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PointsTableHandle`], which mediates access to the table `points`.
    fn points(&self) -> PointsTableHandle<'_>;
}

impl PointsTableAccess for super::RemoteTables {
    fn points(&self) -> PointsTableHandle<'_> {
        PointsTableHandle {
            imp: self.imp.get_table::<Point>("points"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PointsInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct PointsDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for PointsTableHandle<'ctx> {
    type Row = Point;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Point> + '_ { self.imp.iter() }

    type InsertCallbackId = PointsInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PointsInsertCallbackId {
        PointsInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PointsInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PointsDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PointsDeleteCallbackId {
        PointsDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PointsDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<Point>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"points\"")
}
'''
"private_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::private_type::Private;

/// Table handle for the table `private`.
///
/// Obtain a handle from the [`PrivateTableAccess::private`] method on [`super::RemoteTables`],
/// like `ctx.db.private()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.private().on_insert(...)`.
pub struct PrivateTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<Private>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `private`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PrivateTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PrivateTableHandle`], which mediates access to the table `private`.
    fn private(&self) -> PrivateTableHandle<'_>;
}

impl PrivateTableAccess for super::RemoteTables {
    fn private(&self) -> PrivateTableHandle<'_> {
        PrivateTableHandle {
            imp: self.imp.get_table::<Private>("private"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PrivateInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct PrivateDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for PrivateTableHandle<'ctx> {
    type Row = Private;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Private> + '_ { self.imp.iter() }

    type InsertCallbackId = PrivateInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PrivateInsertCallbackId {
        PrivateInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PrivateInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PrivateDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PrivateDeleteCallbackId {
        PrivateDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PrivateDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<Private>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"private\"")
}
'''
"private_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Private {
	pub name: String,
}


impl __sdk::spacetime_module::InModule for Private {
    type Module = super::RemoteModule;
}

'''
"query_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct QueryPrivate {
	}


impl __sdk::spacetime_module::InModule for QueryPrivate {
    type Module = super::RemoteModule;
}

pub struct QueryPrivateCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `query_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait query_private {
    /// Request that the remote module invoke the reducer `query_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_query_private`] callbacks.
    fn query_private(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `query_private`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`QueryPrivateCallbackId`] can be passed to [`Self::remove_on_query_private`]
    /// to cancel the callback.
    fn on_query_private(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> QueryPrivateCallbackId;
    /// Cancel a callback previously registered by [`Self::on_query_private`],
    /// causing it not to run in the future.
    fn remove_on_query_private(&self, callback: QueryPrivateCallbackId);
}

impl query_private for super::RemoteReducers {
    fn query_private(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("query_private", QueryPrivate {  })
    }
    fn on_query_private(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> QueryPrivateCallbackId {
        QueryPrivateCallbackId(self.imp.on_reducer::<QueryPrivate>(
            "query_private",
            Box::new(move |ctx: &super::EventContext, args: &QueryPrivate| callback(ctx, )),
        ))
    }
    fn remove_on_query_private(&self, callback: QueryPrivateCallbackId) {
        self.imp.remove_on_reducer::<QueryPrivate>("query_private", callback.0)
    }
}

'''
"repeating_test_arg_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::repeating_test_arg_type::RepeatingTestArg;

/// Table handle for the table `repeating_test_arg`.
///
/// Obtain a handle from the [`RepeatingTestArgTableAccess::repeating_test_arg`] method on [`super::RemoteTables`],
/// like `ctx.db.repeating_test_arg()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.repeating_test_arg().on_insert(...)`.
pub struct RepeatingTestArgTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<RepeatingTestArg>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `repeating_test_arg`.
///
/// Implemented for [`super::RemoteTables`].
pub trait RepeatingTestArgTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`RepeatingTestArgTableHandle`], which mediates access to the table `repeating_test_arg`.
    fn repeating_test_arg(&self) -> RepeatingTestArgTableHandle<'_>;
}

impl RepeatingTestArgTableAccess for super::RemoteTables {
    fn repeating_test_arg(&self) -> RepeatingTestArgTableHandle<'_> {
        RepeatingTestArgTableHandle {
            imp: self.imp.get_table::<RepeatingTestArg>("repeating_test_arg"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct RepeatingTestArgInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct RepeatingTestArgDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for RepeatingTestArgTableHandle<'ctx> {
    type Row = RepeatingTestArg;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = RepeatingTestArg> + '_ { self.imp.iter() }

    type InsertCallbackId = RepeatingTestArgInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgInsertCallbackId {
        RepeatingTestArgInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: RepeatingTestArgInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = RepeatingTestArgDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgDeleteCallbackId {
        RepeatingTestArgDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: RepeatingTestArgDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

pub struct RepeatingTestArgUpdateCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::TableWithPrimaryKey for RepeatingTestArgTableHandle<'ctx> {
    type UpdateCallbackId = RepeatingTestArgUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgUpdateCallbackId {
        RepeatingTestArgUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: RepeatingTestArgUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<RepeatingTestArg>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_with_primary_key::<u64>(
        raw_updates,
        |row: &RepeatingTestArg| &row.scheduled_id,
    ).context("Failed to parse table update for table \"repeating_test_arg\"")
}

        /// Access to the `scheduled_id` unique index on the table `repeating_test_arg`,
        /// which allows point queries on the field of the same name
        /// via the [`RepeatingTestArgScheduledIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.repeating_test_arg().scheduled_id().find(...)`.
        pub struct RepeatingTestArgScheduledIdUnique<'ctx> {
            imp: __sdk::client_cache::UniqueConstraint<RepeatingTestArg, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> RepeatingTestArgTableHandle<'ctx> {
            /// Get a handle on the `scheduled_id` unique index on the table `repeating_test_arg`.
            pub fn scheduled_id(&self) -> RepeatingTestArgScheduledIdUnique<'ctx> {
                RepeatingTestArgScheduledIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("scheduled_id", |row| &row.scheduled_id),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> RepeatingTestArgScheduledIdUnique<'ctx> {
            /// Find the subscribed row whose `scheduled_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<RepeatingTestArg> {
                self.imp.find(col_val)
            }
        }
        '''
"repeating_test_arg_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct RepeatingTestArg {
	pub prev_time: __sdk::Timestamp,
	pub scheduled_id: u64,
	pub scheduled_at: __sdk::ScheduleAt,
}


impl __sdk::spacetime_module::InModule for RepeatingTestArg {
    type Module = super::RemoteModule;
}

'''
"repeating_test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

use super::repeating_test_arg_type::RepeatingTestArg;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct RepeatingTest {
	pub arg: RepeatingTestArg,
}


impl __sdk::spacetime_module::InModule for RepeatingTest {
    type Module = super::RemoteModule;
}

pub struct RepeatingTestCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `repeating_test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait repeating_test {
    /// Request that the remote module invoke the reducer `repeating_test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_repeating_test`] callbacks.
    fn repeating_test(&self, arg: RepeatingTestArg,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `repeating_test`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`RepeatingTestCallbackId`] can be passed to [`Self::remove_on_repeating_test`]
    /// to cancel the callback.
    fn on_repeating_test(&self, callback: impl FnMut(&super::EventContext, &RepeatingTestArg, ) + Send + 'static) -> RepeatingTestCallbackId;
    /// Cancel a callback previously registered by [`Self::on_repeating_test`],
    /// causing it not to run in the future.
    fn remove_on_repeating_test(&self, callback: RepeatingTestCallbackId);
}

impl repeating_test for super::RemoteReducers {
    fn repeating_test(&self, arg: RepeatingTestArg,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("repeating_test", RepeatingTest { arg,  })
    }
    fn on_repeating_test(
        &self,
        mut callback: impl FnMut(&super::EventContext, &RepeatingTestArg, ) + Send + 'static,
    ) -> RepeatingTestCallbackId {
        RepeatingTestCallbackId(self.imp.on_reducer::<RepeatingTest>(
            "repeating_test",
            Box::new(move |ctx: &super::EventContext, args: &RepeatingTest| callback(ctx, &args.arg, )),
        ))
    }
    fn remove_on_repeating_test(&self, callback: RepeatingTestCallbackId) {
        self.imp.remove_on_reducer::<RepeatingTest>("repeating_test", callback.0)
    }
}

'''
"test_a_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::test_a_type::TestA;

/// Table handle for the table `test_a`.
///
/// Obtain a handle from the [`TestATableAccess::test_a`] method on [`super::RemoteTables`],
/// like `ctx.db.test_a()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_a().on_insert(...)`.
pub struct TestATableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<TestA>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_a`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestATableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestATableHandle`], which mediates access to the table `test_a`.
    fn test_a(&self) -> TestATableHandle<'_>;
}

impl TestATableAccess for super::RemoteTables {
    fn test_a(&self) -> TestATableHandle<'_> {
        TestATableHandle {
            imp: self.imp.get_table::<TestA>("test_a"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestAInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct TestADeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for TestATableHandle<'ctx> {
    type Row = TestA;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestA> + '_ { self.imp.iter() }

    type InsertCallbackId = TestAInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestAInsertCallbackId {
        TestAInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestAInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestADeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestADeleteCallbackId {
        TestADeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestADeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<TestA>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"test_a\"")
}
'''
"test_a_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestA {
	pub x: u32,
	pub y: u32,
	pub z: String,
}


impl __sdk::spacetime_module::InModule for TestA {
    type Module = super::RemoteModule;
}

'''
"test_b_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestB {
	pub foo: String,
}


impl __sdk::spacetime_module::InModule for TestB {
    type Module = super::RemoteModule;
}

'''
"test_d_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::test_d_type::TestD;
use super::namespace_test_c_type::NamespaceTestC;

/// Table handle for the table `test_d`.
///
/// Obtain a handle from the [`TestDTableAccess::test_d`] method on [`super::RemoteTables`],
/// like `ctx.db.test_d()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_d().on_insert(...)`.
pub struct TestDTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<TestD>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_d`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestDTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestDTableHandle`], which mediates access to the table `test_d`.
    fn test_d(&self) -> TestDTableHandle<'_>;
}

impl TestDTableAccess for super::RemoteTables {
    fn test_d(&self) -> TestDTableHandle<'_> {
        TestDTableHandle {
            imp: self.imp.get_table::<TestD>("test_d"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestDInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct TestDDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for TestDTableHandle<'ctx> {
    type Row = TestD;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestD> + '_ { self.imp.iter() }

    type InsertCallbackId = TestDInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDInsertCallbackId {
        TestDInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestDInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestDDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDDeleteCallbackId {
        TestDDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestDDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<TestD>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"test_d\"")
}
'''
"test_d_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

use super::namespace_test_c_type::NamespaceTestC;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestD {
	pub test_c: Option::<NamespaceTestC>,
}


impl __sdk::spacetime_module::InModule for TestD {
    type Module = super::RemoteModule;
}

'''
"test_e_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::test_e_type::TestE;

/// Table handle for the table `test_e`.
///
/// Obtain a handle from the [`TestETableAccess::test_e`] method on [`super::RemoteTables`],
/// like `ctx.db.test_e()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_e().on_insert(...)`.
pub struct TestETableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<TestE>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_e`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestETableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestETableHandle`], which mediates access to the table `test_e`.
    fn test_e(&self) -> TestETableHandle<'_>;
}

impl TestETableAccess for super::RemoteTables {
    fn test_e(&self) -> TestETableHandle<'_> {
        TestETableHandle {
            imp: self.imp.get_table::<TestE>("test_e"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestEInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct TestEDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for TestETableHandle<'ctx> {
    type Row = TestE;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestE> + '_ { self.imp.iter() }

    type InsertCallbackId = TestEInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestEInsertCallbackId {
        TestEInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestEInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestEDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestEDeleteCallbackId {
        TestEDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestEDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

pub struct TestEUpdateCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::TableWithPrimaryKey for TestETableHandle<'ctx> {
    type UpdateCallbackId = TestEUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> TestEUpdateCallbackId {
        TestEUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: TestEUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<TestE>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_with_primary_key::<u64>(
        raw_updates,
        |row: &TestE| &row.id,
    ).context("Failed to parse table update for table \"test_e\"")
}

        /// Access to the `id` unique index on the table `test_e`,
        /// which allows point queries on the field of the same name
        /// via the [`TestEIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.test_e().id().find(...)`.
        pub struct TestEIdUnique<'ctx> {
            imp: __sdk::client_cache::UniqueConstraint<TestE, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> TestETableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `test_e`.
            pub fn id(&self) -> TestEIdUnique<'ctx> {
                TestEIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("id", |row| &row.id),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> TestEIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<TestE> {
                self.imp.find(col_val)
            }
        }
        '''
"test_e_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestE {
	pub id: u64,
	pub name: String,
}


impl __sdk::spacetime_module::InModule for TestE {
    type Module = super::RemoteModule;
}

'''
"test_f_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};
use super::test_foobar_type::TestFoobar;
use super::foobar_type::Foobar;

/// Table handle for the table `test_f`.
///
/// Obtain a handle from the [`TestFTableAccess::test_f`] method on [`super::RemoteTables`],
/// like `ctx.db.test_f()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_f().on_insert(...)`.
pub struct TestFTableHandle<'ctx> {
    imp: __sdk::db_connection::TableHandle<TestFoobar>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_f`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestFTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestFTableHandle`], which mediates access to the table `test_f`.
    fn test_f(&self) -> TestFTableHandle<'_>;
}

impl TestFTableAccess for super::RemoteTables {
    fn test_f(&self) -> TestFTableHandle<'_> {
        TestFTableHandle {
            imp: self.imp.get_table::<TestFoobar>("test_f"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestFInsertCallbackId(__sdk::callbacks::CallbackId);
pub struct TestFDeleteCallbackId(__sdk::callbacks::CallbackId);

impl<'ctx> __sdk::table::Table for TestFTableHandle<'ctx> {
    type Row = TestFoobar;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestFoobar> + '_ { self.imp.iter() }

    type InsertCallbackId = TestFInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFInsertCallbackId {
        TestFInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestFInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestFDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFDeleteCallbackId {
        TestFDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestFDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::spacetime_module::TableUpdate<TestFoobar>> {
    __sdk::spacetime_module::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"test_f\"")
}
'''
"test_foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

use super::foobar_type::Foobar;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestFoobar {
	pub field: Foobar,
}


impl __sdk::spacetime_module::InModule for TestFoobar {
    type Module = super::RemoteModule;
}

'''
"test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	lib as __lib,
	sats as __sats,
	ws_messages as __ws,
};

use super::test_a_type::TestA;
use super::test_b_type::TestB;
use super::namespace_test_c_type::NamespaceTestC;
use super::namespace_test_f_type::NamespaceTestF;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Test {
	pub arg: TestA,
	pub arg_2: TestB,
	pub arg_3: NamespaceTestC,
	pub arg_4: NamespaceTestF,
}


impl __sdk::spacetime_module::InModule for Test {
    type Module = super::RemoteModule;
}

pub struct TestCallbackId(__sdk::callbacks::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test {
    /// Request that the remote module invoke the reducer `test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_test`] callbacks.
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `test`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`TestCallbackId`] can be passed to [`Self::remove_on_test`]
    /// to cancel the callback.
    fn on_test(&self, callback: impl FnMut(&super::EventContext, &TestA, &TestB, &NamespaceTestC, &NamespaceTestF, ) + Send + 'static) -> TestCallbackId;
    /// Cancel a callback previously registered by [`Self::on_test`],
    /// causing it not to run in the future.
    fn remove_on_test(&self, callback: TestCallbackId);
}

impl test for super::RemoteReducers {
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("test", Test { arg, arg_2, arg_3, arg_4,  })
    }
    fn on_test(
        &self,
        mut callback: impl FnMut(&super::EventContext, &TestA, &TestB, &NamespaceTestC, &NamespaceTestF, ) + Send + 'static,
    ) -> TestCallbackId {
        TestCallbackId(self.imp.on_reducer::<Test>(
            "test",
            Box::new(move |ctx: &super::EventContext, args: &Test| callback(ctx, &args.arg, &args.arg_2, &args.arg_3, &args.arg_4, )),
        ))
    }
    fn remove_on_test(&self, callback: TestCallbackId) {
        self.imp.remove_on_reducer::<Test>("test", callback.0)
    }
}

'''
