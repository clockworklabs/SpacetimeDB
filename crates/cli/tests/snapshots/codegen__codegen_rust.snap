---
source: crates/cli/tests/codegen.rs
expression: outfiles
---
"add_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddPlayerArgs {
	pub name: String,
}

impl From<AddPlayerArgs> for super::Reducer {
	fn from(args: AddPlayerArgs) -> Self {
		Self::AddPlayer {
			name: args.name,
}
}
}

impl __sdk::InModule for AddPlayerArgs {
    type Module = super::RemoteModule;
}

pub struct AddPlayerCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_player {
    /// Request that the remote module invoke the reducer `add_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add_player`] callbacks.
    fn add_player(&self, name: String,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add_player`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddPlayerCallbackId`] can be passed to [`Self::remove_on_add_player`]
    /// to cancel the callback.
    fn on_add_player(&self, callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static) -> AddPlayerCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add_player`],
    /// causing it not to run in the future.
    fn remove_on_add_player(&self, callback: AddPlayerCallbackId);
}

impl add_player for super::RemoteReducers {
    fn add_player(&self, name: String,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("add_player", AddPlayerArgs { name,  })
    }
    fn on_add_player(
        &self,
        mut callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static,
    ) -> AddPlayerCallbackId {
        AddPlayerCallbackId(self.imp.on_reducer(
            "add_player",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::AddPlayer {
                            name, 
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, )
            }),
        ))
    }
    fn remove_on_add_player(&self, callback: AddPlayerCallbackId) {
        self.imp.remove_on_reducer("add_player", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `add_player`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_add_player {
    /// Set the call-reducer flags for the reducer `add_player` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn add_player(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_add_player for super::SetReducerFlags {
    fn add_player(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("add_player", flags);
    }
}

'''
"add_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AddPrivateArgs {
	pub name: String,
}

impl From<AddPrivateArgs> for super::Reducer {
	fn from(args: AddPrivateArgs) -> Self {
		Self::AddPrivate {
			name: args.name,
}
}
}

impl __sdk::InModule for AddPrivateArgs {
    type Module = super::RemoteModule;
}

pub struct AddPrivateCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `add_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait add_private {
    /// Request that the remote module invoke the reducer `add_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_add_private`] callbacks.
    fn add_private(&self, name: String,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `add_private`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AddPrivateCallbackId`] can be passed to [`Self::remove_on_add_private`]
    /// to cancel the callback.
    fn on_add_private(&self, callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static) -> AddPrivateCallbackId;
    /// Cancel a callback previously registered by [`Self::on_add_private`],
    /// causing it not to run in the future.
    fn remove_on_add_private(&self, callback: AddPrivateCallbackId);
}

impl add_private for super::RemoteReducers {
    fn add_private(&self, name: String,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("add_private", AddPrivateArgs { name,  })
    }
    fn on_add_private(
        &self,
        mut callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static,
    ) -> AddPrivateCallbackId {
        AddPrivateCallbackId(self.imp.on_reducer(
            "add_private",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::AddPrivate {
                            name, 
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, )
            }),
        ))
    }
    fn remove_on_add_private(&self, callback: AddPrivateCallbackId) {
        self.imp.remove_on_reducer("add_private", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `add_private`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_add_private {
    /// Set the call-reducer flags for the reducer `add_private` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn add_private(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_add_private for super::SetReducerFlags {
    fn add_private(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("add_private", flags);
    }
}

'''
"assert_caller_identity_is_module_identity_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct AssertCallerIdentityIsModuleIdentityArgs {
	}

impl From<AssertCallerIdentityIsModuleIdentityArgs> for super::Reducer {
	fn from(args: AssertCallerIdentityIsModuleIdentityArgs) -> Self {
		Self::AssertCallerIdentityIsModuleIdentity
}
}

impl __sdk::InModule for AssertCallerIdentityIsModuleIdentityArgs {
    type Module = super::RemoteModule;
}

pub struct AssertCallerIdentityIsModuleIdentityCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `assert_caller_identity_is_module_identity`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait assert_caller_identity_is_module_identity {
    /// Request that the remote module invoke the reducer `assert_caller_identity_is_module_identity` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_assert_caller_identity_is_module_identity`] callbacks.
    fn assert_caller_identity_is_module_identity(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `assert_caller_identity_is_module_identity`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`AssertCallerIdentityIsModuleIdentityCallbackId`] can be passed to [`Self::remove_on_assert_caller_identity_is_module_identity`]
    /// to cancel the callback.
    fn on_assert_caller_identity_is_module_identity(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> AssertCallerIdentityIsModuleIdentityCallbackId;
    /// Cancel a callback previously registered by [`Self::on_assert_caller_identity_is_module_identity`],
    /// causing it not to run in the future.
    fn remove_on_assert_caller_identity_is_module_identity(&self, callback: AssertCallerIdentityIsModuleIdentityCallbackId);
}

impl assert_caller_identity_is_module_identity for super::RemoteReducers {
    fn assert_caller_identity_is_module_identity(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("assert_caller_identity_is_module_identity", AssertCallerIdentityIsModuleIdentityArgs {  })
    }
    fn on_assert_caller_identity_is_module_identity(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> AssertCallerIdentityIsModuleIdentityCallbackId {
        AssertCallerIdentityIsModuleIdentityCallbackId(self.imp.on_reducer(
            "assert_caller_identity_is_module_identity",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::AssertCallerIdentityIsModuleIdentity {
                            
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_assert_caller_identity_is_module_identity(&self, callback: AssertCallerIdentityIsModuleIdentityCallbackId) {
        self.imp.remove_on_reducer("assert_caller_identity_is_module_identity", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `assert_caller_identity_is_module_identity`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_assert_caller_identity_is_module_identity {
    /// Set the call-reducer flags for the reducer `assert_caller_identity_is_module_identity` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn assert_caller_identity_is_module_identity(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_assert_caller_identity_is_module_identity for super::SetReducerFlags {
    fn assert_caller_identity_is_module_identity(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("assert_caller_identity_is_module_identity", flags);
    }
}

'''
"baz_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Baz {
	pub field: String,
}


impl __sdk::InModule for Baz {
    type Module = super::RemoteModule;
}

'''
"delete_player_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct DeletePlayerArgs {
	pub id: u64,
}

impl From<DeletePlayerArgs> for super::Reducer {
	fn from(args: DeletePlayerArgs) -> Self {
		Self::DeletePlayer {
			id: args.id,
}
}
}

impl __sdk::InModule for DeletePlayerArgs {
    type Module = super::RemoteModule;
}

pub struct DeletePlayerCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_player`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_player {
    /// Request that the remote module invoke the reducer `delete_player` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_delete_player`] callbacks.
    fn delete_player(&self, id: u64,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `delete_player`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`DeletePlayerCallbackId`] can be passed to [`Self::remove_on_delete_player`]
    /// to cancel the callback.
    fn on_delete_player(&self, callback: impl FnMut(&super::EventContext, &u64, ) + Send + 'static) -> DeletePlayerCallbackId;
    /// Cancel a callback previously registered by [`Self::on_delete_player`],
    /// causing it not to run in the future.
    fn remove_on_delete_player(&self, callback: DeletePlayerCallbackId);
}

impl delete_player for super::RemoteReducers {
    fn delete_player(&self, id: u64,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("delete_player", DeletePlayerArgs { id,  })
    }
    fn on_delete_player(
        &self,
        mut callback: impl FnMut(&super::EventContext, &u64, ) + Send + 'static,
    ) -> DeletePlayerCallbackId {
        DeletePlayerCallbackId(self.imp.on_reducer(
            "delete_player",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::DeletePlayer {
                            id, 
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, id, )
            }),
        ))
    }
    fn remove_on_delete_player(&self, callback: DeletePlayerCallbackId) {
        self.imp.remove_on_reducer("delete_player", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `delete_player`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_delete_player {
    /// Set the call-reducer flags for the reducer `delete_player` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn delete_player(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_delete_player for super::SetReducerFlags {
    fn delete_player(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("delete_player", flags);
    }
}

'''
"delete_players_by_name_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct DeletePlayersByNameArgs {
	pub name: String,
}

impl From<DeletePlayersByNameArgs> for super::Reducer {
	fn from(args: DeletePlayersByNameArgs) -> Self {
		Self::DeletePlayersByName {
			name: args.name,
}
}
}

impl __sdk::InModule for DeletePlayersByNameArgs {
    type Module = super::RemoteModule;
}

pub struct DeletePlayersByNameCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `delete_players_by_name`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait delete_players_by_name {
    /// Request that the remote module invoke the reducer `delete_players_by_name` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_delete_players_by_name`] callbacks.
    fn delete_players_by_name(&self, name: String,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `delete_players_by_name`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`DeletePlayersByNameCallbackId`] can be passed to [`Self::remove_on_delete_players_by_name`]
    /// to cancel the callback.
    fn on_delete_players_by_name(&self, callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static) -> DeletePlayersByNameCallbackId;
    /// Cancel a callback previously registered by [`Self::on_delete_players_by_name`],
    /// causing it not to run in the future.
    fn remove_on_delete_players_by_name(&self, callback: DeletePlayersByNameCallbackId);
}

impl delete_players_by_name for super::RemoteReducers {
    fn delete_players_by_name(&self, name: String,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("delete_players_by_name", DeletePlayersByNameArgs { name,  })
    }
    fn on_delete_players_by_name(
        &self,
        mut callback: impl FnMut(&super::EventContext, &String, ) + Send + 'static,
    ) -> DeletePlayersByNameCallbackId {
        DeletePlayersByNameCallbackId(self.imp.on_reducer(
            "delete_players_by_name",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::DeletePlayersByName {
                            name, 
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, name, )
            }),
        ))
    }
    fn remove_on_delete_players_by_name(&self, callback: DeletePlayersByNameCallbackId) {
        self.imp.remove_on_reducer("delete_players_by_name", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `delete_players_by_name`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_delete_players_by_name {
    /// Set the call-reducer flags for the reducer `delete_players_by_name` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn delete_players_by_name(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_delete_players_by_name for super::SetReducerFlags {
    fn delete_players_by_name(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("delete_players_by_name", flags);
    }
}

'''
"foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

use super::baz_type::Baz;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum Foobar {
	Baz(Baz),

	Bar,

	Har(u32),

}



impl __sdk::InModule for Foobar {
    type Module = super::RemoteModule;
}

'''
"has_special_stuff_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::has_special_stuff_type::HasSpecialStuff;

/// Table handle for the table `has_special_stuff`.
///
/// Obtain a handle from the [`HasSpecialStuffTableAccess::has_special_stuff`] method on [`super::RemoteTables`],
/// like `ctx.db.has_special_stuff()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.has_special_stuff().on_insert(...)`.
pub struct HasSpecialStuffTableHandle<'ctx> {
    imp: __sdk::TableHandle<HasSpecialStuff>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `has_special_stuff`.
///
/// Implemented for [`super::RemoteTables`].
pub trait HasSpecialStuffTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`HasSpecialStuffTableHandle`], which mediates access to the table `has_special_stuff`.
    fn has_special_stuff(&self) -> HasSpecialStuffTableHandle<'_>;
}

impl HasSpecialStuffTableAccess for super::RemoteTables {
    fn has_special_stuff(&self) -> HasSpecialStuffTableHandle<'_> {
        HasSpecialStuffTableHandle {
            imp: self.imp.get_table::<HasSpecialStuff>("has_special_stuff"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct HasSpecialStuffInsertCallbackId(__sdk::CallbackId);
pub struct HasSpecialStuffDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for HasSpecialStuffTableHandle<'ctx> {
    type Row = HasSpecialStuff;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = HasSpecialStuff> + '_ { self.imp.iter() }

    type InsertCallbackId = HasSpecialStuffInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> HasSpecialStuffInsertCallbackId {
        HasSpecialStuffInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: HasSpecialStuffInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = HasSpecialStuffDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> HasSpecialStuffDeleteCallbackId {
        HasSpecialStuffDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: HasSpecialStuffDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<HasSpecialStuff>("has_special_stuff");
}
#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<HasSpecialStuff>> {
    __sdk::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"has_special_stuff\"")
}
'''
"has_special_stuff_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct HasSpecialStuff {
	pub identity: __sdk::Identity,
	pub address: __sdk::Address,
}


impl __sdk::InModule for HasSpecialStuff {
    type Module = super::RemoteModule;
}

'''
"identity_connected_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct IdentityConnectedArgs {
	}

impl From<IdentityConnectedArgs> for super::Reducer {
	fn from(args: IdentityConnectedArgs) -> Self {
		Self::IdentityConnected
}
}

impl __sdk::InModule for IdentityConnectedArgs {
    type Module = super::RemoteModule;
}

pub struct IdentityConnectedCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `__identity_connected__`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait identity_connected {
    /// Request that the remote module invoke the reducer `__identity_connected__` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_identity_connected`] callbacks.
    fn identity_connected(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `__identity_connected__`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`IdentityConnectedCallbackId`] can be passed to [`Self::remove_on_identity_connected`]
    /// to cancel the callback.
    fn on_identity_connected(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> IdentityConnectedCallbackId;
    /// Cancel a callback previously registered by [`Self::on_identity_connected`],
    /// causing it not to run in the future.
    fn remove_on_identity_connected(&self, callback: IdentityConnectedCallbackId);
}

impl identity_connected for super::RemoteReducers {
    fn identity_connected(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("__identity_connected__", IdentityConnectedArgs {  })
    }
    fn on_identity_connected(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> IdentityConnectedCallbackId {
        IdentityConnectedCallbackId(self.imp.on_reducer(
            "__identity_connected__",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::IdentityConnected {
                            
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_identity_connected(&self, callback: IdentityConnectedCallbackId) {
        self.imp.remove_on_reducer("__identity_connected__", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `__identity_connected__`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_identity_connected {
    /// Set the call-reducer flags for the reducer `__identity_connected__` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn identity_connected(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_identity_connected for super::SetReducerFlags {
    fn identity_connected(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("__identity_connected__", flags);
    }
}

'''
"init_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct InitArgs {
	}

impl From<InitArgs> for super::Reducer {
	fn from(args: InitArgs) -> Self {
		Self::Init
}
}

impl __sdk::InModule for InitArgs {
    type Module = super::RemoteModule;
}

pub struct InitCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `__init__`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait init {
    /// Request that the remote module invoke the reducer `__init__` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_init`] callbacks.
    fn init(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `__init__`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`InitCallbackId`] can be passed to [`Self::remove_on_init`]
    /// to cancel the callback.
    fn on_init(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> InitCallbackId;
    /// Cancel a callback previously registered by [`Self::on_init`],
    /// causing it not to run in the future.
    fn remove_on_init(&self, callback: InitCallbackId);
}

impl init for super::RemoteReducers {
    fn init(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("__init__", InitArgs {  })
    }
    fn on_init(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> InitCallbackId {
        InitCallbackId(self.imp.on_reducer(
            "__init__",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::Init {
                            
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_init(&self, callback: InitCallbackId) {
        self.imp.remove_on_reducer("__init__", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `__init__`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_init {
    /// Set the call-reducer flags for the reducer `__init__` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn init(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_init for super::SetReducerFlags {
    fn init(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("__init__", flags);
    }
}

'''
"logged_out_player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `logged_out_player`.
///
/// Obtain a handle from the [`LoggedOutPlayerTableAccess::logged_out_player`] method on [`super::RemoteTables`],
/// like `ctx.db.logged_out_player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.logged_out_player().on_insert(...)`.
pub struct LoggedOutPlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `logged_out_player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait LoggedOutPlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`LoggedOutPlayerTableHandle`], which mediates access to the table `logged_out_player`.
    fn logged_out_player(&self) -> LoggedOutPlayerTableHandle<'_>;
}

impl LoggedOutPlayerTableAccess for super::RemoteTables {
    fn logged_out_player(&self) -> LoggedOutPlayerTableHandle<'_> {
        LoggedOutPlayerTableHandle {
            imp: self.imp.get_table::<Player>("logged_out_player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct LoggedOutPlayerInsertCallbackId(__sdk::CallbackId);
pub struct LoggedOutPlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for LoggedOutPlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = LoggedOutPlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerInsertCallbackId {
        LoggedOutPlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: LoggedOutPlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = LoggedOutPlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerDeleteCallbackId {
        LoggedOutPlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: LoggedOutPlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<Player>("logged_out_player");
	_table.add_unique_constraint::<__sdk::Identity>("identity", |row| &row.identity);
	_table.add_unique_constraint::<u64>("player_id", |row| &row.player_id);
}
pub struct LoggedOutPlayerUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for LoggedOutPlayerTableHandle<'ctx> {
    type UpdateCallbackId = LoggedOutPlayerUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> LoggedOutPlayerUpdateCallbackId {
        LoggedOutPlayerUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: LoggedOutPlayerUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update_with_primary_key::<__sdk::Identity>(
        raw_updates,
        |row: &Player| &row.identity,
    ).context("Failed to parse table update for table \"logged_out_player\"")
}

        /// Access to the `identity` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerIdentityUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().identity().find(...)`.
        pub struct LoggedOutPlayerIdentityUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, __sdk::Identity>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `identity` unique index on the table `logged_out_player`.
            pub fn identity(&self) -> LoggedOutPlayerIdentityUnique<'ctx> {
                LoggedOutPlayerIdentityUnique {
                    imp: self.imp.get_unique_constraint::<__sdk::Identity>("identity"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerIdentityUnique<'ctx> {
            /// Find the subscribed row whose `identity` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &__sdk::Identity) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `player_id` unique index on the table `logged_out_player`,
        /// which allows point queries on the field of the same name
        /// via the [`LoggedOutPlayerPlayerIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.logged_out_player().player_id().find(...)`.
        pub struct LoggedOutPlayerPlayerIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> LoggedOutPlayerTableHandle<'ctx> {
            /// Get a handle on the `player_id` unique index on the table `logged_out_player`.
            pub fn player_id(&self) -> LoggedOutPlayerPlayerIdUnique<'ctx> {
                LoggedOutPlayerPlayerIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("player_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> LoggedOutPlayerPlayerIdUnique<'ctx> {
            /// Find the subscribed row whose `player_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        '''
"mod.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

pub mod baz_type;
pub mod foobar_type;
pub mod has_special_stuff_type;
pub mod namespace_test_c_type;
pub mod namespace_test_f_type;
pub mod pk_multi_identity_type;
pub mod player_type;
pub mod point_type;
pub mod private_type;
pub mod repeating_test_arg_type;
pub mod test_a_type;
pub mod test_b_type;
pub mod test_d_type;
pub mod test_e_type;
pub mod test_foobar_type;
pub mod add_player_reducer;
pub mod add_private_reducer;
pub mod assert_caller_identity_is_module_identity_reducer;
pub mod delete_player_reducer;
pub mod delete_players_by_name_reducer;
pub mod identity_connected_reducer;
pub mod init_reducer;
pub mod query_private_reducer;
pub mod repeating_test_reducer;
pub mod test_btree_index_args_reducer;
pub mod test_reducer;
pub mod has_special_stuff_table;
pub mod logged_out_player_table;
pub mod pk_multi_identity_table;
pub mod player_table;
pub mod points_table;
pub mod private_table;
pub mod repeating_test_arg_table;
pub mod test_a_table;
pub mod test_d_table;
pub mod test_e_table;
pub mod test_f_table;

pub use baz_type::Baz;
pub use foobar_type::Foobar;
pub use has_special_stuff_type::HasSpecialStuff;
pub use pk_multi_identity_type::PkMultiIdentity;
pub use player_type::Player;
pub use point_type::Point;
pub use private_type::Private;
pub use repeating_test_arg_type::RepeatingTestArg;
pub use test_a_type::TestA;
pub use test_b_type::TestB;
pub use test_d_type::TestD;
pub use test_e_type::TestE;
pub use test_foobar_type::TestFoobar;
pub use namespace_test_c_type::NamespaceTestC;
pub use namespace_test_f_type::NamespaceTestF;
pub use has_special_stuff_table::*;
pub use logged_out_player_table::*;
pub use pk_multi_identity_table::*;
pub use player_table::*;
pub use points_table::*;
pub use private_table::*;
pub use repeating_test_arg_table::*;
pub use test_a_table::*;
pub use test_d_table::*;
pub use test_e_table::*;
pub use test_f_table::*;
pub use identity_connected_reducer::{identity_connected, set_flags_for_identity_connected, IdentityConnectedCallbackId};
pub use init_reducer::{init, set_flags_for_init, InitCallbackId};
pub use add_player_reducer::{add_player, set_flags_for_add_player, AddPlayerCallbackId};
pub use add_private_reducer::{add_private, set_flags_for_add_private, AddPrivateCallbackId};
pub use assert_caller_identity_is_module_identity_reducer::{assert_caller_identity_is_module_identity, set_flags_for_assert_caller_identity_is_module_identity, AssertCallerIdentityIsModuleIdentityCallbackId};
pub use delete_player_reducer::{delete_player, set_flags_for_delete_player, DeletePlayerCallbackId};
pub use delete_players_by_name_reducer::{delete_players_by_name, set_flags_for_delete_players_by_name, DeletePlayersByNameCallbackId};
pub use query_private_reducer::{query_private, set_flags_for_query_private, QueryPrivateCallbackId};
pub use repeating_test_reducer::{repeating_test, set_flags_for_repeating_test, RepeatingTestCallbackId};
pub use test_reducer::{test, set_flags_for_test, TestCallbackId};
pub use test_btree_index_args_reducer::{test_btree_index_args, set_flags_for_test_btree_index_args, TestBtreeIndexArgsCallbackId};

#[derive(Clone, PartialEq, Debug)]

/// One of the reducers defined by this module.
///
/// Contained within a [`__sdk::ReducerEvent`] in [`EventContext`]s for reducer events
/// to indicate which reducer caused the event.

pub enum Reducer {
		IdentityConnected ,
	Init ,
	AddPlayer {
		name: String,
}	,
	AddPrivate {
		name: String,
}	,
	AssertCallerIdentityIsModuleIdentity ,
	DeletePlayer {
		id: u64,
}	,
	DeletePlayersByName {
		name: String,
}	,
	QueryPrivate ,
	RepeatingTest {
		arg: RepeatingTestArg,
}	,
	Test {
		arg: TestA,
		arg_2: TestB,
		arg_3: NamespaceTestC,
		arg_4: NamespaceTestF,
}	,
	TestBtreeIndexArgs ,
}


impl __sdk::InModule for Reducer {
    type Module = RemoteModule;
}

impl __sdk::Reducer for Reducer {
	fn reducer_name(&self) -> &'static str {
		match self {
						Reducer::IdentityConnected => "__identity_connected__",
			Reducer::Init => "__init__",
			Reducer::AddPlayer { .. } => "add_player",
			Reducer::AddPrivate { .. } => "add_private",
			Reducer::AssertCallerIdentityIsModuleIdentity => "assert_caller_identity_is_module_identity",
			Reducer::DeletePlayer { .. } => "delete_player",
			Reducer::DeletePlayersByName { .. } => "delete_players_by_name",
			Reducer::QueryPrivate => "query_private",
			Reducer::RepeatingTest { .. } => "repeating_test",
			Reducer::Test { .. } => "test",
			Reducer::TestBtreeIndexArgs => "test_btree_index_args",
}
}
}
impl TryFrom<__ws::ReducerCallInfo<__ws::BsatnFormat>> for Reducer {
		type Error = __anyhow::Error;
fn try_from(value: __ws::ReducerCallInfo<__ws::BsatnFormat>) -> __anyhow::Result<Self> {
		match &value.reducer_name[..] {
						"__identity_connected__" => Ok(__sdk::parse_reducer_args::<identity_connected_reducer::IdentityConnectedArgs>("__identity_connected__", &value.args)?.into()),
			"__init__" => Ok(__sdk::parse_reducer_args::<init_reducer::InitArgs>("__init__", &value.args)?.into()),
			"add_player" => Ok(__sdk::parse_reducer_args::<add_player_reducer::AddPlayerArgs>("add_player", &value.args)?.into()),
			"add_private" => Ok(__sdk::parse_reducer_args::<add_private_reducer::AddPrivateArgs>("add_private", &value.args)?.into()),
			"assert_caller_identity_is_module_identity" => Ok(__sdk::parse_reducer_args::<assert_caller_identity_is_module_identity_reducer::AssertCallerIdentityIsModuleIdentityArgs>("assert_caller_identity_is_module_identity", &value.args)?.into()),
			"delete_player" => Ok(__sdk::parse_reducer_args::<delete_player_reducer::DeletePlayerArgs>("delete_player", &value.args)?.into()),
			"delete_players_by_name" => Ok(__sdk::parse_reducer_args::<delete_players_by_name_reducer::DeletePlayersByNameArgs>("delete_players_by_name", &value.args)?.into()),
			"query_private" => Ok(__sdk::parse_reducer_args::<query_private_reducer::QueryPrivateArgs>("query_private", &value.args)?.into()),
			"repeating_test" => Ok(__sdk::parse_reducer_args::<repeating_test_reducer::RepeatingTestArgs>("repeating_test", &value.args)?.into()),
			"test" => Ok(__sdk::parse_reducer_args::<test_reducer::TestArgs>("test", &value.args)?.into()),
			"test_btree_index_args" => Ok(__sdk::parse_reducer_args::<test_btree_index_args_reducer::TestBtreeIndexArgsArgs>("test_btree_index_args", &value.args)?.into()),
			_ => Err(__anyhow::anyhow!("Unknown reducer {:?}", value.reducer_name)),
}
}
}

#[derive(Default)]
#[allow(non_snake_case)]
#[doc(hidden)]
pub struct DbUpdate {
		has_special_stuff: __sdk::TableUpdate<HasSpecialStuff>,
	logged_out_player: __sdk::TableUpdate<Player>,
	pk_multi_identity: __sdk::TableUpdate<PkMultiIdentity>,
	player: __sdk::TableUpdate<Player>,
	points: __sdk::TableUpdate<Point>,
	private: __sdk::TableUpdate<Private>,
	repeating_test_arg: __sdk::TableUpdate<RepeatingTestArg>,
	test_a: __sdk::TableUpdate<TestA>,
	test_d: __sdk::TableUpdate<TestD>,
	test_e: __sdk::TableUpdate<TestE>,
	test_f: __sdk::TableUpdate<TestFoobar>,
}


impl TryFrom<__ws::DatabaseUpdate<__ws::BsatnFormat>> for DbUpdate {
    type Error = __anyhow::Error;
    fn try_from(raw: __ws::DatabaseUpdate<__ws::BsatnFormat>) -> Result<Self, Self::Error> {
        let mut db_update = DbUpdate::default();
        for table_update in raw.tables {
            match &table_update.table_name[..] {

		"has_special_stuff" => db_update.has_special_stuff = has_special_stuff_table::parse_table_update(table_update)?,
	"logged_out_player" => db_update.logged_out_player = logged_out_player_table::parse_table_update(table_update)?,
	"pk_multi_identity" => db_update.pk_multi_identity = pk_multi_identity_table::parse_table_update(table_update)?,
	"player" => db_update.player = player_table::parse_table_update(table_update)?,
	"points" => db_update.points = points_table::parse_table_update(table_update)?,
	"private" => db_update.private = private_table::parse_table_update(table_update)?,
	"repeating_test_arg" => db_update.repeating_test_arg = repeating_test_arg_table::parse_table_update(table_update)?,
	"test_a" => db_update.test_a = test_a_table::parse_table_update(table_update)?,
	"test_d" => db_update.test_d = test_d_table::parse_table_update(table_update)?,
	"test_e" => db_update.test_e = test_e_table::parse_table_update(table_update)?,
	"test_f" => db_update.test_f = test_f_table::parse_table_update(table_update)?,

                unknown => __anyhow::bail!("Unknown table {unknown:?} in DatabaseUpdate"),
            }
        }
        Ok(db_update)
    }
}

impl __sdk::InModule for DbUpdate {
    type Module = RemoteModule;
}

impl __sdk::DbUpdate for DbUpdate {
	fn apply_to_client_cache(&self, cache: &mut __sdk::ClientCache<RemoteModule>) {
				cache.apply_diff_to_table::<HasSpecialStuff>("has_special_stuff", &self.has_special_stuff);
		cache.apply_diff_to_table::<Player>("logged_out_player", &self.logged_out_player);
		cache.apply_diff_to_table::<PkMultiIdentity>("pk_multi_identity", &self.pk_multi_identity);
		cache.apply_diff_to_table::<Player>("player", &self.player);
		cache.apply_diff_to_table::<Point>("points", &self.points);
		cache.apply_diff_to_table::<Private>("private", &self.private);
		cache.apply_diff_to_table::<RepeatingTestArg>("repeating_test_arg", &self.repeating_test_arg);
		cache.apply_diff_to_table::<TestA>("test_a", &self.test_a);
		cache.apply_diff_to_table::<TestD>("test_d", &self.test_d);
		cache.apply_diff_to_table::<TestE>("test_e", &self.test_e);
		cache.apply_diff_to_table::<TestFoobar>("test_f", &self.test_f);
}
fn invoke_row_callbacks(&self, event: &EventContext, callbacks: &mut __sdk::DbCallbacks<RemoteModule>) {
				callbacks.invoke_table_row_callbacks::<HasSpecialStuff>("has_special_stuff", &self.has_special_stuff, event);
		callbacks.invoke_table_row_callbacks::<Player>("logged_out_player", &self.logged_out_player, event);
		callbacks.invoke_table_row_callbacks::<PkMultiIdentity>("pk_multi_identity", &self.pk_multi_identity, event);
		callbacks.invoke_table_row_callbacks::<Player>("player", &self.player, event);
		callbacks.invoke_table_row_callbacks::<Point>("points", &self.points, event);
		callbacks.invoke_table_row_callbacks::<Private>("private", &self.private, event);
		callbacks.invoke_table_row_callbacks::<RepeatingTestArg>("repeating_test_arg", &self.repeating_test_arg, event);
		callbacks.invoke_table_row_callbacks::<TestA>("test_a", &self.test_a, event);
		callbacks.invoke_table_row_callbacks::<TestD>("test_d", &self.test_d, event);
		callbacks.invoke_table_row_callbacks::<TestE>("test_e", &self.test_e, event);
		callbacks.invoke_table_row_callbacks::<TestFoobar>("test_f", &self.test_f, event);
}
}


#[doc(hidden)]
pub struct RemoteModule;

impl __sdk::InModule for RemoteModule {
    type Module = Self;
}

/// The `reducers` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
pub struct RemoteReducers {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteReducers {
    type Module = RemoteModule;
}

#[doc(hidden)]
/// The `set_reducer_flags` field of [`DbConnection`],
/// with methods provided by extension traits for each reducer defined by the module.
/// Each method sets the flags for the reducer with the same name.
///
/// This type is currently unstable and may be removed without a major version bump.
pub struct SetReducerFlags {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for SetReducerFlags {
    type Module = RemoteModule;
}

/// The `db` field of [`EventContext`] and [`DbConnection`],
/// with methods provided by extension traits for each table defined by the module.
pub struct RemoteTables {
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for RemoteTables {
    type Module = RemoteModule;
}

/// A connection to a remote module, including a materialized view of a subset of the database.
///
/// Connect to a remote module by calling [`DbConnection::builder`]
/// and using the [`__sdk::DbConnectionBuilder`] builder-pattern constructor.
///
/// You must explicitly advance the connection by calling any one of:
///
/// - [`DbConnection::frame_tick`].
/// - [`DbConnection::run_threaded`].
/// - [`DbConnection::run_async`].
/// - [`DbConnection::advance_one_message`].
/// - [`DbConnection::advance_one_message_blocking`].
/// - [`DbConnection::advance_one_message_async`].
///
/// Which of these methods you should call depends on the specific needs of your application,
/// but you must call one of them, or else the connection will never progress.
pub struct DbConnection {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    #[doc(hidden)]
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,

    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for DbConnection {
    type Module = RemoteModule;
}

impl __sdk::DbContext for DbConnection {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __anyhow::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn address(&self) -> __sdk::Address {
        self.imp.address()
    }
}

impl DbConnection {
    /// Builder-pattern constructor for a connection to a remote module.
    ///
    /// See [`__sdk::DbConnectionBuilder`] for required and optional configuration for the new connection.
    pub fn builder() -> __sdk::DbConnectionBuilder<RemoteModule> {
        __sdk::DbConnectionBuilder::new()
    }

    /// If any WebSocket messages are waiting, process one of them.
    ///
    /// Returns `true` if a message was processed, or `false` if the queue is empty.
    /// Callers should invoke this message in a loop until it returns `false`
    /// or for as much time is available to process messages.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::frame_tick`] each frame
    /// to fully exhaust the queue whenever time is available.
    pub fn advance_one_message(&self) -> __anyhow::Result<bool> {
        self.imp.advance_one_message()
    }

    /// Process one WebSocket message, potentially blocking the current thread until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_threaded`] to spawn a thread
    /// which advances the connection automatically.
    pub fn advance_one_message_blocking(&self) -> __anyhow::Result<()> {
        self.imp.advance_one_message_blocking()
    }

    /// Process one WebSocket message, `await`ing until one is received.
    ///
    /// Returns an error if the connection is disconnected.
    /// If the disconnection in question was normal,
    ///  i.e. the result of a call to [`__sdk::DbContext::disconnect`],
    /// the returned error will be downcastable to [`__sdk::DisconnectedError`].
    ///
    /// This is a low-level primitive exposed for power users who need significant control over scheduling.
    /// Most applications should call [`Self::run_async`] to run an `async` loop
    /// which advances the connection when polled.
    pub async fn advance_one_message_async(&self) -> __anyhow::Result<()> {
        self.imp.advance_one_message_async().await
    }

    /// Process all WebSocket messages waiting in the queue,
    /// then return without `await`ing or blocking the current thread.
    pub fn frame_tick(&self) -> __anyhow::Result<()> {
        self.imp.frame_tick()
    }

    /// Spawn a thread which processes WebSocket messages as they are received.
    pub fn run_threaded(&self) -> std::thread::JoinHandle<()> {
        self.imp.run_threaded()
    }

    /// Run an `async` loop which processes WebSocket messages when polled.
    pub async fn run_async(&self) -> __anyhow::Result<()> {
        self.imp.run_async().await
    }
}

impl __sdk::DbConnection for DbConnection {
    fn new(imp: __sdk::DbContextImpl<RemoteModule>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            imp,
        }
    }
}

/// A [`DbConnection`] augmented with an [`__sdk::Event`],
/// passed to various callbacks invoked by the SDK.
pub struct EventContext {
    /// Access to tables defined by the module via extension traits implemented for [`RemoteTables`].
    pub db: RemoteTables,
    /// Access to reducers defined by the module via extension traits implemented for [`RemoteReducers`].
    pub reducers: RemoteReducers,
    /// Access to setting the call-flags of each reducer defined for each reducer defined by the module
    /// via extension traits implemented for [`SetReducerFlags`].
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    pub set_reducer_flags: SetReducerFlags,
    /// The event which caused these callbacks to run.
    pub event: __sdk::Event<Reducer>,
    imp: __sdk::DbContextImpl<RemoteModule>,
}

impl __sdk::InModule for EventContext {
    type Module = RemoteModule;
}

impl __sdk::DbContext for EventContext {
    type DbView = RemoteTables;
    type Reducers = RemoteReducers;
    type SetReducerFlags = SetReducerFlags;

    fn db(&self) -> &Self::DbView {
        &self.db
    }
    fn reducers(&self) -> &Self::Reducers {
        &self.reducers
    }
    fn set_reducer_flags(&self) -> &Self::SetReducerFlags {
        &self.set_reducer_flags
    }

    fn is_active(&self) -> bool {
        self.imp.is_active()
    }

    fn disconnect(&self) -> __anyhow::Result<()> {
        self.imp.disconnect()
    }

    type SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder {
        __sdk::SubscriptionBuilder::new(&self.imp)
    }

    fn try_identity(&self) -> Option<__sdk::Identity> {
        self.imp.try_identity()
    }
    fn address(&self) -> __sdk::Address {
        self.imp.address()
    }
}

impl __sdk::EventContext for EventContext {
    fn event(&self) -> &__sdk::Event<Reducer> {
        &self.event
    }
    fn new(imp: __sdk::DbContextImpl<RemoteModule>, event: __sdk::Event<Reducer>) -> Self {
        Self {
            db: RemoteTables { imp: imp.clone() },
            reducers: RemoteReducers { imp: imp.clone() },
            set_reducer_flags: SetReducerFlags { imp: imp.clone() },
            event,
            imp,
        }
    }
}

/// A handle on a subscribed query.
// TODO: Document this better after implementing the new subscription API.
pub struct SubscriptionHandle {
    imp: __sdk::SubscriptionHandleImpl<RemoteModule>,
}

impl __sdk::InModule for SubscriptionHandle {
    type Module = RemoteModule;
}

impl __sdk::SubscriptionHandle for SubscriptionHandle {
    fn new(imp: __sdk::SubscriptionHandleImpl<RemoteModule>) -> Self {
        Self { imp }
    }
}

/// Alias trait for a [`__sdk::DbContext`] connected to this module,
/// with that trait's associated types bounded to this module's concrete types.
///
/// Users can use this trait as a boundary on definitions which should accept
/// either a [`DbConnection`] or an [`EventContext`] and operate on either.
pub trait RemoteDbContext: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SetReducerFlags = SetReducerFlags,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
> {}
impl<Ctx: __sdk::DbContext<
    DbView = RemoteTables,
    Reducers = RemoteReducers,
    SetReducerFlags = SetReducerFlags,
    SubscriptionBuilder = __sdk::SubscriptionBuilder<RemoteModule>,
>> RemoteDbContext for Ctx {}


impl __sdk::SpacetimeModule for RemoteModule {
	
	type DbConnection = DbConnection;
	type EventContext = EventContext;
	type Reducer = Reducer;
	type DbView = RemoteTables;
	type Reducers = RemoteReducers;
	type SetReducerFlags = SetReducerFlags;
	type DbUpdate = DbUpdate;
	type SubscriptionHandle = SubscriptionHandle;

fn register_tables(client_cache: &mut __sdk::ClientCache<Self>) {
				has_special_stuff_table::register_table(client_cache);
		logged_out_player_table::register_table(client_cache);
		pk_multi_identity_table::register_table(client_cache);
		player_table::register_table(client_cache);
		points_table::register_table(client_cache);
		private_table::register_table(client_cache);
		repeating_test_arg_table::register_table(client_cache);
		test_a_table::register_table(client_cache);
		test_d_table::register_table(client_cache);
		test_e_table::register_table(client_cache);
		test_f_table::register_table(client_cache);
}
}
'''
"namespace_test_c_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestC {
	Foo,

	Bar,

}



impl __sdk::InModule for NamespaceTestC {
    type Module = super::RemoteModule;
}

'''
"namespace_test_f_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub enum NamespaceTestF {
	Foo,

	Bar,

	Baz(String),

}



impl __sdk::InModule for NamespaceTestF {
    type Module = super::RemoteModule;
}

'''
"pk_multi_identity_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::pk_multi_identity_type::PkMultiIdentity;

/// Table handle for the table `pk_multi_identity`.
///
/// Obtain a handle from the [`PkMultiIdentityTableAccess::pk_multi_identity`] method on [`super::RemoteTables`],
/// like `ctx.db.pk_multi_identity()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.pk_multi_identity().on_insert(...)`.
pub struct PkMultiIdentityTableHandle<'ctx> {
    imp: __sdk::TableHandle<PkMultiIdentity>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `pk_multi_identity`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PkMultiIdentityTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PkMultiIdentityTableHandle`], which mediates access to the table `pk_multi_identity`.
    fn pk_multi_identity(&self) -> PkMultiIdentityTableHandle<'_>;
}

impl PkMultiIdentityTableAccess for super::RemoteTables {
    fn pk_multi_identity(&self) -> PkMultiIdentityTableHandle<'_> {
        PkMultiIdentityTableHandle {
            imp: self.imp.get_table::<PkMultiIdentity>("pk_multi_identity"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PkMultiIdentityInsertCallbackId(__sdk::CallbackId);
pub struct PkMultiIdentityDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PkMultiIdentityTableHandle<'ctx> {
    type Row = PkMultiIdentity;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = PkMultiIdentity> + '_ { self.imp.iter() }

    type InsertCallbackId = PkMultiIdentityInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityInsertCallbackId {
        PkMultiIdentityInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PkMultiIdentityInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PkMultiIdentityDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityDeleteCallbackId {
        PkMultiIdentityDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PkMultiIdentityDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<PkMultiIdentity>("pk_multi_identity");
	_table.add_unique_constraint::<u32>("id", |row| &row.id);
	_table.add_unique_constraint::<u32>("other", |row| &row.other);
}
pub struct PkMultiIdentityUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PkMultiIdentityTableHandle<'ctx> {
    type UpdateCallbackId = PkMultiIdentityUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PkMultiIdentityUpdateCallbackId {
        PkMultiIdentityUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PkMultiIdentityUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<PkMultiIdentity>> {
    __sdk::TableUpdate::parse_table_update_with_primary_key::<u32>(
        raw_updates,
        |row: &PkMultiIdentity| &row.id,
    ).context("Failed to parse table update for table \"pk_multi_identity\"")
}

        /// Access to the `id` unique index on the table `pk_multi_identity`,
        /// which allows point queries on the field of the same name
        /// via the [`PkMultiIdentityIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.pk_multi_identity().id().find(...)`.
        pub struct PkMultiIdentityIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<PkMultiIdentity, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PkMultiIdentityTableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `pk_multi_identity`.
            pub fn id(&self) -> PkMultiIdentityIdUnique<'ctx> {
                PkMultiIdentityIdUnique {
                    imp: self.imp.get_unique_constraint::<u32>("id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PkMultiIdentityIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<PkMultiIdentity> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `other` unique index on the table `pk_multi_identity`,
        /// which allows point queries on the field of the same name
        /// via the [`PkMultiIdentityOtherUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.pk_multi_identity().other().find(...)`.
        pub struct PkMultiIdentityOtherUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<PkMultiIdentity, u32>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PkMultiIdentityTableHandle<'ctx> {
            /// Get a handle on the `other` unique index on the table `pk_multi_identity`.
            pub fn other(&self) -> PkMultiIdentityOtherUnique<'ctx> {
                PkMultiIdentityOtherUnique {
                    imp: self.imp.get_unique_constraint::<u32>("other"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PkMultiIdentityOtherUnique<'ctx> {
            /// Find the subscribed row whose `other` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u32) -> Option<PkMultiIdentity> {
                self.imp.find(col_val)
            }
        }
        '''
"pk_multi_identity_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct PkMultiIdentity {
	pub id: u32,
	pub other: u32,
}


impl __sdk::InModule for PkMultiIdentity {
    type Module = super::RemoteModule;
}

'''
"player_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::player_type::Player;

/// Table handle for the table `player`.
///
/// Obtain a handle from the [`PlayerTableAccess::player`] method on [`super::RemoteTables`],
/// like `ctx.db.player()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.player().on_insert(...)`.
pub struct PlayerTableHandle<'ctx> {
    imp: __sdk::TableHandle<Player>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `player`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PlayerTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PlayerTableHandle`], which mediates access to the table `player`.
    fn player(&self) -> PlayerTableHandle<'_>;
}

impl PlayerTableAccess for super::RemoteTables {
    fn player(&self) -> PlayerTableHandle<'_> {
        PlayerTableHandle {
            imp: self.imp.get_table::<Player>("player"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PlayerInsertCallbackId(__sdk::CallbackId);
pub struct PlayerDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PlayerTableHandle<'ctx> {
    type Row = Player;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Player> + '_ { self.imp.iter() }

    type InsertCallbackId = PlayerInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PlayerInsertCallbackId {
        PlayerInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PlayerInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PlayerDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PlayerDeleteCallbackId {
        PlayerDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PlayerDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<Player>("player");
	_table.add_unique_constraint::<__sdk::Identity>("identity", |row| &row.identity);
	_table.add_unique_constraint::<u64>("player_id", |row| &row.player_id);
}
pub struct PlayerUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for PlayerTableHandle<'ctx> {
    type UpdateCallbackId = PlayerUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> PlayerUpdateCallbackId {
        PlayerUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: PlayerUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<Player>> {
    __sdk::TableUpdate::parse_table_update_with_primary_key::<__sdk::Identity>(
        raw_updates,
        |row: &Player| &row.identity,
    ).context("Failed to parse table update for table \"player\"")
}

        /// Access to the `identity` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerIdentityUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().identity().find(...)`.
        pub struct PlayerIdentityUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, __sdk::Identity>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `identity` unique index on the table `player`.
            pub fn identity(&self) -> PlayerIdentityUnique<'ctx> {
                PlayerIdentityUnique {
                    imp: self.imp.get_unique_constraint::<__sdk::Identity>("identity"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerIdentityUnique<'ctx> {
            /// Find the subscribed row whose `identity` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &__sdk::Identity) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        
        /// Access to the `player_id` unique index on the table `player`,
        /// which allows point queries on the field of the same name
        /// via the [`PlayerPlayerIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.player().player_id().find(...)`.
        pub struct PlayerPlayerIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<Player, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> PlayerTableHandle<'ctx> {
            /// Get a handle on the `player_id` unique index on the table `player`.
            pub fn player_id(&self) -> PlayerPlayerIdUnique<'ctx> {
                PlayerPlayerIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("player_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> PlayerPlayerIdUnique<'ctx> {
            /// Find the subscribed row whose `player_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<Player> {
                self.imp.find(col_val)
            }
        }
        '''
"player_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Player {
	pub identity: __sdk::Identity,
	pub player_id: u64,
	pub name: String,
}


impl __sdk::InModule for Player {
    type Module = super::RemoteModule;
}

'''
"point_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Point {
	pub x: i64,
	pub y: i64,
}


impl __sdk::InModule for Point {
    type Module = super::RemoteModule;
}

'''
"points_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::point_type::Point;

/// Table handle for the table `points`.
///
/// Obtain a handle from the [`PointsTableAccess::points`] method on [`super::RemoteTables`],
/// like `ctx.db.points()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.points().on_insert(...)`.
pub struct PointsTableHandle<'ctx> {
    imp: __sdk::TableHandle<Point>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `points`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PointsTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PointsTableHandle`], which mediates access to the table `points`.
    fn points(&self) -> PointsTableHandle<'_>;
}

impl PointsTableAccess for super::RemoteTables {
    fn points(&self) -> PointsTableHandle<'_> {
        PointsTableHandle {
            imp: self.imp.get_table::<Point>("points"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PointsInsertCallbackId(__sdk::CallbackId);
pub struct PointsDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PointsTableHandle<'ctx> {
    type Row = Point;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Point> + '_ { self.imp.iter() }

    type InsertCallbackId = PointsInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PointsInsertCallbackId {
        PointsInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PointsInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PointsDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PointsDeleteCallbackId {
        PointsDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PointsDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<Point>("points");
}
#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<Point>> {
    __sdk::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"points\"")
}
'''
"private_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::private_type::Private;

/// Table handle for the table `private`.
///
/// Obtain a handle from the [`PrivateTableAccess::private`] method on [`super::RemoteTables`],
/// like `ctx.db.private()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.private().on_insert(...)`.
pub struct PrivateTableHandle<'ctx> {
    imp: __sdk::TableHandle<Private>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `private`.
///
/// Implemented for [`super::RemoteTables`].
pub trait PrivateTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`PrivateTableHandle`], which mediates access to the table `private`.
    fn private(&self) -> PrivateTableHandle<'_>;
}

impl PrivateTableAccess for super::RemoteTables {
    fn private(&self) -> PrivateTableHandle<'_> {
        PrivateTableHandle {
            imp: self.imp.get_table::<Private>("private"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct PrivateInsertCallbackId(__sdk::CallbackId);
pub struct PrivateDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for PrivateTableHandle<'ctx> {
    type Row = Private;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = Private> + '_ { self.imp.iter() }

    type InsertCallbackId = PrivateInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PrivateInsertCallbackId {
        PrivateInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: PrivateInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = PrivateDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> PrivateDeleteCallbackId {
        PrivateDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: PrivateDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<Private>("private");
}
#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<Private>> {
    __sdk::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"private\"")
}
'''
"private_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct Private {
	pub name: String,
}


impl __sdk::InModule for Private {
    type Module = super::RemoteModule;
}

'''
"query_private_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct QueryPrivateArgs {
	}

impl From<QueryPrivateArgs> for super::Reducer {
	fn from(args: QueryPrivateArgs) -> Self {
		Self::QueryPrivate
}
}

impl __sdk::InModule for QueryPrivateArgs {
    type Module = super::RemoteModule;
}

pub struct QueryPrivateCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `query_private`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait query_private {
    /// Request that the remote module invoke the reducer `query_private` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_query_private`] callbacks.
    fn query_private(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `query_private`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`QueryPrivateCallbackId`] can be passed to [`Self::remove_on_query_private`]
    /// to cancel the callback.
    fn on_query_private(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> QueryPrivateCallbackId;
    /// Cancel a callback previously registered by [`Self::on_query_private`],
    /// causing it not to run in the future.
    fn remove_on_query_private(&self, callback: QueryPrivateCallbackId);
}

impl query_private for super::RemoteReducers {
    fn query_private(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("query_private", QueryPrivateArgs {  })
    }
    fn on_query_private(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> QueryPrivateCallbackId {
        QueryPrivateCallbackId(self.imp.on_reducer(
            "query_private",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::QueryPrivate {
                            
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_query_private(&self, callback: QueryPrivateCallbackId) {
        self.imp.remove_on_reducer("query_private", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `query_private`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_query_private {
    /// Set the call-reducer flags for the reducer `query_private` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn query_private(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_query_private for super::SetReducerFlags {
    fn query_private(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("query_private", flags);
    }
}

'''
"repeating_test_arg_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::repeating_test_arg_type::RepeatingTestArg;

/// Table handle for the table `repeating_test_arg`.
///
/// Obtain a handle from the [`RepeatingTestArgTableAccess::repeating_test_arg`] method on [`super::RemoteTables`],
/// like `ctx.db.repeating_test_arg()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.repeating_test_arg().on_insert(...)`.
pub struct RepeatingTestArgTableHandle<'ctx> {
    imp: __sdk::TableHandle<RepeatingTestArg>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `repeating_test_arg`.
///
/// Implemented for [`super::RemoteTables`].
pub trait RepeatingTestArgTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`RepeatingTestArgTableHandle`], which mediates access to the table `repeating_test_arg`.
    fn repeating_test_arg(&self) -> RepeatingTestArgTableHandle<'_>;
}

impl RepeatingTestArgTableAccess for super::RemoteTables {
    fn repeating_test_arg(&self) -> RepeatingTestArgTableHandle<'_> {
        RepeatingTestArgTableHandle {
            imp: self.imp.get_table::<RepeatingTestArg>("repeating_test_arg"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct RepeatingTestArgInsertCallbackId(__sdk::CallbackId);
pub struct RepeatingTestArgDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for RepeatingTestArgTableHandle<'ctx> {
    type Row = RepeatingTestArg;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = RepeatingTestArg> + '_ { self.imp.iter() }

    type InsertCallbackId = RepeatingTestArgInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgInsertCallbackId {
        RepeatingTestArgInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: RepeatingTestArgInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = RepeatingTestArgDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgDeleteCallbackId {
        RepeatingTestArgDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: RepeatingTestArgDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<RepeatingTestArg>("repeating_test_arg");
	_table.add_unique_constraint::<u64>("scheduled_id", |row| &row.scheduled_id);
}
pub struct RepeatingTestArgUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for RepeatingTestArgTableHandle<'ctx> {
    type UpdateCallbackId = RepeatingTestArgUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> RepeatingTestArgUpdateCallbackId {
        RepeatingTestArgUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: RepeatingTestArgUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<RepeatingTestArg>> {
    __sdk::TableUpdate::parse_table_update_with_primary_key::<u64>(
        raw_updates,
        |row: &RepeatingTestArg| &row.scheduled_id,
    ).context("Failed to parse table update for table \"repeating_test_arg\"")
}

        /// Access to the `scheduled_id` unique index on the table `repeating_test_arg`,
        /// which allows point queries on the field of the same name
        /// via the [`RepeatingTestArgScheduledIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.repeating_test_arg().scheduled_id().find(...)`.
        pub struct RepeatingTestArgScheduledIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<RepeatingTestArg, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> RepeatingTestArgTableHandle<'ctx> {
            /// Get a handle on the `scheduled_id` unique index on the table `repeating_test_arg`.
            pub fn scheduled_id(&self) -> RepeatingTestArgScheduledIdUnique<'ctx> {
                RepeatingTestArgScheduledIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("scheduled_id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> RepeatingTestArgScheduledIdUnique<'ctx> {
            /// Find the subscribed row whose `scheduled_id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<RepeatingTestArg> {
                self.imp.find(col_val)
            }
        }
        '''
"repeating_test_arg_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct RepeatingTestArg {
	pub scheduled_id: u64,
	pub scheduled_at: __sdk::ScheduleAt,
	pub prev_time: u64,
}


impl __sdk::InModule for RepeatingTestArg {
    type Module = super::RemoteModule;
}

'''
"repeating_test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

use super::repeating_test_arg_type::RepeatingTestArg;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct RepeatingTestArgs {
	pub arg: RepeatingTestArg,
}

impl From<RepeatingTestArgs> for super::Reducer {
	fn from(args: RepeatingTestArgs) -> Self {
		Self::RepeatingTest {
			arg: args.arg,
}
}
}

impl __sdk::InModule for RepeatingTestArgs {
    type Module = super::RemoteModule;
}

pub struct RepeatingTestCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `repeating_test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait repeating_test {
    /// Request that the remote module invoke the reducer `repeating_test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_repeating_test`] callbacks.
    fn repeating_test(&self, arg: RepeatingTestArg,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `repeating_test`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`RepeatingTestCallbackId`] can be passed to [`Self::remove_on_repeating_test`]
    /// to cancel the callback.
    fn on_repeating_test(&self, callback: impl FnMut(&super::EventContext, &RepeatingTestArg, ) + Send + 'static) -> RepeatingTestCallbackId;
    /// Cancel a callback previously registered by [`Self::on_repeating_test`],
    /// causing it not to run in the future.
    fn remove_on_repeating_test(&self, callback: RepeatingTestCallbackId);
}

impl repeating_test for super::RemoteReducers {
    fn repeating_test(&self, arg: RepeatingTestArg,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("repeating_test", RepeatingTestArgs { arg,  })
    }
    fn on_repeating_test(
        &self,
        mut callback: impl FnMut(&super::EventContext, &RepeatingTestArg, ) + Send + 'static,
    ) -> RepeatingTestCallbackId {
        RepeatingTestCallbackId(self.imp.on_reducer(
            "repeating_test",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::RepeatingTest {
                            arg, 
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, arg, )
            }),
        ))
    }
    fn remove_on_repeating_test(&self, callback: RepeatingTestCallbackId) {
        self.imp.remove_on_reducer("repeating_test", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `repeating_test`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_repeating_test {
    /// Set the call-reducer flags for the reducer `repeating_test` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn repeating_test(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_repeating_test for super::SetReducerFlags {
    fn repeating_test(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("repeating_test", flags);
    }
}

'''
"test_a_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::test_a_type::TestA;

/// Table handle for the table `test_a`.
///
/// Obtain a handle from the [`TestATableAccess::test_a`] method on [`super::RemoteTables`],
/// like `ctx.db.test_a()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_a().on_insert(...)`.
pub struct TestATableHandle<'ctx> {
    imp: __sdk::TableHandle<TestA>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_a`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestATableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestATableHandle`], which mediates access to the table `test_a`.
    fn test_a(&self) -> TestATableHandle<'_>;
}

impl TestATableAccess for super::RemoteTables {
    fn test_a(&self) -> TestATableHandle<'_> {
        TestATableHandle {
            imp: self.imp.get_table::<TestA>("test_a"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestAInsertCallbackId(__sdk::CallbackId);
pub struct TestADeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestATableHandle<'ctx> {
    type Row = TestA;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestA> + '_ { self.imp.iter() }

    type InsertCallbackId = TestAInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestAInsertCallbackId {
        TestAInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestAInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestADeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestADeleteCallbackId {
        TestADeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestADeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<TestA>("test_a");
}
#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<TestA>> {
    __sdk::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"test_a\"")
}
'''
"test_a_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestA {
	pub x: u32,
	pub y: u32,
	pub z: String,
}


impl __sdk::InModule for TestA {
    type Module = super::RemoteModule;
}

'''
"test_b_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestB {
	pub foo: String,
}


impl __sdk::InModule for TestB {
    type Module = super::RemoteModule;
}

'''
"test_btree_index_args_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct TestBtreeIndexArgsArgs {
	}

impl From<TestBtreeIndexArgsArgs> for super::Reducer {
	fn from(args: TestBtreeIndexArgsArgs) -> Self {
		Self::TestBtreeIndexArgs
}
}

impl __sdk::InModule for TestBtreeIndexArgsArgs {
    type Module = super::RemoteModule;
}

pub struct TestBtreeIndexArgsCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test_btree_index_args`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test_btree_index_args {
    /// Request that the remote module invoke the reducer `test_btree_index_args` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_test_btree_index_args`] callbacks.
    fn test_btree_index_args(&self, ) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `test_btree_index_args`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`TestBtreeIndexArgsCallbackId`] can be passed to [`Self::remove_on_test_btree_index_args`]
    /// to cancel the callback.
    fn on_test_btree_index_args(&self, callback: impl FnMut(&super::EventContext, ) + Send + 'static) -> TestBtreeIndexArgsCallbackId;
    /// Cancel a callback previously registered by [`Self::on_test_btree_index_args`],
    /// causing it not to run in the future.
    fn remove_on_test_btree_index_args(&self, callback: TestBtreeIndexArgsCallbackId);
}

impl test_btree_index_args for super::RemoteReducers {
    fn test_btree_index_args(&self, ) -> __anyhow::Result<()> {
        self.imp.call_reducer("test_btree_index_args", TestBtreeIndexArgsArgs {  })
    }
    fn on_test_btree_index_args(
        &self,
        mut callback: impl FnMut(&super::EventContext, ) + Send + 'static,
    ) -> TestBtreeIndexArgsCallbackId {
        TestBtreeIndexArgsCallbackId(self.imp.on_reducer(
            "test_btree_index_args",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::TestBtreeIndexArgs {
                            
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, )
            }),
        ))
    }
    fn remove_on_test_btree_index_args(&self, callback: TestBtreeIndexArgsCallbackId) {
        self.imp.remove_on_reducer("test_btree_index_args", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `test_btree_index_args`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_test_btree_index_args {
    /// Set the call-reducer flags for the reducer `test_btree_index_args` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn test_btree_index_args(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_test_btree_index_args for super::SetReducerFlags {
    fn test_btree_index_args(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("test_btree_index_args", flags);
    }
}

'''
"test_d_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::test_d_type::TestD;
use super::namespace_test_c_type::NamespaceTestC;

/// Table handle for the table `test_d`.
///
/// Obtain a handle from the [`TestDTableAccess::test_d`] method on [`super::RemoteTables`],
/// like `ctx.db.test_d()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_d().on_insert(...)`.
pub struct TestDTableHandle<'ctx> {
    imp: __sdk::TableHandle<TestD>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_d`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestDTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestDTableHandle`], which mediates access to the table `test_d`.
    fn test_d(&self) -> TestDTableHandle<'_>;
}

impl TestDTableAccess for super::RemoteTables {
    fn test_d(&self) -> TestDTableHandle<'_> {
        TestDTableHandle {
            imp: self.imp.get_table::<TestD>("test_d"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestDInsertCallbackId(__sdk::CallbackId);
pub struct TestDDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestDTableHandle<'ctx> {
    type Row = TestD;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestD> + '_ { self.imp.iter() }

    type InsertCallbackId = TestDInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDInsertCallbackId {
        TestDInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestDInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestDDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestDDeleteCallbackId {
        TestDDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestDDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<TestD>("test_d");
}
#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<TestD>> {
    __sdk::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"test_d\"")
}
'''
"test_d_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

use super::namespace_test_c_type::NamespaceTestC;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestD {
	pub test_c: Option::<NamespaceTestC>,
}


impl __sdk::InModule for TestD {
    type Module = super::RemoteModule;
}

'''
"test_e_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::test_e_type::TestE;

/// Table handle for the table `test_e`.
///
/// Obtain a handle from the [`TestETableAccess::test_e`] method on [`super::RemoteTables`],
/// like `ctx.db.test_e()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_e().on_insert(...)`.
pub struct TestETableHandle<'ctx> {
    imp: __sdk::TableHandle<TestE>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_e`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestETableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestETableHandle`], which mediates access to the table `test_e`.
    fn test_e(&self) -> TestETableHandle<'_>;
}

impl TestETableAccess for super::RemoteTables {
    fn test_e(&self) -> TestETableHandle<'_> {
        TestETableHandle {
            imp: self.imp.get_table::<TestE>("test_e"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestEInsertCallbackId(__sdk::CallbackId);
pub struct TestEDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestETableHandle<'ctx> {
    type Row = TestE;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestE> + '_ { self.imp.iter() }

    type InsertCallbackId = TestEInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestEInsertCallbackId {
        TestEInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestEInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestEDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestEDeleteCallbackId {
        TestEDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestEDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<TestE>("test_e");
	_table.add_unique_constraint::<u64>("id", |row| &row.id);
}
pub struct TestEUpdateCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::TableWithPrimaryKey for TestETableHandle<'ctx> {
    type UpdateCallbackId = TestEUpdateCallbackId;

    fn on_update(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row, &Self::Row) + Send + 'static,
    ) -> TestEUpdateCallbackId {
        TestEUpdateCallbackId(self.imp.on_update(Box::new(callback)))
    }

    fn remove_on_update(&self, callback: TestEUpdateCallbackId) {
        self.imp.remove_on_update(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<TestE>> {
    __sdk::TableUpdate::parse_table_update_with_primary_key::<u64>(
        raw_updates,
        |row: &TestE| &row.id,
    ).context("Failed to parse table update for table \"test_e\"")
}

        /// Access to the `id` unique index on the table `test_e`,
        /// which allows point queries on the field of the same name
        /// via the [`TestEIdUnique::find`] method.
        ///
        /// Users are encouraged not to explicitly reference this type,
        /// but to directly chain method calls,
        /// like `ctx.db.test_e().id().find(...)`.
        pub struct TestEIdUnique<'ctx> {
            imp: __sdk::UniqueConstraintHandle<TestE, u64>,
            phantom: std::marker::PhantomData<&'ctx super::RemoteTables>,
        }

        impl<'ctx> TestETableHandle<'ctx> {
            /// Get a handle on the `id` unique index on the table `test_e`.
            pub fn id(&self) -> TestEIdUnique<'ctx> {
                TestEIdUnique {
                    imp: self.imp.get_unique_constraint::<u64>("id"),
                    phantom: std::marker::PhantomData,
                }
            }
        }

        impl<'ctx> TestEIdUnique<'ctx> {
            /// Find the subscribed row whose `id` column value is equal to `col_val`,
            /// if such a row is present in the client cache.
            pub fn find(&self, col_val: &u64) -> Option<TestE> {
                self.imp.find(col_val)
            }
        }
        '''
"test_e_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};


#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestE {
	pub id: u64,
	pub name: String,
}


impl __sdk::InModule for TestE {
    type Module = super::RemoteModule;
}

'''
"test_f_table.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};
use super::test_foobar_type::TestFoobar;
use super::foobar_type::Foobar;

/// Table handle for the table `test_f`.
///
/// Obtain a handle from the [`TestFTableAccess::test_f`] method on [`super::RemoteTables`],
/// like `ctx.db.test_f()`.
///
/// Users are encouraged not to explicitly reference this type,
/// but to directly chain method calls,
/// like `ctx.db.test_f().on_insert(...)`.
pub struct TestFTableHandle<'ctx> {
    imp: __sdk::TableHandle<TestFoobar>,
    ctx: std::marker::PhantomData<&'ctx super::RemoteTables>,
}

#[allow(non_camel_case_types)]
/// Extension trait for access to the table `test_f`.
///
/// Implemented for [`super::RemoteTables`].
pub trait TestFTableAccess {
    #[allow(non_snake_case)]
    /// Obtain a [`TestFTableHandle`], which mediates access to the table `test_f`.
    fn test_f(&self) -> TestFTableHandle<'_>;
}

impl TestFTableAccess for super::RemoteTables {
    fn test_f(&self) -> TestFTableHandle<'_> {
        TestFTableHandle {
            imp: self.imp.get_table::<TestFoobar>("test_f"),
            ctx: std::marker::PhantomData,
        }
    }
}

pub struct TestFInsertCallbackId(__sdk::CallbackId);
pub struct TestFDeleteCallbackId(__sdk::CallbackId);

impl<'ctx> __sdk::Table for TestFTableHandle<'ctx> {
    type Row = TestFoobar;
    type EventContext = super::EventContext;

    fn count(&self) -> u64 { self.imp.count() }
    fn iter(&self) -> impl Iterator<Item = TestFoobar> + '_ { self.imp.iter() }

    type InsertCallbackId = TestFInsertCallbackId;

    fn on_insert(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFInsertCallbackId {
        TestFInsertCallbackId(self.imp.on_insert(Box::new(callback)))
    }

    fn remove_on_insert(&self, callback: TestFInsertCallbackId) {
        self.imp.remove_on_insert(callback.0)
    }

    type DeleteCallbackId = TestFDeleteCallbackId;

    fn on_delete(
        &self,
        callback: impl FnMut(&Self::EventContext, &Self::Row) + Send + 'static,
    ) -> TestFDeleteCallbackId {
        TestFDeleteCallbackId(self.imp.on_delete(Box::new(callback)))
    }

    fn remove_on_delete(&self, callback: TestFDeleteCallbackId) {
        self.imp.remove_on_delete(callback.0)
    }
}

#[doc(hidden)]
pub(super) fn register_table(client_cache: &mut __sdk::ClientCache<super::RemoteModule>) {

		let _table = client_cache.get_or_make_table::<TestFoobar>("test_f");
}
#[doc(hidden)]
pub(super) fn parse_table_update(
    raw_updates: __ws::TableUpdate<__ws::BsatnFormat>,
) -> __anyhow::Result<__sdk::TableUpdate<TestFoobar>> {
    __sdk::TableUpdate::parse_table_update_no_primary_key(raw_updates)
        .context("Failed to parse table update for table \"test_f\"")
}
'''
"test_foobar_type.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

use super::foobar_type::Foobar;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub struct TestFoobar {
	pub field: Foobar,
}


impl __sdk::InModule for TestFoobar {
    type Module = super::RemoteModule;
}

'''
"test_reducer.rs" = '''
// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN RUST INSTEAD.

#![allow(unused)]use spacetimedb_sdk::__codegen::{
	self as __sdk,
	anyhow::{self as __anyhow, Context as _},
	__lib,
	__sats,
	__ws,
};

use super::test_a_type::TestA;
use super::test_b_type::TestB;
use super::namespace_test_c_type::NamespaceTestC;
use super::namespace_test_f_type::NamespaceTestF;

#[derive(__lib::ser::Serialize, __lib::de::Deserialize, Clone, PartialEq, Debug)]
#[sats(crate = __lib)]
pub(super) struct TestArgs {
	pub arg: TestA,
	pub arg_2: TestB,
	pub arg_3: NamespaceTestC,
	pub arg_4: NamespaceTestF,
}

impl From<TestArgs> for super::Reducer {
	fn from(args: TestArgs) -> Self {
		Self::Test {
			arg: args.arg,
			arg_2: args.arg_2,
			arg_3: args.arg_3,
			arg_4: args.arg_4,
}
}
}

impl __sdk::InModule for TestArgs {
    type Module = super::RemoteModule;
}

pub struct TestCallbackId(__sdk::CallbackId);

#[allow(non_camel_case_types)]
/// Extension trait for access to the reducer `test`.
///
/// Implemented for [`super::RemoteReducers`].
pub trait test {
    /// Request that the remote module invoke the reducer `test` to run as soon as possible.
    ///
    /// This method returns immediately, and errors only if we are unable to send the request.
    /// The reducer will run asynchronously in the future,
    ///  and its status can be observed by listening for [`Self::on_test`] callbacks.
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __anyhow::Result<()>;
    /// Register a callback to run whenever we are notified of an invocation of the reducer `test`.
    ///
    /// The [`super::EventContext`] passed to the `callback`
    /// will always have [`__sdk::Event::Reducer`] as its `event`,
    /// but it may or may not have terminated successfully and been committed.
    /// Callbacks should inspect the [`__sdk::ReducerEvent`] contained in the [`super::EventContext`]
    /// to determine the reducer's status.
    ///
    /// The returned [`TestCallbackId`] can be passed to [`Self::remove_on_test`]
    /// to cancel the callback.
    fn on_test(&self, callback: impl FnMut(&super::EventContext, &TestA, &TestB, &NamespaceTestC, &NamespaceTestF, ) + Send + 'static) -> TestCallbackId;
    /// Cancel a callback previously registered by [`Self::on_test`],
    /// causing it not to run in the future.
    fn remove_on_test(&self, callback: TestCallbackId);
}

impl test for super::RemoteReducers {
    fn test(&self, arg: TestA,
arg_2: TestB,
arg_3: NamespaceTestC,
arg_4: NamespaceTestF,
) -> __anyhow::Result<()> {
        self.imp.call_reducer("test", TestArgs { arg, arg_2, arg_3, arg_4,  })
    }
    fn on_test(
        &self,
        mut callback: impl FnMut(&super::EventContext, &TestA, &TestB, &NamespaceTestC, &NamespaceTestF, ) + Send + 'static,
    ) -> TestCallbackId {
        TestCallbackId(self.imp.on_reducer(
            "test",
            Box::new(move |ctx: &super::EventContext| {
                let super::EventContext {
                    event: __sdk::Event::Reducer(__sdk::ReducerEvent {
                        reducer: super::Reducer::Test {
                            arg, arg_2, arg_3, arg_4, 
                        },
                        ..
                    }),
                    ..
                } = ctx else { unreachable!() };
                callback(ctx, arg, arg_2, arg_3, arg_4, )
            }),
        ))
    }
    fn remove_on_test(&self, callback: TestCallbackId) {
        self.imp.remove_on_reducer("test", callback.0)
    }
}

#[allow(non_camel_case_types)]
#[doc(hidden)]
/// Extension trait for setting the call-flags for the reducer `test`.
///
/// Implemented for [`super::SetReducerFlags`].
///
/// This type is currently unstable and may be removed without a major version bump.
pub trait set_flags_for_test {
    /// Set the call-reducer flags for the reducer `test` to `flags`.
    ///
    /// This type is currently unstable and may be removed without a major version bump.
    fn test(&self, flags: __ws::CallReducerFlags);
}

impl set_flags_for_test for super::SetReducerFlags {
    fn test(&self, flags: __ws::CallReducerFlags) {
        self.imp.set_call_reducer_flags("test", flags);
    }
}

'''
