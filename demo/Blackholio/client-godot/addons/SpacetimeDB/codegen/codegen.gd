class_name SpacetimeCodegen extends Resource

const REQUIRED_FOLDERS_IN_CODEGEN_FOLDER: Array[String] = ["tables", "types"]
const OPTION_CLASS_NAME := "Option"
const AUTOGENERATED_COMMENT := "# THIS FILE IS AUTOMATICALLY GENERATED BY THE SPACETIMEDB ADDON. EDITS TO THIS\n" + \
                               "# FILE WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.\n"

var _config: SpacetimeCodegenConfig
var _schema_path: String

func _init(p_schema_path: String) -> void:
    _schema_path = p_schema_path
    _config = SpacetimeCodegenConfig.new()
    
func generate_bindings(module_schemas: Dictionary[String, String]) -> Array[String]:
    var generated_files: Array[String] = []
    
    for module_name in module_schemas:
        generated_files.append_array(_generate_module_bindings(module_name, module_schemas[module_name]))
    
    var autoload_content := _generate_autoload_gdscript(module_schemas.keys())
    var autoload_output_file_path := "%s/%s" % [_schema_path, SpacetimePlugin.AUTOLOAD_FILE_NAME]
    var autoload_file := FileAccess.open(autoload_output_file_path, FileAccess.WRITE)
    if autoload_file:
        autoload_file.store_string(autoload_content)
        autoload_file.close()
        generated_files.append(autoload_output_file_path)
        
    SpacetimePlugin.print_log("Generated files:")
    for generated_file in generated_files:
        SpacetimePlugin.print_log(generated_file)
    
    return generated_files

func _generate_module_bindings(module_name: String, json_string: String) -> Array[String]:
    var json = JSON.parse_string(json_string)
    var schema := SpacetimeSchemaParser.parse_schema(json, module_name)
    if schema.is_empty():
        SpacetimePlugin.print_err("Schema parsing failed for module: %s. Aborting codegen for this module." % module_name)
        return []
    
    for folder in REQUIRED_FOLDERS_IN_CODEGEN_FOLDER:
        var folder_path := "%s/%s" % [_schema_path, folder]
        if not DirAccess.dir_exists_absolute(folder_path):
            DirAccess.make_dir_recursive_absolute(folder_path)
    
    var debug_dir_path := "%s/%s" % [SpacetimePlugin.BINDINGS_PATH, "codegen_debug"]
    if not DirAccess.dir_exists_absolute(debug_dir_path):
        DirAccess.make_dir_recursive_absolute(debug_dir_path)
            
    var file = FileAccess.open("%s/readme.txt" % [debug_dir_path], FileAccess.WRITE)
    file.store_string("You can delete this directory and files. It's only used for codegen debugging.")
    file = FileAccess.open("%s/schema_%s.json" % [debug_dir_path, module_name], FileAccess.WRITE)
    file.store_string(JSON.stringify(schema.to_dictionary(), "\t", false))
    
    var generated_files := _generate_gdscript_from_schema(schema)
    return generated_files

func _generate_gdscript_from_schema(schema: SpacetimeParsedSchema) -> Array[String]:
    var generated_files: Array[String] = []
    
    for type_def in schema.types:
        if type_def.has("gd_native"): continue
        
        var content: String
        if type_def.has("struct"):
            var generated_table_names: Array[String]
            if type_def.has("table_names"):
                if not type_def.has("primary_key_name"): continue
                if _config.hide_private_tables and not type_def.get("is_public", []).has(true):
                    SpacetimePlugin.print_log("Skipping private table struct %s" % type_def.get("name", ""))
                    continue
                var table_names_arr: Array = type_def.get("table_names", [])
                for i in table_names_arr.size():
                    var tbl_name: String = table_names_arr[i]
                    if _config.hide_private_tables and not type_def.get("is_public", [])[i]:
                        SpacetimePlugin.print_log("Skipping private table %s" % tbl_name)
                        continue
                    generated_table_names.append(tbl_name)
                    
            content = _generate_struct_gdscript(schema, type_def, generated_table_names)
        elif type_def.has("enum"):
            if not type_def.get("is_sum_type"): continue
            content = _generate_enum_gdscript(schema, type_def)
        
        var output_file_name := "%s_%s.gd" % \
            [schema.module.to_snake_case(), type_def.get("name", "").to_snake_case()]
        var folder_path := "%s/types" % _schema_path
        var output_file_path := "%s/%s" % [folder_path, output_file_name]
        if not DirAccess.dir_exists_absolute(folder_path):
            DirAccess.make_dir_recursive_absolute(folder_path)
            
        var file := FileAccess.open(output_file_path, FileAccess.WRITE)
        if file:
            file.store_string(content)
            file.close()
            generated_files.append(output_file_path)

    for table_def in schema.tables:
        var table_name = table_def.get("name", null)
        if table_name == null: continue
        if _config.hide_private_tables and not table_def.get("is_public", true):
            SpacetimePlugin.print_log("Skipping private table: %s" % table_name)
            continue
        
        var unique_indexes = table_def.get("unique_indexes", [])
        for unique_index in unique_indexes:
            var content := _generate_table_unique_index_gdscript(schema, unique_index, table_def)
            
            var output_file_name := "%s_%s_%s_unique_index.gd" % \
                [schema.module.to_snake_case(), table_name.to_snake_case(), unique_index.get("name", "").to_snake_case()]
            var folder_path := "%s/tables" % _schema_path
            var output_file_path := "%s/%s" % [folder_path, output_file_name]
            if not DirAccess.dir_exists_absolute(folder_path):
                DirAccess.make_dir_recursive_absolute(folder_path)
                
            var file := FileAccess.open(output_file_path, FileAccess.WRITE)
            if file:
                file.store_string(content)
                file.close()
                generated_files.append(output_file_path)
        
        var content := _generate_table_gdscript(schema, table_def)
        
        var output_file_name := "%s_%s_table.gd" % \
            [schema.module.to_snake_case(), table_name.to_snake_case()]
        var folder_path := "%s/tables" % _schema_path
        var output_file_path := "%s/%s" % [folder_path, output_file_name]
        if not DirAccess.dir_exists_absolute(folder_path):
            DirAccess.make_dir_recursive_absolute(folder_path)
            
        var file := FileAccess.open(output_file_path, FileAccess.WRITE)
        if file:
            file.store_string(content)
            file.close()
            generated_files.append(output_file_path)

    var module_content := _generate_module_client_gdscript(schema)
    var output_file_name_module := "module_%s_client.gd" % schema.module.to_snake_case()
    var output_file_path_module := "%s/%s" % [_schema_path, output_file_name_module]
    var file_module := FileAccess.open(output_file_path_module, FileAccess.WRITE)
    if file_module:
        file_module.store_string(module_content)
        file_module.close()
        generated_files.append(output_file_path_module)

    var db_content := _generate_db_gdscript(schema)
    var db_output_file_name := "module_%s_db.gd" % schema.module.to_snake_case()
    var db_output_file_path := "%s/%s" % [_schema_path, db_output_file_name]
    var db_file := FileAccess.open(db_output_file_path, FileAccess.WRITE)
    if db_file:
        db_file.store_string(db_content)
        db_file.close()
        generated_files.append(db_output_file_path)

    var reducers_content := _generate_reducers_gdscript(schema)
    var output_file_name_reducers := "module_%s_reducers.gd" % schema.module.to_snake_case()
    var output_file_path_reducers := "%s/%s" % [_schema_path, output_file_name_reducers]
    var file_reducers := FileAccess.open(output_file_path_reducers, FileAccess.WRITE)
    if file_reducers:
        file_reducers.store_string(reducers_content)
        file_reducers.close()
        generated_files.append(output_file_path_reducers)

    var types_content := _generate_types_gdscript(schema)
    var output_file_name_types := "module_%s_types.gd" % schema.module.to_snake_case()
    var output_file_path_types := "%s/%s" % [_schema_path, output_file_name_types]
    var file_types := FileAccess.open(output_file_path_types, FileAccess.WRITE)
    if file_types:
        file_types.store_string(types_content)
        file_types.close()
        generated_files.append(output_file_path_types)
        
    return generated_files

func _generate_table_unique_index_gdscript(schema: SpacetimeParsedSchema, unique_index_def: Dictionary, table_def: Dictionary) -> String:
    var table_name: String = table_def.get("name", "")
    var field_name: String = unique_index_def.get("name", "")
    var original_field_type: String = unique_index_def.get("type", "Variant")
    var field_type: String = schema.type_map.get(original_field_type, "Variant")
    var type_def: Dictionary = schema.types[table_def.get("type_idx")] if table_def.has("type_idx") else {}
    var original_type_name: String = type_def.get("name", "Variant")
    var type_name: String = schema.type_map.get(original_type_name, "Variant")
    
    var _class_name := "%s%s%sUniqueIndex" % \
        [schema.module.to_pascal_case(), table_name.to_pascal_case(), field_name.to_pascal_case()]
    var content: String = AUTOGENERATED_COMMENT + \
    "class_name %s extends _ModuleTableUniqueIndex\n\n" % _class_name + \
    "var _cache: Dictionary[%s, %s] = {}\n\n" % [field_type, type_name] + \
    "func _init(p_local_db: LocalDatabase) -> void:\n" + \
    "\tset_meta(\"table_name\", \"%s\")\n" % table_name + \
    "\tset_meta(\"field_name\", \"%s\")\n" % field_name + \
    "\t_connect_cache_to_db(_cache, p_local_db)\n\n" + \
    "func find(col_val: %s) -> %s:\n" % [field_type, type_name] + \
    "\treturn _cache.get(col_val, null)\n"
    
    return content

func _generate_table_gdscript(schema: SpacetimeParsedSchema, table_def: Dictionary) -> String:
    var table_name: String = table_def.get("name", "")
    var type_def: Dictionary = schema.types[table_def.get("type_idx")] if table_def.has("type_idx") else {}
    var original_type_name: String = type_def.get("name", "Variant")
    var type_name: String = schema.type_map.get(original_type_name, "Variant")
    var unique_index_fields: Dictionary[String, String] = {}
    for unique_index_def in table_def.get("unique_indexes", []):
        var field_name: String = unique_index_def.get("name", "")
        var unique_index_class_name := "%s%s%sUniqueIndex" % \
            [schema.module.to_pascal_case(), table_name.to_pascal_case(), field_name.to_pascal_case()]
        unique_index_fields[field_name] = unique_index_class_name
    
    var _class_name := "%s%sTable" % [schema.module.to_pascal_case(), table_name.to_pascal_case()]
    var content: String = AUTOGENERATED_COMMENT + \
    "class_name %s extends _ModuleTable\n\n" % _class_name
    for field_name in unique_index_fields:
        var unique_index_class_name := unique_index_fields[field_name]
        content += "var %s: %s\n" % [field_name, unique_index_class_name]
    
    content += "\nfunc _init(p_local_db: LocalDatabase) -> void:\n" + \
    "\tsuper(p_local_db)\n" + \
    "\tset_meta(\"table_name\", \"%s\")\n" % table_name
    
    for field_name in unique_index_fields:
        var unique_index_class_name := unique_index_fields[field_name]
        content += "\t%s = %s.new(p_local_db)\n" % [field_name, unique_index_class_name]
    
    content += "\nfunc iter() -> Array[%s]:\n" % type_name + \
    "\tvar rows: Array = super()\n" + \
    "\tvar typed_array: Array[%s] = []\n" % type_name + \
    "\ttyped_array.assign(rows)\n" + \
    "\treturn typed_array\n"
    
    return content

func _generate_struct_gdscript(schema: SpacetimeParsedSchema, type_def: Dictionary, table_names: Array[String]) -> String:
    var struct_name: String = type_def.get("name", "")
    var fields: Array = type_def.get("struct", [])
    var meta_data: Array = []
    var table_name: String = type_def.get("table_name", "")
    var _class_name: String = schema.module.to_pascal_case() + struct_name.to_pascal_case()
    var _extends_class = "Resource"
    if table_name:
        _extends_class = "_ModuleTableType"
        var primary_key_name: String = type_def.get("primary_key_name", "")
        if primary_key_name:
            meta_data.append("set_meta('primary_key', '%s')" % primary_key_name)
    
    var content: String = AUTOGENERATED_COMMENT + \
    "@tool\n" + \
    "class_name %s extends %s\n\n" % [_class_name, _extends_class]
        
    if table_names.size() > 0:
        content += "const module_name := \"%s\"\n" % schema.module + \
        "const table_names: Array[String] = [%s]\n\n" % \
            [", ".join(table_names.map(func(x): return "'%s'" % x))]
        
    var class_fields: Array = []
    var create_func_documentation_comment: String
    # format for create_func_documentation_comment
    var format_cfdc: Callable = func(index, field_name, nested_type) -> String:
        return "## %d. %s: %s[br]\n" % [index, field_name, " of ".join(nested_type)]

    for i in fields.size():
        var field: Dictionary = fields[i]
        var field_name: String = field.get("name", "")
        var original_inner_type_name: String = field.get("type", "Variant")
        var gd_field_type: String
        var bsatn_meta_type_string: String
        var documentation_comment: String
        var nested_type: Array = field.get("nested_type", []).duplicate()
        nested_type.append(schema.type_map.get(original_inner_type_name, "Variant"))
        
        if field.has("is_option"):
            gd_field_type = OPTION_CLASS_NAME
            documentation_comment = "## %s" % [" of ".join(nested_type)]
            create_func_documentation_comment += format_cfdc.call(i, field_name, nested_type)
            if field.has("is_array_inside_option"):
                bsatn_meta_type_string = "vec_%s" % schema.meta_type_map.get(original_inner_type_name, "Variant")
            else:
                bsatn_meta_type_string = schema.meta_type_map.get(original_inner_type_name, original_inner_type_name)
        elif field.has("is_array"):
            var element_gd_type = schema.type_map.get(original_inner_type_name, "Variant")
            if field.has("is_option_inside_array"):
                element_gd_type = OPTION_CLASS_NAME
                documentation_comment = "## %s" % [" of ".join(nested_type)]
            create_func_documentation_comment += format_cfdc.call(i, field_name, nested_type)
            gd_field_type = "Array[%s]" % element_gd_type
            var inner_meta = schema.meta_type_map.get(original_inner_type_name, original_inner_type_name)
            bsatn_meta_type_string = "%s" % inner_meta
        else:
            gd_field_type = schema.type_map.get(original_inner_type_name, "Variant")
            bsatn_meta_type_string = schema.meta_type_map.get(original_inner_type_name, original_inner_type_name)
            create_func_documentation_comment += format_cfdc.call(i, field_name, nested_type)

        var add_meta_for_field = false
        if field.has("is_option") or field.has("is_array"):
            add_meta_for_field = true
        elif not SpacetimeSchemaParser.GDNATIVE_TYPES.has(original_inner_type_name):
            add_meta_for_field = true
        elif schema.meta_type_map.has(original_inner_type_name):
            add_meta_for_field = true
        
        if add_meta_for_field and not bsatn_meta_type_string.is_empty():
            meta_data.append("set_meta('bsatn_type_%s', &'%s')" % [field_name, bsatn_meta_type_string])
        
        content += "@export var %s: %s %s\n" % [field_name, gd_field_type, documentation_comment]
        class_fields.append([field_name, gd_field_type])

    content += "\nfunc _init() -> void:\n"
    for m in meta_data:
        content += "\t%s\n" % m
    if meta_data.size() == 0:
        content += "\tpass\n"

    content += "\n" + create_func_documentation_comment
    content += "static func create(%s) -> %s:\n" % \
    [", ".join(class_fields.map(func(x): return "p_%s: %s" % [x[0], x[1]])), _class_name] + \
    "\tvar result = %s.new()\n" % [_class_name]
    for field_data in class_fields:
        var f_name: String = field_data[0]
        content += "\tresult.%s = p_%s\n" % [f_name, f_name]
    content += "\treturn result\n"
    return content

func _generate_enum_gdscript(schema: SpacetimeParsedSchema, type_def: Dictionary) -> String:
    var enum_name: String = type_def.get("name", "")
    var variants: Array = type_def.get("enum", [""])
    var variant_names: String = "\n".join(variants.map(func(x):
        return "\t%s," % [x.get("name", "")]))
    
    var _class_name: String = schema.module.to_pascal_case() + enum_name.to_pascal_case()
    var content: String = AUTOGENERATED_COMMENT + \
    "class_name %s extends RustEnum\n\n" % _class_name + \
    "enum {\n%s\n}\n\n" % variant_names + \
    "func _init():\n" + \
    "\tset_meta('enum_options', [%s])\n" % \
    [", ".join(variants.map(func(x):
        var type = x.get("type", "")
        var rust_type = schema.meta_type_map.get(type, type)
        if x.has("is_array_inside_option"):
            rust_type = "opt_vec_%s" % rust_type
        elif x.has("is_option_inside_array"):
            rust_type = "vec_opt_%s" % rust_type
        elif x.has("is_array"):
            rust_type = "vec_%s" % rust_type
        elif x.has("is_option"):
            rust_type = "opt_%s" % rust_type
        return "&'%s'" % rust_type if not rust_type.is_empty() else "&''"
        ))] + \
    "\tset_meta('bsatn_enum_type', &'%s')\n" % _class_name + \
    "\n" + \
    "static func parse_enum_name(i: int) -> String:\n" + \
    "\tmatch i:\n"
    for i in range(variants.size()):
        content += "\t\t%d: return &'%s'\n" % [i, variants[i].get("name", "")]
    content += "\t\t_:\n" + \
    "\t\t\tprinterr(\"Enum does not have value for %d. This is out of bounds.\" % i)\n" + \
    "\t\t\treturn &'Unknown'\n\n"
    var get_funcs: Array[String]
    var create_funcs: Array[String]
    for v_schema in variants:
        var variant_name: String = v_schema.get("name", "")
        var variant_gd_type: String = schema.type_map.get(v_schema.get("type", ""), "Variant")
        var nested_type: Array = v_schema.get("nested_type", []).duplicate()
        nested_type.append(variant_gd_type)
        if v_schema.has("is_option"):
            variant_gd_type = OPTION_CLASS_NAME
        elif v_schema.has("is_array"):
            if v_schema.has("is_option_inside_array"):
                variant_gd_type = OPTION_CLASS_NAME
            variant_gd_type = "Array[%s]" % variant_gd_type
        
        if v_schema.has("type"):
            if v_schema.has("is_option") or v_schema.has("is_option_inside_array"):
                get_funcs.append("## Returns: %s\n" % \
                [" of ".join(nested_type)])
                create_funcs.append("## 0. data: %s\n" % \
                [" of ".join(nested_type)])
            get_funcs.append("func get_%s() -> %s:\n" % [variant_name.to_snake_case(), variant_gd_type] + \
            "\treturn data\n\n")
            create_funcs.append("static func create_%s(_data: %s) -> %s:\n" % [variant_name.to_snake_case(), variant_gd_type, _class_name] + \
            "\treturn create(%s, _data)\n\n" % [variant_name])
        else:
            create_funcs.append("static func create_%s() -> %s:\n" % [variant_name.to_snake_case(), _class_name] + \
            "\treturn create(%s)\n\n" % [variant_name])
    
    content += "".join(get_funcs)
    content += "static func create(p_type: int, p_data: Variant = null) -> %s:\n" % _class_name + \
    "\tvar result = %s.new()\n" % _class_name + \
    "\tresult.value = p_type\n" + \
    "\tresult.data = p_data\n" + \
    "\treturn result\n\n"
    content += "".join(create_funcs)

    # Clean up trailing newlines
    while content.ends_with("\n"):
        content = content.left(-1)
        
    return content

func _generate_module_client_gdscript(schema: SpacetimeParsedSchema) -> String:
    var content := AUTOGENERATED_COMMENT + \
    "@tool\n" + \
    "class_name %sModuleClient extends SpacetimeDBClient\n\n" % schema.module.to_pascal_case() + \
    "const Types = preload('%s/module_%s_types.gd')\n\n" % [_schema_path, schema.module.to_snake_case()]
    
    var types_part := _generate_types_gdscript(schema, true)
    if not types_part.is_empty():
        content += types_part + "\n"
        
    content += "var reducers: %sModuleReducers\n" % schema.module.to_pascal_case() + \
    "var db: %sModuleDb\n\n" % schema.module.to_pascal_case() + \
    "func _init() -> void:\n" + \
    "\tset_meta(\"module_name\", \"%s\")\n" % schema.module + \
    "\tname = \"%sModule\"\n" % schema.module.to_pascal_case() + \
    "\treducers = preload('%s/module_%s_reducers.gd').new(self)\n" % [_schema_path, schema.module.to_snake_case()] + \
    "\nfunc _init_db(p_local_db: LocalDatabase) -> void:\n" + \
    "\tdb = preload('%s/module_%s_db.gd').new(p_local_db)\n" % [_schema_path, schema.module.to_snake_case()]
        
    return content

func _generate_db_gdscript(schema: SpacetimeParsedSchema) -> String:
    var tables: Dictionary[String, String] = {}
    var table_names: Array[String] = []
    for table_def in schema.tables:
        var table_name = table_def.get("name", null)
        if table_name == null: continue
        if _config.hide_private_tables and not table_def.get("is_public", true): continue
        tables[table_name] = "%s%sTable" % [schema.module.to_pascal_case(), table_name.to_pascal_case()]
        table_names.append("\"%s\"" % table_name)
    
    var content := AUTOGENERATED_COMMENT + \
    "class_name %sModuleDb extends RefCounted\n\n" % schema.module.to_pascal_case() + \
    "const table_names := [%s]\n\n" % ", ".join(table_names)
    for table_name in tables:
        var table_type := tables[table_name]
        content += "var %s: %s\n" % [table_name.to_snake_case(), table_type]
    
    content += "\nfunc _init(p_local_db: LocalDatabase) -> void:\n"
    for table_name in tables:
        content += "\t%s = preload('%s/tables/%s_%s_table.gd').new(p_local_db)\n" % \
            [table_name.to_snake_case(), _schema_path, schema.module.to_snake_case(), table_name.to_snake_case()]
    
    return content

func _generate_types_gdscript(schema: SpacetimeParsedSchema, const_pointer: bool = false) -> String:
    var content := "" if const_pointer else AUTOGENERATED_COMMENT + "\n"
    for _type_def in schema.types:
        if _type_def.has("gd_native"): continue
        var type_name: String = _type_def.get("name", "")
        var file_suffix := ""
        if _type_def.has("table_name"):
            if not _type_def.has("primary_key_name"):
                continue
            if _config.hide_private_tables and not _type_def.get("is_public", []).has(true): continue
        
        if const_pointer:
            content += "const %s = Types.%s\n" % \
            [type_name.to_pascal_case(), type_name.to_pascal_case()]
        else:
            if _type_def.has("is_sum_type") and not _type_def.get("is_sum_type"):
                content += "enum %s {\n" % type_name.to_pascal_case()
                var variants_str := ""
                for variant in _type_def.get("enum", []):
                    var variant_name: String = variant.get("name", "")
                    variants_str += "\t%s,\n" % variant_name.to_pascal_case()
                if not variants_str.is_empty():
                    variants_str = variants_str.left(-2)
                content += variants_str
                content += "\n}\n"
            else:
                content += "const %s = preload('%s/types/%s_%s.gd')\n" % \
                [type_name.to_pascal_case(), _schema_path,
                schema.module.to_snake_case(), type_name.to_snake_case()]
    return content

func _generate_reducers_gdscript(schema: SpacetimeParsedSchema) -> String:
    var content := AUTOGENERATED_COMMENT + \
    "class_name %sModuleReducers extends RefCounted\n\n" % schema.module.to_pascal_case() + \
    "var _client: SpacetimeDBClient\n\n" + \
    "func _init(p_client: SpacetimeDBClient) -> void:\n" + \
    "\t_client = p_client\n"
    
    for reducer in schema.reducers:
        if reducer.get("is_scheduled", false) and _config.hide_scheduled_reducers: continue
        
        var params_str_parts: Array[String] = []
        var description_comment: Array = []
        var reducer_params = reducer.get("params", [])
        for i in reducer_params.size():
            var param = reducer_params[i]
            var param_name: String = param.get("name", "")
            var gd_param_type: String
            var original_inner_type_name: String = param.get("type", "Variant")
            var nested_type: Array = param.get("nested_type", []).duplicate()
            nested_type.append(schema.type_map.get(original_inner_type_name, "Variant"))
            description_comment.append("## %d. %s: %s [br]" % [i, param_name, " of ".join(nested_type)])
            if param.has("is_option"):
                gd_param_type = OPTION_CLASS_NAME
            elif param.has("is_array"):
                var element_gd_type = schema.type_map.get(original_inner_type_name, "Variant")
                if param.has("is_option_inside_array"):
                    element_gd_type = OPTION_CLASS_NAME
                gd_param_type = "Array[%s]" % element_gd_type
            else:
                gd_param_type = schema.type_map.get(original_inner_type_name, "Variant")
            params_str_parts.append("%s: %s" % [param_name, gd_param_type])
        
        var params_str: String
        if params_str_parts.is_empty():
            params_str = "cb: Callable = func(_t: TransactionUpdateMessage): pass"
        else:
            params_str = ", ".join(params_str_parts) + ", cb: Callable = func(_t: TransactionUpdateMessage): pass"

        var param_names_list = reducer.get("params", []).map(func(x): return x.get("name", ""))
        var param_names_str = ""
        if not param_names_list.is_empty():
            param_names_str = ", ".join(param_names_list)
        
        var param_bsatn_types_list = (reducer.get("params", []) as Array).map(func(x):
            var original_inner_type_name_bsatn: String = x.get("type", "Variant")
            var bsatn_param_type: String

            if x.has("is_option"):
                var inner_meta_for_option: String
                if x.has("is_array_inside_option"):
                    inner_meta_for_option = "vec_%s" % schema.meta_type_map.get(original_inner_type_name_bsatn, original_inner_type_name_bsatn)
                else:
                    inner_meta_for_option = schema.meta_type_map.get(original_inner_type_name_bsatn, original_inner_type_name_bsatn)
                bsatn_param_type = "%s" % inner_meta_for_option
            else:
                bsatn_param_type = schema.meta_type_map.get(original_inner_type_name_bsatn, original_inner_type_name_bsatn)
            
            if bsatn_param_type.is_empty(): return "''"
            return "&'%s'" % bsatn_param_type
        )
        var param_bsatn_types_str := ""
        if not param_bsatn_types_list.is_empty():
            param_bsatn_types_str = ", ".join(param_bsatn_types_list)
        
        content += "\n".join(description_comment) + "\n"
        var reducer_name: String = reducer.get("name", "")
        content += "func %s(%s) -> Error:\n" % [reducer_name, params_str] + \
        "\tvar __handle__ := _client.call_reducer('%s', [%s], [%s])\n" % \
        [reducer_name, param_names_str, param_bsatn_types_str] + \
        "\tif __handle__.error: return __handle__.error\n" + \
        "\tvar __result__ = await __handle__.wait_for_response()\n" + \
        "\tcb.call(__result__)\n" + \
        "\treturn OK\n\n"
    
    if not content.is_empty():
        content = content.left(-2)
    return content

func _generate_autoload_gdscript(modules: Array[String]) -> String:
    var content := AUTOGENERATED_COMMENT + \
    "class_name SpacetimeAutoload extends Node\n\n"
    for module_name in modules:
        content += "var %s: %sModuleClient\n" % \
            [module_name.to_pascal_case(), module_name.to_pascal_case()]
        
    content += "\nfunc _init() -> void:\n"
    for module_name in modules:
        content += "\t%s = preload('%s/module_%s_client.gd').new()\n" % \
            [module_name.to_pascal_case(), _schema_path, module_name.to_snake_case()] + \
        "\tadd_child(%s)\n" % [module_name.to_pascal_case()]
    
    return content
