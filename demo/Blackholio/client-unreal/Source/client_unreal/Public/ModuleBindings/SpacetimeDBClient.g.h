// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb cli version 2.0.1 (commit a953d3b65c4a925b3b3824c419eb53821db95e2f).

#pragma once
#include "CoreMinimal.h"
#include "BSATN/UESpacetimeDB.h"
#include "Connection/Callback.h"
#include "Connection/DbConnectionBase.h"
#include "Connection/DbConnectionBuilder.h"
#include "Connection/Subscription.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "ModuleBindings/ReducerBase.g.h"
#include "ModuleBindings/Reducers/EnterGame.g.h"
#include "ModuleBindings/Reducers/PlayerSplit.g.h"
#include "ModuleBindings/Reducers/Respawn.g.h"
#include "ModuleBindings/Reducers/Suicide.g.h"
#include "ModuleBindings/Reducers/UpdatePlayerInput.g.h"
#include "ModuleBindings/Types/DbVector2Type.g.h"
#include "Types/Builtins.h"
#include "SpacetimeDBClient.g.generated.h"

// Forward declarations
class UDbConnection;
class URemoteTables;
class URemoteReducers;
class URemoteProcedures;
class USubscriptionBuilder;
class USubscriptionHandle;

/** Forward declaration for tables */
class UCircleTable;
class UConfigTable;
class UConsumeEntityEventTable;
class UEntityTable;
class UFoodTable;
class UPlayerTable;
/***/

// Delegates using the generated connection type. These wrap the base
// delegates defined in the SDK so that projects can work directly with
// UDbConnection without manual casting in user code.
DECLARE_DYNAMIC_DELEGATE_ThreeParams(
	FOnConnectDelegate,
	UDbConnection*, Connection,
	FSpacetimeDBIdentity, Identity,
	const FString&, Token);

DECLARE_DYNAMIC_DELEGATE_TwoParams(
	FOnDisconnectDelegate,
	UDbConnection*, Connection,
	const FString&, Error);


// Context classes for event handling

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FContextBase
{
	GENERATED_BODY()

	FContextBase() : Db(nullptr), Reducers(nullptr), Procedures(nullptr), Conn(nullptr) {};
	FContextBase(UDbConnection* InConn);

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteTables* Db;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteReducers* Reducers;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteProcedures* Procedures;

	bool IsActive() const;
	void Disconnect();
	bool TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const;
	FSpacetimeDBConnectionId GetConnectionId() const;
	USubscriptionBuilder* SubscriptionBuilder();

protected:
	UPROPERTY()
	UDbConnection* Conn;

};

UCLASS()
class CLIENT_UNREAL_API UContextBaseBpLib : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

private:
	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static URemoteTables* GetDb(const FContextBase& Ctx) { return Ctx.Db; }

	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static URemoteReducers* GetReducers(const FContextBase& Ctx) { return Ctx.Reducers; }

	static URemoteProcedures* GetProcedures(const FContextBase& Ctx) { return Ctx.Procedures; }

	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static bool IsActive(const FContextBase& Ctx) { return Ctx.IsActive(); }
};

UENUM(BlueprintType, Category = "SpacetimeDB")
enum class EReducerTag : uint8
{
    EnterGame,
    PlayerSplit,
    Respawn,
    Suicide,
    UpdatePlayerInput
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FReducer
{
    GENERATED_BODY()

public:
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    EReducerTag Tag = static_cast<EReducerTag>(0);

    TVariant<FEnterGameArgs, FPlayerSplitArgs, FRespawnArgs, FSuicideArgs, FUpdatePlayerInputArgs> Data;

    // Optional metadata
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    FString ReducerName;
    uint32 ReducerId = 0;
    uint32 RequestId = 0;

    static FReducer EnterGame(const FEnterGameArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::EnterGame;
        Out.Data.Set<FEnterGameArgs>(Value);
        Out.ReducerName = TEXT("enter_game");
        return Out;
    }

    FORCEINLINE bool IsEnterGame() const { return Tag == EReducerTag::EnterGame; }
    FORCEINLINE FEnterGameArgs GetAsEnterGame() const
    {
        ensureMsgf(IsEnterGame(), TEXT("Reducer does not hold EnterGame!"));
        return Data.Get<FEnterGameArgs>();
    }

    static FReducer PlayerSplit(const FPlayerSplitArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::PlayerSplit;
        Out.Data.Set<FPlayerSplitArgs>(Value);
        Out.ReducerName = TEXT("player_split");
        return Out;
    }

    FORCEINLINE bool IsPlayerSplit() const { return Tag == EReducerTag::PlayerSplit; }
    FORCEINLINE FPlayerSplitArgs GetAsPlayerSplit() const
    {
        ensureMsgf(IsPlayerSplit(), TEXT("Reducer does not hold PlayerSplit!"));
        return Data.Get<FPlayerSplitArgs>();
    }

    static FReducer Respawn(const FRespawnArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::Respawn;
        Out.Data.Set<FRespawnArgs>(Value);
        Out.ReducerName = TEXT("respawn");
        return Out;
    }

    FORCEINLINE bool IsRespawn() const { return Tag == EReducerTag::Respawn; }
    FORCEINLINE FRespawnArgs GetAsRespawn() const
    {
        ensureMsgf(IsRespawn(), TEXT("Reducer does not hold Respawn!"));
        return Data.Get<FRespawnArgs>();
    }

    static FReducer Suicide(const FSuicideArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::Suicide;
        Out.Data.Set<FSuicideArgs>(Value);
        Out.ReducerName = TEXT("suicide");
        return Out;
    }

    FORCEINLINE bool IsSuicide() const { return Tag == EReducerTag::Suicide; }
    FORCEINLINE FSuicideArgs GetAsSuicide() const
    {
        ensureMsgf(IsSuicide(), TEXT("Reducer does not hold Suicide!"));
        return Data.Get<FSuicideArgs>();
    }

    static FReducer UpdatePlayerInput(const FUpdatePlayerInputArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::UpdatePlayerInput;
        Out.Data.Set<FUpdatePlayerInputArgs>(Value);
        Out.ReducerName = TEXT("update_player_input");
        return Out;
    }

    FORCEINLINE bool IsUpdatePlayerInput() const { return Tag == EReducerTag::UpdatePlayerInput; }
    FORCEINLINE FUpdatePlayerInputArgs GetAsUpdatePlayerInput() const
    {
        ensureMsgf(IsUpdatePlayerInput(), TEXT("Reducer does not hold UpdatePlayerInput!"));
        return Data.Get<FUpdatePlayerInputArgs>();
    }

    FORCEINLINE bool operator==(const FReducer& Other) const
    {
        if (Tag != Other.Tag || ReducerId != Other.ReducerId || RequestId != Other.RequestId || ReducerName != Other.ReducerName) return false;
        switch (Tag)
        {
        case EReducerTag::EnterGame:
            return GetAsEnterGame() == Other.GetAsEnterGame();
        case EReducerTag::PlayerSplit:
            return GetAsPlayerSplit() == Other.GetAsPlayerSplit();
        case EReducerTag::Respawn:
            return GetAsRespawn() == Other.GetAsRespawn();
        case EReducerTag::Suicide:
            return GetAsSuicide() == Other.GetAsSuicide();
        case EReducerTag::UpdatePlayerInput:
            return GetAsUpdatePlayerInput() == Other.GetAsUpdatePlayerInput();
        default: return false;
        }
    }
    FORCEINLINE bool operator!=(const FReducer& Other) const { return !(*this == Other); }
};

UCLASS()
class CLIENT_UNREAL_API UReducerBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer EnterGame(const FEnterGameArgs& Value) {
        return FReducer::EnterGame(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsEnterGame(const FReducer& Reducer) { return Reducer.IsEnterGame(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FEnterGameArgs GetAsEnterGame(const FReducer& Reducer) {
        return Reducer.GetAsEnterGame();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer PlayerSplit(const FPlayerSplitArgs& Value) {
        return FReducer::PlayerSplit(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsPlayerSplit(const FReducer& Reducer) { return Reducer.IsPlayerSplit(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FPlayerSplitArgs GetAsPlayerSplit(const FReducer& Reducer) {
        return Reducer.GetAsPlayerSplit();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer Respawn(const FRespawnArgs& Value) {
        return FReducer::Respawn(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsRespawn(const FReducer& Reducer) { return Reducer.IsRespawn(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FRespawnArgs GetAsRespawn(const FReducer& Reducer) {
        return Reducer.GetAsRespawn();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer Suicide(const FSuicideArgs& Value) {
        return FReducer::Suicide(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsSuicide(const FReducer& Reducer) { return Reducer.IsSuicide(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FSuicideArgs GetAsSuicide(const FReducer& Reducer) {
        return Reducer.GetAsSuicide();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer UpdatePlayerInput(const FUpdatePlayerInputArgs& Value) {
        return FReducer::UpdatePlayerInput(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsUpdatePlayerInput(const FReducer& Reducer) { return Reducer.IsUpdatePlayerInput(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FUpdatePlayerInputArgs GetAsUpdatePlayerInput(const FReducer& Reducer) {
        return Reducer.GetAsUpdatePlayerInput();
    }
};

/** Metadata describing a reducer run. */
USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FClientUnrealReducerEvent
{
	GENERATED_BODY()

	/** Timestamp for when the reducer executed */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimestamp Timestamp;

	/** Result status of the reducer */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBStatus Status;

	/** Identity that initiated the call */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBIdentity CallerIdentity;

	/** Connection ID for the caller */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBConnectionId CallerConnectionId;

	/** Energy consumed while executing */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FEnergyQuantaType EnergyConsumed;

	/** Detailed call information */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FReducer Reducer;

	FORCEINLINE bool operator==(const FClientUnrealReducerEvent& Other) const
	{
		return Status == Other.Status && Timestamp == Other.Timestamp && CallerIdentity == Other.CallerIdentity &&
			CallerConnectionId == Other.CallerConnectionId && EnergyConsumed == Other.EnergyConsumed &&
			Reducer == Other.Reducer;
	}

	FORCEINLINE bool operator!=(const FClientUnrealReducerEvent& Other) const
	{
		return !(*this == Other);
	}
};

// No procedures defined in this module.
/** Metadata describing a procedure run. */
USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FClientUnrealProcedureEvent
{
	GENERATED_BODY()

	/** Timestamp for when the procedure executed */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimestamp Timestamp;

	/** Result status of the procedure */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBProcedureStatus Status;

	/** Identity that initiated the call */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimeDuration TotalHostExecutionDuration;

	FClientUnrealProcedureEvent() {
	}
	FClientUnrealProcedureEvent(FProcedureEvent Event) {
		Timestamp = Event.Timestamp;
		Status = FSpacetimeDBProcedureStatus::FromStatus(Event.Status);
		TotalHostExecutionDuration = Event.TotalHostExecutionDuration;
	}
	FORCEINLINE bool operator==(const FClientUnrealProcedureEvent& Other) const
	{
		return Status == Other.Status && Timestamp == Other.Timestamp &&
			TotalHostExecutionDuration == Other.TotalHostExecutionDuration;
	}

	FORCEINLINE bool operator!=(const FClientUnrealProcedureEvent& Other) const
	{
		return !(*this == Other);
	}
};

/** Represents event with variant message data. */
USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FClientUnrealEvent
{
	GENERATED_BODY()

	/** Tagged union holding reducer call, unit events, or error string */
	TVariant<FReducer, FSpacetimeDBUnit, FString> MessageData;

	/** Type tag indicating what this event represents */
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	ESpacetimeDBEventTag Tag = ESpacetimeDBEventTag::UnknownTransaction;

	/** === Static factory methods ===*/
	static FClientUnrealEvent Reducer(const FReducer& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Reducer;
		Obj.MessageData.Set<FReducer>(Value);
		return Obj;
	}

	static FClientUnrealEvent SubscribeApplied(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::SubscribeApplied;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent UnsubscribeApplied(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::UnsubscribeApplied;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent Disconnected(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Disconnected;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent Transaction(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Transaction;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent SubscribeError(const FString& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::SubscribeError;
		Obj.MessageData.Set<FString>(Value);
		return Obj;
	}

	static FClientUnrealEvent UnknownTransaction(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::UnknownTransaction;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	FORCEINLINE bool IsReducer() const { return Tag == ESpacetimeDBEventTag::Reducer; }
	FORCEINLINE FReducer GetAsReducer() const
	{
		ensureMsgf(IsReducer(), TEXT("MessageData does not hold Reducer!"));
		return MessageData.Get<FReducer>();
	}

	FORCEINLINE bool IsSubscribeApplied() const { return Tag == ESpacetimeDBEventTag::SubscribeApplied; }
	FORCEINLINE FSpacetimeDBUnit GetAsSubscribeApplied() const
	{
		ensureMsgf(IsSubscribeApplied(), TEXT("MessageData does not hold SubscribeApplied!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsUnsubscribeApplied() const { return Tag == ESpacetimeDBEventTag::UnsubscribeApplied; }
	FORCEINLINE FSpacetimeDBUnit GetAsUnsubscribeApplied() const
	{
		ensureMsgf(IsUnsubscribeApplied(), TEXT("MessageData does not hold UnsubscribeApplied!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsDisconnected() const { return Tag == ESpacetimeDBEventTag::Disconnected; }
	FORCEINLINE FSpacetimeDBUnit GetAsDisconnected() const
	{
		ensureMsgf(IsDisconnected(), TEXT("MessageData does not hold Disconnected!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsTransaction() const { return Tag == ESpacetimeDBEventTag::Transaction; }
	FORCEINLINE FSpacetimeDBUnit GetAsTransaction() const
	{
		ensureMsgf(IsTransaction(), TEXT("MessageData does not hold Transaction!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsSubscribeError() const { return Tag == ESpacetimeDBEventTag::SubscribeError; }
	FORCEINLINE FString GetAsSubscribeError() const
	{
		ensureMsgf(IsSubscribeError(), TEXT("MessageData does not hold SubscribeError!"));
		return MessageData.Get<FString>();
	}

	FORCEINLINE bool IsUnknownTransaction() const { return Tag == ESpacetimeDBEventTag::UnknownTransaction; }
	FORCEINLINE FSpacetimeDBUnit GetAsUnknownTransaction() const
	{
		ensureMsgf(IsUnknownTransaction(), TEXT("MessageData does not hold UnknownTransaction!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool operator==(const FClientUnrealEvent& Other) const
	{
		if (Tag != Other.Tag) return false;
		switch (Tag)
		{
		case ESpacetimeDBEventTag::Reducer: return GetAsReducer() == Other.GetAsReducer();
		case ESpacetimeDBEventTag::SubscribeApplied: return GetAsSubscribeApplied() == Other.GetAsSubscribeApplied();
		case ESpacetimeDBEventTag::UnsubscribeApplied: return GetAsUnsubscribeApplied() == Other.GetAsUnsubscribeApplied();
		case ESpacetimeDBEventTag::Disconnected: return GetAsDisconnected() == Other.GetAsDisconnected();
		case ESpacetimeDBEventTag::Transaction: return GetAsTransaction() == Other.GetAsTransaction();
		case ESpacetimeDBEventTag::SubscribeError: return GetAsSubscribeError() == Other.GetAsSubscribeError();
		case ESpacetimeDBEventTag::UnknownTransaction: return GetAsUnknownTransaction() == Other.GetAsUnknownTransaction();
		default: return false;
		}
	}

	FORCEINLINE bool operator!=(const FClientUnrealEvent& Other) const
	{
		return !(*this == Other);
	}
};

UCLASS()
class CLIENT_UNREAL_API UClientUnrealEventBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent Reducer(const FReducer& InValue)
    {
        return FClientUnrealEvent::Reducer(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent SubscribeApplied(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::SubscribeApplied(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent UnsubscribeApplied(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::UnsubscribeApplied(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent Disconnected(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::Disconnected(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent Transaction(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::Transaction(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent SubscribeError(const FString& InValue)
    {
        return FClientUnrealEvent::SubscribeError(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent UnknownTransaction(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::UnknownTransaction(InValue);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsReducer(const FClientUnrealEvent& Event) { return Event.IsReducer(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsSubscribeApplied(const FClientUnrealEvent& Event) { return Event.IsSubscribeApplied(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsUnsubscribeApplied(const FClientUnrealEvent& Event) { return Event.IsUnsubscribeApplied(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsDisconnected(const FClientUnrealEvent& Event) { return Event.IsDisconnected(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsTransaction(const FClientUnrealEvent& Event) { return Event.IsTransaction(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsSubscribeError(const FClientUnrealEvent& Event) { return Event.IsSubscribeError(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsUnknownTransaction(const FClientUnrealEvent& Event) { return Event.IsUnknownTransaction(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FReducer GetAsReducer(const FClientUnrealEvent& Event)
    {
        return Event.GetAsReducer();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsSubscribeApplied(const FClientUnrealEvent& Event)
    {
        return Event.GetAsSubscribeApplied();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsUnsubscribeApplied(const FClientUnrealEvent& Event)
    {
        return Event.GetAsUnsubscribeApplied();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsDisconnected(const FClientUnrealEvent& Event)
    {
        return Event.GetAsDisconnected();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsTransaction(const FClientUnrealEvent& Event)
    {
        return Event.GetAsTransaction();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FString GetAsSubscribeError(const FClientUnrealEvent& Event)
    {
        return Event.GetAsSubscribeError();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsUnknownTransaction(const FClientUnrealEvent& Event)
    {
        return Event.GetAsUnknownTransaction();
    }

};


USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FEventContext : public FContextBase
{
	GENERATED_BODY()

	FEventContext() = default;
	FEventContext(UDbConnection* InConn, const FClientUnrealEvent& InEvent) : FContextBase(InConn), Event(InEvent) {}

	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	FClientUnrealEvent Event;
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FReducerEventContext : public FContextBase
{
	GENERATED_BODY()

	FReducerEventContext() = default;
	FReducerEventContext(UDbConnection* InConn, FClientUnrealReducerEvent InEvent) : FContextBase(InConn), Event(InEvent) {}
	
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB") 
	FClientUnrealReducerEvent Event;
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FProcedureEventContext : public FContextBase
{
	GENERATED_BODY()

	FProcedureEventContext() = default;
	FProcedureEventContext(UDbConnection* InConn, FClientUnrealProcedureEvent InEvent) : FContextBase(InConn), Event(InEvent) {}
	
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB") 
	FClientUnrealProcedureEvent Event;
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FErrorContext : public FContextBase
{
	GENERATED_BODY()

	FErrorContext() = default;
	FErrorContext(UDbConnection* InConn, const FString& InError) : FContextBase(InConn), Error(InError) {}

	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	FString Error;

};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FSubscriptionEventContext : public FContextBase
{
	GENERATED_BODY()

	FSubscriptionEventContext() = default;
	FSubscriptionEventContext(UDbConnection* InConn) : FContextBase(InConn) {}

};

DECLARE_DYNAMIC_DELEGATE_OneParam(
	FOnSubscriptionApplied,
	FSubscriptionEventContext, Context);

DECLARE_DYNAMIC_DELEGATE_OneParam(
	FOnSubscriptionError,
	FErrorContext, Context);

// RemoteTables class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API URemoteTables : public UObject
{
    GENERATED_BODY()

public:
    void Initialize();

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UCircleTable* Circle;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UConfigTable* Config;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UConsumeEntityEventTable* ConsumeEntityEvent;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UEntityTable* Entity;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UFoodTable* Food;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UPlayerTable* Player;

};

// RemoteReducers class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API URemoteReducers : public UObject
{
    GENERATED_BODY()

public:

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FEnterGameHandler,
        const FReducerEventContext&, Context,
        const FString&, Name
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FEnterGameHandler OnEnterGame;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void EnterGame(const FString& Name);

    bool InvokeEnterGame(const FReducerEventContext& Context, const UEnterGameReducer* Args);
    bool InvokeEnterGameWithArgs(const FReducerEventContext& Context, const FEnterGameArgs& Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FPlayerSplitHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FPlayerSplitHandler OnPlayerSplit;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void PlayerSplit();

    bool InvokePlayerSplit(const FReducerEventContext& Context, const UPlayerSplitReducer* Args);
    bool InvokePlayerSplitWithArgs(const FReducerEventContext& Context, const FPlayerSplitArgs& Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FRespawnHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FRespawnHandler OnRespawn;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void Respawn();

    bool InvokeRespawn(const FReducerEventContext& Context, const URespawnReducer* Args);
    bool InvokeRespawnWithArgs(const FReducerEventContext& Context, const FRespawnArgs& Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FSuicideHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FSuicideHandler OnSuicide;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void Suicide();

    bool InvokeSuicide(const FReducerEventContext& Context, const USuicideReducer* Args);
    bool InvokeSuicideWithArgs(const FReducerEventContext& Context, const FSuicideArgs& Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FUpdatePlayerInputHandler,
        const FReducerEventContext&, Context,
        const FDbVector2Type&, Direction
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FUpdatePlayerInputHandler OnUpdatePlayerInput;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void UpdatePlayerInput(const FDbVector2Type& Direction);

    bool InvokeUpdatePlayerInput(const FReducerEventContext& Context, const UUpdatePlayerInputReducer* Args);
    bool InvokeUpdatePlayerInputWithArgs(const FReducerEventContext& Context, const FUpdatePlayerInputArgs& Args);

    // Internal error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FInternalOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);
    FInternalOnUnhandledReducerError InternalOnUnhandledReducerError;

private:

    friend UDbConnection;

    UPROPERTY()
    class UDbConnection* Conn;
};

// RemoteProcedures class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API URemoteProcedures : public UObject
{
    GENERATED_BODY()

public:

    // Internal error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FInternalOnUnhandledProcedureError, const FProcedureEventContext&, Context, const FString&, Error);
    FInternalOnUnhandledProcedureError InternalOnUnhandledProcedureError;

private:

    friend UDbConnection;

    UPROPERTY()
    class UDbConnection* Conn;
};

// SubscriptionBuilder class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API USubscriptionBuilder : public USubscriptionBuilderBase
{
    GENERATED_BODY()

public:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionBuilder* OnApplied(FOnSubscriptionApplied Callback);

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionBuilder* OnError(FOnSubscriptionError Callback);

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    USubscriptionHandle* Subscribe(const TArray<FString>& SQL);

    /** Convenience for subscribing to all rows from all tables */
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionHandle* SubscribeToAllTables();


    friend class UDbConnection;
    friend class UDbConnectionBase;

protected:
    UPROPERTY()
    class UDbConnection* Conn;

    // Delegates stored so Subscribe() can bind forwarding callbacks
    FOnSubscriptionApplied OnAppliedDelegateInternal;
    FOnSubscriptionError OnErrorDelegateInternal;
};

// SubscriptionHandle class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API USubscriptionHandle : public USubscriptionHandleBase
{
    GENERATED_BODY()

public:

    USubscriptionHandle() {};

    explicit USubscriptionHandle(UDbConnection* InConn);

    friend class USubscriptionBuilder;

private:
    UPROPERTY()
    class UDbConnection* Conn;

    // Delegates that expose subscription events with connection aware contexts
    FOnSubscriptionApplied OnAppliedDelegate;
    FOnSubscriptionError OnErrorDelegate;

    UFUNCTION()
    void ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx);

    UFUNCTION()
    void ForwardOnError(const FErrorContextBase& BaseCtx);
};

/*
    @Note: Child class of UDbConnectionBuilderBase.
*/
UCLASS(BlueprintType)
class CLIENT_UNREAL_API UDbConnectionBuilder : public UDbConnectionBuilderBase
{
    GENERATED_BODY()
public:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithUri(const FString& InUri);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithDatabaseName(const FString& InName);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithToken(const FString& InToken);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithCompression(const ESpacetimeDBCompression& InCompression);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnConnect(FOnConnectDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnConnectError(FOnConnectErrorDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnDisconnect(FOnDisconnectDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnection* Build();

private:

    // Stored delegates which will be forwarded when the connection events occur.
    FOnConnectDelegate OnConnectDelegateInternal;
    FOnDisconnectDelegate OnDisconnectDelegateInternal;
};

// Main DbConnection class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API UDbConnection : public UDbConnectionBase
{
    GENERATED_BODY()

public:
    explicit UDbConnection(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());


    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteTables* Db;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteReducers* Reducers;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteProcedures* Procedures;

    // Delegates that allow users to bind with the concrete connection type.
    FOnConnectDelegate OnConnectDelegate;
    FOnDisconnectDelegate OnDisconnectDelegate;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    USubscriptionBuilder* SubscriptionBuilder();

    /** Static entry point for constructing a connection. */
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB", DisplayName = "SpacetimeDB Builder")
    static UDbConnectionBuilder* Builder();

    // Error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FOnUnhandledReducerError OnUnhandledReducerError;

    // Error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnUnhandledProcedureError, const FProcedureEventContext&, Context, const FString&, Error);
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FOnUnhandledProcedureError OnUnhandledProcedureError;


protected:

    // Hook up error handling to reducers and procedures
    virtual void PostInitProperties() override;

    UFUNCTION()
    void ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken);
    UFUNCTION()
    void ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error);

    UFUNCTION()
    void OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error);

    UFUNCTION()
    void OnUnhandledProcedureErrorHandler(const FProcedureEventContext& Context, const FString& Error);

    // Override the DbConnectionBase methods to handle updates and events
    virtual void DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event) override;
    
    // Override the reducer event handler to dispatch events to the appropriate reducers
    virtual void ReducerEvent(const FReducerEvent& Event) override;
    
    // Override the reducer event failed handler
    virtual void ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage) override;
    // Override the procedure event failed handler
    virtual void ProcedureEventFailed(const FProcedureEvent& Event, const FString ErrorMessage) override;

    friend class URemoteReducers;

    // Internal reducer correlation helpers (request_id -> typed reducer)
    void RegisterPendingTypedReducer(uint32 RequestId, FReducer Reducer);
    bool TryGetPendingTypedReducer(uint32 RequestId, FReducer& OutReducer) const;
    bool TryTakePendingTypedReducer(uint32 RequestId, FReducer& OutReducer);

private:
    TMap<uint32, FReducer> PendingTypedReducers;
};

