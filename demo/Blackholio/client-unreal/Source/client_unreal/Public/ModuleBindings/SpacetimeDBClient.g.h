// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb cli version 1.4.0 (commit dc59211c1453848981aeb2efce2249c9a07947b2).

#pragma once
#include "CoreMinimal.h"
#include "BSATN/UESpacetimeDB.h"
#include "Connection/Callback.h"
#include "Connection/DbConnectionBase.h"
#include "Connection/DbConnectionBuilder.h"
#include "Connection/SetReducerFlags.h"
#include "Connection/Subscription.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "ModuleBindings/ReducerBase.g.h"
#include "ModuleBindings/Reducers/CircleDecay.g.h"
#include "ModuleBindings/Reducers/CircleRecombine.g.h"
#include "ModuleBindings/Reducers/Connect.g.h"
#include "ModuleBindings/Reducers/ConsumeEntity.g.h"
#include "ModuleBindings/Reducers/Disconnect.g.h"
#include "ModuleBindings/Reducers/EnterGame.g.h"
#include "ModuleBindings/Reducers/MoveAllPlayers.g.h"
#include "ModuleBindings/Reducers/PlayerSplit.g.h"
#include "ModuleBindings/Reducers/Respawn.g.h"
#include "ModuleBindings/Reducers/SpawnFood.g.h"
#include "ModuleBindings/Reducers/Suicide.g.h"
#include "ModuleBindings/Reducers/UpdatePlayerInput.g.h"
#include "ModuleBindings/Types/CircleDecayTimerType.g.h"
#include "ModuleBindings/Types/CircleRecombineTimerType.g.h"
#include "ModuleBindings/Types/ConsumeEntityTimerType.g.h"
#include "ModuleBindings/Types/DbVector2Type.g.h"
#include "ModuleBindings/Types/MoveAllPlayersTimerType.g.h"
#include "ModuleBindings/Types/SpawnFoodTimerType.g.h"
#include "Types/Builtins.h"
#include "SpacetimeDBClient.g.generated.h"

// Forward declarations
class UDbConnection;
class URemoteTables;
class URemoteReducers;
class USubscriptionBuilder;
class USubscriptionHandle;

/** Forward declaration for tables */
class UCircleTable;
class UCircleDecayTimerTable;
class UCircleRecombineTimerTable;
class UConfigTable;
class UConsumeEntityTimerTable;
class UEntityTable;
class UFoodTable;
class UCircleTable;
class UEntityTable;
class UPlayerTable;
class UMoveAllPlayersTimerTable;
class UPlayerTable;
class USpawnFoodTimerTable;
/***/

// Delegates using the generated connection type. These wrap the base
// delegates defined in the SDK so that projects can work directly with
// UDbConnection without manual casting in user code.
DECLARE_DYNAMIC_DELEGATE_ThreeParams(
	FOnConnectDelegate,
	UDbConnection*, Connection,
	FSpacetimeDBIdentity, Identity,
	const FString&, Token);

DECLARE_DYNAMIC_DELEGATE_TwoParams(
	FOnDisconnectDelegate,
	UDbConnection*, Connection,
	const FString&, Error);


// Context classes for event handling

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FContextBase
{
	GENERATED_BODY()

	FContextBase() = default;
	FContextBase(UDbConnection* InConn);

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteTables* Db;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteReducers* Reducers;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	USetReducerFlags* SetReducerFlags;

	bool IsActive() const;
	void Disconnect();
	bool TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const;
	FSpacetimeDBConnectionId GetConnectionId() const;
	USubscriptionBuilder* SubscriptionBuilder();

protected:
	UPROPERTY()
	UDbConnection* Conn;

};

UENUM(BlueprintType, Category = "SpacetimeDB")
enum class EReducerTag : uint8
{
    CircleDecay,
    CircleRecombine,
    Connect,
    ConsumeEntity,
    Disconnect,
    EnterGame,
    MoveAllPlayers,
    PlayerSplit,
    Respawn,
    SpawnFood,
    Suicide,
    UpdatePlayerInput
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FReducer
{
    GENERATED_BODY()

public:
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    EReducerTag Tag;

    TVariant<FCircleDecayArgs, FCircleRecombineArgs, FConnectArgs, FConsumeEntityArgs, FDisconnectArgs, FEnterGameArgs, FMoveAllPlayersArgs, FPlayerSplitArgs, FRespawnArgs, FSpawnFoodArgs, FSuicideArgs, FUpdatePlayerInputArgs> Data;

    // Optional metadata
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    FString ReducerName;
    uint32 ReducerId = 0;
    uint32 RequestId = 0;

    static FReducer CircleDecay(const FCircleDecayArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::CircleDecay;
        Out.Data.Set<FCircleDecayArgs>(Value);
        Out.ReducerName = TEXT("circle_decay");
        return Out;
    }

    FORCEINLINE bool IsCircleDecay() const { return Tag == EReducerTag::CircleDecay; }
    FORCEINLINE FCircleDecayArgs GetAsCircleDecay() const
    {
        ensureMsgf(IsCircleDecay(), TEXT("Reducer does not hold CircleDecay!"));
        return Data.Get<FCircleDecayArgs>();
    }

    static FReducer CircleRecombine(const FCircleRecombineArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::CircleRecombine;
        Out.Data.Set<FCircleRecombineArgs>(Value);
        Out.ReducerName = TEXT("circle_recombine");
        return Out;
    }

    FORCEINLINE bool IsCircleRecombine() const { return Tag == EReducerTag::CircleRecombine; }
    FORCEINLINE FCircleRecombineArgs GetAsCircleRecombine() const
    {
        ensureMsgf(IsCircleRecombine(), TEXT("Reducer does not hold CircleRecombine!"));
        return Data.Get<FCircleRecombineArgs>();
    }

    static FReducer Connect(const FConnectArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::Connect;
        Out.Data.Set<FConnectArgs>(Value);
        Out.ReducerName = TEXT("connect");
        return Out;
    }

    FORCEINLINE bool IsConnect() const { return Tag == EReducerTag::Connect; }
    FORCEINLINE FConnectArgs GetAsConnect() const
    {
        ensureMsgf(IsConnect(), TEXT("Reducer does not hold Connect!"));
        return Data.Get<FConnectArgs>();
    }

    static FReducer ConsumeEntity(const FConsumeEntityArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::ConsumeEntity;
        Out.Data.Set<FConsumeEntityArgs>(Value);
        Out.ReducerName = TEXT("consume_entity");
        return Out;
    }

    FORCEINLINE bool IsConsumeEntity() const { return Tag == EReducerTag::ConsumeEntity; }
    FORCEINLINE FConsumeEntityArgs GetAsConsumeEntity() const
    {
        ensureMsgf(IsConsumeEntity(), TEXT("Reducer does not hold ConsumeEntity!"));
        return Data.Get<FConsumeEntityArgs>();
    }

    static FReducer Disconnect(const FDisconnectArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::Disconnect;
        Out.Data.Set<FDisconnectArgs>(Value);
        Out.ReducerName = TEXT("disconnect");
        return Out;
    }

    FORCEINLINE bool IsDisconnect() const { return Tag == EReducerTag::Disconnect; }
    FORCEINLINE FDisconnectArgs GetAsDisconnect() const
    {
        ensureMsgf(IsDisconnect(), TEXT("Reducer does not hold Disconnect!"));
        return Data.Get<FDisconnectArgs>();
    }

    static FReducer EnterGame(const FEnterGameArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::EnterGame;
        Out.Data.Set<FEnterGameArgs>(Value);
        Out.ReducerName = TEXT("enter_game");
        return Out;
    }

    FORCEINLINE bool IsEnterGame() const { return Tag == EReducerTag::EnterGame; }
    FORCEINLINE FEnterGameArgs GetAsEnterGame() const
    {
        ensureMsgf(IsEnterGame(), TEXT("Reducer does not hold EnterGame!"));
        return Data.Get<FEnterGameArgs>();
    }

    static FReducer MoveAllPlayers(const FMoveAllPlayersArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::MoveAllPlayers;
        Out.Data.Set<FMoveAllPlayersArgs>(Value);
        Out.ReducerName = TEXT("move_all_players");
        return Out;
    }

    FORCEINLINE bool IsMoveAllPlayers() const { return Tag == EReducerTag::MoveAllPlayers; }
    FORCEINLINE FMoveAllPlayersArgs GetAsMoveAllPlayers() const
    {
        ensureMsgf(IsMoveAllPlayers(), TEXT("Reducer does not hold MoveAllPlayers!"));
        return Data.Get<FMoveAllPlayersArgs>();
    }

    static FReducer PlayerSplit(const FPlayerSplitArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::PlayerSplit;
        Out.Data.Set<FPlayerSplitArgs>(Value);
        Out.ReducerName = TEXT("player_split");
        return Out;
    }

    FORCEINLINE bool IsPlayerSplit() const { return Tag == EReducerTag::PlayerSplit; }
    FORCEINLINE FPlayerSplitArgs GetAsPlayerSplit() const
    {
        ensureMsgf(IsPlayerSplit(), TEXT("Reducer does not hold PlayerSplit!"));
        return Data.Get<FPlayerSplitArgs>();
    }

    static FReducer Respawn(const FRespawnArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::Respawn;
        Out.Data.Set<FRespawnArgs>(Value);
        Out.ReducerName = TEXT("respawn");
        return Out;
    }

    FORCEINLINE bool IsRespawn() const { return Tag == EReducerTag::Respawn; }
    FORCEINLINE FRespawnArgs GetAsRespawn() const
    {
        ensureMsgf(IsRespawn(), TEXT("Reducer does not hold Respawn!"));
        return Data.Get<FRespawnArgs>();
    }

    static FReducer SpawnFood(const FSpawnFoodArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::SpawnFood;
        Out.Data.Set<FSpawnFoodArgs>(Value);
        Out.ReducerName = TEXT("spawn_food");
        return Out;
    }

    FORCEINLINE bool IsSpawnFood() const { return Tag == EReducerTag::SpawnFood; }
    FORCEINLINE FSpawnFoodArgs GetAsSpawnFood() const
    {
        ensureMsgf(IsSpawnFood(), TEXT("Reducer does not hold SpawnFood!"));
        return Data.Get<FSpawnFoodArgs>();
    }

    static FReducer Suicide(const FSuicideArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::Suicide;
        Out.Data.Set<FSuicideArgs>(Value);
        Out.ReducerName = TEXT("suicide");
        return Out;
    }

    FORCEINLINE bool IsSuicide() const { return Tag == EReducerTag::Suicide; }
    FORCEINLINE FSuicideArgs GetAsSuicide() const
    {
        ensureMsgf(IsSuicide(), TEXT("Reducer does not hold Suicide!"));
        return Data.Get<FSuicideArgs>();
    }

    static FReducer UpdatePlayerInput(const FUpdatePlayerInputArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::UpdatePlayerInput;
        Out.Data.Set<FUpdatePlayerInputArgs>(Value);
        Out.ReducerName = TEXT("update_player_input");
        return Out;
    }

    FORCEINLINE bool IsUpdatePlayerInput() const { return Tag == EReducerTag::UpdatePlayerInput; }
    FORCEINLINE FUpdatePlayerInputArgs GetAsUpdatePlayerInput() const
    {
        ensureMsgf(IsUpdatePlayerInput(), TEXT("Reducer does not hold UpdatePlayerInput!"));
        return Data.Get<FUpdatePlayerInputArgs>();
    }

    FORCEINLINE bool operator==(const FReducer& Other) const
    {
        if (Tag != Other.Tag || ReducerId != Other.ReducerId || RequestId != Other.RequestId || ReducerName != Other.ReducerName) return false;
        switch (Tag)
        {
        case EReducerTag::CircleDecay:
            return GetAsCircleDecay() == Other.GetAsCircleDecay();
        case EReducerTag::CircleRecombine:
            return GetAsCircleRecombine() == Other.GetAsCircleRecombine();
        case EReducerTag::Connect:
            return GetAsConnect() == Other.GetAsConnect();
        case EReducerTag::ConsumeEntity:
            return GetAsConsumeEntity() == Other.GetAsConsumeEntity();
        case EReducerTag::Disconnect:
            return GetAsDisconnect() == Other.GetAsDisconnect();
        case EReducerTag::EnterGame:
            return GetAsEnterGame() == Other.GetAsEnterGame();
        case EReducerTag::MoveAllPlayers:
            return GetAsMoveAllPlayers() == Other.GetAsMoveAllPlayers();
        case EReducerTag::PlayerSplit:
            return GetAsPlayerSplit() == Other.GetAsPlayerSplit();
        case EReducerTag::Respawn:
            return GetAsRespawn() == Other.GetAsRespawn();
        case EReducerTag::SpawnFood:
            return GetAsSpawnFood() == Other.GetAsSpawnFood();
        case EReducerTag::Suicide:
            return GetAsSuicide() == Other.GetAsSuicide();
        case EReducerTag::UpdatePlayerInput:
            return GetAsUpdatePlayerInput() == Other.GetAsUpdatePlayerInput();
        default: return false;
        }
    }
    FORCEINLINE bool operator!=(const FReducer& Other) const { return !(*this == Other); }
};

UCLASS()
class CLIENT_UNREAL_API UReducerBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer CircleDecay(const FCircleDecayArgs& Value) {
        return FReducer::CircleDecay(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsCircleDecay(const FReducer& Reducer) { return Reducer.IsCircleDecay(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FCircleDecayArgs GetAsCircleDecay(const FReducer& Reducer) {
        return Reducer.GetAsCircleDecay();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer CircleRecombine(const FCircleRecombineArgs& Value) {
        return FReducer::CircleRecombine(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsCircleRecombine(const FReducer& Reducer) { return Reducer.IsCircleRecombine(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FCircleRecombineArgs GetAsCircleRecombine(const FReducer& Reducer) {
        return Reducer.GetAsCircleRecombine();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer Connect(const FConnectArgs& Value) {
        return FReducer::Connect(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsConnect(const FReducer& Reducer) { return Reducer.IsConnect(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FConnectArgs GetAsConnect(const FReducer& Reducer) {
        return Reducer.GetAsConnect();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer ConsumeEntity(const FConsumeEntityArgs& Value) {
        return FReducer::ConsumeEntity(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsConsumeEntity(const FReducer& Reducer) { return Reducer.IsConsumeEntity(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FConsumeEntityArgs GetAsConsumeEntity(const FReducer& Reducer) {
        return Reducer.GetAsConsumeEntity();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer Disconnect(const FDisconnectArgs& Value) {
        return FReducer::Disconnect(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsDisconnect(const FReducer& Reducer) { return Reducer.IsDisconnect(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FDisconnectArgs GetAsDisconnect(const FReducer& Reducer) {
        return Reducer.GetAsDisconnect();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer EnterGame(const FEnterGameArgs& Value) {
        return FReducer::EnterGame(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsEnterGame(const FReducer& Reducer) { return Reducer.IsEnterGame(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FEnterGameArgs GetAsEnterGame(const FReducer& Reducer) {
        return Reducer.GetAsEnterGame();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer MoveAllPlayers(const FMoveAllPlayersArgs& Value) {
        return FReducer::MoveAllPlayers(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsMoveAllPlayers(const FReducer& Reducer) { return Reducer.IsMoveAllPlayers(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FMoveAllPlayersArgs GetAsMoveAllPlayers(const FReducer& Reducer) {
        return Reducer.GetAsMoveAllPlayers();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer PlayerSplit(const FPlayerSplitArgs& Value) {
        return FReducer::PlayerSplit(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsPlayerSplit(const FReducer& Reducer) { return Reducer.IsPlayerSplit(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FPlayerSplitArgs GetAsPlayerSplit(const FReducer& Reducer) {
        return Reducer.GetAsPlayerSplit();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer Respawn(const FRespawnArgs& Value) {
        return FReducer::Respawn(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsRespawn(const FReducer& Reducer) { return Reducer.IsRespawn(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FRespawnArgs GetAsRespawn(const FReducer& Reducer) {
        return Reducer.GetAsRespawn();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer SpawnFood(const FSpawnFoodArgs& Value) {
        return FReducer::SpawnFood(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsSpawnFood(const FReducer& Reducer) { return Reducer.IsSpawnFood(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FSpawnFoodArgs GetAsSpawnFood(const FReducer& Reducer) {
        return Reducer.GetAsSpawnFood();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer Suicide(const FSuicideArgs& Value) {
        return FReducer::Suicide(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsSuicide(const FReducer& Reducer) { return Reducer.IsSuicide(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FSuicideArgs GetAsSuicide(const FReducer& Reducer) {
        return Reducer.GetAsSuicide();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer UpdatePlayerInput(const FUpdatePlayerInputArgs& Value) {
        return FReducer::UpdatePlayerInput(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsUpdatePlayerInput(const FReducer& Reducer) { return Reducer.IsUpdatePlayerInput(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FUpdatePlayerInputArgs GetAsUpdatePlayerInput(const FReducer& Reducer) {
        return Reducer.GetAsUpdatePlayerInput();
    }
};

/** Metadata describing a reducer run. */
USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FClientUnrealReducerEvent
{
	GENERATED_BODY()

	/** Timestamp for when the reducer executed */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimestamp Timestamp;

	/** Result status of the reducer */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBStatus Status;

	/** Identity that initiated the call */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBIdentity CallerIdentity;

	/** Connection ID for the caller */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBConnectionId CallerConnectionId;

	/** Energy consumed while executing */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FEnergyQuantaType EnergyConsumed;

	/** Detailed call information */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FReducer Reducer;

	FORCEINLINE bool operator==(const FClientUnrealReducerEvent& Other) const
	{
		return Status == Other.Status && Timestamp == Other.Timestamp && CallerIdentity == Other.CallerIdentity &&
			CallerConnectionId == Other.CallerConnectionId && EnergyConsumed == Other.EnergyConsumed &&
			Reducer == Other.Reducer;
	}

	FORCEINLINE bool operator!=(const FClientUnrealReducerEvent& Other) const
	{
		return !(*this == Other);
	}
};

/** Represents event with variant message data. */
USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FClientUnrealEvent
{
	GENERATED_BODY()

	/** Tagged union holding reducer call, unit events, or error string */
	TVariant<FReducer, FSpacetimeDBUnit, FString> MessageData;

	/** Type tag indicating what this event represents */
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	ESpacetimeDBEventTag Tag = ESpacetimeDBEventTag::UnknownTransaction;

	/** === Static factory methods ===*/
	static FClientUnrealEvent Reducer(const FReducer& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Reducer;
		Obj.MessageData.Set<FReducer>(Value);
		return Obj;
	}

	static FClientUnrealEvent SubscribeApplied(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::SubscribeApplied;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent UnsubscribeApplied(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::UnsubscribeApplied;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent Disconnected(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Disconnected;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FClientUnrealEvent SubscribeError(const FString& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::SubscribeError;
		Obj.MessageData.Set<FString>(Value);
		return Obj;
	}

	static FClientUnrealEvent UnknownTransaction(const FSpacetimeDBUnit& Value)
	{
		FClientUnrealEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::UnknownTransaction;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	FORCEINLINE bool IsReducer() const { return Tag == ESpacetimeDBEventTag::Reducer; }
	FORCEINLINE FReducer GetAsReducer() const
	{
		ensureMsgf(IsReducer(), TEXT("MessageData does not hold Reducer!"));
		return MessageData.Get<FReducer>();
	}

	FORCEINLINE bool IsSubscribeApplied() const { return Tag == ESpacetimeDBEventTag::SubscribeApplied; }
	FORCEINLINE FSpacetimeDBUnit GetAsSubscribeApplied() const
	{
		ensureMsgf(IsSubscribeApplied(), TEXT("MessageData does not hold SubscribeApplied!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsUnsubscribeApplied() const { return Tag == ESpacetimeDBEventTag::UnsubscribeApplied; }
	FORCEINLINE FSpacetimeDBUnit GetAsUnsubscribeApplied() const
	{
		ensureMsgf(IsUnsubscribeApplied(), TEXT("MessageData does not hold UnsubscribeApplied!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsDisconnected() const { return Tag == ESpacetimeDBEventTag::Disconnected; }
	FORCEINLINE FSpacetimeDBUnit GetAsDisconnected() const
	{
		ensureMsgf(IsDisconnected(), TEXT("MessageData does not hold Disconnected!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsSubscribeError() const { return Tag == ESpacetimeDBEventTag::SubscribeError; }
	FORCEINLINE FString GetAsSubscribeError() const
	{
		ensureMsgf(IsSubscribeError(), TEXT("MessageData does not hold SubscribeError!"));
		return MessageData.Get<FString>();
	}

	FORCEINLINE bool IsUnknownTransaction() const { return Tag == ESpacetimeDBEventTag::UnknownTransaction; }
	FORCEINLINE FSpacetimeDBUnit GetAsUnknownTransaction() const
	{
		ensureMsgf(IsUnknownTransaction(), TEXT("MessageData does not hold UnknownTransaction!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool operator==(const FClientUnrealEvent& Other) const
	{
		if (Tag != Other.Tag) return false;
		switch (Tag)
		{
		case ESpacetimeDBEventTag::Reducer: return GetAsReducer() == Other.GetAsReducer();
		case ESpacetimeDBEventTag::SubscribeApplied: return GetAsSubscribeApplied() == Other.GetAsSubscribeApplied();
		case ESpacetimeDBEventTag::UnsubscribeApplied: return GetAsUnsubscribeApplied() == Other.GetAsUnsubscribeApplied();
		case ESpacetimeDBEventTag::Disconnected: return GetAsDisconnected() == Other.GetAsDisconnected();
		case ESpacetimeDBEventTag::SubscribeError: return GetAsSubscribeError() == Other.GetAsSubscribeError();
		case ESpacetimeDBEventTag::UnknownTransaction: return GetAsUnknownTransaction() == Other.GetAsUnknownTransaction();
		default: return false;
		}
	}

	FORCEINLINE bool operator!=(const FClientUnrealEvent& Other) const
	{
		return !(*this == Other);
	}
};

UCLASS()
class CLIENT_UNREAL_API UClientUnrealEventBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent Reducer(const FReducer& InValue)
    {
        return FClientUnrealEvent::Reducer(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent SubscribeApplied(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::SubscribeApplied(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent UnsubscribeApplied(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::UnsubscribeApplied(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent Disconnected(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::Disconnected(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent SubscribeError(const FString& InValue)
    {
        return FClientUnrealEvent::SubscribeError(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|ClientUnrealEvent")
    static FClientUnrealEvent UnknownTransaction(const FSpacetimeDBUnit& InValue)
    {
        return FClientUnrealEvent::UnknownTransaction(InValue);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsReducer(const FClientUnrealEvent& Event) { return Event.IsReducer(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsSubscribeApplied(const FClientUnrealEvent& Event) { return Event.IsSubscribeApplied(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsUnsubscribeApplied(const FClientUnrealEvent& Event) { return Event.IsUnsubscribeApplied(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsDisconnected(const FClientUnrealEvent& Event) { return Event.IsDisconnected(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsSubscribeError(const FClientUnrealEvent& Event) { return Event.IsSubscribeError(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static bool IsUnknownTransaction(const FClientUnrealEvent& Event) { return Event.IsUnknownTransaction(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FReducer GetAsReducer(const FClientUnrealEvent& Event)
    {
        return Event.GetAsReducer();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsSubscribeApplied(const FClientUnrealEvent& Event)
    {
        return Event.GetAsSubscribeApplied();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsUnsubscribeApplied(const FClientUnrealEvent& Event)
    {
        return Event.GetAsUnsubscribeApplied();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsDisconnected(const FClientUnrealEvent& Event)
    {
        return Event.GetAsDisconnected();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FString GetAsSubscribeError(const FClientUnrealEvent& Event)
    {
        return Event.GetAsSubscribeError();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|ClientUnrealEvent")
    static FSpacetimeDBUnit GetAsUnknownTransaction(const FClientUnrealEvent& Event)
    {
        return Event.GetAsUnknownTransaction();
    }

};


USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FEventContext : public FContextBase
{
	GENERATED_BODY()

	FEventContext() = default;
	FEventContext(UDbConnection* InConn, const FClientUnrealEvent& InEvent) : FContextBase(InConn), Event(InEvent) {}

	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	FClientUnrealEvent Event;
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FReducerEventContext : public FContextBase
{
	GENERATED_BODY()

	FReducerEventContext() = default;
	FReducerEventContext(UDbConnection* InConn, FClientUnrealReducerEvent InEvent) : FContextBase(InConn), Event(InEvent) {}
	
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB") 
	FClientUnrealReducerEvent Event;
};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FErrorContext : public FContextBase
{
	GENERATED_BODY()

	FErrorContext() = default;
	FErrorContext(UDbConnection* InConn, const FString& InError) : FContextBase(InConn), Error(InError) {}

	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	FString Error;

};

USTRUCT(BlueprintType)
struct CLIENT_UNREAL_API FSubscriptionEventContext : public FContextBase
{
	GENERATED_BODY()

	FSubscriptionEventContext() = default;
	FSubscriptionEventContext(UDbConnection* InConn) : FContextBase(InConn) {}

};

DECLARE_DYNAMIC_DELEGATE_OneParam(
	FOnSubscriptionApplied,
	FSubscriptionEventContext, Context);

DECLARE_DYNAMIC_DELEGATE_OneParam(
	FOnSubscriptionError,
	FErrorContext, Context);

UCLASS(BlueprintType)
class CLIENT_UNREAL_API USetReducerFlags : public USetReducerFlagsBase
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void CircleDecay(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void CircleRecombine(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void Connect(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void ConsumeEntity(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void Disconnect(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void EnterGame(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void MoveAllPlayers(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void PlayerSplit(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void Respawn(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void SpawnFood(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void Suicide(ECallReducerFlags Flag);
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void UpdatePlayerInput(ECallReducerFlags Flag);

};

// RemoteTables class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API URemoteTables : public UObject
{
    GENERATED_BODY()

public:
    void Initialize();

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UEntityTable* LoggedOutEntity;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UMoveAllPlayersTimerTable* MoveAllPlayersTimer;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UCircleDecayTimerTable* CircleDecayTimer;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UEntityTable* Entity;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UFoodTable* Food;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UCircleRecombineTimerTable* CircleRecombineTimer;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UConfigTable* Config;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UPlayerTable* LoggedOutPlayer;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UCircleTable* LoggedOutCircle;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UPlayerTable* Player;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UConsumeEntityTimerTable* ConsumeEntityTimer;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    USpawnFoodTimerTable* SpawnFoodTimer;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UCircleTable* Circle;

};

// RemoteReducers class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API URemoteReducers : public UObject
{
    GENERATED_BODY()

public:

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FCircleDecayHandler,
        const FReducerEventContext&, Context,
        const FCircleDecayTimerType&, Timer
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FCircleDecayHandler OnCircleDecay;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void CircleDecay(const FCircleDecayTimerType& Timer);

    bool InvokeCircleDecay(const FReducerEventContext& Context, const UCircleDecayReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FCircleRecombineHandler,
        const FReducerEventContext&, Context,
        const FCircleRecombineTimerType&, Timer
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FCircleRecombineHandler OnCircleRecombine;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void CircleRecombine(const FCircleRecombineTimerType& Timer);

    bool InvokeCircleRecombine(const FReducerEventContext& Context, const UCircleRecombineReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FConnectHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FConnectHandler OnConnect;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void Connect();

    bool InvokeConnect(const FReducerEventContext& Context, const UConnectReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FConsumeEntityHandler,
        const FReducerEventContext&, Context,
        const FConsumeEntityTimerType&, Request
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FConsumeEntityHandler OnConsumeEntity;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void ConsumeEntity(const FConsumeEntityTimerType& Request);

    bool InvokeConsumeEntity(const FReducerEventContext& Context, const UConsumeEntityReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FDisconnectHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FDisconnectHandler OnDisconnect;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void Disconnect();

    bool InvokeDisconnect(const FReducerEventContext& Context, const UDisconnectReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FEnterGameHandler,
        const FReducerEventContext&, Context,
        const FString&, Name
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FEnterGameHandler OnEnterGame;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void EnterGame(const FString& Name);

    bool InvokeEnterGame(const FReducerEventContext& Context, const UEnterGameReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FMoveAllPlayersHandler,
        const FReducerEventContext&, Context,
        const FMoveAllPlayersTimerType&, Timer
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FMoveAllPlayersHandler OnMoveAllPlayers;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void MoveAllPlayers(const FMoveAllPlayersTimerType& Timer);

    bool InvokeMoveAllPlayers(const FReducerEventContext& Context, const UMoveAllPlayersReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FPlayerSplitHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FPlayerSplitHandler OnPlayerSplit;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void PlayerSplit();

    bool InvokePlayerSplit(const FReducerEventContext& Context, const UPlayerSplitReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FRespawnHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FRespawnHandler OnRespawn;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void Respawn();

    bool InvokeRespawn(const FReducerEventContext& Context, const URespawnReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FSpawnFoodHandler,
        const FReducerEventContext&, Context,
        const FSpawnFoodTimerType&, Timer
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FSpawnFoodHandler OnSpawnFood;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void SpawnFood(const FSpawnFoodTimerType& Timer);

    bool InvokeSpawnFood(const FReducerEventContext& Context, const USpawnFoodReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FSuicideHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FSuicideHandler OnSuicide;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void Suicide();

    bool InvokeSuicide(const FReducerEventContext& Context, const USuicideReducer* Args);

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(
        FUpdatePlayerInputHandler,
        const FReducerEventContext&, Context,
        const FDbVector2Type&, Direction
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FUpdatePlayerInputHandler OnUpdatePlayerInput;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void UpdatePlayerInput(const FDbVector2Type& Direction);

    bool InvokeUpdatePlayerInput(const FReducerEventContext& Context, const UUpdatePlayerInputReducer* Args);

    // Internal error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FInternalOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);
    FInternalOnUnhandledReducerError InternalOnUnhandledReducerError;

private:

    friend UDbConnection;

    UPROPERTY()
    class UDbConnection* Conn;

    UPROPERTY()
    USetReducerFlags* SetCallReducerFlags;
};

// SubscriptionBuilder class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API USubscriptionBuilder : public USubscriptionBuilderBase
{
    GENERATED_BODY()

public:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionBuilder* OnApplied(FOnSubscriptionApplied Callback);

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionBuilder* OnError(FOnSubscriptionError Callback);

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    USubscriptionHandle* Subscribe(const TArray<FString>& SQL);

    /** Convenience for subscribing to all rows from all tables */
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionHandle* SubscribeToAllTables();


    friend class UDbConnection;
    friend class UDbConnectionBase;

protected:
    UPROPERTY()
    class UDbConnection* Conn;

    // Delegates stored so Subscribe() can bind forwarding callbacks
    FOnSubscriptionApplied OnAppliedDelegateInternal;
    FOnSubscriptionError OnErrorDelegateInternal;
};

// SubscriptionHandle class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API USubscriptionHandle : public USubscriptionHandleBase
{
    GENERATED_BODY()

public:

    USubscriptionHandle() {};

    explicit USubscriptionHandle(UDbConnection* InConn);

    friend class USubscriptionBuilder;

private:
    UPROPERTY()
    class UDbConnection* Conn;

    // Delegates that expose subscription events with connection aware contexts
    FOnSubscriptionApplied OnAppliedDelegate;
    FOnSubscriptionError OnErrorDelegate;

    UFUNCTION()
    void ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx);

    UFUNCTION()
    void ForwardOnError(const FErrorContextBase& BaseCtx);
};

/*
    @Note: Child class of UDbConnectionBuilderBase.
*/
UCLASS(BlueprintType)
class CLIENT_UNREAL_API UDbConnectionBuilder : public UDbConnectionBuilderBase
{
    GENERATED_BODY()
public:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithUri(const FString& InUri);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithModuleName(const FString& InName);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithToken(const FString& InToken);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithCompression(const ESpacetimeDBCompression& InCompression);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnConnect(FOnConnectDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnConnectError(FOnConnectErrorDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnDisconnect(FOnDisconnectDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnection* Build();

private:

    // Stored delegates which will be forwarded when the connection events occur.
    FOnConnectDelegate OnConnectDelegateInternal;
    FOnDisconnectDelegate OnDisconnectDelegateInternal;
};

// Main DbConnection class
UCLASS(BlueprintType)
class CLIENT_UNREAL_API UDbConnection : public UDbConnectionBase
{
    GENERATED_BODY()

public:
    explicit UDbConnection(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());


    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteTables* Db;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteReducers* Reducers;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    USetReducerFlags* SetReducerFlags;

    // Delegates that allow users to bind with the concrete connection type.
    FOnConnectDelegate OnConnectDelegate;
    FOnDisconnectDelegate OnDisconnectDelegate;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    USubscriptionBuilder* SubscriptionBuilder();

    /** Static entry point for constructing a connection. */
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB", DisplayName = "SpacetimeDB Builder")
    static UDbConnectionBuilder* Builder();

    // Error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FOnUnhandledReducerError OnUnhandledReducerError;


protected:

    // Hook up error handling to reducers
    virtual void PostInitProperties() override;

    UFUNCTION()
    void ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken);
    UFUNCTION()
    void ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error);

    UFUNCTION()
    void OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error);

    // Override the DbConnectionBase methods to handle updates and events
    virtual void DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event) override;
    
    // Override the reducer event handler to dispatch events to the appropriate reducers
    virtual void ReducerEvent(const FReducerEvent& Event) override;
    
    // Override the reducer event failed handler
    virtual void ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage) override;
};

