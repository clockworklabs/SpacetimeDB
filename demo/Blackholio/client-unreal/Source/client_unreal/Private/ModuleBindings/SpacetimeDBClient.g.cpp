// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#include "ModuleBindings/SpacetimeDBClient.g.h"
#include "DBCache/WithBsatn.h"
#include "BSATN/UEBSATNHelpers.h"
#include "ModuleBindings/Tables/ConsumeEntityTimerTable.g.h"
#include "ModuleBindings/Tables/CircleTable.g.h"
#include "ModuleBindings/Tables/FoodTable.g.h"
#include "ModuleBindings/Tables/CircleTable.g.h"
#include "ModuleBindings/Tables/SpawnFoodTimerTable.g.h"
#include "ModuleBindings/Tables/ConfigTable.g.h"
#include "ModuleBindings/Tables/PlayerTable.g.h"
#include "ModuleBindings/Tables/EntityTable.g.h"
#include "ModuleBindings/Tables/PlayerTable.g.h"
#include "ModuleBindings/Tables/CircleDecayTimerTable.g.h"
#include "ModuleBindings/Tables/CircleRecombineTimerTable.g.h"
#include "ModuleBindings/Tables/EntityTable.g.h"
#include "ModuleBindings/Tables/MoveAllPlayersTimerTable.g.h"

static FReducer DecodeReducer(const FReducerEvent& Event)
{
    const FString& ReducerName = Event.ReducerCall.ReducerName;

    if (ReducerName == TEXT("circle_decay"))
    {
        FCircleDecayArgs Args = UE::SpacetimeDB::Deserialize<FCircleDecayArgs>(Event.ReducerCall.Args);
        return FReducer::CircleDecay(Args);
    }

    if (ReducerName == TEXT("circle_recombine"))
    {
        FCircleRecombineArgs Args = UE::SpacetimeDB::Deserialize<FCircleRecombineArgs>(Event.ReducerCall.Args);
        return FReducer::CircleRecombine(Args);
    }

    if (ReducerName == TEXT("connect"))
    {
        FConnectArgs Args = UE::SpacetimeDB::Deserialize<FConnectArgs>(Event.ReducerCall.Args);
        return FReducer::Connect(Args);
    }

    if (ReducerName == TEXT("consume_entity"))
    {
        FConsumeEntityArgs Args = UE::SpacetimeDB::Deserialize<FConsumeEntityArgs>(Event.ReducerCall.Args);
        return FReducer::ConsumeEntity(Args);
    }

    if (ReducerName == TEXT("disconnect"))
    {
        FDisconnectArgs Args = UE::SpacetimeDB::Deserialize<FDisconnectArgs>(Event.ReducerCall.Args);
        return FReducer::Disconnect(Args);
    }

    if (ReducerName == TEXT("enter_game"))
    {
        FEnterGameArgs Args = UE::SpacetimeDB::Deserialize<FEnterGameArgs>(Event.ReducerCall.Args);
        return FReducer::EnterGame(Args);
    }

    if (ReducerName == TEXT("move_all_players"))
    {
        FMoveAllPlayersArgs Args = UE::SpacetimeDB::Deserialize<FMoveAllPlayersArgs>(Event.ReducerCall.Args);
        return FReducer::MoveAllPlayers(Args);
    }

    if (ReducerName == TEXT("player_split"))
    {
        FPlayerSplitArgs Args = UE::SpacetimeDB::Deserialize<FPlayerSplitArgs>(Event.ReducerCall.Args);
        return FReducer::PlayerSplit(Args);
    }

    if (ReducerName == TEXT("respawn"))
    {
        FRespawnArgs Args = UE::SpacetimeDB::Deserialize<FRespawnArgs>(Event.ReducerCall.Args);
        return FReducer::Respawn(Args);
    }

    if (ReducerName == TEXT("spawn_food"))
    {
        FSpawnFoodArgs Args = UE::SpacetimeDB::Deserialize<FSpawnFoodArgs>(Event.ReducerCall.Args);
        return FReducer::SpawnFood(Args);
    }

    if (ReducerName == TEXT("suicide"))
    {
        FSuicideArgs Args = UE::SpacetimeDB::Deserialize<FSuicideArgs>(Event.ReducerCall.Args);
        return FReducer::Suicide(Args);
    }

    if (ReducerName == TEXT("update_player_input"))
    {
        FUpdatePlayerInputArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePlayerInputArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePlayerInput(Args);
    }

    return FReducer();
}

UDbConnection::UDbConnection(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	SetReducerFlags = ObjectInitializer.CreateDefaultSubobject<USetReducerFlags>(this, TEXT("SetReducerFlags"));

	Db = ObjectInitializer.CreateDefaultSubobject<URemoteTables>(this, TEXT("RemoteTables"));
	Db->Initialize();
	
	Reducers = ObjectInitializer.CreateDefaultSubobject<URemoteReducers>(this, TEXT("RemoteReducers"));
	Reducers->SetCallReducerFlags = SetReducerFlags;
	Reducers->Conn = this;

	RegisterTable<FConsumeEntityTimerType, UConsumeEntityTimerTable, FEventContext>(TEXT("consume_entity_timer"), Db->ConsumeEntityTimer);
	RegisterTable<FCircleType, UCircleTable, FEventContext>(TEXT("circle"), Db->Circle);
	RegisterTable<FFoodType, UFoodTable, FEventContext>(TEXT("food"), Db->Food);
	RegisterTable<FCircleType, UCircleTable, FEventContext>(TEXT("logged_out_circle"), Db->LoggedOutCircle);
	RegisterTable<FSpawnFoodTimerType, USpawnFoodTimerTable, FEventContext>(TEXT("spawn_food_timer"), Db->SpawnFoodTimer);
	RegisterTable<FConfigType, UConfigTable, FEventContext>(TEXT("config"), Db->Config);
	RegisterTable<FPlayerType, UPlayerTable, FEventContext>(TEXT("player"), Db->Player);
	RegisterTable<FEntityType, UEntityTable, FEventContext>(TEXT("logged_out_entity"), Db->LoggedOutEntity);
	RegisterTable<FPlayerType, UPlayerTable, FEventContext>(TEXT("logged_out_player"), Db->LoggedOutPlayer);
	RegisterTable<FCircleDecayTimerType, UCircleDecayTimerTable, FEventContext>(TEXT("circle_decay_timer"), Db->CircleDecayTimer);
	RegisterTable<FCircleRecombineTimerType, UCircleRecombineTimerTable, FEventContext>(TEXT("circle_recombine_timer"), Db->CircleRecombineTimer);
	RegisterTable<FEntityType, UEntityTable, FEventContext>(TEXT("entity"), Db->Entity);
	RegisterTable<FMoveAllPlayersTimerType, UMoveAllPlayersTimerTable, FEventContext>(TEXT("move_all_players_timer"), Db->MoveAllPlayersTimer);
}

FContextBase::FContextBase(UDbConnection* InConn)
{
	Db = InConn->Db;
	Reducers = InConn->Reducers;
	SetReducerFlags = InConn->SetReducerFlags;
	Conn = InConn;
}
bool FContextBase::IsActive() const
{
	return Conn->IsActive();
}
void FContextBase::Disconnect()
{
	Conn->Disconnect();
}
USubscriptionBuilder* FContextBase::SubscriptionBuilder()
{
	return Conn->SubscriptionBuilder();
}
bool FContextBase::TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const
{
	return Conn->TryGetIdentity(OutIdentity);
}
FSpacetimeDBConnectionId FContextBase::GetConnectionId() const
{
	return Conn->GetConnectionId();
}

void URemoteTables::Initialize()
{

	/** Creating tables */
	ConsumeEntityTimer = NewObject<UConsumeEntityTimerTable>(this);
	Circle = NewObject<UCircleTable>(this);
	Food = NewObject<UFoodTable>(this);
	LoggedOutCircle = NewObject<UCircleTable>(this);
	SpawnFoodTimer = NewObject<USpawnFoodTimerTable>(this);
	Config = NewObject<UConfigTable>(this);
	Player = NewObject<UPlayerTable>(this);
	LoggedOutEntity = NewObject<UEntityTable>(this);
	LoggedOutPlayer = NewObject<UPlayerTable>(this);
	CircleDecayTimer = NewObject<UCircleDecayTimerTable>(this);
	CircleRecombineTimer = NewObject<UCircleRecombineTimerTable>(this);
	Entity = NewObject<UEntityTable>(this);
	MoveAllPlayersTimer = NewObject<UMoveAllPlayersTimerTable>(this);
	/**/

	/** Initialization */
	ConsumeEntityTimer->PostInitialize();
	Circle->PostInitialize();
	Food->PostInitialize();
	LoggedOutCircle->PostInitialize();
	SpawnFoodTimer->PostInitialize();
	Config->PostInitialize();
	Player->PostInitialize();
	LoggedOutEntity->PostInitialize();
	LoggedOutPlayer->PostInitialize();
	CircleDecayTimer->PostInitialize();
	CircleRecombineTimer->PostInitialize();
	Entity->PostInitialize();
	MoveAllPlayersTimer->PostInitialize();
	/**/
}

void USetReducerFlags::CircleDecay(ECallReducerFlags Flag)
{
	FlagMap.Add("CircleDecay", Flag);
}
void USetReducerFlags::CircleRecombine(ECallReducerFlags Flag)
{
	FlagMap.Add("CircleRecombine", Flag);
}
void USetReducerFlags::Connect(ECallReducerFlags Flag)
{
	FlagMap.Add("Connect", Flag);
}
void USetReducerFlags::ConsumeEntity(ECallReducerFlags Flag)
{
	FlagMap.Add("ConsumeEntity", Flag);
}
void USetReducerFlags::Disconnect(ECallReducerFlags Flag)
{
	FlagMap.Add("Disconnect", Flag);
}
void USetReducerFlags::EnterGame(ECallReducerFlags Flag)
{
	FlagMap.Add("EnterGame", Flag);
}
void USetReducerFlags::MoveAllPlayers(ECallReducerFlags Flag)
{
	FlagMap.Add("MoveAllPlayers", Flag);
}
void USetReducerFlags::PlayerSplit(ECallReducerFlags Flag)
{
	FlagMap.Add("PlayerSplit", Flag);
}
void USetReducerFlags::Respawn(ECallReducerFlags Flag)
{
	FlagMap.Add("Respawn", Flag);
}
void USetReducerFlags::SpawnFood(ECallReducerFlags Flag)
{
	FlagMap.Add("SpawnFood", Flag);
}
void USetReducerFlags::Suicide(ECallReducerFlags Flag)
{
	FlagMap.Add("Suicide", Flag);
}
void USetReducerFlags::UpdatePlayerInput(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePlayerInput", Flag);
}

void URemoteReducers::CircleDecay(const FCircleDecayTimerType& Timer)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("circle_decay"), FCircleDecayArgs(Timer), SetCallReducerFlags);
}

bool URemoteReducers::InvokeCircleDecay(const FReducerEventContext& Context, const UCircleDecayReducer* Args)
{
    if (!OnCircleDecay.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for CircleDecay"));
        }
        return false;
    }

    OnCircleDecay.Broadcast(Context, Args->Timer);
    return true;
}

void URemoteReducers::CircleRecombine(const FCircleRecombineTimerType& Timer)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("circle_recombine"), FCircleRecombineArgs(Timer), SetCallReducerFlags);
}

bool URemoteReducers::InvokeCircleRecombine(const FReducerEventContext& Context, const UCircleRecombineReducer* Args)
{
    if (!OnCircleRecombine.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for CircleRecombine"));
        }
        return false;
    }

    OnCircleRecombine.Broadcast(Context, Args->Timer);
    return true;
}

void URemoteReducers::Connect()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("connect"), FConnectArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeConnect(const FReducerEventContext& Context, const UConnectReducer* Args)
{
    if (!OnConnect.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for Connect"));
        }
        return false;
    }

    OnConnect.Broadcast(Context);
    return true;
}

void URemoteReducers::ConsumeEntity(const FConsumeEntityTimerType& Request)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("consume_entity"), FConsumeEntityArgs(Request), SetCallReducerFlags);
}

bool URemoteReducers::InvokeConsumeEntity(const FReducerEventContext& Context, const UConsumeEntityReducer* Args)
{
    if (!OnConsumeEntity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for ConsumeEntity"));
        }
        return false;
    }

    OnConsumeEntity.Broadcast(Context, Args->Request);
    return true;
}

void URemoteReducers::Disconnect()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("disconnect"), FDisconnectArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDisconnect(const FReducerEventContext& Context, const UDisconnectReducer* Args)
{
    if (!OnDisconnect.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for Disconnect"));
        }
        return false;
    }

    OnDisconnect.Broadcast(Context);
    return true;
}

void URemoteReducers::EnterGame(const FString& Name)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("enter_game"), FEnterGameArgs(Name), SetCallReducerFlags);
}

bool URemoteReducers::InvokeEnterGame(const FReducerEventContext& Context, const UEnterGameReducer* Args)
{
    if (!OnEnterGame.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for EnterGame"));
        }
        return false;
    }

    OnEnterGame.Broadcast(Context, Args->Name);
    return true;
}

void URemoteReducers::MoveAllPlayers(const FMoveAllPlayersTimerType& Timer)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("move_all_players"), FMoveAllPlayersArgs(Timer), SetCallReducerFlags);
}

bool URemoteReducers::InvokeMoveAllPlayers(const FReducerEventContext& Context, const UMoveAllPlayersReducer* Args)
{
    if (!OnMoveAllPlayers.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for MoveAllPlayers"));
        }
        return false;
    }

    OnMoveAllPlayers.Broadcast(Context, Args->Timer);
    return true;
}

void URemoteReducers::PlayerSplit()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("player_split"), FPlayerSplitArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokePlayerSplit(const FReducerEventContext& Context, const UPlayerSplitReducer* Args)
{
    if (!OnPlayerSplit.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for PlayerSplit"));
        }
        return false;
    }

    OnPlayerSplit.Broadcast(Context);
    return true;
}

void URemoteReducers::Respawn()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("respawn"), FRespawnArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeRespawn(const FReducerEventContext& Context, const URespawnReducer* Args)
{
    if (!OnRespawn.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for Respawn"));
        }
        return false;
    }

    OnRespawn.Broadcast(Context);
    return true;
}

void URemoteReducers::SpawnFood(const FSpawnFoodTimerType& Timer)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("spawn_food"), FSpawnFoodArgs(Timer), SetCallReducerFlags);
}

bool URemoteReducers::InvokeSpawnFood(const FReducerEventContext& Context, const USpawnFoodReducer* Args)
{
    if (!OnSpawnFood.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for SpawnFood"));
        }
        return false;
    }

    OnSpawnFood.Broadcast(Context, Args->Timer);
    return true;
}

void URemoteReducers::Suicide()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("suicide"), FSuicideArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeSuicide(const FReducerEventContext& Context, const USuicideReducer* Args)
{
    if (!OnSuicide.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for Suicide"));
        }
        return false;
    }

    OnSuicide.Broadcast(Context);
    return true;
}

void URemoteReducers::UpdatePlayerInput(const FDbVector2Type& Direction)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_player_input"), FUpdatePlayerInputArgs(Direction), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePlayerInput(const FReducerEventContext& Context, const UUpdatePlayerInputReducer* Args)
{
    if (!OnUpdatePlayerInput.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePlayerInput"));
        }
        return false;
    }

    OnUpdatePlayerInput.Broadcast(Context, Args->Direction);
    return true;
}

void UDbConnection::PostInitProperties()
{
    Super::PostInitProperties();
    
    // Connect OnUnhandledReducerError to Reducers.InternalOnUnhandledReducerError
    if (Reducers)
    {
        Reducers->InternalOnUnhandledReducerError.AddDynamic(this, &UDbConnection::OnUnhandledReducerErrorHandler);
    }
}

UFUNCTION()
void UDbConnection::OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error)
{
    if (OnUnhandledReducerError.IsBound())
    {
        OnUnhandledReducerError.Broadcast(Context, Error);
    }
}

void UDbConnection::ReducerEvent(const FReducerEvent& Event)
{
    if (!Reducers) { return; }

    FReducer DecodedReducer = DecodeReducer(Event);

    FClientUnrealReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;
    ReducerEvent.Reducer            = DecodedReducer;

    FReducerEventContext Context(this, ReducerEvent);

    // Use hardcoded string matching for reducer dispatching
    const FString& ReducerName = Event.ReducerCall.ReducerName;

    if (ReducerName == TEXT("circle_decay"))
    {
        FCircleDecayArgs Args = ReducerEvent.Reducer.GetAsCircleDecay();
        UCircleDecayReducer* Reducer = NewObject<UCircleDecayReducer>();
        Reducer->Timer = Args.Timer;
        Reducers->InvokeCircleDecay(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("circle_recombine"))
    {
        FCircleRecombineArgs Args = ReducerEvent.Reducer.GetAsCircleRecombine();
        UCircleRecombineReducer* Reducer = NewObject<UCircleRecombineReducer>();
        Reducer->Timer = Args.Timer;
        Reducers->InvokeCircleRecombine(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("connect"))
    {
        FConnectArgs Args = ReducerEvent.Reducer.GetAsConnect();
        UConnectReducer* Reducer = NewObject<UConnectReducer>();
        Reducers->InvokeConnect(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("consume_entity"))
    {
        FConsumeEntityArgs Args = ReducerEvent.Reducer.GetAsConsumeEntity();
        UConsumeEntityReducer* Reducer = NewObject<UConsumeEntityReducer>();
        Reducer->Request = Args.Request;
        Reducers->InvokeConsumeEntity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("disconnect"))
    {
        FDisconnectArgs Args = ReducerEvent.Reducer.GetAsDisconnect();
        UDisconnectReducer* Reducer = NewObject<UDisconnectReducer>();
        Reducers->InvokeDisconnect(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("enter_game"))
    {
        FEnterGameArgs Args = ReducerEvent.Reducer.GetAsEnterGame();
        UEnterGameReducer* Reducer = NewObject<UEnterGameReducer>();
        Reducer->Name = Args.Name;
        Reducers->InvokeEnterGame(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("move_all_players"))
    {
        FMoveAllPlayersArgs Args = ReducerEvent.Reducer.GetAsMoveAllPlayers();
        UMoveAllPlayersReducer* Reducer = NewObject<UMoveAllPlayersReducer>();
        Reducer->Timer = Args.Timer;
        Reducers->InvokeMoveAllPlayers(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("player_split"))
    {
        FPlayerSplitArgs Args = ReducerEvent.Reducer.GetAsPlayerSplit();
        UPlayerSplitReducer* Reducer = NewObject<UPlayerSplitReducer>();
        Reducers->InvokePlayerSplit(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("respawn"))
    {
        FRespawnArgs Args = ReducerEvent.Reducer.GetAsRespawn();
        URespawnReducer* Reducer = NewObject<URespawnReducer>();
        Reducers->InvokeRespawn(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("spawn_food"))
    {
        FSpawnFoodArgs Args = ReducerEvent.Reducer.GetAsSpawnFood();
        USpawnFoodReducer* Reducer = NewObject<USpawnFoodReducer>();
        Reducer->Timer = Args.Timer;
        Reducers->InvokeSpawnFood(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("suicide"))
    {
        FSuicideArgs Args = ReducerEvent.Reducer.GetAsSuicide();
        USuicideReducer* Reducer = NewObject<USuicideReducer>();
        Reducers->InvokeSuicide(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_player_input"))
    {
        FUpdatePlayerInputArgs Args = ReducerEvent.Reducer.GetAsUpdatePlayerInput();
        UUpdatePlayerInputReducer* Reducer = NewObject<UUpdatePlayerInputReducer>();
        Reducer->Direction = Args.Direction;
        Reducers->InvokeUpdatePlayerInput(Context, Reducer);
        return;
    }

    UE_LOG(LogTemp, Warning, TEXT("Unknown reducer: %s"), *ReducerName);
}

void UDbConnection::ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage)
{
    if (!Reducers) { return; }

    FClientUnrealReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;

    FReducerEventContext Context(this, ReducerEvent);

    if (Reducers->InternalOnUnhandledReducerError.IsBound())
    {
        Reducers->InternalOnUnhandledReducerError.Broadcast(Context, ErrorMessage);
    }
}

UDbConnectionBuilder* UDbConnection::Builder()
{
	return NewObject<UDbConnectionBuilder>();
}
// Added for creating subscriptions
USubscriptionBuilder* UDbConnection::SubscriptionBuilder()
{
	USubscriptionBuilder* Builder = NewObject<USubscriptionBuilder>(this);
	Builder->Conn = this;
	return Builder;
}
USubscriptionBuilder* USubscriptionBuilder::OnApplied(FOnSubscriptionApplied Callback)
{
	OnAppliedDelegateInternal = Callback;
	return this;
}
USubscriptionBuilder* USubscriptionBuilder::OnError(FOnSubscriptionError Callback)
{
	OnErrorDelegateInternal = Callback;
	return this;
}
USubscriptionHandle* USubscriptionBuilder::Subscribe(const TArray<FString>& SQL)
{
	USubscriptionHandle* Handle = NewObject<USubscriptionHandle>();

	// Store user callbacks on the handle
	Handle->Conn = Conn;
	Handle->OnAppliedDelegate = OnAppliedDelegateInternal;
	Handle->OnErrorDelegate = OnErrorDelegateInternal;

	// Bind forwarding functions that will convert base contexts
	FSubscriptionEventDelegate BaseApplied;
	BaseApplied.BindUFunction(Handle, TEXT("ForwardOnApplied"));
	OnAppliedBase(BaseApplied);

	FSubscriptionErrorDelegate BaseError;
	BaseError.BindUFunction(Handle, TEXT("ForwardOnError"));
	OnErrorBase(BaseError);

	SubscribeBase(SQL, Handle);
	if (Conn)
	{
		Conn->StartSubscription(Handle);
	}
	return Handle;
}
USubscriptionHandle* USubscriptionBuilder::SubscribeToAllTables()
{
	return Subscribe({ "SELECT * FROM * " });
}

USubscriptionHandle::USubscriptionHandle(UDbConnection* InConn)
{
	Conn = InConn;
}

void USubscriptionHandle::ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx)
{
	if (OnAppliedDelegate.IsBound())
	{
		FSubscriptionEventContext Ctx(Conn);
		OnAppliedDelegate.Execute(Ctx);
	}
}

void USubscriptionHandle::ForwardOnError(const FErrorContextBase& BaseCtx)
{
	if (OnErrorDelegate.IsBound())
	{
		FErrorContext Ctx(Conn, BaseCtx.Error);
		OnErrorDelegate.Execute(Ctx);
	}
}


// Cast from parent to child class
UDbConnectionBuilder* UDbConnectionBuilder::WithUri(const FString& InUri)
{
	return Cast<UDbConnectionBuilder>(WithUriBase(InUri));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithModuleName(const FString& InName)
{
	return Cast<UDbConnectionBuilder>(WithModuleNameBase(InName));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithToken(const FString& InToken)
{
	return Cast<UDbConnectionBuilder>(WithTokenBase(InToken));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithCompression(const ESpacetimeDBCompression& InCompression)
{
	return Cast<UDbConnectionBuilder>(WithCompressionBase(InCompression));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnect(FOnConnectDelegate Callback)
{
	OnConnectDelegateInternal = Callback;
	return this;
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnectError(FOnConnectErrorDelegate Callback)
{
	return Cast<UDbConnectionBuilder>(OnConnectErrorBase(Callback));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnDisconnect(FOnDisconnectDelegate Callback)
{
	OnDisconnectDelegateInternal = Callback;
	return this;
}
UDbConnection* UDbConnectionBuilder::Build()
{
	UDbConnection* Connection = NewObject<UDbConnection>();

	// Store delegates on the connection for later use
	Connection->OnConnectDelegate = OnConnectDelegateInternal;
	Connection->OnDisconnectDelegate = OnDisconnectDelegateInternal;

	// Wrap delegates so the base builder can bind them
	FOnConnectBaseDelegate BaseConnect;
	BaseConnect.BindUFunction(Connection, TEXT("ForwardOnConnect"));
	Connection->SetOnConnectDelegate(BaseConnect);
	OnConnectBase(BaseConnect);

	FOnDisconnectBaseDelegate BaseDisconnect;
	BaseDisconnect.BindUFunction(Connection, TEXT("ForwardOnDisconnect"));
	Connection->SetOnDisconnectDelegate(BaseDisconnect);
	OnDisconnectBase(BaseDisconnect);

	return Cast<UDbConnection>(BuildConnection(Connection));
}
void UDbConnection::ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken)
{
	if (OnConnectDelegate.IsBound())
	{
		OnConnectDelegate.Execute(this, Identity, Token);
	}
}
void UDbConnection::ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error)
{
	if (OnDisconnectDelegate.IsBound())
	{
		OnDisconnectDelegate.Execute(this, Error);
	}
}


void UDbConnection::DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event)
{
    FClientUnrealEvent BaseEvent;
    BaseEvent.Tag = Event.Tag;

    switch (Event.Tag)
    {
    case ESpacetimeDBEventTag::Reducer:
    {
        FReducerEvent ReducerEvent = Event.GetAsReducer();
        FReducer Reducer = DecodeReducer(ReducerEvent);
        BaseEvent = FClientUnrealEvent::Reducer(Reducer);
        break;
    }

    case ESpacetimeDBEventTag::SubscribeApplied:
        BaseEvent = FClientUnrealEvent::SubscribeApplied(Event.GetAsSubscribeApplied());
        break;

    case ESpacetimeDBEventTag::UnsubscribeApplied:
        BaseEvent = FClientUnrealEvent::UnsubscribeApplied(Event.GetAsUnsubscribeApplied());
        break;

    case ESpacetimeDBEventTag::Disconnected:
        BaseEvent = FClientUnrealEvent::Disconnected(Event.GetAsDisconnected());
        break;

    case ESpacetimeDBEventTag::SubscribeError:
        BaseEvent = FClientUnrealEvent::SubscribeError(Event.GetAsSubscribeError());
        break;

    case ESpacetimeDBEventTag::UnknownTransaction:
        BaseEvent = FClientUnrealEvent::UnknownTransaction(Event.GetAsUnknownTransaction());
        break;

    default:
        break;
    }

    FEventContext Context(this, BaseEvent);
    // Populate typed reducer args for convenience in table handlers

    ApplyRegisteredTableUpdates(Update, &Context);
}

