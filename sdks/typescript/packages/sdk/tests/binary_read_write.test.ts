import { describe, expect, test } from 'vitest';
import BinaryReader from '../src/binary_reader';
import BinaryWriter from '../src/binary_writer';

/*
// Generated by the following Rust code:

#[cfg(test)]
mod tests {
    use rand::{thread_rng, Rng};
    use spacetimedb_sats::{bsatn, i256, u256};

    #[test]
    fn make_some_numbers() {
        let mut rng = thread_rng();
        let v_u8: u8 = rng.gen();
        let v_u16: u16 = rng.gen();
        let v_u32: u32 = rng.gen();
        let v_u64: u64 = rng.gen();
        let v_u128: u128 = rng.gen();
        let v_u256: u256 = u256::from_words(rng.gen(), rng.gen());
        let v_i8: i8 = rng.gen();
        let v_i16: i16 = rng.gen();
        let v_i32: i32 = rng.gen();
        let v_i64: i64 = rng.gen();
        let v_i128: i128 = rng.gen();
        let v_i256: i256 = i256::from_words(rng.gen(), rng.gen());

        println!("['I8', {}, {:?}],", v_i8, bsatn::to_vec(&v_i8).unwrap());
        println!("['I16', {}, {:?}],", v_i16, bsatn::to_vec(&v_i16).unwrap());
        println!("['I32', {}, {:?}],", v_i32, bsatn::to_vec(&v_i32).unwrap());
        println!("['I64', BigInt('{}'), {:?}],", v_i64, bsatn::to_vec(&v_i64).unwrap());
        println!("['I128', BigInt('{}'), {:?}],", v_i128, bsatn::to_vec(&v_i128).unwrap());
        println!("['I256', BigInt('{}'), {:?}],", v_i256, bsatn::to_vec(&v_i256).unwrap());

        println!("['U8', {}, {:?}],", v_u8, bsatn::to_vec(&v_u8).unwrap());
        println!("['U16', {}, {:?}],", v_u16, bsatn::to_vec(&v_u16).unwrap());
        println!("['U32', {}, {:?}],", v_u32, bsatn::to_vec(&v_u32).unwrap());
        println!("['U64', BigInt('{}'), {:?}],", v_u64, bsatn::to_vec(&v_u64).unwrap());
        println!("['U128', BigInt('{}'), {:?}],", v_u128, bsatn::to_vec(&v_u128).unwrap());
        println!("['U256', BigInt('{}'), {:?}],", v_u256, bsatn::to_vec(&v_u256).unwrap());
        panic!();
    }
}
*/

let testCases: Array<[string, BigInt | number, Array<number>]> = [
  ['I8', 48, [48]],
  ['I16', 2910, [94, 11]],
  ['I32', -799760706, [190, 158, 84, 208]],
  [
    'I64',
    BigInt('-1541553498090056195'),
    [253, 213, 20, 208, 66, 77, 155, 234],
  ],
  [
    'I128',
    BigInt('12547586996680216771838914786222604020'),
    [244, 254, 202, 102, 17, 36, 114, 210, 182, 88, 120, 98, 205, 147, 112, 9],
  ],
  [
    'I256',
    BigInt(
      '35334490670013506332541201493144667192747188790291257662501378603950330458369'
    ),
    [
      1, 177, 117, 147, 65, 153, 110, 71, 110, 80, 45, 231, 208, 112, 149, 150,
      251, 157, 51, 25, 129, 124, 13, 154, 238, 225, 7, 63, 237, 156, 30, 78,
    ],
  ],
  ['U8', 63, [63]],
  ['U16', 14776, [184, 57]],
  ['U32', 2260346643, [19, 39, 186, 134]],
  [
    'U64',
    BigInt('6355943419584016569'),
    [185, 112, 201, 104, 221, 216, 52, 88],
  ],
  [
    'U128',
    BigInt('190443100270131819986139062814080853012'),
    [20, 100, 201, 134, 99, 82, 196, 32, 34, 79, 25, 142, 199, 1, 70, 143],
  ],
  [
    'U256',
    BigInt(
      '58716185326733447174109779681509939791568291171619953995835894271369692835957'
    ),
    [
      117, 240, 99, 239, 213, 99, 55, 201, 2, 145, 4, 24, 0, 173, 62, 27, 124,
      53, 44, 244, 71, 1, 156, 30, 111, 187, 149, 150, 229, 46, 208, 129,
    ],
  ],
];

describe('BinaryReader/Writer', () => {
  test('correctly reads/writes little endian values', () => {
    for (let [name, int, buf] of testCases) {
      let arr = new Uint8Array(buf);
      let reader = new BinaryReader(arr);

      let read = reader['read' + name]();
      expect(read).toEqual(int);

      let writer = new BinaryWriter(0);
      writer['write' + name](int);

      expect(writer.getBuffer()).toEqual(arr);
    }
  });
});
