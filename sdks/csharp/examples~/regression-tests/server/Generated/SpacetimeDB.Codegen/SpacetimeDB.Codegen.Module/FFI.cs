// <auto-generated />
#nullable enable
// The runtime already defines SpacetimeDB.Internal.LocalReadOnly in Runtime\Internal\Module.cs as an empty partial type.
// This is needed so every module build doesn't generate a full LocalReadOnly type, but just adds on to the existing.
// We extend it here with generated table accessors, and just need to suppress the duplicate-type warning.
#pragma warning disable CS0436
#pragma warning disable STDB_UNSTABLE

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Internal = SpacetimeDB.Internal;
using TxContext = SpacetimeDB.Internal.TxContext;

namespace SpacetimeDB {
    public sealed record ReducerContext : DbContext<Local>, Internal.IReducerContext {
        public readonly Identity Sender;
        public readonly ConnectionId? ConnectionId;
        public readonly Random Rng;
        public readonly Timestamp Timestamp;
        public readonly AuthCtx SenderAuth;

        // We need this property to be non-static for parity with client SDK.
        public Identity Identity => Internal.IReducerContext.GetIdentity();

        internal ReducerContext(Identity identity, ConnectionId? connectionId, Random random,
                        Timestamp time, AuthCtx? senderAuth = null)
        {
            Sender = identity;
            ConnectionId = connectionId;
            Rng = random;
            Timestamp = time;
            SenderAuth = senderAuth ?? AuthCtx.BuildFromSystemTables(connectionId, identity);
        }
    }
    
    public sealed partial class ProcedureContext : global::SpacetimeDB.ProcedureContextBase {
        private readonly Local _db = new();

        internal ProcedureContext(Identity identity, ConnectionId? connectionId, Random random, Timestamp time)
            : base(identity, connectionId, random, time) {}

        protected override global::SpacetimeDB.LocalBase CreateLocal() => _db;
        protected override global::SpacetimeDB.ProcedureTxContextBase CreateTxContext(Internal.TxContext inner) =>
            _cached ??= new ProcedureTxContext(inner);

        private ProcedureTxContext? _cached;

        [Experimental("STDB_UNSTABLE")]
        public Local Db => _db;
        
        [Experimental("STDB_UNSTABLE")]
        public TResult WithTx<TResult>(Func<ProcedureTxContext, TResult> body) =>
            base.WithTx(tx => body((ProcedureTxContext)tx));
        
        [Experimental("STDB_UNSTABLE")]
        public TxOutcome<TResult> TryWithTx<TResult, TError>(
            Func<ProcedureTxContext, TxResult<TResult, TError>> body)
            where TError : Exception =>
            base.TryWithTx(tx => body((ProcedureTxContext)tx));
    }

    [Experimental("STDB_UNSTABLE")]
    public sealed class ProcedureTxContext : global::SpacetimeDB.ProcedureTxContextBase {
        internal ProcedureTxContext(Internal.TxContext inner) : base(inner) {}

        public new Local Db => (Local)base.Db;
    }

    public sealed class Local : global::SpacetimeDB.LocalBase {
        public global::SpacetimeDB.Internal.TableHandles.example_data example_data => new();
public global::SpacetimeDB.Internal.TableHandles.my_table my_table => new();
public global::SpacetimeDB.Internal.TableHandles.player player => new();
public global::SpacetimeDB.Internal.TableHandles.player_level player_level => new();
public global::SpacetimeDB.Internal.TableHandles.retry_log retry_log => new();
    }

    public sealed class LocalReadOnly : global::SpacetimeDB.LocalReadOnlyBase {
        public global::SpacetimeDB.Internal.ViewHandles.example_dataReadOnly example_data => new();
public global::SpacetimeDB.Internal.ViewHandles.my_tableReadOnly my_table => new();
public global::SpacetimeDB.Internal.ViewHandles.player_levelReadOnly player_level => new();
public global::SpacetimeDB.Internal.ViewHandles.playerReadOnly player => new();
public global::SpacetimeDB.Internal.ViewHandles.retry_logReadOnly retry_log => new();
    }
    
    public sealed record ViewContext : DbContext<LocalReadOnly>, Internal.IViewContext
    {
        public Identity Sender { get; }
        internal ViewContext(Identity sender, LocalReadOnly db) : base(db) => Sender = sender;
    }

    public sealed record AnonymousViewContext : DbContext<LocalReadOnly>, Internal.IAnonymousViewContext {
        internal AnonymousViewContext(LocalReadOnly db) : base(db) { }
    }
}

namespace SpacetimeDB.Internal.TableHandles {
    public readonly struct example_data : global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData> {
    static global::Module.ExampleData global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.ReadGenFields(System.IO.BinaryReader reader, global::Module.ExampleData row) {
        
        return row;
    }

    static SpacetimeDB.Internal.RawTableDefV9 global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.MakeTableDesc(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        Name: nameof(example_data),
        ProductTypeRef: (uint) new global::Module.ExampleData.BSATN().GetAlgebraicType(registrar).Ref_,
        PrimaryKey: [0],
        Indexes: [
            new(
    Name: null,
    AccessorName: "Id",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
),
new(
    Name: null,
    AccessorName: "Indexed",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([1])
)
        ],
        Constraints: [
    global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.MakeUniqueConstraint(0)
],
        Sequences: [
    
],
        Schedule: null,
        TableType: SpacetimeDB.Internal.TableType.User,
        TableAccess: SpacetimeDB.Internal.TableAccess.Public
    );

    public ulong Count => global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.DoCount();
    public IEnumerable<global::Module.ExampleData> Iter() => global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.DoIter();
    public global::Module.ExampleData Insert(global::Module.ExampleData row) => global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.DoInsert(row);
    public bool Delete(global::Module.ExampleData row) => global::SpacetimeDB.Internal.ITableView<example_data, global::Module.ExampleData>.DoDelete(row);

    public sealed class IdUniqueIndex : UniqueIndex<example_data, global::Module.ExampleData, uint, SpacetimeDB.BSATN.U32> {
    internal IdUniqueIndex() : base("example_data_Id_idx_btree") {}
    // Important: don't move this to the base class.
    // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
    // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
    public global::Module.ExampleData? Find(uint key) => DoFilter(key).Cast<global::Module.ExampleData?>().SingleOrDefault();
    public global::Module.ExampleData Update(global::Module.ExampleData row) => DoUpdate(row);
}
public IdUniqueIndex Id => new();
    public sealed class IndexedIndex() : SpacetimeDB.Internal.IndexBase<global::Module.ExampleData>("example_data_Indexed_idx_btree") {
    public IEnumerable<global::Module.ExampleData> Filter(uint Indexed) =>
        DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(Indexed));

    public ulong Delete(uint Indexed) =>
        DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(Indexed));

    public IEnumerable<global::Module.ExampleData> Filter(Bound<uint> Indexed) =>
        DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(Indexed));

    public ulong Delete(Bound<uint> Indexed) =>
        DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(Indexed));

}
 public IndexedIndex Indexed => new();

}
public readonly struct my_table : global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable> {
    static global::Module.MyTable global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable>.ReadGenFields(System.IO.BinaryReader reader, global::Module.MyTable row) {
        
        return row;
    }

    static SpacetimeDB.Internal.RawTableDefV9 global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable>.MakeTableDesc(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        Name: nameof(my_table),
        ProductTypeRef: (uint) new global::Module.MyTable.BSATN().GetAlgebraicType(registrar).Ref_,
        PrimaryKey: [],
        Indexes: [
            
        ],
        Constraints: [
    
],
        Sequences: [
    
],
        Schedule: null,
        TableType: SpacetimeDB.Internal.TableType.User,
        TableAccess: SpacetimeDB.Internal.TableAccess.Public
    );

    public ulong Count => global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable>.DoCount();
    public IEnumerable<global::Module.MyTable> Iter() => global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable>.DoIter();
    public global::Module.MyTable Insert(global::Module.MyTable row) => global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable>.DoInsert(row);
    public bool Delete(global::Module.MyTable row) => global::SpacetimeDB.Internal.ITableView<my_table, global::Module.MyTable>.DoDelete(row);

    
}
public readonly struct player : global::SpacetimeDB.Internal.ITableView<player, global::Module.Player> {
    static global::Module.Player global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.ReadGenFields(System.IO.BinaryReader reader, global::Module.Player row) {
        if (row.Id == default)
{
    row.Id = global::Module.Player.BSATN.IdRW.Read(reader);
}
        return row;
    }

    static SpacetimeDB.Internal.RawTableDefV9 global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.MakeTableDesc(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        Name: nameof(player),
        ProductTypeRef: (uint) new global::Module.Player.BSATN().GetAlgebraicType(registrar).Ref_,
        PrimaryKey: [0],
        Indexes: [
            new(
    Name: null,
    AccessorName: "Id",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
),
new(
    Name: null,
    AccessorName: "Identity",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([1])
)
        ],
        Constraints: [
    global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.MakeUniqueConstraint(0),
global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.MakeUniqueConstraint(1)
],
        Sequences: [
    global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.MakeSequence(0)
],
        Schedule: null,
        TableType: SpacetimeDB.Internal.TableType.User,
        TableAccess: SpacetimeDB.Internal.TableAccess.Public
    );

    public ulong Count => global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.DoCount();
    public IEnumerable<global::Module.Player> Iter() => global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.DoIter();
    public global::Module.Player Insert(global::Module.Player row) => global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.DoInsert(row);
    public bool Delete(global::Module.Player row) => global::SpacetimeDB.Internal.ITableView<player, global::Module.Player>.DoDelete(row);

    public sealed class IdUniqueIndex : UniqueIndex<player, global::Module.Player, ulong, SpacetimeDB.BSATN.U64> {
    internal IdUniqueIndex() : base("player_Id_idx_btree") {}
    // Important: don't move this to the base class.
    // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
    // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
    public global::Module.Player? Find(ulong key) => DoFilter(key).Cast<global::Module.Player?>().SingleOrDefault();
    public global::Module.Player Update(global::Module.Player row) => DoUpdate(row);
}
public IdUniqueIndex Id => new();
public sealed class IdentityUniqueIndex : UniqueIndex<player, global::Module.Player, SpacetimeDB.Identity, SpacetimeDB.Identity.BSATN> {
    internal IdentityUniqueIndex() : base("player_Identity_idx_btree") {}
    // Important: don't move this to the base class.
    // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
    // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
    public global::Module.Player? Find(SpacetimeDB.Identity key) => DoFilter(key).Cast<global::Module.Player?>().SingleOrDefault();
    public global::Module.Player Update(global::Module.Player row) => DoUpdate(row);
}
public IdentityUniqueIndex Identity => new();
}
public readonly struct player_level : global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel> {
    static global::Module.PlayerLevel global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.ReadGenFields(System.IO.BinaryReader reader, global::Module.PlayerLevel row) {
        
        return row;
    }

    static SpacetimeDB.Internal.RawTableDefV9 global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.MakeTableDesc(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        Name: nameof(player_level),
        ProductTypeRef: (uint) new global::Module.PlayerLevel.BSATN().GetAlgebraicType(registrar).Ref_,
        PrimaryKey: [],
        Indexes: [
            new(
    Name: null,
    AccessorName: "PlayerId",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
),
new(
    Name: null,
    AccessorName: "Level",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([1])
)
        ],
        Constraints: [
    global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.MakeUniqueConstraint(0)
],
        Sequences: [
    
],
        Schedule: null,
        TableType: SpacetimeDB.Internal.TableType.User,
        TableAccess: SpacetimeDB.Internal.TableAccess.Public
    );

    public ulong Count => global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.DoCount();
    public IEnumerable<global::Module.PlayerLevel> Iter() => global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.DoIter();
    public global::Module.PlayerLevel Insert(global::Module.PlayerLevel row) => global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.DoInsert(row);
    public bool Delete(global::Module.PlayerLevel row) => global::SpacetimeDB.Internal.ITableView<player_level, global::Module.PlayerLevel>.DoDelete(row);

    public sealed class PlayerIdUniqueIndex : UniqueIndex<player_level, global::Module.PlayerLevel, ulong, SpacetimeDB.BSATN.U64> {
    internal PlayerIdUniqueIndex() : base("player_level_PlayerId_idx_btree") {}
    // Important: don't move this to the base class.
    // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
    // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
    public global::Module.PlayerLevel? Find(ulong key) => DoFilter(key).Cast<global::Module.PlayerLevel?>().SingleOrDefault();
    public global::Module.PlayerLevel Update(global::Module.PlayerLevel row) => DoUpdate(row);
}
public PlayerIdUniqueIndex PlayerId => new();
    public sealed class LevelIndex() : SpacetimeDB.Internal.IndexBase<global::Module.PlayerLevel>("player_level_Level_idx_btree") {
    public IEnumerable<global::Module.PlayerLevel> Filter(ulong Level) =>
        DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<ulong, SpacetimeDB.BSATN.U64>(Level));

    public ulong Delete(ulong Level) =>
        DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<ulong, SpacetimeDB.BSATN.U64>(Level));

    public IEnumerable<global::Module.PlayerLevel> Filter(Bound<ulong> Level) =>
        DoFilter(new SpacetimeDB.Internal.BTreeIndexBounds<ulong, SpacetimeDB.BSATN.U64>(Level));

    public ulong Delete(Bound<ulong> Level) =>
        DoDelete(new SpacetimeDB.Internal.BTreeIndexBounds<ulong, SpacetimeDB.BSATN.U64>(Level));

}
 public LevelIndex Level => new();

}
public readonly struct retry_log : global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog> {
    static global::Module.RetryLog global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.ReadGenFields(System.IO.BinaryReader reader, global::Module.RetryLog row) {
        
        return row;
    }

    static SpacetimeDB.Internal.RawTableDefV9 global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.MakeTableDesc(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        Name: nameof(retry_log),
        ProductTypeRef: (uint) new global::Module.RetryLog.BSATN().GetAlgebraicType(registrar).Ref_,
        PrimaryKey: [0],
        Indexes: [
            new(
    Name: null,
    AccessorName: "Id",
    Algorithm: new SpacetimeDB.Internal.RawIndexAlgorithm.BTree([0])
)
        ],
        Constraints: [
    global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.MakeUniqueConstraint(0)
],
        Sequences: [
    
],
        Schedule: null,
        TableType: SpacetimeDB.Internal.TableType.User,
        TableAccess: SpacetimeDB.Internal.TableAccess.Public
    );

    public ulong Count => global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.DoCount();
    public IEnumerable<global::Module.RetryLog> Iter() => global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.DoIter();
    public global::Module.RetryLog Insert(global::Module.RetryLog row) => global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.DoInsert(row);
    public bool Delete(global::Module.RetryLog row) => global::SpacetimeDB.Internal.ITableView<retry_log, global::Module.RetryLog>.DoDelete(row);

    public sealed class IdUniqueIndex : UniqueIndex<retry_log, global::Module.RetryLog, uint, SpacetimeDB.BSATN.U32> {
    internal IdUniqueIndex() : base("retry_log_Id_idx_btree") {}
    // Important: don't move this to the base class.
    // C# generics don't play well with nullable types and can't accept both struct-type-based and class-type-based
    // `globalName` in one generic definition, leading to buggy `Row?` expansion for either one or another.
    public global::Module.RetryLog? Find(uint key) => DoFilter(key).Cast<global::Module.RetryLog?>().SingleOrDefault();
    public global::Module.RetryLog Update(global::Module.RetryLog row) => DoUpdate(row);
}
public IdUniqueIndex Id => new();
}
}

sealed class my_playerViewDispatcher : global::SpacetimeDB.Internal.IView {
    
    
    public SpacetimeDB.Internal.RawViewDefV9 MakeViewDef(SpacetimeDB.BSATN.ITypeRegistrar registrar)
        => new global::SpacetimeDB.Internal.RawViewDefV9(
    Name: "my_player",
    Index: 0,
    IsPublic: true,
    IsAnonymous: false,
    Params: [],
    ReturnType: new SpacetimeDB.BSATN.ValueOption<Module.Player, Module.Player.BSATN>().GetAlgebraicType(registrar)
);

    public byte[] Invoke(
        System.IO.BinaryReader reader,
        global::SpacetimeDB.Internal.IViewContext ctx
    ) {
        try {
            
            var returnValue = Module.MyPlayer((SpacetimeDB.ViewContext)ctx);
                var listSerializer = SpacetimeDB.BSATN.ValueOption<Module.Player, Module.Player.BSATN>.GetListSerializer();
    var listValue = ModuleRegistration.ToListOrEmpty(returnValue);
    using var output = new System.IO.MemoryStream();
    using var writer = new System.IO.BinaryWriter(output);
    listSerializer.Write(writer, listValue);
    return output.ToArray();
        } catch (System.Exception e) {
            global::SpacetimeDB.Log.Error("Error in view 'my_player': " + e);
            throw;
        }
    }
}
sealed class players_at_level_oneViewDispatcher : global::SpacetimeDB.Internal.IAnonymousView {
    
    
    public SpacetimeDB.Internal.RawViewDefV9 MakeAnonymousViewDef(SpacetimeDB.BSATN.ITypeRegistrar registrar)
        => new global::SpacetimeDB.Internal.RawViewDefV9(
    Name: "players_at_level_one",
    Index: 0,
    IsPublic: true,
    IsAnonymous: true,
    Params: [],
    ReturnType: new SpacetimeDB.BSATN.List<Module.PlayerAndLevel, Module.PlayerAndLevel.BSATN>().GetAlgebraicType(registrar)
);

    public byte[] Invoke(
        System.IO.BinaryReader reader,
        global::SpacetimeDB.Internal.IAnonymousViewContext ctx
    ) {
        try {
            
            var returnValue = Module.PlayersAtLevelOne((SpacetimeDB.AnonymousViewContext)ctx);
                SpacetimeDB.BSATN.List<Module.PlayerAndLevel, Module.PlayerAndLevel.BSATN> returnRW = new();
    using var output = new System.IO.MemoryStream();
    using var writer = new System.IO.BinaryWriter(output);
    returnRW.Write(writer, returnValue);
    return output.ToArray();            
        } catch (System.Exception e) {
            global::SpacetimeDB.Log.Error("Error in view 'players_at_level_one': " + e);
            throw;
        }
    }
}
    
namespace SpacetimeDB.Internal.ViewHandles {
    public sealed class example_dataReadOnly
    : global::SpacetimeDB.Internal.ReadOnlyTableView<global::Module.ExampleData>
{
    internal example_dataReadOnly() : base("example_data") { }

    public ulong Count => DoCount();

    public sealed class IdIndex
    : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
          global::SpacetimeDB.Internal.ViewHandles.example_dataReadOnly,
          global::Module.ExampleData,
          uint,
          SpacetimeDB.BSATN.U32>
{
    internal IdIndex() : base("example_data_Id_idx_btree") { }

    public global::Module.ExampleData? Find(uint key) => FindSingle(key);
}

public IdIndex Id => new();
public sealed class IndexedIndex
: global::SpacetimeDB.Internal.ReadOnlyIndexBase<global::Module.ExampleData>
{
internal IndexedIndex() : base("example_data_Indexed_idx_btree") {}
public IEnumerable<global::Module.ExampleData> Filter(uint Indexed) =>
    DoFilter(new global::SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(Indexed));

public IEnumerable<global::Module.ExampleData> Filter(global::SpacetimeDB.Internal.Bound<uint> Indexed) =>
    DoFilter(new global::SpacetimeDB.Internal.BTreeIndexBounds<uint, SpacetimeDB.BSATN.U32>(Indexed));
}
public IndexedIndex Indexed => new();
}
public sealed class my_tableReadOnly
    : global::SpacetimeDB.Internal.ReadOnlyTableView<global::Module.MyTable>
{
    internal my_tableReadOnly() : base("my_table") { }

    public ulong Count => DoCount();

    
}
public sealed class player_levelReadOnly
    : global::SpacetimeDB.Internal.ReadOnlyTableView<global::Module.PlayerLevel>
{
    internal player_levelReadOnly() : base("player_level") { }

    public ulong Count => DoCount();

    public sealed class PlayerIdIndex
    : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
          global::SpacetimeDB.Internal.ViewHandles.player_levelReadOnly,
          global::Module.PlayerLevel,
          ulong,
          SpacetimeDB.BSATN.U64>
{
    internal PlayerIdIndex() : base("player_level_PlayerId_idx_btree") { }

    public global::Module.PlayerLevel? Find(ulong key) => FindSingle(key);
}

public PlayerIdIndex PlayerId => new();
public sealed class LevelIndex
: global::SpacetimeDB.Internal.ReadOnlyIndexBase<global::Module.PlayerLevel>
{
internal LevelIndex() : base("player_level_Level_idx_btree") {}
public IEnumerable<global::Module.PlayerLevel> Filter(ulong Level) =>
    DoFilter(new global::SpacetimeDB.Internal.BTreeIndexBounds<ulong, SpacetimeDB.BSATN.U64>(Level));

public IEnumerable<global::Module.PlayerLevel> Filter(global::SpacetimeDB.Internal.Bound<ulong> Level) =>
    DoFilter(new global::SpacetimeDB.Internal.BTreeIndexBounds<ulong, SpacetimeDB.BSATN.U64>(Level));
}
public LevelIndex Level => new();
}
public sealed class playerReadOnly
    : global::SpacetimeDB.Internal.ReadOnlyTableView<global::Module.Player>
{
    internal playerReadOnly() : base("player") { }

    public ulong Count => DoCount();

    public sealed class IdIndex
    : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
          global::SpacetimeDB.Internal.ViewHandles.playerReadOnly,
          global::Module.Player,
          ulong,
          SpacetimeDB.BSATN.U64>
{
    internal IdIndex() : base("player_Id_idx_btree") { }

    public global::Module.Player? Find(ulong key) => FindSingle(key);
}

public IdIndex Id => new();
public sealed class IdentityIndex
    : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
          global::SpacetimeDB.Internal.ViewHandles.playerReadOnly,
          global::Module.Player,
          SpacetimeDB.Identity,
          SpacetimeDB.Identity.BSATN>
{
    internal IdentityIndex() : base("player_Identity_idx_btree") { }

    public global::Module.Player? Find(SpacetimeDB.Identity key) => FindSingle(key);
}

public IdentityIndex Identity => new();
}
public sealed class retry_logReadOnly
    : global::SpacetimeDB.Internal.ReadOnlyTableView<global::Module.RetryLog>
{
    internal retry_logReadOnly() : base("retry_log") { }

    public ulong Count => DoCount();

    public sealed class IdIndex
    : global::SpacetimeDB.Internal.ReadOnlyUniqueIndex<
          global::SpacetimeDB.Internal.ViewHandles.retry_logReadOnly,
          global::Module.RetryLog,
          uint,
          SpacetimeDB.BSATN.U32>
{
    internal IdIndex() : base("retry_log_Id_idx_btree") { }

    public global::Module.RetryLog? Find(uint key) => FindSingle(key);
}

public IdIndex Id => new();
}
}

static class ModuleRegistration {
    class Add: SpacetimeDB.Internal.IReducer {
    private static readonly SpacetimeDB.BSATN.U32 idRW = new();
        private static readonly SpacetimeDB.BSATN.U32 indexedRW = new();

    public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        nameof(Add),
        [new("id", idRW.GetAlgebraicType(registrar)),
                new("indexed", indexedRW.GetAlgebraicType(registrar))],
        null
    );

    public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx) {
        Module.Add((SpacetimeDB.ReducerContext)ctx, idRW.Read(reader), indexedRW.Read(reader));
    }
}
class ClientConnected: SpacetimeDB.Internal.IReducer {
    

    public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        nameof(ClientConnected),
        [],
        SpacetimeDB.Internal.Lifecycle.OnConnect
    );

    public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx) {
        Module.ClientConnected((SpacetimeDB.ReducerContext)ctx);
    }
}
class Delete: SpacetimeDB.Internal.IReducer {
    private static readonly SpacetimeDB.BSATN.U32 idRW = new();

    public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        nameof(Delete),
        [new("id", idRW.GetAlgebraicType(registrar))],
        null
    );

    public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx) {
        Module.Delete((SpacetimeDB.ReducerContext)ctx, idRW.Read(reader));
    }
}
class ThrowError: SpacetimeDB.Internal.IReducer {
    private static readonly SpacetimeDB.BSATN.String errorRW = new();

    public SpacetimeDB.Internal.RawReducerDefV9 MakeReducerDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new (
        nameof(ThrowError),
        [new("error", errorRW.GetAlgebraicType(registrar))],
        null
    );

    public void Invoke(BinaryReader reader, SpacetimeDB.Internal.IReducerContext ctx) {
        Module.ThrowError((SpacetimeDB.ReducerContext)ctx, errorRW.Read(reader));
    }
}
    
    class AuthenticationCapabilities : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(AuthenticationCapabilities),
        [],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var result = Module.AuthenticationCapabilities((SpacetimeDB.ProcedureContext)ctx);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class DanglingTxWarning : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(DanglingTxWarning),
        [],
        SpacetimeDB.BSATN.AlgebraicType.Unit
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            Module.DanglingTxWarning((SpacetimeDB.ProcedureContext)ctx);
                    return System.Array.Empty<byte>();
    }
}
class DocumentationGapChecks : SpacetimeDB.Internal.IProcedure {
    private static readonly SpacetimeDB.BSATN.U32 inputValueRW = new();
        private static readonly SpacetimeDB.BSATN.String inputTextRW = new();

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(DocumentationGapChecks),
        [new("inputValue", inputValueRW.GetAlgebraicType(registrar)),
                new("inputText", inputTextRW.GetAlgebraicType(registrar))],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var inputValue = inputValueRW.Read(reader);
                    var inputText = inputTextRW.Read(reader);
                    var result = Module.DocumentationGapChecks((SpacetimeDB.ProcedureContext)ctx, inputValue, inputText);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class InsertWithTxCommit : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(InsertWithTxCommit),
        [],
        SpacetimeDB.BSATN.AlgebraicType.Unit
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            Module.InsertWithTxCommit((SpacetimeDB.ProcedureContext)ctx);
                    return System.Array.Empty<byte>();
    }
}
class InsertWithTxPanic : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(InsertWithTxPanic),
        [],
        SpacetimeDB.BSATN.AlgebraicType.Unit
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            Module.InsertWithTxPanic((SpacetimeDB.ProcedureContext)ctx);
                    return System.Array.Empty<byte>();
    }
}
class InsertWithTxRetry : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(InsertWithTxRetry),
        [],
        new SpacetimeDB.BSATN.U32().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var result = Module.InsertWithTxRetry((SpacetimeDB.ProcedureContext)ctx);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new SpacetimeDB.BSATN.U32().Write(writer, result);
                    return output.ToArray();
    }
}
class InsertWithTxRollback : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(InsertWithTxRollback),
        [],
        SpacetimeDB.BSATN.AlgebraicType.Unit
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            Module.InsertWithTxRollback((SpacetimeDB.ProcedureContext)ctx);
                    return System.Array.Empty<byte>();
    }
}
class ReturnEnumA : SpacetimeDB.Internal.IProcedure {
    private static readonly SpacetimeDB.BSATN.U32 aRW = new();

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(ReturnEnumA),
        [new("a", aRW.GetAlgebraicType(registrar))],
        new ReturnEnum.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var a = aRW.Read(reader);
                    var result = Module.ReturnEnumA((SpacetimeDB.ProcedureContext)ctx, a);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnEnum.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class ReturnEnumB : SpacetimeDB.Internal.IProcedure {
    private static readonly SpacetimeDB.BSATN.String bRW = new();

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(ReturnEnumB),
        [new("b", bRW.GetAlgebraicType(registrar))],
        new ReturnEnum.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var b = bRW.Read(reader);
                    var result = Module.ReturnEnumB((SpacetimeDB.ProcedureContext)ctx, b);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnEnum.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class ReturnPrimitive : SpacetimeDB.Internal.IProcedure {
    private static readonly SpacetimeDB.BSATN.U32 lhsRW = new();
        private static readonly SpacetimeDB.BSATN.U32 rhsRW = new();

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(ReturnPrimitive),
        [new("lhs", lhsRW.GetAlgebraicType(registrar)),
                new("rhs", rhsRW.GetAlgebraicType(registrar))],
        new SpacetimeDB.BSATN.U32().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var lhs = lhsRW.Read(reader);
                    var rhs = rhsRW.Read(reader);
                    var result = Module.ReturnPrimitive((SpacetimeDB.ProcedureContext)ctx, lhs, rhs);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new SpacetimeDB.BSATN.U32().Write(writer, result);
                    return output.ToArray();
    }
}
class ReturnStructProcedure : SpacetimeDB.Internal.IProcedure {
    private static readonly SpacetimeDB.BSATN.U32 aRW = new();
        private static readonly SpacetimeDB.BSATN.String bRW = new();

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(ReturnStructProcedure),
        [new("a", aRW.GetAlgebraicType(registrar)),
                new("b", bRW.GetAlgebraicType(registrar))],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var a = aRW.Read(reader);
                    var b = bRW.Read(reader);
                    var result = Module.ReturnStructProcedure((SpacetimeDB.ProcedureContext)ctx, a, b);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class SleepUntilTimestampUpdate : SpacetimeDB.Internal.IProcedure {
    private static readonly SpacetimeDB.BSATN.U32 sleepMillisRW = new();

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(SleepUntilTimestampUpdate),
        [new("sleepMillis", sleepMillisRW.GetAlgebraicType(registrar))],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var sleepMillis = sleepMillisRW.Read(reader);
                    var result = Module.SleepUntilTimestampUpdate((SpacetimeDB.ProcedureContext)ctx, sleepMillis);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class SubscriptionEventOffset : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(SubscriptionEventOffset),
        [],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var result = Module.SubscriptionEventOffset((SpacetimeDB.ProcedureContext)ctx);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class TimestampCapabilities : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(TimestampCapabilities),
        [],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var result = Module.TimestampCapabilities((SpacetimeDB.ProcedureContext)ctx);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class TxContextCapabilities : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(TxContextCapabilities),
        [],
        new ReturnStruct.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var result = Module.TxContextCapabilities((SpacetimeDB.ProcedureContext)ctx);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new ReturnStruct.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}
class WillPanic : SpacetimeDB.Internal.IProcedure {
    

    public SpacetimeDB.Internal.RawProcedureDefV9 MakeProcedureDef(SpacetimeDB.BSATN.ITypeRegistrar registrar) => new(
        nameof(WillPanic),
        [],
        new SpacetimeDB.Unit.BSATN().GetAlgebraicType(registrar)
    );

    public byte[] Invoke(BinaryReader reader, SpacetimeDB.Internal.IProcedureContext ctx) {
                            var result = Module.WillPanic((SpacetimeDB.ProcedureContext)ctx);
                    using var output = new MemoryStream();
                    using var writer = new BinaryWriter(output);
                    new SpacetimeDB.Unit.BSATN().Write(writer, result);
                    return output.ToArray();
    }
}

    public static List<T> ToListOrEmpty<T>(T? value) where T : struct
            => value is null ? new List<T>() : new List<T> { value.Value };

#if EXPERIMENTAL_WASM_AOT
    // In AOT mode we're building a library.
    // Main method won't be called automatically, so we need to export it as a preinit function.
    [UnmanagedCallersOnly(EntryPoint = "__preinit__10_init_csharp")]
#else
    // Prevent trimming of FFI exports that are invoked from C and not visible to C# trimmer.
    [DynamicDependency(DynamicallyAccessedMemberTypes.PublicMethods, typeof(SpacetimeDB.Internal.Module))]
#endif
    public static void Main() {
      SpacetimeDB.Internal.Module.SetReducerContextConstructor((identity, connectionId, random, time) => new SpacetimeDB.ReducerContext(identity, connectionId, random, time));
      SpacetimeDB.Internal.Module.SetViewContextConstructor(identity => new SpacetimeDB.ViewContext(identity, new SpacetimeDB.LocalReadOnly()));
      SpacetimeDB.Internal.Module.SetAnonymousViewContextConstructor(() => new SpacetimeDB.AnonymousViewContext(new SpacetimeDB.LocalReadOnly()));
      SpacetimeDB.Internal.Module.SetProcedureContextConstructor((identity, connectionId, random, time) => new SpacetimeDB.ProcedureContext(identity, connectionId, random, time));
      var __memoryStream = new MemoryStream();
      var __writer = new BinaryWriter(__memoryStream);

        SpacetimeDB.Internal.Module.RegisterReducer<Add>();
SpacetimeDB.Internal.Module.RegisterReducer<ClientConnected>();
SpacetimeDB.Internal.Module.RegisterReducer<Delete>();
SpacetimeDB.Internal.Module.RegisterReducer<ThrowError>();
        SpacetimeDB.Internal.Module.RegisterProcedure<AuthenticationCapabilities>();
SpacetimeDB.Internal.Module.RegisterProcedure<DanglingTxWarning>();
SpacetimeDB.Internal.Module.RegisterProcedure<DocumentationGapChecks>();
SpacetimeDB.Internal.Module.RegisterProcedure<InsertWithTxCommit>();
SpacetimeDB.Internal.Module.RegisterProcedure<InsertWithTxPanic>();
SpacetimeDB.Internal.Module.RegisterProcedure<InsertWithTxRetry>();
SpacetimeDB.Internal.Module.RegisterProcedure<InsertWithTxRollback>();
SpacetimeDB.Internal.Module.RegisterProcedure<ReturnEnumA>();
SpacetimeDB.Internal.Module.RegisterProcedure<ReturnEnumB>();
SpacetimeDB.Internal.Module.RegisterProcedure<ReturnPrimitive>();
SpacetimeDB.Internal.Module.RegisterProcedure<ReturnStructProcedure>();
SpacetimeDB.Internal.Module.RegisterProcedure<SleepUntilTimestampUpdate>();
SpacetimeDB.Internal.Module.RegisterProcedure<SubscriptionEventOffset>();
SpacetimeDB.Internal.Module.RegisterProcedure<TimestampCapabilities>();
SpacetimeDB.Internal.Module.RegisterProcedure<TxContextCapabilities>();
SpacetimeDB.Internal.Module.RegisterProcedure<WillPanic>();

        // IMPORTANT: The order in which we register views matters.
        // It must correspond to the order in which we call `GenerateDispatcherClass`.
        // See the comment on `GenerateDispatcherClass` for more explanation.
        SpacetimeDB.Internal.Module.RegisterView<my_playerViewDispatcher>();
SpacetimeDB.Internal.Module.RegisterAnonymousView<players_at_level_oneViewDispatcher>();                            

        SpacetimeDB.Internal.Module.RegisterTable<global::Module.ExampleData, SpacetimeDB.Internal.TableHandles.example_data>();
SpacetimeDB.Internal.Module.RegisterTable<global::Module.MyTable, SpacetimeDB.Internal.TableHandles.my_table>();
SpacetimeDB.Internal.Module.RegisterTable<global::Module.Player, SpacetimeDB.Internal.TableHandles.player>();
SpacetimeDB.Internal.Module.RegisterTable<global::Module.PlayerLevel, SpacetimeDB.Internal.TableHandles.player_level>();
SpacetimeDB.Internal.Module.RegisterTable<global::Module.RetryLog, SpacetimeDB.Internal.TableHandles.retry_log>();
        
        
    }

// Exports only work from the main assembly, so we need to generate forwarding methods.
#if EXPERIMENTAL_WASM_AOT
    [UnmanagedCallersOnly(EntryPoint = "__describe_module__")]
    public static void __describe_module__(SpacetimeDB.Internal.BytesSink d) => SpacetimeDB.Internal.Module.__describe_module__(d);

    [UnmanagedCallersOnly(EntryPoint = "__call_reducer__")]
    public static SpacetimeDB.Internal.Errno __call_reducer__(
        uint id,
        ulong sender_0,
        ulong sender_1,
        ulong sender_2,
        ulong sender_3,
        ulong conn_id_0,
        ulong conn_id_1,
        SpacetimeDB.Timestamp timestamp,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink error
    ) => SpacetimeDB.Internal.Module.__call_reducer__(
        id,
        sender_0,
        sender_1,
        sender_2,
        sender_3,
        conn_id_0,
        conn_id_1,
        timestamp,
        args,
        error
    );
    
    [UnmanagedCallersOnly(EntryPoint = "__call_procedure__")]
    public static SpacetimeDB.Internal.Errno __call_procedure__(
        uint id,
        ulong sender_0,
        ulong sender_1,
        ulong sender_2,
        ulong sender_3,
        ulong conn_id_0,
        ulong conn_id_1,
        SpacetimeDB.Timestamp timestamp,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink result_sink
    ) => SpacetimeDB.Internal.Module.__call_procedure__(
        id,
        sender_0,
        sender_1,
        sender_2,
        sender_3,
        conn_id_0,
        conn_id_1,
        timestamp,
        args,
        result_sink
    );
    
    [UnmanagedCallersOnly(EntryPoint = "__take_procedure_tx_offset__")]
    public static byte __take_procedure_tx_offset__(ulong* offset) =>
        SpacetimeDB.Internal.Module.__take_procedure_tx_offset__(out *offset) ? (byte)1 : (byte)0;

    [UnmanagedCallersOnly(EntryPoint = "__call_view__")]
    public static SpacetimeDB.Internal.Errno __call_view__(
        uint id,
        ulong sender_0,
        ulong sender_1,
        ulong sender_2,
        ulong sender_3,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink sink
    ) => SpacetimeDB.Internal.Module.__call_view__(
        id,
        sender_0,
        sender_1,
        sender_2,
        sender_3,
        args,
        sink
    );

    [UnmanagedCallersOnly(EntryPoint = "__call_view_anon__")]
    public static SpacetimeDB.Internal.Errno __call_view_anon__(
        uint id,
        SpacetimeDB.Internal.BytesSource args,
        SpacetimeDB.Internal.BytesSink sink
    ) => SpacetimeDB.Internal.Module.__call_view_anon__(
        id,
        args,
        sink
    );                                                
#endif
}

#pragma warning restore STDB_UNSTABLE
#pragma warning restore CS0436