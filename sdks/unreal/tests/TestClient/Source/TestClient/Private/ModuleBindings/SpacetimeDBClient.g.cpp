// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#include "ModuleBindings/SpacetimeDBClient.g.h"
#include "DBCache/WithBsatn.h"
#include "BSATN/UEBSATNHelpers.h"
#include "ModuleBindings/Tables/UsersTable.g.h"
#include "ModuleBindings/Tables/UniqueI32Table.g.h"
#include "ModuleBindings/Tables/OneTimestampTable.g.h"
#include "ModuleBindings/Tables/VecI8Table.g.h"
#include "ModuleBindings/Tables/BTreeU32Table.g.h"
#include "ModuleBindings/Tables/VecByteStructTable.g.h"
#include "ModuleBindings/Tables/VecI256Table.g.h"
#include "ModuleBindings/Tables/VecU16Table.g.h"
#include "ModuleBindings/Tables/UniqueU16Table.g.h"
#include "ModuleBindings/Tables/VecI128Table.g.h"
#include "ModuleBindings/Tables/ScheduledTableTable.g.h"
#include "ModuleBindings/Tables/VecI16Table.g.h"
#include "ModuleBindings/Tables/PkBoolTable.g.h"
#include "ModuleBindings/Tables/OneI32Table.g.h"
#include "ModuleBindings/Tables/VecU256Table.g.h"
#include "ModuleBindings/Tables/OneEveryPrimitiveStructTable.g.h"
#include "ModuleBindings/Tables/PkI64Table.g.h"
#include "ModuleBindings/Tables/PkI32Table.g.h"
#include "ModuleBindings/Tables/OneStringTable.g.h"
#include "ModuleBindings/Tables/OptionStringTable.g.h"
#include "ModuleBindings/Tables/OneUnitStructTable.g.h"
#include "ModuleBindings/Tables/PkIdentityTable.g.h"
#include "ModuleBindings/Tables/OptionEveryPrimitiveStructTable.g.h"
#include "ModuleBindings/Tables/UniqueI64Table.g.h"
#include "ModuleBindings/Tables/PkU128Table.g.h"
#include "ModuleBindings/Tables/PkConnectionIdTable.g.h"
#include "ModuleBindings/Tables/VecConnectionIdTable.g.h"
#include "ModuleBindings/Tables/VecI32Table.g.h"
#include "ModuleBindings/Tables/VecTimestampTable.g.h"
#include "ModuleBindings/Tables/OneEveryVecStructTable.g.h"
#include "ModuleBindings/Tables/OneF32Table.g.h"
#include "ModuleBindings/Tables/OneU8Table.g.h"
#include "ModuleBindings/Tables/OptionVecOptionI32Table.g.h"
#include "ModuleBindings/Tables/OneU256Table.g.h"
#include "ModuleBindings/Tables/UniqueIdentityTable.g.h"
#include "ModuleBindings/Tables/VecStringTable.g.h"
#include "ModuleBindings/Tables/UniqueConnectionIdTable.g.h"
#include "ModuleBindings/Tables/VecU32Table.g.h"
#include "ModuleBindings/Tables/LargeTableTable.g.h"
#include "ModuleBindings/Tables/VecUnitStructTable.g.h"
#include "ModuleBindings/Tables/OneI8Table.g.h"
#include "ModuleBindings/Tables/PkI16Table.g.h"
#include "ModuleBindings/Tables/UniqueI16Table.g.h"
#include "ModuleBindings/Tables/UniqueU8Table.g.h"
#include "ModuleBindings/Tables/OptionIdentityTable.g.h"
#include "ModuleBindings/Tables/UniqueI256Table.g.h"
#include "ModuleBindings/Tables/IndexedTableTable.g.h"
#include "ModuleBindings/Tables/VecEveryVecStructTable.g.h"
#include "ModuleBindings/Tables/VecU128Table.g.h"
#include "ModuleBindings/Tables/UniqueU256Table.g.h"
#include "ModuleBindings/Tables/VecF32Table.g.h"
#include "ModuleBindings/Tables/VecIdentityTable.g.h"
#include "ModuleBindings/Tables/OptionI32Table.g.h"
#include "ModuleBindings/Tables/OneU16Table.g.h"
#include "ModuleBindings/Tables/OneU32Table.g.h"
#include "ModuleBindings/Tables/OneI128Table.g.h"
#include "ModuleBindings/Tables/UniqueI128Table.g.h"
#include "ModuleBindings/Tables/UniqueU128Table.g.h"
#include "ModuleBindings/Tables/PkI8Table.g.h"
#include "ModuleBindings/Tables/OneEnumWithPayloadTable.g.h"
#include "ModuleBindings/Tables/OneByteStructTable.g.h"
#include "ModuleBindings/Tables/PkU64Table.g.h"
#include "ModuleBindings/Tables/PkU256Table.g.h"
#include "ModuleBindings/Tables/TableHoldsTableTable.g.h"
#include "ModuleBindings/Tables/VecI64Table.g.h"
#include "ModuleBindings/Tables/UniqueU64Table.g.h"
#include "ModuleBindings/Tables/VecU8Table.g.h"
#include "ModuleBindings/Tables/OneF64Table.g.h"
#include "ModuleBindings/Tables/OneBoolTable.g.h"
#include "ModuleBindings/Tables/VecEnumWithPayloadTable.g.h"
#include "ModuleBindings/Tables/OneConnectionIdTable.g.h"
#include "ModuleBindings/Tables/PkI128Table.g.h"
#include "ModuleBindings/Tables/OneU128Table.g.h"
#include "ModuleBindings/Tables/IndexedTable2Table.g.h"
#include "ModuleBindings/Tables/OneI16Table.g.h"
#include "ModuleBindings/Tables/OneI64Table.g.h"
#include "ModuleBindings/Tables/OptionSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/PkSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/PkStringTable.g.h"
#include "ModuleBindings/Tables/PkU8Table.g.h"
#include "ModuleBindings/Tables/UniqueBoolTable.g.h"
#include "ModuleBindings/Tables/VecBoolTable.g.h"
#include "ModuleBindings/Tables/VecEveryPrimitiveStructTable.g.h"
#include "ModuleBindings/Tables/IndexedSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/PkU32Table.g.h"
#include "ModuleBindings/Tables/UniqueI8Table.g.h"
#include "ModuleBindings/Tables/UniqueStringTable.g.h"
#include "ModuleBindings/Tables/VecF64Table.g.h"
#include "ModuleBindings/Tables/OneU64Table.g.h"
#include "ModuleBindings/Tables/OneIdentityTable.g.h"
#include "ModuleBindings/Tables/PkU16Table.g.h"
#include "ModuleBindings/Tables/VecSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/OneSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/PkU32TwoTable.g.h"
#include "ModuleBindings/Tables/UniqueU32Table.g.h"
#include "ModuleBindings/Tables/VecU64Table.g.h"
#include "ModuleBindings/Tables/PkI256Table.g.h"
#include "ModuleBindings/Tables/OneI256Table.g.h"

static FReducer DecodeReducer(const FReducerEvent& Event)
{
    const FString& ReducerName = Event.ReducerCall.ReducerName;

    if (ReducerName == TEXT("delete_from_btree_u32"))
    {
        FDeleteFromBtreeU32Args Args = UE::SpacetimeDB::Deserialize<FDeleteFromBtreeU32Args>(Event.ReducerCall.Args);
        return FReducer::DeleteFromBtreeU32(Args);
    }

    if (ReducerName == TEXT("delete_large_table"))
    {
        FDeleteLargeTableArgs Args = UE::SpacetimeDB::Deserialize<FDeleteLargeTableArgs>(Event.ReducerCall.Args);
        return FReducer::DeleteLargeTable(Args);
    }

    if (ReducerName == TEXT("delete_pk_bool"))
    {
        FDeletePkBoolArgs Args = UE::SpacetimeDB::Deserialize<FDeletePkBoolArgs>(Event.ReducerCall.Args);
        return FReducer::DeletePkBool(Args);
    }

    if (ReducerName == TEXT("delete_pk_connection_id"))
    {
        FDeletePkConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FDeletePkConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::DeletePkConnectionId(Args);
    }

    if (ReducerName == TEXT("delete_pk_i128"))
    {
        FDeletePkI128Args Args = UE::SpacetimeDB::Deserialize<FDeletePkI128Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkI128(Args);
    }

    if (ReducerName == TEXT("delete_pk_i16"))
    {
        FDeletePkI16Args Args = UE::SpacetimeDB::Deserialize<FDeletePkI16Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkI16(Args);
    }

    if (ReducerName == TEXT("delete_pk_i256"))
    {
        FDeletePkI256Args Args = UE::SpacetimeDB::Deserialize<FDeletePkI256Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkI256(Args);
    }

    if (ReducerName == TEXT("delete_pk_i32"))
    {
        FDeletePkI32Args Args = UE::SpacetimeDB::Deserialize<FDeletePkI32Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkI32(Args);
    }

    if (ReducerName == TEXT("delete_pk_i64"))
    {
        FDeletePkI64Args Args = UE::SpacetimeDB::Deserialize<FDeletePkI64Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkI64(Args);
    }

    if (ReducerName == TEXT("delete_pk_i8"))
    {
        FDeletePkI8Args Args = UE::SpacetimeDB::Deserialize<FDeletePkI8Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkI8(Args);
    }

    if (ReducerName == TEXT("delete_pk_identity"))
    {
        FDeletePkIdentityArgs Args = UE::SpacetimeDB::Deserialize<FDeletePkIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::DeletePkIdentity(Args);
    }

    if (ReducerName == TEXT("delete_pk_string"))
    {
        FDeletePkStringArgs Args = UE::SpacetimeDB::Deserialize<FDeletePkStringArgs>(Event.ReducerCall.Args);
        return FReducer::DeletePkString(Args);
    }

    if (ReducerName == TEXT("delete_pk_u128"))
    {
        FDeletePkU128Args Args = UE::SpacetimeDB::Deserialize<FDeletePkU128Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkU128(Args);
    }

    if (ReducerName == TEXT("delete_pk_u16"))
    {
        FDeletePkU16Args Args = UE::SpacetimeDB::Deserialize<FDeletePkU16Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkU16(Args);
    }

    if (ReducerName == TEXT("delete_pk_u256"))
    {
        FDeletePkU256Args Args = UE::SpacetimeDB::Deserialize<FDeletePkU256Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkU256(Args);
    }

    if (ReducerName == TEXT("delete_pk_u32"))
    {
        FDeletePkU32Args Args = UE::SpacetimeDB::Deserialize<FDeletePkU32Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkU32(Args);
    }

    if (ReducerName == TEXT("delete_pk_u32_insert_pk_u32_two"))
    {
        FDeletePkU32InsertPkU32TwoArgs Args = UE::SpacetimeDB::Deserialize<FDeletePkU32InsertPkU32TwoArgs>(Event.ReducerCall.Args);
        return FReducer::DeletePkU32InsertPkU32Two(Args);
    }

    if (ReducerName == TEXT("delete_pk_u32_two"))
    {
        FDeletePkU32TwoArgs Args = UE::SpacetimeDB::Deserialize<FDeletePkU32TwoArgs>(Event.ReducerCall.Args);
        return FReducer::DeletePkU32Two(Args);
    }

    if (ReducerName == TEXT("delete_pk_u64"))
    {
        FDeletePkU64Args Args = UE::SpacetimeDB::Deserialize<FDeletePkU64Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkU64(Args);
    }

    if (ReducerName == TEXT("delete_pk_u8"))
    {
        FDeletePkU8Args Args = UE::SpacetimeDB::Deserialize<FDeletePkU8Args>(Event.ReducerCall.Args);
        return FReducer::DeletePkU8(Args);
    }

    if (ReducerName == TEXT("delete_unique_bool"))
    {
        FDeleteUniqueBoolArgs Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueBoolArgs>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueBool(Args);
    }

    if (ReducerName == TEXT("delete_unique_connection_id"))
    {
        FDeleteUniqueConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueConnectionId(Args);
    }

    if (ReducerName == TEXT("delete_unique_i128"))
    {
        FDeleteUniqueI128Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueI128Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueI128(Args);
    }

    if (ReducerName == TEXT("delete_unique_i16"))
    {
        FDeleteUniqueI16Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueI16Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueI16(Args);
    }

    if (ReducerName == TEXT("delete_unique_i256"))
    {
        FDeleteUniqueI256Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueI256Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueI256(Args);
    }

    if (ReducerName == TEXT("delete_unique_i32"))
    {
        FDeleteUniqueI32Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueI32Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueI32(Args);
    }

    if (ReducerName == TEXT("delete_unique_i64"))
    {
        FDeleteUniqueI64Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueI64Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueI64(Args);
    }

    if (ReducerName == TEXT("delete_unique_i8"))
    {
        FDeleteUniqueI8Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueI8Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueI8(Args);
    }

    if (ReducerName == TEXT("delete_unique_identity"))
    {
        FDeleteUniqueIdentityArgs Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueIdentity(Args);
    }

    if (ReducerName == TEXT("delete_unique_string"))
    {
        FDeleteUniqueStringArgs Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueStringArgs>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueString(Args);
    }

    if (ReducerName == TEXT("delete_unique_u128"))
    {
        FDeleteUniqueU128Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueU128Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueU128(Args);
    }

    if (ReducerName == TEXT("delete_unique_u16"))
    {
        FDeleteUniqueU16Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueU16Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueU16(Args);
    }

    if (ReducerName == TEXT("delete_unique_u256"))
    {
        FDeleteUniqueU256Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueU256Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueU256(Args);
    }

    if (ReducerName == TEXT("delete_unique_u32"))
    {
        FDeleteUniqueU32Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueU32Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueU32(Args);
    }

    if (ReducerName == TEXT("delete_unique_u64"))
    {
        FDeleteUniqueU64Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueU64Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueU64(Args);
    }

    if (ReducerName == TEXT("delete_unique_u8"))
    {
        FDeleteUniqueU8Args Args = UE::SpacetimeDB::Deserialize<FDeleteUniqueU8Args>(Event.ReducerCall.Args);
        return FReducer::DeleteUniqueU8(Args);
    }

    if (ReducerName == TEXT("insert_call_timestamp"))
    {
        FInsertCallTimestampArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallTimestampArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallTimestamp(Args);
    }

    if (ReducerName == TEXT("insert_caller_one_connection_id"))
    {
        FInsertCallerOneConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerOneConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerOneConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_caller_one_identity"))
    {
        FInsertCallerOneIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerOneIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerOneIdentity(Args);
    }

    if (ReducerName == TEXT("insert_caller_pk_connection_id"))
    {
        FInsertCallerPkConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerPkConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerPkConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_caller_pk_identity"))
    {
        FInsertCallerPkIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerPkIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerPkIdentity(Args);
    }

    if (ReducerName == TEXT("insert_caller_unique_connection_id"))
    {
        FInsertCallerUniqueConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerUniqueConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerUniqueConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_caller_unique_identity"))
    {
        FInsertCallerUniqueIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerUniqueIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerUniqueIdentity(Args);
    }

    if (ReducerName == TEXT("insert_caller_vec_connection_id"))
    {
        FInsertCallerVecConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerVecConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerVecConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_caller_vec_identity"))
    {
        FInsertCallerVecIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertCallerVecIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertCallerVecIdentity(Args);
    }

    if (ReducerName == TEXT("insert_into_btree_u32"))
    {
        FInsertIntoBtreeU32Args Args = UE::SpacetimeDB::Deserialize<FInsertIntoBtreeU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertIntoBtreeU32(Args);
    }

    if (ReducerName == TEXT("insert_into_indexed_simple_enum"))
    {
        FInsertIntoIndexedSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FInsertIntoIndexedSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::InsertIntoIndexedSimpleEnum(Args);
    }

    if (ReducerName == TEXT("insert_into_pk_btree_u32"))
    {
        FInsertIntoPkBtreeU32Args Args = UE::SpacetimeDB::Deserialize<FInsertIntoPkBtreeU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertIntoPkBtreeU32(Args);
    }

    if (ReducerName == TEXT("insert_large_table"))
    {
        FInsertLargeTableArgs Args = UE::SpacetimeDB::Deserialize<FInsertLargeTableArgs>(Event.ReducerCall.Args);
        return FReducer::InsertLargeTable(Args);
    }

    if (ReducerName == TEXT("insert_one_bool"))
    {
        FInsertOneBoolArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneBoolArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneBool(Args);
    }

    if (ReducerName == TEXT("insert_one_byte_struct"))
    {
        FInsertOneByteStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneByteStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneByteStruct(Args);
    }

    if (ReducerName == TEXT("insert_one_connection_id"))
    {
        FInsertOneConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_one_enum_with_payload"))
    {
        FInsertOneEnumWithPayloadArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneEnumWithPayloadArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneEnumWithPayload(Args);
    }

    if (ReducerName == TEXT("insert_one_every_primitive_struct"))
    {
        FInsertOneEveryPrimitiveStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneEveryPrimitiveStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneEveryPrimitiveStruct(Args);
    }

    if (ReducerName == TEXT("insert_one_every_vec_struct"))
    {
        FInsertOneEveryVecStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneEveryVecStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneEveryVecStruct(Args);
    }

    if (ReducerName == TEXT("insert_one_f32"))
    {
        FInsertOneF32Args Args = UE::SpacetimeDB::Deserialize<FInsertOneF32Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneF32(Args);
    }

    if (ReducerName == TEXT("insert_one_f64"))
    {
        FInsertOneF64Args Args = UE::SpacetimeDB::Deserialize<FInsertOneF64Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneF64(Args);
    }

    if (ReducerName == TEXT("insert_one_i128"))
    {
        FInsertOneI128Args Args = UE::SpacetimeDB::Deserialize<FInsertOneI128Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneI128(Args);
    }

    if (ReducerName == TEXT("insert_one_i16"))
    {
        FInsertOneI16Args Args = UE::SpacetimeDB::Deserialize<FInsertOneI16Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneI16(Args);
    }

    if (ReducerName == TEXT("insert_one_i256"))
    {
        FInsertOneI256Args Args = UE::SpacetimeDB::Deserialize<FInsertOneI256Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneI256(Args);
    }

    if (ReducerName == TEXT("insert_one_i32"))
    {
        FInsertOneI32Args Args = UE::SpacetimeDB::Deserialize<FInsertOneI32Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneI32(Args);
    }

    if (ReducerName == TEXT("insert_one_i64"))
    {
        FInsertOneI64Args Args = UE::SpacetimeDB::Deserialize<FInsertOneI64Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneI64(Args);
    }

    if (ReducerName == TEXT("insert_one_i8"))
    {
        FInsertOneI8Args Args = UE::SpacetimeDB::Deserialize<FInsertOneI8Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneI8(Args);
    }

    if (ReducerName == TEXT("insert_one_identity"))
    {
        FInsertOneIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneIdentity(Args);
    }

    if (ReducerName == TEXT("insert_one_simple_enum"))
    {
        FInsertOneSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneSimpleEnum(Args);
    }

    if (ReducerName == TEXT("insert_one_string"))
    {
        FInsertOneStringArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneStringArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneString(Args);
    }

    if (ReducerName == TEXT("insert_one_timestamp"))
    {
        FInsertOneTimestampArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneTimestampArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneTimestamp(Args);
    }

    if (ReducerName == TEXT("insert_one_u128"))
    {
        FInsertOneU128Args Args = UE::SpacetimeDB::Deserialize<FInsertOneU128Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneU128(Args);
    }

    if (ReducerName == TEXT("insert_one_u16"))
    {
        FInsertOneU16Args Args = UE::SpacetimeDB::Deserialize<FInsertOneU16Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneU16(Args);
    }

    if (ReducerName == TEXT("insert_one_u256"))
    {
        FInsertOneU256Args Args = UE::SpacetimeDB::Deserialize<FInsertOneU256Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneU256(Args);
    }

    if (ReducerName == TEXT("insert_one_u32"))
    {
        FInsertOneU32Args Args = UE::SpacetimeDB::Deserialize<FInsertOneU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneU32(Args);
    }

    if (ReducerName == TEXT("insert_one_u64"))
    {
        FInsertOneU64Args Args = UE::SpacetimeDB::Deserialize<FInsertOneU64Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneU64(Args);
    }

    if (ReducerName == TEXT("insert_one_u8"))
    {
        FInsertOneU8Args Args = UE::SpacetimeDB::Deserialize<FInsertOneU8Args>(Event.ReducerCall.Args);
        return FReducer::InsertOneU8(Args);
    }

    if (ReducerName == TEXT("insert_one_unit_struct"))
    {
        FInsertOneUnitStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertOneUnitStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOneUnitStruct(Args);
    }

    if (ReducerName == TEXT("insert_option_every_primitive_struct"))
    {
        FInsertOptionEveryPrimitiveStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertOptionEveryPrimitiveStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOptionEveryPrimitiveStruct(Args);
    }

    if (ReducerName == TEXT("insert_option_i32"))
    {
        FInsertOptionI32Args Args = UE::SpacetimeDB::Deserialize<FInsertOptionI32Args>(Event.ReducerCall.Args);
        return FReducer::InsertOptionI32(Args);
    }

    if (ReducerName == TEXT("insert_option_identity"))
    {
        FInsertOptionIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertOptionIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOptionIdentity(Args);
    }

    if (ReducerName == TEXT("insert_option_simple_enum"))
    {
        FInsertOptionSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FInsertOptionSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOptionSimpleEnum(Args);
    }

    if (ReducerName == TEXT("insert_option_string"))
    {
        FInsertOptionStringArgs Args = UE::SpacetimeDB::Deserialize<FInsertOptionStringArgs>(Event.ReducerCall.Args);
        return FReducer::InsertOptionString(Args);
    }

    if (ReducerName == TEXT("insert_option_vec_option_i32"))
    {
        FInsertOptionVecOptionI32Args Args = UE::SpacetimeDB::Deserialize<FInsertOptionVecOptionI32Args>(Event.ReducerCall.Args);
        return FReducer::InsertOptionVecOptionI32(Args);
    }

    if (ReducerName == TEXT("insert_pk_bool"))
    {
        FInsertPkBoolArgs Args = UE::SpacetimeDB::Deserialize<FInsertPkBoolArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPkBool(Args);
    }

    if (ReducerName == TEXT("insert_pk_connection_id"))
    {
        FInsertPkConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertPkConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPkConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_pk_i128"))
    {
        FInsertPkI128Args Args = UE::SpacetimeDB::Deserialize<FInsertPkI128Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkI128(Args);
    }

    if (ReducerName == TEXT("insert_pk_i16"))
    {
        FInsertPkI16Args Args = UE::SpacetimeDB::Deserialize<FInsertPkI16Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkI16(Args);
    }

    if (ReducerName == TEXT("insert_pk_i256"))
    {
        FInsertPkI256Args Args = UE::SpacetimeDB::Deserialize<FInsertPkI256Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkI256(Args);
    }

    if (ReducerName == TEXT("insert_pk_i32"))
    {
        FInsertPkI32Args Args = UE::SpacetimeDB::Deserialize<FInsertPkI32Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkI32(Args);
    }

    if (ReducerName == TEXT("insert_pk_i64"))
    {
        FInsertPkI64Args Args = UE::SpacetimeDB::Deserialize<FInsertPkI64Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkI64(Args);
    }

    if (ReducerName == TEXT("insert_pk_i8"))
    {
        FInsertPkI8Args Args = UE::SpacetimeDB::Deserialize<FInsertPkI8Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkI8(Args);
    }

    if (ReducerName == TEXT("insert_pk_identity"))
    {
        FInsertPkIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertPkIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPkIdentity(Args);
    }

    if (ReducerName == TEXT("insert_pk_simple_enum"))
    {
        FInsertPkSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FInsertPkSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPkSimpleEnum(Args);
    }

    if (ReducerName == TEXT("insert_pk_string"))
    {
        FInsertPkStringArgs Args = UE::SpacetimeDB::Deserialize<FInsertPkStringArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPkString(Args);
    }

    if (ReducerName == TEXT("insert_pk_u128"))
    {
        FInsertPkU128Args Args = UE::SpacetimeDB::Deserialize<FInsertPkU128Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkU128(Args);
    }

    if (ReducerName == TEXT("insert_pk_u16"))
    {
        FInsertPkU16Args Args = UE::SpacetimeDB::Deserialize<FInsertPkU16Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkU16(Args);
    }

    if (ReducerName == TEXT("insert_pk_u256"))
    {
        FInsertPkU256Args Args = UE::SpacetimeDB::Deserialize<FInsertPkU256Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkU256(Args);
    }

    if (ReducerName == TEXT("insert_pk_u32"))
    {
        FInsertPkU32Args Args = UE::SpacetimeDB::Deserialize<FInsertPkU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkU32(Args);
    }

    if (ReducerName == TEXT("insert_pk_u32_two"))
    {
        FInsertPkU32TwoArgs Args = UE::SpacetimeDB::Deserialize<FInsertPkU32TwoArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPkU32Two(Args);
    }

    if (ReducerName == TEXT("insert_pk_u64"))
    {
        FInsertPkU64Args Args = UE::SpacetimeDB::Deserialize<FInsertPkU64Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkU64(Args);
    }

    if (ReducerName == TEXT("insert_pk_u8"))
    {
        FInsertPkU8Args Args = UE::SpacetimeDB::Deserialize<FInsertPkU8Args>(Event.ReducerCall.Args);
        return FReducer::InsertPkU8(Args);
    }

    if (ReducerName == TEXT("insert_primitives_as_strings"))
    {
        FInsertPrimitivesAsStringsArgs Args = UE::SpacetimeDB::Deserialize<FInsertPrimitivesAsStringsArgs>(Event.ReducerCall.Args);
        return FReducer::InsertPrimitivesAsStrings(Args);
    }

    if (ReducerName == TEXT("insert_table_holds_table"))
    {
        FInsertTableHoldsTableArgs Args = UE::SpacetimeDB::Deserialize<FInsertTableHoldsTableArgs>(Event.ReducerCall.Args);
        return FReducer::InsertTableHoldsTable(Args);
    }

    if (ReducerName == TEXT("insert_unique_bool"))
    {
        FInsertUniqueBoolArgs Args = UE::SpacetimeDB::Deserialize<FInsertUniqueBoolArgs>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueBool(Args);
    }

    if (ReducerName == TEXT("insert_unique_connection_id"))
    {
        FInsertUniqueConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertUniqueConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_unique_i128"))
    {
        FInsertUniqueI128Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueI128Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueI128(Args);
    }

    if (ReducerName == TEXT("insert_unique_i16"))
    {
        FInsertUniqueI16Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueI16Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueI16(Args);
    }

    if (ReducerName == TEXT("insert_unique_i256"))
    {
        FInsertUniqueI256Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueI256Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueI256(Args);
    }

    if (ReducerName == TEXT("insert_unique_i32"))
    {
        FInsertUniqueI32Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueI32Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueI32(Args);
    }

    if (ReducerName == TEXT("insert_unique_i64"))
    {
        FInsertUniqueI64Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueI64Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueI64(Args);
    }

    if (ReducerName == TEXT("insert_unique_i8"))
    {
        FInsertUniqueI8Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueI8Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueI8(Args);
    }

    if (ReducerName == TEXT("insert_unique_identity"))
    {
        FInsertUniqueIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertUniqueIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueIdentity(Args);
    }

    if (ReducerName == TEXT("insert_unique_string"))
    {
        FInsertUniqueStringArgs Args = UE::SpacetimeDB::Deserialize<FInsertUniqueStringArgs>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueString(Args);
    }

    if (ReducerName == TEXT("insert_unique_u128"))
    {
        FInsertUniqueU128Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU128Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU128(Args);
    }

    if (ReducerName == TEXT("insert_unique_u16"))
    {
        FInsertUniqueU16Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU16Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU16(Args);
    }

    if (ReducerName == TEXT("insert_unique_u256"))
    {
        FInsertUniqueU256Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU256Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU256(Args);
    }

    if (ReducerName == TEXT("insert_unique_u32"))
    {
        FInsertUniqueU32Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU32(Args);
    }

    if (ReducerName == TEXT("insert_unique_u32_update_pk_u32"))
    {
        FInsertUniqueU32UpdatePkU32Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU32UpdatePkU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU32UpdatePkU32(Args);
    }

    if (ReducerName == TEXT("insert_unique_u64"))
    {
        FInsertUniqueU64Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU64Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU64(Args);
    }

    if (ReducerName == TEXT("insert_unique_u8"))
    {
        FInsertUniqueU8Args Args = UE::SpacetimeDB::Deserialize<FInsertUniqueU8Args>(Event.ReducerCall.Args);
        return FReducer::InsertUniqueU8(Args);
    }

    if (ReducerName == TEXT("insert_user"))
    {
        FInsertUserArgs Args = UE::SpacetimeDB::Deserialize<FInsertUserArgs>(Event.ReducerCall.Args);
        return FReducer::InsertUser(Args);
    }

    if (ReducerName == TEXT("insert_vec_bool"))
    {
        FInsertVecBoolArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecBoolArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecBool(Args);
    }

    if (ReducerName == TEXT("insert_vec_byte_struct"))
    {
        FInsertVecByteStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecByteStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecByteStruct(Args);
    }

    if (ReducerName == TEXT("insert_vec_connection_id"))
    {
        FInsertVecConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecConnectionId(Args);
    }

    if (ReducerName == TEXT("insert_vec_enum_with_payload"))
    {
        FInsertVecEnumWithPayloadArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecEnumWithPayloadArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecEnumWithPayload(Args);
    }

    if (ReducerName == TEXT("insert_vec_every_primitive_struct"))
    {
        FInsertVecEveryPrimitiveStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecEveryPrimitiveStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecEveryPrimitiveStruct(Args);
    }

    if (ReducerName == TEXT("insert_vec_every_vec_struct"))
    {
        FInsertVecEveryVecStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecEveryVecStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecEveryVecStruct(Args);
    }

    if (ReducerName == TEXT("insert_vec_f32"))
    {
        FInsertVecF32Args Args = UE::SpacetimeDB::Deserialize<FInsertVecF32Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecF32(Args);
    }

    if (ReducerName == TEXT("insert_vec_f64"))
    {
        FInsertVecF64Args Args = UE::SpacetimeDB::Deserialize<FInsertVecF64Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecF64(Args);
    }

    if (ReducerName == TEXT("insert_vec_i128"))
    {
        FInsertVecI128Args Args = UE::SpacetimeDB::Deserialize<FInsertVecI128Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecI128(Args);
    }

    if (ReducerName == TEXT("insert_vec_i16"))
    {
        FInsertVecI16Args Args = UE::SpacetimeDB::Deserialize<FInsertVecI16Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecI16(Args);
    }

    if (ReducerName == TEXT("insert_vec_i256"))
    {
        FInsertVecI256Args Args = UE::SpacetimeDB::Deserialize<FInsertVecI256Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecI256(Args);
    }

    if (ReducerName == TEXT("insert_vec_i32"))
    {
        FInsertVecI32Args Args = UE::SpacetimeDB::Deserialize<FInsertVecI32Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecI32(Args);
    }

    if (ReducerName == TEXT("insert_vec_i64"))
    {
        FInsertVecI64Args Args = UE::SpacetimeDB::Deserialize<FInsertVecI64Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecI64(Args);
    }

    if (ReducerName == TEXT("insert_vec_i8"))
    {
        FInsertVecI8Args Args = UE::SpacetimeDB::Deserialize<FInsertVecI8Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecI8(Args);
    }

    if (ReducerName == TEXT("insert_vec_identity"))
    {
        FInsertVecIdentityArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecIdentity(Args);
    }

    if (ReducerName == TEXT("insert_vec_simple_enum"))
    {
        FInsertVecSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecSimpleEnum(Args);
    }

    if (ReducerName == TEXT("insert_vec_string"))
    {
        FInsertVecStringArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecStringArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecString(Args);
    }

    if (ReducerName == TEXT("insert_vec_timestamp"))
    {
        FInsertVecTimestampArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecTimestampArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecTimestamp(Args);
    }

    if (ReducerName == TEXT("insert_vec_u128"))
    {
        FInsertVecU128Args Args = UE::SpacetimeDB::Deserialize<FInsertVecU128Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecU128(Args);
    }

    if (ReducerName == TEXT("insert_vec_u16"))
    {
        FInsertVecU16Args Args = UE::SpacetimeDB::Deserialize<FInsertVecU16Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecU16(Args);
    }

    if (ReducerName == TEXT("insert_vec_u256"))
    {
        FInsertVecU256Args Args = UE::SpacetimeDB::Deserialize<FInsertVecU256Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecU256(Args);
    }

    if (ReducerName == TEXT("insert_vec_u32"))
    {
        FInsertVecU32Args Args = UE::SpacetimeDB::Deserialize<FInsertVecU32Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecU32(Args);
    }

    if (ReducerName == TEXT("insert_vec_u64"))
    {
        FInsertVecU64Args Args = UE::SpacetimeDB::Deserialize<FInsertVecU64Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecU64(Args);
    }

    if (ReducerName == TEXT("insert_vec_u8"))
    {
        FInsertVecU8Args Args = UE::SpacetimeDB::Deserialize<FInsertVecU8Args>(Event.ReducerCall.Args);
        return FReducer::InsertVecU8(Args);
    }

    if (ReducerName == TEXT("insert_vec_unit_struct"))
    {
        FInsertVecUnitStructArgs Args = UE::SpacetimeDB::Deserialize<FInsertVecUnitStructArgs>(Event.ReducerCall.Args);
        return FReducer::InsertVecUnitStruct(Args);
    }

    if (ReducerName == TEXT("no_op_succeeds"))
    {
        FNoOpSucceedsArgs Args = UE::SpacetimeDB::Deserialize<FNoOpSucceedsArgs>(Event.ReducerCall.Args);
        return FReducer::NoOpSucceeds(Args);
    }

    if (ReducerName == TEXT("send_scheduled_message"))
    {
        FSendScheduledMessageArgs Args = UE::SpacetimeDB::Deserialize<FSendScheduledMessageArgs>(Event.ReducerCall.Args);
        return FReducer::SendScheduledMessage(Args);
    }

    if (ReducerName == TEXT("update_indexed_simple_enum"))
    {
        FUpdateIndexedSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FUpdateIndexedSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::UpdateIndexedSimpleEnum(Args);
    }

    if (ReducerName == TEXT("update_pk_bool"))
    {
        FUpdatePkBoolArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePkBoolArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePkBool(Args);
    }

    if (ReducerName == TEXT("update_pk_connection_id"))
    {
        FUpdatePkConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePkConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePkConnectionId(Args);
    }

    if (ReducerName == TEXT("update_pk_i128"))
    {
        FUpdatePkI128Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkI128Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkI128(Args);
    }

    if (ReducerName == TEXT("update_pk_i16"))
    {
        FUpdatePkI16Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkI16Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkI16(Args);
    }

    if (ReducerName == TEXT("update_pk_i256"))
    {
        FUpdatePkI256Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkI256Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkI256(Args);
    }

    if (ReducerName == TEXT("update_pk_i32"))
    {
        FUpdatePkI32Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkI32Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkI32(Args);
    }

    if (ReducerName == TEXT("update_pk_i64"))
    {
        FUpdatePkI64Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkI64Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkI64(Args);
    }

    if (ReducerName == TEXT("update_pk_i8"))
    {
        FUpdatePkI8Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkI8Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkI8(Args);
    }

    if (ReducerName == TEXT("update_pk_identity"))
    {
        FUpdatePkIdentityArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePkIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePkIdentity(Args);
    }

    if (ReducerName == TEXT("update_pk_simple_enum"))
    {
        FUpdatePkSimpleEnumArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePkSimpleEnumArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePkSimpleEnum(Args);
    }

    if (ReducerName == TEXT("update_pk_string"))
    {
        FUpdatePkStringArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePkStringArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePkString(Args);
    }

    if (ReducerName == TEXT("update_pk_u128"))
    {
        FUpdatePkU128Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkU128Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU128(Args);
    }

    if (ReducerName == TEXT("update_pk_u16"))
    {
        FUpdatePkU16Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkU16Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU16(Args);
    }

    if (ReducerName == TEXT("update_pk_u256"))
    {
        FUpdatePkU256Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkU256Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU256(Args);
    }

    if (ReducerName == TEXT("update_pk_u32"))
    {
        FUpdatePkU32Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkU32Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU32(Args);
    }

    if (ReducerName == TEXT("update_pk_u32_two"))
    {
        FUpdatePkU32TwoArgs Args = UE::SpacetimeDB::Deserialize<FUpdatePkU32TwoArgs>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU32Two(Args);
    }

    if (ReducerName == TEXT("update_pk_u64"))
    {
        FUpdatePkU64Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkU64Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU64(Args);
    }

    if (ReducerName == TEXT("update_pk_u8"))
    {
        FUpdatePkU8Args Args = UE::SpacetimeDB::Deserialize<FUpdatePkU8Args>(Event.ReducerCall.Args);
        return FReducer::UpdatePkU8(Args);
    }

    if (ReducerName == TEXT("update_unique_bool"))
    {
        FUpdateUniqueBoolArgs Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueBoolArgs>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueBool(Args);
    }

    if (ReducerName == TEXT("update_unique_connection_id"))
    {
        FUpdateUniqueConnectionIdArgs Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueConnectionIdArgs>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueConnectionId(Args);
    }

    if (ReducerName == TEXT("update_unique_i128"))
    {
        FUpdateUniqueI128Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueI128Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueI128(Args);
    }

    if (ReducerName == TEXT("update_unique_i16"))
    {
        FUpdateUniqueI16Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueI16Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueI16(Args);
    }

    if (ReducerName == TEXT("update_unique_i256"))
    {
        FUpdateUniqueI256Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueI256Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueI256(Args);
    }

    if (ReducerName == TEXT("update_unique_i32"))
    {
        FUpdateUniqueI32Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueI32Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueI32(Args);
    }

    if (ReducerName == TEXT("update_unique_i64"))
    {
        FUpdateUniqueI64Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueI64Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueI64(Args);
    }

    if (ReducerName == TEXT("update_unique_i8"))
    {
        FUpdateUniqueI8Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueI8Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueI8(Args);
    }

    if (ReducerName == TEXT("update_unique_identity"))
    {
        FUpdateUniqueIdentityArgs Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueIdentityArgs>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueIdentity(Args);
    }

    if (ReducerName == TEXT("update_unique_string"))
    {
        FUpdateUniqueStringArgs Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueStringArgs>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueString(Args);
    }

    if (ReducerName == TEXT("update_unique_u128"))
    {
        FUpdateUniqueU128Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueU128Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueU128(Args);
    }

    if (ReducerName == TEXT("update_unique_u16"))
    {
        FUpdateUniqueU16Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueU16Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueU16(Args);
    }

    if (ReducerName == TEXT("update_unique_u256"))
    {
        FUpdateUniqueU256Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueU256Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueU256(Args);
    }

    if (ReducerName == TEXT("update_unique_u32"))
    {
        FUpdateUniqueU32Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueU32Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueU32(Args);
    }

    if (ReducerName == TEXT("update_unique_u64"))
    {
        FUpdateUniqueU64Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueU64Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueU64(Args);
    }

    if (ReducerName == TEXT("update_unique_u8"))
    {
        FUpdateUniqueU8Args Args = UE::SpacetimeDB::Deserialize<FUpdateUniqueU8Args>(Event.ReducerCall.Args);
        return FReducer::UpdateUniqueU8(Args);
    }

    return FReducer();
}

UDbConnection::UDbConnection(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	SetReducerFlags = ObjectInitializer.CreateDefaultSubobject<USetReducerFlags>(this, TEXT("SetReducerFlags"));

	Db = ObjectInitializer.CreateDefaultSubobject<URemoteTables>(this, TEXT("RemoteTables"));
	Db->Initialize();
	
	Reducers = ObjectInitializer.CreateDefaultSubobject<URemoteReducers>(this, TEXT("RemoteReducers"));
	Reducers->SetCallReducerFlags = SetReducerFlags;
	Reducers->Conn = this;

	RegisterTable<FUsersType, UUsersTable, FEventContext>(TEXT("users"), Db->Users);
	RegisterTable<FUniqueI32Type, UUniqueI32Table, FEventContext>(TEXT("unique_i32"), Db->UniqueI32);
	RegisterTable<FOneTimestampType, UOneTimestampTable, FEventContext>(TEXT("one_timestamp"), Db->OneTimestamp);
	RegisterTable<FVecI8Type, UVecI8Table, FEventContext>(TEXT("vec_i8"), Db->VecI8);
	RegisterTable<FBTreeU32Type, UBTreeU32Table, FEventContext>(TEXT("btree_u32"), Db->BtreeU32);
	RegisterTable<FVecByteStructType, UVecByteStructTable, FEventContext>(TEXT("vec_byte_struct"), Db->VecByteStruct);
	RegisterTable<FVecI256Type, UVecI256Table, FEventContext>(TEXT("vec_i256"), Db->VecI256);
	RegisterTable<FVecU16Type, UVecU16Table, FEventContext>(TEXT("vec_u16"), Db->VecU16);
	RegisterTable<FUniqueU16Type, UUniqueU16Table, FEventContext>(TEXT("unique_u16"), Db->UniqueU16);
	RegisterTable<FVecI128Type, UVecI128Table, FEventContext>(TEXT("vec_i128"), Db->VecI128);
	RegisterTable<FScheduledTableType, UScheduledTableTable, FEventContext>(TEXT("scheduled_table"), Db->ScheduledTable);
	RegisterTable<FVecI16Type, UVecI16Table, FEventContext>(TEXT("vec_i16"), Db->VecI16);
	RegisterTable<FPkBoolType, UPkBoolTable, FEventContext>(TEXT("pk_bool"), Db->PkBool);
	RegisterTable<FOneI32Type, UOneI32Table, FEventContext>(TEXT("one_i32"), Db->OneI32);
	RegisterTable<FVecU256Type, UVecU256Table, FEventContext>(TEXT("vec_u256"), Db->VecU256);
	RegisterTable<FOneEveryPrimitiveStructType, UOneEveryPrimitiveStructTable, FEventContext>(TEXT("one_every_primitive_struct"), Db->OneEveryPrimitiveStruct);
	RegisterTable<FPkI64Type, UPkI64Table, FEventContext>(TEXT("pk_i64"), Db->PkI64);
	RegisterTable<FPkI32Type, UPkI32Table, FEventContext>(TEXT("pk_i32"), Db->PkI32);
	RegisterTable<FOneStringType, UOneStringTable, FEventContext>(TEXT("one_string"), Db->OneString);
	RegisterTable<FOptionStringType, UOptionStringTable, FEventContext>(TEXT("option_string"), Db->OptionString);
	RegisterTable<FOneUnitStructType, UOneUnitStructTable, FEventContext>(TEXT("one_unit_struct"), Db->OneUnitStruct);
	RegisterTable<FPkIdentityType, UPkIdentityTable, FEventContext>(TEXT("pk_identity"), Db->PkIdentity);
	RegisterTable<FOptionEveryPrimitiveStructType, UOptionEveryPrimitiveStructTable, FEventContext>(TEXT("option_every_primitive_struct"), Db->OptionEveryPrimitiveStruct);
	RegisterTable<FUniqueI64Type, UUniqueI64Table, FEventContext>(TEXT("unique_i64"), Db->UniqueI64);
	RegisterTable<FPkU128Type, UPkU128Table, FEventContext>(TEXT("pk_u128"), Db->PkU128);
	RegisterTable<FPkConnectionIdType, UPkConnectionIdTable, FEventContext>(TEXT("pk_connection_id"), Db->PkConnectionId);
	RegisterTable<FVecConnectionIdType, UVecConnectionIdTable, FEventContext>(TEXT("vec_connection_id"), Db->VecConnectionId);
	RegisterTable<FVecI32Type, UVecI32Table, FEventContext>(TEXT("vec_i32"), Db->VecI32);
	RegisterTable<FVecTimestampType, UVecTimestampTable, FEventContext>(TEXT("vec_timestamp"), Db->VecTimestamp);
	RegisterTable<FOneEveryVecStructType, UOneEveryVecStructTable, FEventContext>(TEXT("one_every_vec_struct"), Db->OneEveryVecStruct);
	RegisterTable<FOneF32Type, UOneF32Table, FEventContext>(TEXT("one_f32"), Db->OneF32);
	RegisterTable<FOneU8Type, UOneU8Table, FEventContext>(TEXT("one_u8"), Db->OneU8);
	RegisterTable<FOptionVecOptionI32Type, UOptionVecOptionI32Table, FEventContext>(TEXT("option_vec_option_i32"), Db->OptionVecOptionI32);
	RegisterTable<FOneU256Type, UOneU256Table, FEventContext>(TEXT("one_u256"), Db->OneU256);
	RegisterTable<FUniqueIdentityType, UUniqueIdentityTable, FEventContext>(TEXT("unique_identity"), Db->UniqueIdentity);
	RegisterTable<FVecStringType, UVecStringTable, FEventContext>(TEXT("vec_string"), Db->VecString);
	RegisterTable<FUniqueConnectionIdType, UUniqueConnectionIdTable, FEventContext>(TEXT("unique_connection_id"), Db->UniqueConnectionId);
	RegisterTable<FVecU32Type, UVecU32Table, FEventContext>(TEXT("vec_u32"), Db->VecU32);
	RegisterTable<FLargeTableType, ULargeTableTable, FEventContext>(TEXT("large_table"), Db->LargeTable);
	RegisterTable<FVecUnitStructType, UVecUnitStructTable, FEventContext>(TEXT("vec_unit_struct"), Db->VecUnitStruct);
	RegisterTable<FOneI8Type, UOneI8Table, FEventContext>(TEXT("one_i8"), Db->OneI8);
	RegisterTable<FPkI16Type, UPkI16Table, FEventContext>(TEXT("pk_i16"), Db->PkI16);
	RegisterTable<FUniqueI16Type, UUniqueI16Table, FEventContext>(TEXT("unique_i16"), Db->UniqueI16);
	RegisterTable<FUniqueU8Type, UUniqueU8Table, FEventContext>(TEXT("unique_u8"), Db->UniqueU8);
	RegisterTable<FOptionIdentityType, UOptionIdentityTable, FEventContext>(TEXT("option_identity"), Db->OptionIdentity);
	RegisterTable<FUniqueI256Type, UUniqueI256Table, FEventContext>(TEXT("unique_i256"), Db->UniqueI256);
	RegisterTable<FIndexedTableType, UIndexedTableTable, FEventContext>(TEXT("indexed_table"), Db->IndexedTable);
	RegisterTable<FVecEveryVecStructType, UVecEveryVecStructTable, FEventContext>(TEXT("vec_every_vec_struct"), Db->VecEveryVecStruct);
	RegisterTable<FVecU128Type, UVecU128Table, FEventContext>(TEXT("vec_u128"), Db->VecU128);
	RegisterTable<FUniqueU256Type, UUniqueU256Table, FEventContext>(TEXT("unique_u256"), Db->UniqueU256);
	RegisterTable<FVecF32Type, UVecF32Table, FEventContext>(TEXT("vec_f32"), Db->VecF32);
	RegisterTable<FVecIdentityType, UVecIdentityTable, FEventContext>(TEXT("vec_identity"), Db->VecIdentity);
	RegisterTable<FOptionI32Type, UOptionI32Table, FEventContext>(TEXT("option_i32"), Db->OptionI32);
	RegisterTable<FOneU16Type, UOneU16Table, FEventContext>(TEXT("one_u16"), Db->OneU16);
	RegisterTable<FOneU32Type, UOneU32Table, FEventContext>(TEXT("one_u32"), Db->OneU32);
	RegisterTable<FOneI128Type, UOneI128Table, FEventContext>(TEXT("one_i128"), Db->OneI128);
	RegisterTable<FUniqueI128Type, UUniqueI128Table, FEventContext>(TEXT("unique_i128"), Db->UniqueI128);
	RegisterTable<FUniqueU128Type, UUniqueU128Table, FEventContext>(TEXT("unique_u128"), Db->UniqueU128);
	RegisterTable<FPkI8Type, UPkI8Table, FEventContext>(TEXT("pk_i8"), Db->PkI8);
	RegisterTable<FOneEnumWithPayloadType, UOneEnumWithPayloadTable, FEventContext>(TEXT("one_enum_with_payload"), Db->OneEnumWithPayload);
	RegisterTable<FOneByteStructType, UOneByteStructTable, FEventContext>(TEXT("one_byte_struct"), Db->OneByteStruct);
	RegisterTable<FPkU64Type, UPkU64Table, FEventContext>(TEXT("pk_u64"), Db->PkU64);
	RegisterTable<FPkU256Type, UPkU256Table, FEventContext>(TEXT("pk_u256"), Db->PkU256);
	RegisterTable<FTableHoldsTableType, UTableHoldsTableTable, FEventContext>(TEXT("table_holds_table"), Db->TableHoldsTable);
	RegisterTable<FVecI64Type, UVecI64Table, FEventContext>(TEXT("vec_i64"), Db->VecI64);
	RegisterTable<FUniqueU64Type, UUniqueU64Table, FEventContext>(TEXT("unique_u64"), Db->UniqueU64);
	RegisterTable<FVecU8Type, UVecU8Table, FEventContext>(TEXT("vec_u8"), Db->VecU8);
	RegisterTable<FOneF64Type, UOneF64Table, FEventContext>(TEXT("one_f64"), Db->OneF64);
	RegisterTable<FOneBoolType, UOneBoolTable, FEventContext>(TEXT("one_bool"), Db->OneBool);
	RegisterTable<FVecEnumWithPayloadType, UVecEnumWithPayloadTable, FEventContext>(TEXT("vec_enum_with_payload"), Db->VecEnumWithPayload);
	RegisterTable<FOneConnectionIdType, UOneConnectionIdTable, FEventContext>(TEXT("one_connection_id"), Db->OneConnectionId);
	RegisterTable<FPkI128Type, UPkI128Table, FEventContext>(TEXT("pk_i128"), Db->PkI128);
	RegisterTable<FOneU128Type, UOneU128Table, FEventContext>(TEXT("one_u128"), Db->OneU128);
	RegisterTable<FIndexedTable2Type, UIndexedTable2Table, FEventContext>(TEXT("indexed_table_2"), Db->IndexedTable2);
	RegisterTable<FOneI16Type, UOneI16Table, FEventContext>(TEXT("one_i16"), Db->OneI16);
	RegisterTable<FOneI64Type, UOneI64Table, FEventContext>(TEXT("one_i64"), Db->OneI64);
	RegisterTable<FOptionSimpleEnumType, UOptionSimpleEnumTable, FEventContext>(TEXT("option_simple_enum"), Db->OptionSimpleEnum);
	RegisterTable<FPkSimpleEnumType, UPkSimpleEnumTable, FEventContext>(TEXT("pk_simple_enum"), Db->PkSimpleEnum);
	RegisterTable<FPkStringType, UPkStringTable, FEventContext>(TEXT("pk_string"), Db->PkString);
	RegisterTable<FPkU8Type, UPkU8Table, FEventContext>(TEXT("pk_u8"), Db->PkU8);
	RegisterTable<FUniqueBoolType, UUniqueBoolTable, FEventContext>(TEXT("unique_bool"), Db->UniqueBool);
	RegisterTable<FVecBoolType, UVecBoolTable, FEventContext>(TEXT("vec_bool"), Db->VecBool);
	RegisterTable<FVecEveryPrimitiveStructType, UVecEveryPrimitiveStructTable, FEventContext>(TEXT("vec_every_primitive_struct"), Db->VecEveryPrimitiveStruct);
	RegisterTable<FIndexedSimpleEnumType, UIndexedSimpleEnumTable, FEventContext>(TEXT("indexed_simple_enum"), Db->IndexedSimpleEnum);
	RegisterTable<FPkU32Type, UPkU32Table, FEventContext>(TEXT("pk_u32"), Db->PkU32);
	RegisterTable<FUniqueI8Type, UUniqueI8Table, FEventContext>(TEXT("unique_i8"), Db->UniqueI8);
	RegisterTable<FUniqueStringType, UUniqueStringTable, FEventContext>(TEXT("unique_string"), Db->UniqueString);
	RegisterTable<FVecF64Type, UVecF64Table, FEventContext>(TEXT("vec_f64"), Db->VecF64);
	RegisterTable<FOneU64Type, UOneU64Table, FEventContext>(TEXT("one_u64"), Db->OneU64);
	RegisterTable<FOneIdentityType, UOneIdentityTable, FEventContext>(TEXT("one_identity"), Db->OneIdentity);
	RegisterTable<FPkU16Type, UPkU16Table, FEventContext>(TEXT("pk_u16"), Db->PkU16);
	RegisterTable<FVecSimpleEnumType, UVecSimpleEnumTable, FEventContext>(TEXT("vec_simple_enum"), Db->VecSimpleEnum);
	RegisterTable<FOneSimpleEnumType, UOneSimpleEnumTable, FEventContext>(TEXT("one_simple_enum"), Db->OneSimpleEnum);
	RegisterTable<FPkU32TwoType, UPkU32TwoTable, FEventContext>(TEXT("pk_u32_two"), Db->PkU32Two);
	RegisterTable<FUniqueU32Type, UUniqueU32Table, FEventContext>(TEXT("unique_u32"), Db->UniqueU32);
	RegisterTable<FVecU64Type, UVecU64Table, FEventContext>(TEXT("vec_u64"), Db->VecU64);
	RegisterTable<FPkI256Type, UPkI256Table, FEventContext>(TEXT("pk_i256"), Db->PkI256);
	RegisterTable<FOneI256Type, UOneI256Table, FEventContext>(TEXT("one_i256"), Db->OneI256);
}

FContextBase::FContextBase(UDbConnection* InConn)
{
	Db = InConn->Db;
	Reducers = InConn->Reducers;
	SetReducerFlags = InConn->SetReducerFlags;
	Conn = InConn;
}
bool FContextBase::IsActive() const
{
	return Conn->IsActive();
}
void FContextBase::Disconnect()
{
	Conn->Disconnect();
}
USubscriptionBuilder* FContextBase::SubscriptionBuilder()
{
	return Conn->SubscriptionBuilder();
}
bool FContextBase::TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const
{
	return Conn->TryGetIdentity(OutIdentity);
}
FSpacetimeDBConnectionId FContextBase::GetConnectionId() const
{
	return Conn->GetConnectionId();
}

void URemoteTables::Initialize()
{

	/** Creating tables */
	Users = NewObject<UUsersTable>(this);
	UniqueI32 = NewObject<UUniqueI32Table>(this);
	OneTimestamp = NewObject<UOneTimestampTable>(this);
	VecI8 = NewObject<UVecI8Table>(this);
	BtreeU32 = NewObject<UBTreeU32Table>(this);
	VecByteStruct = NewObject<UVecByteStructTable>(this);
	VecI256 = NewObject<UVecI256Table>(this);
	VecU16 = NewObject<UVecU16Table>(this);
	UniqueU16 = NewObject<UUniqueU16Table>(this);
	VecI128 = NewObject<UVecI128Table>(this);
	ScheduledTable = NewObject<UScheduledTableTable>(this);
	VecI16 = NewObject<UVecI16Table>(this);
	PkBool = NewObject<UPkBoolTable>(this);
	OneI32 = NewObject<UOneI32Table>(this);
	VecU256 = NewObject<UVecU256Table>(this);
	OneEveryPrimitiveStruct = NewObject<UOneEveryPrimitiveStructTable>(this);
	PkI64 = NewObject<UPkI64Table>(this);
	PkI32 = NewObject<UPkI32Table>(this);
	OneString = NewObject<UOneStringTable>(this);
	OptionString = NewObject<UOptionStringTable>(this);
	OneUnitStruct = NewObject<UOneUnitStructTable>(this);
	PkIdentity = NewObject<UPkIdentityTable>(this);
	OptionEveryPrimitiveStruct = NewObject<UOptionEveryPrimitiveStructTable>(this);
	UniqueI64 = NewObject<UUniqueI64Table>(this);
	PkU128 = NewObject<UPkU128Table>(this);
	PkConnectionId = NewObject<UPkConnectionIdTable>(this);
	VecConnectionId = NewObject<UVecConnectionIdTable>(this);
	VecI32 = NewObject<UVecI32Table>(this);
	VecTimestamp = NewObject<UVecTimestampTable>(this);
	OneEveryVecStruct = NewObject<UOneEveryVecStructTable>(this);
	OneF32 = NewObject<UOneF32Table>(this);
	OneU8 = NewObject<UOneU8Table>(this);
	OptionVecOptionI32 = NewObject<UOptionVecOptionI32Table>(this);
	OneU256 = NewObject<UOneU256Table>(this);
	UniqueIdentity = NewObject<UUniqueIdentityTable>(this);
	VecString = NewObject<UVecStringTable>(this);
	UniqueConnectionId = NewObject<UUniqueConnectionIdTable>(this);
	VecU32 = NewObject<UVecU32Table>(this);
	LargeTable = NewObject<ULargeTableTable>(this);
	VecUnitStruct = NewObject<UVecUnitStructTable>(this);
	OneI8 = NewObject<UOneI8Table>(this);
	PkI16 = NewObject<UPkI16Table>(this);
	UniqueI16 = NewObject<UUniqueI16Table>(this);
	UniqueU8 = NewObject<UUniqueU8Table>(this);
	OptionIdentity = NewObject<UOptionIdentityTable>(this);
	UniqueI256 = NewObject<UUniqueI256Table>(this);
	IndexedTable = NewObject<UIndexedTableTable>(this);
	VecEveryVecStruct = NewObject<UVecEveryVecStructTable>(this);
	VecU128 = NewObject<UVecU128Table>(this);
	UniqueU256 = NewObject<UUniqueU256Table>(this);
	VecF32 = NewObject<UVecF32Table>(this);
	VecIdentity = NewObject<UVecIdentityTable>(this);
	OptionI32 = NewObject<UOptionI32Table>(this);
	OneU16 = NewObject<UOneU16Table>(this);
	OneU32 = NewObject<UOneU32Table>(this);
	OneI128 = NewObject<UOneI128Table>(this);
	UniqueI128 = NewObject<UUniqueI128Table>(this);
	UniqueU128 = NewObject<UUniqueU128Table>(this);
	PkI8 = NewObject<UPkI8Table>(this);
	OneEnumWithPayload = NewObject<UOneEnumWithPayloadTable>(this);
	OneByteStruct = NewObject<UOneByteStructTable>(this);
	PkU64 = NewObject<UPkU64Table>(this);
	PkU256 = NewObject<UPkU256Table>(this);
	TableHoldsTable = NewObject<UTableHoldsTableTable>(this);
	VecI64 = NewObject<UVecI64Table>(this);
	UniqueU64 = NewObject<UUniqueU64Table>(this);
	VecU8 = NewObject<UVecU8Table>(this);
	OneF64 = NewObject<UOneF64Table>(this);
	OneBool = NewObject<UOneBoolTable>(this);
	VecEnumWithPayload = NewObject<UVecEnumWithPayloadTable>(this);
	OneConnectionId = NewObject<UOneConnectionIdTable>(this);
	PkI128 = NewObject<UPkI128Table>(this);
	OneU128 = NewObject<UOneU128Table>(this);
	IndexedTable2 = NewObject<UIndexedTable2Table>(this);
	OneI16 = NewObject<UOneI16Table>(this);
	OneI64 = NewObject<UOneI64Table>(this);
	OptionSimpleEnum = NewObject<UOptionSimpleEnumTable>(this);
	PkSimpleEnum = NewObject<UPkSimpleEnumTable>(this);
	PkString = NewObject<UPkStringTable>(this);
	PkU8 = NewObject<UPkU8Table>(this);
	UniqueBool = NewObject<UUniqueBoolTable>(this);
	VecBool = NewObject<UVecBoolTable>(this);
	VecEveryPrimitiveStruct = NewObject<UVecEveryPrimitiveStructTable>(this);
	IndexedSimpleEnum = NewObject<UIndexedSimpleEnumTable>(this);
	PkU32 = NewObject<UPkU32Table>(this);
	UniqueI8 = NewObject<UUniqueI8Table>(this);
	UniqueString = NewObject<UUniqueStringTable>(this);
	VecF64 = NewObject<UVecF64Table>(this);
	OneU64 = NewObject<UOneU64Table>(this);
	OneIdentity = NewObject<UOneIdentityTable>(this);
	PkU16 = NewObject<UPkU16Table>(this);
	VecSimpleEnum = NewObject<UVecSimpleEnumTable>(this);
	OneSimpleEnum = NewObject<UOneSimpleEnumTable>(this);
	PkU32Two = NewObject<UPkU32TwoTable>(this);
	UniqueU32 = NewObject<UUniqueU32Table>(this);
	VecU64 = NewObject<UVecU64Table>(this);
	PkI256 = NewObject<UPkI256Table>(this);
	OneI256 = NewObject<UOneI256Table>(this);
	/**/

	/** Initialization */
	Users->PostInitialize();
	UniqueI32->PostInitialize();
	OneTimestamp->PostInitialize();
	VecI8->PostInitialize();
	BtreeU32->PostInitialize();
	VecByteStruct->PostInitialize();
	VecI256->PostInitialize();
	VecU16->PostInitialize();
	UniqueU16->PostInitialize();
	VecI128->PostInitialize();
	ScheduledTable->PostInitialize();
	VecI16->PostInitialize();
	PkBool->PostInitialize();
	OneI32->PostInitialize();
	VecU256->PostInitialize();
	OneEveryPrimitiveStruct->PostInitialize();
	PkI64->PostInitialize();
	PkI32->PostInitialize();
	OneString->PostInitialize();
	OptionString->PostInitialize();
	OneUnitStruct->PostInitialize();
	PkIdentity->PostInitialize();
	OptionEveryPrimitiveStruct->PostInitialize();
	UniqueI64->PostInitialize();
	PkU128->PostInitialize();
	PkConnectionId->PostInitialize();
	VecConnectionId->PostInitialize();
	VecI32->PostInitialize();
	VecTimestamp->PostInitialize();
	OneEveryVecStruct->PostInitialize();
	OneF32->PostInitialize();
	OneU8->PostInitialize();
	OptionVecOptionI32->PostInitialize();
	OneU256->PostInitialize();
	UniqueIdentity->PostInitialize();
	VecString->PostInitialize();
	UniqueConnectionId->PostInitialize();
	VecU32->PostInitialize();
	LargeTable->PostInitialize();
	VecUnitStruct->PostInitialize();
	OneI8->PostInitialize();
	PkI16->PostInitialize();
	UniqueI16->PostInitialize();
	UniqueU8->PostInitialize();
	OptionIdentity->PostInitialize();
	UniqueI256->PostInitialize();
	IndexedTable->PostInitialize();
	VecEveryVecStruct->PostInitialize();
	VecU128->PostInitialize();
	UniqueU256->PostInitialize();
	VecF32->PostInitialize();
	VecIdentity->PostInitialize();
	OptionI32->PostInitialize();
	OneU16->PostInitialize();
	OneU32->PostInitialize();
	OneI128->PostInitialize();
	UniqueI128->PostInitialize();
	UniqueU128->PostInitialize();
	PkI8->PostInitialize();
	OneEnumWithPayload->PostInitialize();
	OneByteStruct->PostInitialize();
	PkU64->PostInitialize();
	PkU256->PostInitialize();
	TableHoldsTable->PostInitialize();
	VecI64->PostInitialize();
	UniqueU64->PostInitialize();
	VecU8->PostInitialize();
	OneF64->PostInitialize();
	OneBool->PostInitialize();
	VecEnumWithPayload->PostInitialize();
	OneConnectionId->PostInitialize();
	PkI128->PostInitialize();
	OneU128->PostInitialize();
	IndexedTable2->PostInitialize();
	OneI16->PostInitialize();
	OneI64->PostInitialize();
	OptionSimpleEnum->PostInitialize();
	PkSimpleEnum->PostInitialize();
	PkString->PostInitialize();
	PkU8->PostInitialize();
	UniqueBool->PostInitialize();
	VecBool->PostInitialize();
	VecEveryPrimitiveStruct->PostInitialize();
	IndexedSimpleEnum->PostInitialize();
	PkU32->PostInitialize();
	UniqueI8->PostInitialize();
	UniqueString->PostInitialize();
	VecF64->PostInitialize();
	OneU64->PostInitialize();
	OneIdentity->PostInitialize();
	PkU16->PostInitialize();
	VecSimpleEnum->PostInitialize();
	OneSimpleEnum->PostInitialize();
	PkU32Two->PostInitialize();
	UniqueU32->PostInitialize();
	VecU64->PostInitialize();
	PkI256->PostInitialize();
	OneI256->PostInitialize();
	/**/
}

void USetReducerFlags::DeleteFromBtreeU32(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteFromBtreeU32", Flag);
}
void USetReducerFlags::DeleteLargeTable(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteLargeTable", Flag);
}
void USetReducerFlags::DeletePkBool(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkBool", Flag);
}
void USetReducerFlags::DeletePkConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkConnectionId", Flag);
}
void USetReducerFlags::DeletePkI128(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkI128", Flag);
}
void USetReducerFlags::DeletePkI16(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkI16", Flag);
}
void USetReducerFlags::DeletePkI256(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkI256", Flag);
}
void USetReducerFlags::DeletePkI32(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkI32", Flag);
}
void USetReducerFlags::DeletePkI64(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkI64", Flag);
}
void USetReducerFlags::DeletePkI8(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkI8", Flag);
}
void USetReducerFlags::DeletePkIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkIdentity", Flag);
}
void USetReducerFlags::DeletePkString(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkString", Flag);
}
void USetReducerFlags::DeletePkU128(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU128", Flag);
}
void USetReducerFlags::DeletePkU16(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU16", Flag);
}
void USetReducerFlags::DeletePkU256(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU256", Flag);
}
void USetReducerFlags::DeletePkU32(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU32", Flag);
}
void USetReducerFlags::DeletePkU32InsertPkU32Two(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU32InsertPkU32Two", Flag);
}
void USetReducerFlags::DeletePkU32Two(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU32Two", Flag);
}
void USetReducerFlags::DeletePkU64(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU64", Flag);
}
void USetReducerFlags::DeletePkU8(ECallReducerFlags Flag)
{
	FlagMap.Add("DeletePkU8", Flag);
}
void USetReducerFlags::DeleteUniqueBool(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueBool", Flag);
}
void USetReducerFlags::DeleteUniqueConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueConnectionId", Flag);
}
void USetReducerFlags::DeleteUniqueI128(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueI128", Flag);
}
void USetReducerFlags::DeleteUniqueI16(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueI16", Flag);
}
void USetReducerFlags::DeleteUniqueI256(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueI256", Flag);
}
void USetReducerFlags::DeleteUniqueI32(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueI32", Flag);
}
void USetReducerFlags::DeleteUniqueI64(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueI64", Flag);
}
void USetReducerFlags::DeleteUniqueI8(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueI8", Flag);
}
void USetReducerFlags::DeleteUniqueIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueIdentity", Flag);
}
void USetReducerFlags::DeleteUniqueString(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueString", Flag);
}
void USetReducerFlags::DeleteUniqueU128(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueU128", Flag);
}
void USetReducerFlags::DeleteUniqueU16(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueU16", Flag);
}
void USetReducerFlags::DeleteUniqueU256(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueU256", Flag);
}
void USetReducerFlags::DeleteUniqueU32(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueU32", Flag);
}
void USetReducerFlags::DeleteUniqueU64(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueU64", Flag);
}
void USetReducerFlags::DeleteUniqueU8(ECallReducerFlags Flag)
{
	FlagMap.Add("DeleteUniqueU8", Flag);
}
void USetReducerFlags::InsertCallTimestamp(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallTimestamp", Flag);
}
void USetReducerFlags::InsertCallerOneConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerOneConnectionId", Flag);
}
void USetReducerFlags::InsertCallerOneIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerOneIdentity", Flag);
}
void USetReducerFlags::InsertCallerPkConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerPkConnectionId", Flag);
}
void USetReducerFlags::InsertCallerPkIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerPkIdentity", Flag);
}
void USetReducerFlags::InsertCallerUniqueConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerUniqueConnectionId", Flag);
}
void USetReducerFlags::InsertCallerUniqueIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerUniqueIdentity", Flag);
}
void USetReducerFlags::InsertCallerVecConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerVecConnectionId", Flag);
}
void USetReducerFlags::InsertCallerVecIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertCallerVecIdentity", Flag);
}
void USetReducerFlags::InsertIntoBtreeU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertIntoBtreeU32", Flag);
}
void USetReducerFlags::InsertIntoIndexedSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertIntoIndexedSimpleEnum", Flag);
}
void USetReducerFlags::InsertIntoPkBtreeU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertIntoPkBtreeU32", Flag);
}
void USetReducerFlags::InsertLargeTable(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertLargeTable", Flag);
}
void USetReducerFlags::InsertOneBool(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneBool", Flag);
}
void USetReducerFlags::InsertOneByteStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneByteStruct", Flag);
}
void USetReducerFlags::InsertOneConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneConnectionId", Flag);
}
void USetReducerFlags::InsertOneEnumWithPayload(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneEnumWithPayload", Flag);
}
void USetReducerFlags::InsertOneEveryPrimitiveStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneEveryPrimitiveStruct", Flag);
}
void USetReducerFlags::InsertOneEveryVecStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneEveryVecStruct", Flag);
}
void USetReducerFlags::InsertOneF32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneF32", Flag);
}
void USetReducerFlags::InsertOneF64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneF64", Flag);
}
void USetReducerFlags::InsertOneI128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneI128", Flag);
}
void USetReducerFlags::InsertOneI16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneI16", Flag);
}
void USetReducerFlags::InsertOneI256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneI256", Flag);
}
void USetReducerFlags::InsertOneI32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneI32", Flag);
}
void USetReducerFlags::InsertOneI64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneI64", Flag);
}
void USetReducerFlags::InsertOneI8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneI8", Flag);
}
void USetReducerFlags::InsertOneIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneIdentity", Flag);
}
void USetReducerFlags::InsertOneSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneSimpleEnum", Flag);
}
void USetReducerFlags::InsertOneString(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneString", Flag);
}
void USetReducerFlags::InsertOneTimestamp(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneTimestamp", Flag);
}
void USetReducerFlags::InsertOneU128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneU128", Flag);
}
void USetReducerFlags::InsertOneU16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneU16", Flag);
}
void USetReducerFlags::InsertOneU256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneU256", Flag);
}
void USetReducerFlags::InsertOneU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneU32", Flag);
}
void USetReducerFlags::InsertOneU64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneU64", Flag);
}
void USetReducerFlags::InsertOneU8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneU8", Flag);
}
void USetReducerFlags::InsertOneUnitStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOneUnitStruct", Flag);
}
void USetReducerFlags::InsertOptionEveryPrimitiveStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOptionEveryPrimitiveStruct", Flag);
}
void USetReducerFlags::InsertOptionI32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOptionI32", Flag);
}
void USetReducerFlags::InsertOptionIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOptionIdentity", Flag);
}
void USetReducerFlags::InsertOptionSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOptionSimpleEnum", Flag);
}
void USetReducerFlags::InsertOptionString(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOptionString", Flag);
}
void USetReducerFlags::InsertOptionVecOptionI32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertOptionVecOptionI32", Flag);
}
void USetReducerFlags::InsertPkBool(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkBool", Flag);
}
void USetReducerFlags::InsertPkConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkConnectionId", Flag);
}
void USetReducerFlags::InsertPkI128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkI128", Flag);
}
void USetReducerFlags::InsertPkI16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkI16", Flag);
}
void USetReducerFlags::InsertPkI256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkI256", Flag);
}
void USetReducerFlags::InsertPkI32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkI32", Flag);
}
void USetReducerFlags::InsertPkI64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkI64", Flag);
}
void USetReducerFlags::InsertPkI8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkI8", Flag);
}
void USetReducerFlags::InsertPkIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkIdentity", Flag);
}
void USetReducerFlags::InsertPkSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkSimpleEnum", Flag);
}
void USetReducerFlags::InsertPkString(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkString", Flag);
}
void USetReducerFlags::InsertPkU128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU128", Flag);
}
void USetReducerFlags::InsertPkU16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU16", Flag);
}
void USetReducerFlags::InsertPkU256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU256", Flag);
}
void USetReducerFlags::InsertPkU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU32", Flag);
}
void USetReducerFlags::InsertPkU32Two(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU32Two", Flag);
}
void USetReducerFlags::InsertPkU64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU64", Flag);
}
void USetReducerFlags::InsertPkU8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPkU8", Flag);
}
void USetReducerFlags::InsertPrimitivesAsStrings(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertPrimitivesAsStrings", Flag);
}
void USetReducerFlags::InsertTableHoldsTable(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertTableHoldsTable", Flag);
}
void USetReducerFlags::InsertUniqueBool(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueBool", Flag);
}
void USetReducerFlags::InsertUniqueConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueConnectionId", Flag);
}
void USetReducerFlags::InsertUniqueI128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueI128", Flag);
}
void USetReducerFlags::InsertUniqueI16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueI16", Flag);
}
void USetReducerFlags::InsertUniqueI256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueI256", Flag);
}
void USetReducerFlags::InsertUniqueI32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueI32", Flag);
}
void USetReducerFlags::InsertUniqueI64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueI64", Flag);
}
void USetReducerFlags::InsertUniqueI8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueI8", Flag);
}
void USetReducerFlags::InsertUniqueIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueIdentity", Flag);
}
void USetReducerFlags::InsertUniqueString(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueString", Flag);
}
void USetReducerFlags::InsertUniqueU128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU128", Flag);
}
void USetReducerFlags::InsertUniqueU16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU16", Flag);
}
void USetReducerFlags::InsertUniqueU256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU256", Flag);
}
void USetReducerFlags::InsertUniqueU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU32", Flag);
}
void USetReducerFlags::InsertUniqueU32UpdatePkU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU32UpdatePkU32", Flag);
}
void USetReducerFlags::InsertUniqueU64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU64", Flag);
}
void USetReducerFlags::InsertUniqueU8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUniqueU8", Flag);
}
void USetReducerFlags::InsertUser(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertUser", Flag);
}
void USetReducerFlags::InsertVecBool(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecBool", Flag);
}
void USetReducerFlags::InsertVecByteStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecByteStruct", Flag);
}
void USetReducerFlags::InsertVecConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecConnectionId", Flag);
}
void USetReducerFlags::InsertVecEnumWithPayload(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecEnumWithPayload", Flag);
}
void USetReducerFlags::InsertVecEveryPrimitiveStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecEveryPrimitiveStruct", Flag);
}
void USetReducerFlags::InsertVecEveryVecStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecEveryVecStruct", Flag);
}
void USetReducerFlags::InsertVecF32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecF32", Flag);
}
void USetReducerFlags::InsertVecF64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecF64", Flag);
}
void USetReducerFlags::InsertVecI128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecI128", Flag);
}
void USetReducerFlags::InsertVecI16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecI16", Flag);
}
void USetReducerFlags::InsertVecI256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecI256", Flag);
}
void USetReducerFlags::InsertVecI32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecI32", Flag);
}
void USetReducerFlags::InsertVecI64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecI64", Flag);
}
void USetReducerFlags::InsertVecI8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecI8", Flag);
}
void USetReducerFlags::InsertVecIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecIdentity", Flag);
}
void USetReducerFlags::InsertVecSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecSimpleEnum", Flag);
}
void USetReducerFlags::InsertVecString(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecString", Flag);
}
void USetReducerFlags::InsertVecTimestamp(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecTimestamp", Flag);
}
void USetReducerFlags::InsertVecU128(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecU128", Flag);
}
void USetReducerFlags::InsertVecU16(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecU16", Flag);
}
void USetReducerFlags::InsertVecU256(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecU256", Flag);
}
void USetReducerFlags::InsertVecU32(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecU32", Flag);
}
void USetReducerFlags::InsertVecU64(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecU64", Flag);
}
void USetReducerFlags::InsertVecU8(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecU8", Flag);
}
void USetReducerFlags::InsertVecUnitStruct(ECallReducerFlags Flag)
{
	FlagMap.Add("InsertVecUnitStruct", Flag);
}
void USetReducerFlags::NoOpSucceeds(ECallReducerFlags Flag)
{
	FlagMap.Add("NoOpSucceeds", Flag);
}
void USetReducerFlags::SendScheduledMessage(ECallReducerFlags Flag)
{
	FlagMap.Add("SendScheduledMessage", Flag);
}
void USetReducerFlags::UpdateIndexedSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateIndexedSimpleEnum", Flag);
}
void USetReducerFlags::UpdatePkBool(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkBool", Flag);
}
void USetReducerFlags::UpdatePkConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkConnectionId", Flag);
}
void USetReducerFlags::UpdatePkI128(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkI128", Flag);
}
void USetReducerFlags::UpdatePkI16(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkI16", Flag);
}
void USetReducerFlags::UpdatePkI256(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkI256", Flag);
}
void USetReducerFlags::UpdatePkI32(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkI32", Flag);
}
void USetReducerFlags::UpdatePkI64(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkI64", Flag);
}
void USetReducerFlags::UpdatePkI8(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkI8", Flag);
}
void USetReducerFlags::UpdatePkIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkIdentity", Flag);
}
void USetReducerFlags::UpdatePkSimpleEnum(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkSimpleEnum", Flag);
}
void USetReducerFlags::UpdatePkString(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkString", Flag);
}
void USetReducerFlags::UpdatePkU128(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU128", Flag);
}
void USetReducerFlags::UpdatePkU16(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU16", Flag);
}
void USetReducerFlags::UpdatePkU256(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU256", Flag);
}
void USetReducerFlags::UpdatePkU32(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU32", Flag);
}
void USetReducerFlags::UpdatePkU32Two(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU32Two", Flag);
}
void USetReducerFlags::UpdatePkU64(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU64", Flag);
}
void USetReducerFlags::UpdatePkU8(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdatePkU8", Flag);
}
void USetReducerFlags::UpdateUniqueBool(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueBool", Flag);
}
void USetReducerFlags::UpdateUniqueConnectionId(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueConnectionId", Flag);
}
void USetReducerFlags::UpdateUniqueI128(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueI128", Flag);
}
void USetReducerFlags::UpdateUniqueI16(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueI16", Flag);
}
void USetReducerFlags::UpdateUniqueI256(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueI256", Flag);
}
void USetReducerFlags::UpdateUniqueI32(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueI32", Flag);
}
void USetReducerFlags::UpdateUniqueI64(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueI64", Flag);
}
void USetReducerFlags::UpdateUniqueI8(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueI8", Flag);
}
void USetReducerFlags::UpdateUniqueIdentity(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueIdentity", Flag);
}
void USetReducerFlags::UpdateUniqueString(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueString", Flag);
}
void USetReducerFlags::UpdateUniqueU128(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueU128", Flag);
}
void USetReducerFlags::UpdateUniqueU16(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueU16", Flag);
}
void USetReducerFlags::UpdateUniqueU256(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueU256", Flag);
}
void USetReducerFlags::UpdateUniqueU32(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueU32", Flag);
}
void USetReducerFlags::UpdateUniqueU64(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueU64", Flag);
}
void USetReducerFlags::UpdateUniqueU8(ECallReducerFlags Flag)
{
	FlagMap.Add("UpdateUniqueU8", Flag);
}

void URemoteReducers::DeleteFromBtreeU32(const TArray<FBTreeU32Type>& Rows)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_from_btree_u32"), FDeleteFromBtreeU32Args(Rows), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteFromBtreeU32(const FReducerEventContext& Context, const UDeleteFromBtreeU32Reducer* Args)
{
    if (!OnDeleteFromBtreeU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteFromBtreeU32"));
        }
        return false;
    }

    OnDeleteFromBtreeU32.Broadcast(Context, Args->Rows);
    return true;
}

void URemoteReducers::DeleteLargeTable(const uint8 A, const uint16 B, const uint32 C, const uint64 D, const FSpacetimeDBUInt128& E, const FSpacetimeDBUInt256& F, const int8 G, const int16 H, const int32 I, const int64 J, const FSpacetimeDBInt128& K, const FSpacetimeDBInt256& L, const bool M, const float N, const double O, const FString& P, const ESimpleEnumType& Q, const FEnumWithPayloadType& R, const FUnitStructType& S, const FByteStructType& T, const FEveryPrimitiveStructType& U, const FEveryVecStructType& V)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_large_table"), FDeleteLargeTableArgs(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteLargeTable(const FReducerEventContext& Context, const UDeleteLargeTableReducer* Args)
{
    if (!OnDeleteLargeTable.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteLargeTable"));
        }
        return false;
    }

    FDeleteLargeTableArgs ArgsStruct;
    ArgsStruct.A = Args->A;
    ArgsStruct.B = Args->B;
    ArgsStruct.C = Args->C;
    ArgsStruct.D = Args->D;
    ArgsStruct.E = Args->E;
    ArgsStruct.F = Args->F;
    ArgsStruct.G = Args->G;
    ArgsStruct.H = Args->H;
    ArgsStruct.I = Args->I;
    ArgsStruct.J = Args->J;
    ArgsStruct.K = Args->K;
    ArgsStruct.L = Args->L;
    ArgsStruct.M = Args->M;
    ArgsStruct.N = Args->N;
    ArgsStruct.O = Args->O;
    ArgsStruct.P = Args->P;
    ArgsStruct.Q = Args->Q;
    ArgsStruct.R = Args->R;
    ArgsStruct.S = Args->S;
    ArgsStruct.T = Args->T;
    ArgsStruct.U = Args->U;
    ArgsStruct.V = Args->V;
    OnDeleteLargeTable.Broadcast(Context, ArgsStruct);
    return true;
}

void URemoteReducers::DeletePkBool(const bool B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_bool"), FDeletePkBoolArgs(B), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkBool(const FReducerEventContext& Context, const UDeletePkBoolReducer* Args)
{
    if (!OnDeletePkBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkBool"));
        }
        return false;
    }

    OnDeletePkBool.Broadcast(Context, Args->B);
    return true;
}

void URemoteReducers::DeletePkConnectionId(const FSpacetimeDBConnectionId& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_connection_id"), FDeletePkConnectionIdArgs(A), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkConnectionId(const FReducerEventContext& Context, const UDeletePkConnectionIdReducer* Args)
{
    if (!OnDeletePkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkConnectionId"));
        }
        return false;
    }

    OnDeletePkConnectionId.Broadcast(Context, Args->A);
    return true;
}

void URemoteReducers::DeletePkI128(const FSpacetimeDBInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_i128"), FDeletePkI128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkI128(const FReducerEventContext& Context, const UDeletePkI128Reducer* Args)
{
    if (!OnDeletePkI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI128"));
        }
        return false;
    }

    OnDeletePkI128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkI16(const int16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_i16"), FDeletePkI16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkI16(const FReducerEventContext& Context, const UDeletePkI16Reducer* Args)
{
    if (!OnDeletePkI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI16"));
        }
        return false;
    }

    OnDeletePkI16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkI256(const FSpacetimeDBInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_i256"), FDeletePkI256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkI256(const FReducerEventContext& Context, const UDeletePkI256Reducer* Args)
{
    if (!OnDeletePkI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI256"));
        }
        return false;
    }

    OnDeletePkI256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkI32(const int32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_i32"), FDeletePkI32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkI32(const FReducerEventContext& Context, const UDeletePkI32Reducer* Args)
{
    if (!OnDeletePkI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI32"));
        }
        return false;
    }

    OnDeletePkI32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkI64(const int64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_i64"), FDeletePkI64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkI64(const FReducerEventContext& Context, const UDeletePkI64Reducer* Args)
{
    if (!OnDeletePkI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI64"));
        }
        return false;
    }

    OnDeletePkI64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkI8(const int8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_i8"), FDeletePkI8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkI8(const FReducerEventContext& Context, const UDeletePkI8Reducer* Args)
{
    if (!OnDeletePkI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI8"));
        }
        return false;
    }

    OnDeletePkI8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkIdentity(const FSpacetimeDBIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_identity"), FDeletePkIdentityArgs(I), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkIdentity(const FReducerEventContext& Context, const UDeletePkIdentityReducer* Args)
{
    if (!OnDeletePkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkIdentity"));
        }
        return false;
    }

    OnDeletePkIdentity.Broadcast(Context, Args->I);
    return true;
}

void URemoteReducers::DeletePkString(const FString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_string"), FDeletePkStringArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkString(const FReducerEventContext& Context, const UDeletePkStringReducer* Args)
{
    if (!OnDeletePkString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkString"));
        }
        return false;
    }

    OnDeletePkString.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::DeletePkU128(const FSpacetimeDBUInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u128"), FDeletePkU128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU128(const FReducerEventContext& Context, const UDeletePkU128Reducer* Args)
{
    if (!OnDeletePkU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU128"));
        }
        return false;
    }

    OnDeletePkU128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkU16(const uint16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u16"), FDeletePkU16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU16(const FReducerEventContext& Context, const UDeletePkU16Reducer* Args)
{
    if (!OnDeletePkU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU16"));
        }
        return false;
    }

    OnDeletePkU16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkU256(const FSpacetimeDBUInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u256"), FDeletePkU256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU256(const FReducerEventContext& Context, const UDeletePkU256Reducer* Args)
{
    if (!OnDeletePkU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU256"));
        }
        return false;
    }

    OnDeletePkU256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkU32(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u32"), FDeletePkU32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU32(const FReducerEventContext& Context, const UDeletePkU32Reducer* Args)
{
    if (!OnDeletePkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32"));
        }
        return false;
    }

    OnDeletePkU32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkU32InsertPkU32Two(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u32_insert_pk_u32_two"), FDeletePkU32InsertPkU32TwoArgs(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU32InsertPkU32Two(const FReducerEventContext& Context, const UDeletePkU32InsertPkU32TwoReducer* Args)
{
    if (!OnDeletePkU32InsertPkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32InsertPkU32Two"));
        }
        return false;
    }

    OnDeletePkU32InsertPkU32Two.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::DeletePkU32Two(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u32_two"), FDeletePkU32TwoArgs(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU32Two(const FReducerEventContext& Context, const UDeletePkU32TwoReducer* Args)
{
    if (!OnDeletePkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32Two"));
        }
        return false;
    }

    OnDeletePkU32Two.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkU64(const uint64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u64"), FDeletePkU64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU64(const FReducerEventContext& Context, const UDeletePkU64Reducer* Args)
{
    if (!OnDeletePkU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU64"));
        }
        return false;
    }

    OnDeletePkU64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeletePkU8(const uint8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_pk_u8"), FDeletePkU8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeletePkU8(const FReducerEventContext& Context, const UDeletePkU8Reducer* Args)
{
    if (!OnDeletePkU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU8"));
        }
        return false;
    }

    OnDeletePkU8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueBool(const bool B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_bool"), FDeleteUniqueBoolArgs(B), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueBool(const FReducerEventContext& Context, const UDeleteUniqueBoolReducer* Args)
{
    if (!OnDeleteUniqueBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueBool"));
        }
        return false;
    }

    OnDeleteUniqueBool.Broadcast(Context, Args->B);
    return true;
}

void URemoteReducers::DeleteUniqueConnectionId(const FSpacetimeDBConnectionId& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_connection_id"), FDeleteUniqueConnectionIdArgs(A), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueConnectionId(const FReducerEventContext& Context, const UDeleteUniqueConnectionIdReducer* Args)
{
    if (!OnDeleteUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueConnectionId"));
        }
        return false;
    }

    OnDeleteUniqueConnectionId.Broadcast(Context, Args->A);
    return true;
}

void URemoteReducers::DeleteUniqueI128(const FSpacetimeDBInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_i128"), FDeleteUniqueI128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueI128(const FReducerEventContext& Context, const UDeleteUniqueI128Reducer* Args)
{
    if (!OnDeleteUniqueI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI128"));
        }
        return false;
    }

    OnDeleteUniqueI128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueI16(const int16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_i16"), FDeleteUniqueI16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueI16(const FReducerEventContext& Context, const UDeleteUniqueI16Reducer* Args)
{
    if (!OnDeleteUniqueI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI16"));
        }
        return false;
    }

    OnDeleteUniqueI16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueI256(const FSpacetimeDBInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_i256"), FDeleteUniqueI256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueI256(const FReducerEventContext& Context, const UDeleteUniqueI256Reducer* Args)
{
    if (!OnDeleteUniqueI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI256"));
        }
        return false;
    }

    OnDeleteUniqueI256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueI32(const int32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_i32"), FDeleteUniqueI32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueI32(const FReducerEventContext& Context, const UDeleteUniqueI32Reducer* Args)
{
    if (!OnDeleteUniqueI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI32"));
        }
        return false;
    }

    OnDeleteUniqueI32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueI64(const int64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_i64"), FDeleteUniqueI64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueI64(const FReducerEventContext& Context, const UDeleteUniqueI64Reducer* Args)
{
    if (!OnDeleteUniqueI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI64"));
        }
        return false;
    }

    OnDeleteUniqueI64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueI8(const int8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_i8"), FDeleteUniqueI8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueI8(const FReducerEventContext& Context, const UDeleteUniqueI8Reducer* Args)
{
    if (!OnDeleteUniqueI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI8"));
        }
        return false;
    }

    OnDeleteUniqueI8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueIdentity(const FSpacetimeDBIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_identity"), FDeleteUniqueIdentityArgs(I), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueIdentity(const FReducerEventContext& Context, const UDeleteUniqueIdentityReducer* Args)
{
    if (!OnDeleteUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueIdentity"));
        }
        return false;
    }

    OnDeleteUniqueIdentity.Broadcast(Context, Args->I);
    return true;
}

void URemoteReducers::DeleteUniqueString(const FString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_string"), FDeleteUniqueStringArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueString(const FReducerEventContext& Context, const UDeleteUniqueStringReducer* Args)
{
    if (!OnDeleteUniqueString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueString"));
        }
        return false;
    }

    OnDeleteUniqueString.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::DeleteUniqueU128(const FSpacetimeDBUInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_u128"), FDeleteUniqueU128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueU128(const FReducerEventContext& Context, const UDeleteUniqueU128Reducer* Args)
{
    if (!OnDeleteUniqueU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU128"));
        }
        return false;
    }

    OnDeleteUniqueU128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueU16(const uint16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_u16"), FDeleteUniqueU16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueU16(const FReducerEventContext& Context, const UDeleteUniqueU16Reducer* Args)
{
    if (!OnDeleteUniqueU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU16"));
        }
        return false;
    }

    OnDeleteUniqueU16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueU256(const FSpacetimeDBUInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_u256"), FDeleteUniqueU256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueU256(const FReducerEventContext& Context, const UDeleteUniqueU256Reducer* Args)
{
    if (!OnDeleteUniqueU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU256"));
        }
        return false;
    }

    OnDeleteUniqueU256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueU32(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_u32"), FDeleteUniqueU32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueU32(const FReducerEventContext& Context, const UDeleteUniqueU32Reducer* Args)
{
    if (!OnDeleteUniqueU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU32"));
        }
        return false;
    }

    OnDeleteUniqueU32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueU64(const uint64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_u64"), FDeleteUniqueU64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueU64(const FReducerEventContext& Context, const UDeleteUniqueU64Reducer* Args)
{
    if (!OnDeleteUniqueU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU64"));
        }
        return false;
    }

    OnDeleteUniqueU64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::DeleteUniqueU8(const uint8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("delete_unique_u8"), FDeleteUniqueU8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeDeleteUniqueU8(const FReducerEventContext& Context, const UDeleteUniqueU8Reducer* Args)
{
    if (!OnDeleteUniqueU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU8"));
        }
        return false;
    }

    OnDeleteUniqueU8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertCallTimestamp()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_call_timestamp"), FInsertCallTimestampArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallTimestamp(const FReducerEventContext& Context, const UInsertCallTimestampReducer* Args)
{
    if (!OnInsertCallTimestamp.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallTimestamp"));
        }
        return false;
    }

    OnInsertCallTimestamp.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerOneConnectionId()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_one_connection_id"), FInsertCallerOneConnectionIdArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerOneConnectionId(const FReducerEventContext& Context, const UInsertCallerOneConnectionIdReducer* Args)
{
    if (!OnInsertCallerOneConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerOneConnectionId"));
        }
        return false;
    }

    OnInsertCallerOneConnectionId.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerOneIdentity()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_one_identity"), FInsertCallerOneIdentityArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerOneIdentity(const FReducerEventContext& Context, const UInsertCallerOneIdentityReducer* Args)
{
    if (!OnInsertCallerOneIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerOneIdentity"));
        }
        return false;
    }

    OnInsertCallerOneIdentity.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerPkConnectionId(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_pk_connection_id"), FInsertCallerPkConnectionIdArgs(Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerPkConnectionId(const FReducerEventContext& Context, const UInsertCallerPkConnectionIdReducer* Args)
{
    if (!OnInsertCallerPkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerPkConnectionId"));
        }
        return false;
    }

    OnInsertCallerPkConnectionId.Broadcast(Context, Args->Data);
    return true;
}

void URemoteReducers::InsertCallerPkIdentity(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_pk_identity"), FInsertCallerPkIdentityArgs(Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerPkIdentity(const FReducerEventContext& Context, const UInsertCallerPkIdentityReducer* Args)
{
    if (!OnInsertCallerPkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerPkIdentity"));
        }
        return false;
    }

    OnInsertCallerPkIdentity.Broadcast(Context, Args->Data);
    return true;
}

void URemoteReducers::InsertCallerUniqueConnectionId(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_unique_connection_id"), FInsertCallerUniqueConnectionIdArgs(Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerUniqueConnectionId(const FReducerEventContext& Context, const UInsertCallerUniqueConnectionIdReducer* Args)
{
    if (!OnInsertCallerUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerUniqueConnectionId"));
        }
        return false;
    }

    OnInsertCallerUniqueConnectionId.Broadcast(Context, Args->Data);
    return true;
}

void URemoteReducers::InsertCallerUniqueIdentity(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_unique_identity"), FInsertCallerUniqueIdentityArgs(Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerUniqueIdentity(const FReducerEventContext& Context, const UInsertCallerUniqueIdentityReducer* Args)
{
    if (!OnInsertCallerUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerUniqueIdentity"));
        }
        return false;
    }

    OnInsertCallerUniqueIdentity.Broadcast(Context, Args->Data);
    return true;
}

void URemoteReducers::InsertCallerVecConnectionId()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_vec_connection_id"), FInsertCallerVecConnectionIdArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerVecConnectionId(const FReducerEventContext& Context, const UInsertCallerVecConnectionIdReducer* Args)
{
    if (!OnInsertCallerVecConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerVecConnectionId"));
        }
        return false;
    }

    OnInsertCallerVecConnectionId.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerVecIdentity()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_caller_vec_identity"), FInsertCallerVecIdentityArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertCallerVecIdentity(const FReducerEventContext& Context, const UInsertCallerVecIdentityReducer* Args)
{
    if (!OnInsertCallerVecIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerVecIdentity"));
        }
        return false;
    }

    OnInsertCallerVecIdentity.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertIntoBtreeU32(const TArray<FBTreeU32Type>& Rows)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_into_btree_u32"), FInsertIntoBtreeU32Args(Rows), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertIntoBtreeU32(const FReducerEventContext& Context, const UInsertIntoBtreeU32Reducer* Args)
{
    if (!OnInsertIntoBtreeU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoBtreeU32"));
        }
        return false;
    }

    OnInsertIntoBtreeU32.Broadcast(Context, Args->Rows);
    return true;
}

void URemoteReducers::InsertIntoIndexedSimpleEnum(const ESimpleEnumType& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_into_indexed_simple_enum"), FInsertIntoIndexedSimpleEnumArgs(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertIntoIndexedSimpleEnum(const FReducerEventContext& Context, const UInsertIntoIndexedSimpleEnumReducer* Args)
{
    if (!OnInsertIntoIndexedSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoIndexedSimpleEnum"));
        }
        return false;
    }

    OnInsertIntoIndexedSimpleEnum.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertIntoPkBtreeU32(const TArray<FPkU32Type>& PkU32, const TArray<FBTreeU32Type>& BtU32)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_into_pk_btree_u32"), FInsertIntoPkBtreeU32Args(PkU32, BtU32), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertIntoPkBtreeU32(const FReducerEventContext& Context, const UInsertIntoPkBtreeU32Reducer* Args)
{
    if (!OnInsertIntoPkBtreeU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoPkBtreeU32"));
        }
        return false;
    }

    OnInsertIntoPkBtreeU32.Broadcast(Context, Args->PkU32, Args->BtU32);
    return true;
}

void URemoteReducers::InsertLargeTable(const uint8 A, const uint16 B, const uint32 C, const uint64 D, const FSpacetimeDBUInt128& E, const FSpacetimeDBUInt256& F, const int8 G, const int16 H, const int32 I, const int64 J, const FSpacetimeDBInt128& K, const FSpacetimeDBInt256& L, const bool M, const float N, const double O, const FString& P, const ESimpleEnumType& Q, const FEnumWithPayloadType& R, const FUnitStructType& S, const FByteStructType& T, const FEveryPrimitiveStructType& U, const FEveryVecStructType& V)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_large_table"), FInsertLargeTableArgs(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertLargeTable(const FReducerEventContext& Context, const UInsertLargeTableReducer* Args)
{
    if (!OnInsertLargeTable.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertLargeTable"));
        }
        return false;
    }

    FInsertLargeTableArgs ArgsStruct;
    ArgsStruct.A = Args->A;
    ArgsStruct.B = Args->B;
    ArgsStruct.C = Args->C;
    ArgsStruct.D = Args->D;
    ArgsStruct.E = Args->E;
    ArgsStruct.F = Args->F;
    ArgsStruct.G = Args->G;
    ArgsStruct.H = Args->H;
    ArgsStruct.I = Args->I;
    ArgsStruct.J = Args->J;
    ArgsStruct.K = Args->K;
    ArgsStruct.L = Args->L;
    ArgsStruct.M = Args->M;
    ArgsStruct.N = Args->N;
    ArgsStruct.O = Args->O;
    ArgsStruct.P = Args->P;
    ArgsStruct.Q = Args->Q;
    ArgsStruct.R = Args->R;
    ArgsStruct.S = Args->S;
    ArgsStruct.T = Args->T;
    ArgsStruct.U = Args->U;
    ArgsStruct.V = Args->V;
    OnInsertLargeTable.Broadcast(Context, ArgsStruct);
    return true;
}

void URemoteReducers::InsertOneBool(const bool B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_bool"), FInsertOneBoolArgs(B), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneBool(const FReducerEventContext& Context, const UInsertOneBoolReducer* Args)
{
    if (!OnInsertOneBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneBool"));
        }
        return false;
    }

    OnInsertOneBool.Broadcast(Context, Args->B);
    return true;
}

void URemoteReducers::InsertOneByteStruct(const FByteStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_byte_struct"), FInsertOneByteStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneByteStruct(const FReducerEventContext& Context, const UInsertOneByteStructReducer* Args)
{
    if (!OnInsertOneByteStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneByteStruct"));
        }
        return false;
    }

    OnInsertOneByteStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOneConnectionId(const FSpacetimeDBConnectionId& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_connection_id"), FInsertOneConnectionIdArgs(A), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneConnectionId(const FReducerEventContext& Context, const UInsertOneConnectionIdReducer* Args)
{
    if (!OnInsertOneConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneConnectionId"));
        }
        return false;
    }

    OnInsertOneConnectionId.Broadcast(Context, Args->A);
    return true;
}

void URemoteReducers::InsertOneEnumWithPayload(const FEnumWithPayloadType& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_enum_with_payload"), FInsertOneEnumWithPayloadArgs(E), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneEnumWithPayload(const FReducerEventContext& Context, const UInsertOneEnumWithPayloadReducer* Args)
{
    if (!OnInsertOneEnumWithPayload.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEnumWithPayload"));
        }
        return false;
    }

    OnInsertOneEnumWithPayload.Broadcast(Context, Args->E);
    return true;
}

void URemoteReducers::InsertOneEveryPrimitiveStruct(const FEveryPrimitiveStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_every_primitive_struct"), FInsertOneEveryPrimitiveStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneEveryPrimitiveStruct(const FReducerEventContext& Context, const UInsertOneEveryPrimitiveStructReducer* Args)
{
    if (!OnInsertOneEveryPrimitiveStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertOneEveryPrimitiveStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOneEveryVecStruct(const FEveryVecStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_every_vec_struct"), FInsertOneEveryVecStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneEveryVecStruct(const FReducerEventContext& Context, const UInsertOneEveryVecStructReducer* Args)
{
    if (!OnInsertOneEveryVecStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEveryVecStruct"));
        }
        return false;
    }

    OnInsertOneEveryVecStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOneF32(const float F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_f32"), FInsertOneF32Args(F), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneF32(const FReducerEventContext& Context, const UInsertOneF32Reducer* Args)
{
    if (!OnInsertOneF32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneF32"));
        }
        return false;
    }

    OnInsertOneF32.Broadcast(Context, Args->F);
    return true;
}

void URemoteReducers::InsertOneF64(const double F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_f64"), FInsertOneF64Args(F), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneF64(const FReducerEventContext& Context, const UInsertOneF64Reducer* Args)
{
    if (!OnInsertOneF64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneF64"));
        }
        return false;
    }

    OnInsertOneF64.Broadcast(Context, Args->F);
    return true;
}

void URemoteReducers::InsertOneI128(const FSpacetimeDBInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_i128"), FInsertOneI128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneI128(const FReducerEventContext& Context, const UInsertOneI128Reducer* Args)
{
    if (!OnInsertOneI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI128"));
        }
        return false;
    }

    OnInsertOneI128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneI16(const int16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_i16"), FInsertOneI16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneI16(const FReducerEventContext& Context, const UInsertOneI16Reducer* Args)
{
    if (!OnInsertOneI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI16"));
        }
        return false;
    }

    OnInsertOneI16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneI256(const FSpacetimeDBInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_i256"), FInsertOneI256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneI256(const FReducerEventContext& Context, const UInsertOneI256Reducer* Args)
{
    if (!OnInsertOneI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI256"));
        }
        return false;
    }

    OnInsertOneI256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneI32(const int32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_i32"), FInsertOneI32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneI32(const FReducerEventContext& Context, const UInsertOneI32Reducer* Args)
{
    if (!OnInsertOneI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI32"));
        }
        return false;
    }

    OnInsertOneI32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneI64(const int64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_i64"), FInsertOneI64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneI64(const FReducerEventContext& Context, const UInsertOneI64Reducer* Args)
{
    if (!OnInsertOneI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI64"));
        }
        return false;
    }

    OnInsertOneI64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneI8(const int8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_i8"), FInsertOneI8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneI8(const FReducerEventContext& Context, const UInsertOneI8Reducer* Args)
{
    if (!OnInsertOneI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI8"));
        }
        return false;
    }

    OnInsertOneI8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneIdentity(const FSpacetimeDBIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_identity"), FInsertOneIdentityArgs(I), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneIdentity(const FReducerEventContext& Context, const UInsertOneIdentityReducer* Args)
{
    if (!OnInsertOneIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneIdentity"));
        }
        return false;
    }

    OnInsertOneIdentity.Broadcast(Context, Args->I);
    return true;
}

void URemoteReducers::InsertOneSimpleEnum(const ESimpleEnumType& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_simple_enum"), FInsertOneSimpleEnumArgs(E), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneSimpleEnum(const FReducerEventContext& Context, const UInsertOneSimpleEnumReducer* Args)
{
    if (!OnInsertOneSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneSimpleEnum"));
        }
        return false;
    }

    OnInsertOneSimpleEnum.Broadcast(Context, Args->E);
    return true;
}

void URemoteReducers::InsertOneString(const FString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_string"), FInsertOneStringArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneString(const FReducerEventContext& Context, const UInsertOneStringReducer* Args)
{
    if (!OnInsertOneString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneString"));
        }
        return false;
    }

    OnInsertOneString.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOneTimestamp(const FSpacetimeDBTimestamp& T)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_timestamp"), FInsertOneTimestampArgs(T), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneTimestamp(const FReducerEventContext& Context, const UInsertOneTimestampReducer* Args)
{
    if (!OnInsertOneTimestamp.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneTimestamp"));
        }
        return false;
    }

    OnInsertOneTimestamp.Broadcast(Context, Args->T);
    return true;
}

void URemoteReducers::InsertOneU128(const FSpacetimeDBUInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_u128"), FInsertOneU128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneU128(const FReducerEventContext& Context, const UInsertOneU128Reducer* Args)
{
    if (!OnInsertOneU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU128"));
        }
        return false;
    }

    OnInsertOneU128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneU16(const uint16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_u16"), FInsertOneU16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneU16(const FReducerEventContext& Context, const UInsertOneU16Reducer* Args)
{
    if (!OnInsertOneU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU16"));
        }
        return false;
    }

    OnInsertOneU16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneU256(const FSpacetimeDBUInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_u256"), FInsertOneU256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneU256(const FReducerEventContext& Context, const UInsertOneU256Reducer* Args)
{
    if (!OnInsertOneU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU256"));
        }
        return false;
    }

    OnInsertOneU256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneU32(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_u32"), FInsertOneU32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneU32(const FReducerEventContext& Context, const UInsertOneU32Reducer* Args)
{
    if (!OnInsertOneU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU32"));
        }
        return false;
    }

    OnInsertOneU32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneU64(const uint64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_u64"), FInsertOneU64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneU64(const FReducerEventContext& Context, const UInsertOneU64Reducer* Args)
{
    if (!OnInsertOneU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU64"));
        }
        return false;
    }

    OnInsertOneU64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneU8(const uint8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_u8"), FInsertOneU8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneU8(const FReducerEventContext& Context, const UInsertOneU8Reducer* Args)
{
    if (!OnInsertOneU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU8"));
        }
        return false;
    }

    OnInsertOneU8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOneUnitStruct(const FUnitStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_one_unit_struct"), FInsertOneUnitStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOneUnitStruct(const FReducerEventContext& Context, const UInsertOneUnitStructReducer* Args)
{
    if (!OnInsertOneUnitStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneUnitStruct"));
        }
        return false;
    }

    OnInsertOneUnitStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOptionEveryPrimitiveStruct(const FTestClientOptionalEveryPrimitiveStruct& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_option_every_primitive_struct"), FInsertOptionEveryPrimitiveStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOptionEveryPrimitiveStruct(const FReducerEventContext& Context, const UInsertOptionEveryPrimitiveStructReducer* Args)
{
    if (!OnInsertOptionEveryPrimitiveStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertOptionEveryPrimitiveStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOptionI32(const FTestClientOptionalInt32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_option_i32"), FInsertOptionI32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOptionI32(const FReducerEventContext& Context, const UInsertOptionI32Reducer* Args)
{
    if (!OnInsertOptionI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionI32"));
        }
        return false;
    }

    OnInsertOptionI32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertOptionIdentity(const FTestClientOptionalIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_option_identity"), FInsertOptionIdentityArgs(I), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOptionIdentity(const FReducerEventContext& Context, const UInsertOptionIdentityReducer* Args)
{
    if (!OnInsertOptionIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionIdentity"));
        }
        return false;
    }

    OnInsertOptionIdentity.Broadcast(Context, Args->I);
    return true;
}

void URemoteReducers::InsertOptionSimpleEnum(const FTestClientOptionalSimpleEnum& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_option_simple_enum"), FInsertOptionSimpleEnumArgs(E), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOptionSimpleEnum(const FReducerEventContext& Context, const UInsertOptionSimpleEnumReducer* Args)
{
    if (!OnInsertOptionSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionSimpleEnum"));
        }
        return false;
    }

    OnInsertOptionSimpleEnum.Broadcast(Context, Args->E);
    return true;
}

void URemoteReducers::InsertOptionString(const FTestClientOptionalString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_option_string"), FInsertOptionStringArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOptionString(const FReducerEventContext& Context, const UInsertOptionStringReducer* Args)
{
    if (!OnInsertOptionString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionString"));
        }
        return false;
    }

    OnInsertOptionString.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertOptionVecOptionI32(const FTestClientOptionalVecInt32& V)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_option_vec_option_i32"), FInsertOptionVecOptionI32Args(V), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertOptionVecOptionI32(const FReducerEventContext& Context, const UInsertOptionVecOptionI32Reducer* Args)
{
    if (!OnInsertOptionVecOptionI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionVecOptionI32"));
        }
        return false;
    }

    OnInsertOptionVecOptionI32.Broadcast(Context, Args->V);
    return true;
}

void URemoteReducers::InsertPkBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_bool"), FInsertPkBoolArgs(B, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkBool(const FReducerEventContext& Context, const UInsertPkBoolReducer* Args)
{
    if (!OnInsertPkBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkBool"));
        }
        return false;
    }

    OnInsertPkBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

void URemoteReducers::InsertPkConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_connection_id"), FInsertPkConnectionIdArgs(A, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkConnectionId(const FReducerEventContext& Context, const UInsertPkConnectionIdReducer* Args)
{
    if (!OnInsertPkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkConnectionId"));
        }
        return false;
    }

    OnInsertPkConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

void URemoteReducers::InsertPkI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_i128"), FInsertPkI128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkI128(const FReducerEventContext& Context, const UInsertPkI128Reducer* Args)
{
    if (!OnInsertPkI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI128"));
        }
        return false;
    }

    OnInsertPkI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_i16"), FInsertPkI16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkI16(const FReducerEventContext& Context, const UInsertPkI16Reducer* Args)
{
    if (!OnInsertPkI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI16"));
        }
        return false;
    }

    OnInsertPkI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_i256"), FInsertPkI256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkI256(const FReducerEventContext& Context, const UInsertPkI256Reducer* Args)
{
    if (!OnInsertPkI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI256"));
        }
        return false;
    }

    OnInsertPkI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_i32"), FInsertPkI32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkI32(const FReducerEventContext& Context, const UInsertPkI32Reducer* Args)
{
    if (!OnInsertPkI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI32"));
        }
        return false;
    }

    OnInsertPkI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_i64"), FInsertPkI64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkI64(const FReducerEventContext& Context, const UInsertPkI64Reducer* Args)
{
    if (!OnInsertPkI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI64"));
        }
        return false;
    }

    OnInsertPkI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_i8"), FInsertPkI8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkI8(const FReducerEventContext& Context, const UInsertPkI8Reducer* Args)
{
    if (!OnInsertPkI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI8"));
        }
        return false;
    }

    OnInsertPkI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_identity"), FInsertPkIdentityArgs(I, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkIdentity(const FReducerEventContext& Context, const UInsertPkIdentityReducer* Args)
{
    if (!OnInsertPkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkIdentity"));
        }
        return false;
    }

    OnInsertPkIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

void URemoteReducers::InsertPkSimpleEnum(const ESimpleEnumType& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_simple_enum"), FInsertPkSimpleEnumArgs(A, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkSimpleEnum(const FReducerEventContext& Context, const UInsertPkSimpleEnumReducer* Args)
{
    if (!OnInsertPkSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkSimpleEnum"));
        }
        return false;
    }

    OnInsertPkSimpleEnum.Broadcast(Context, Args->A, Args->Data);
    return true;
}

void URemoteReducers::InsertPkString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_string"), FInsertPkStringArgs(S, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkString(const FReducerEventContext& Context, const UInsertPkStringReducer* Args)
{
    if (!OnInsertPkString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkString"));
        }
        return false;
    }

    OnInsertPkString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u128"), FInsertPkU128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU128(const FReducerEventContext& Context, const UInsertPkU128Reducer* Args)
{
    if (!OnInsertPkU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU128"));
        }
        return false;
    }

    OnInsertPkU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u16"), FInsertPkU16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU16(const FReducerEventContext& Context, const UInsertPkU16Reducer* Args)
{
    if (!OnInsertPkU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU16"));
        }
        return false;
    }

    OnInsertPkU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u256"), FInsertPkU256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU256(const FReducerEventContext& Context, const UInsertPkU256Reducer* Args)
{
    if (!OnInsertPkU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU256"));
        }
        return false;
    }

    OnInsertPkU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u32"), FInsertPkU32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU32(const FReducerEventContext& Context, const UInsertPkU32Reducer* Args)
{
    if (!OnInsertPkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU32"));
        }
        return false;
    }

    OnInsertPkU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU32Two(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u32_two"), FInsertPkU32TwoArgs(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU32Two(const FReducerEventContext& Context, const UInsertPkU32TwoReducer* Args)
{
    if (!OnInsertPkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU32Two"));
        }
        return false;
    }

    OnInsertPkU32Two.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u64"), FInsertPkU64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU64(const FReducerEventContext& Context, const UInsertPkU64Reducer* Args)
{
    if (!OnInsertPkU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU64"));
        }
        return false;
    }

    OnInsertPkU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPkU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_pk_u8"), FInsertPkU8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPkU8(const FReducerEventContext& Context, const UInsertPkU8Reducer* Args)
{
    if (!OnInsertPkU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU8"));
        }
        return false;
    }

    OnInsertPkU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertPrimitivesAsStrings(const FEveryPrimitiveStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_primitives_as_strings"), FInsertPrimitivesAsStringsArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertPrimitivesAsStrings(const FReducerEventContext& Context, const UInsertPrimitivesAsStringsReducer* Args)
{
    if (!OnInsertPrimitivesAsStrings.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPrimitivesAsStrings"));
        }
        return false;
    }

    OnInsertPrimitivesAsStrings.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertTableHoldsTable(const FOneU8Type& A, const FVecU8Type& B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_table_holds_table"), FInsertTableHoldsTableArgs(A, B), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertTableHoldsTable(const FReducerEventContext& Context, const UInsertTableHoldsTableReducer* Args)
{
    if (!OnInsertTableHoldsTable.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertTableHoldsTable"));
        }
        return false;
    }

    OnInsertTableHoldsTable.Broadcast(Context, Args->A, Args->B);
    return true;
}

void URemoteReducers::InsertUniqueBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_bool"), FInsertUniqueBoolArgs(B, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueBool(const FReducerEventContext& Context, const UInsertUniqueBoolReducer* Args)
{
    if (!OnInsertUniqueBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueBool"));
        }
        return false;
    }

    OnInsertUniqueBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_connection_id"), FInsertUniqueConnectionIdArgs(A, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueConnectionId(const FReducerEventContext& Context, const UInsertUniqueConnectionIdReducer* Args)
{
    if (!OnInsertUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueConnectionId"));
        }
        return false;
    }

    OnInsertUniqueConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_i128"), FInsertUniqueI128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueI128(const FReducerEventContext& Context, const UInsertUniqueI128Reducer* Args)
{
    if (!OnInsertUniqueI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI128"));
        }
        return false;
    }

    OnInsertUniqueI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_i16"), FInsertUniqueI16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueI16(const FReducerEventContext& Context, const UInsertUniqueI16Reducer* Args)
{
    if (!OnInsertUniqueI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI16"));
        }
        return false;
    }

    OnInsertUniqueI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_i256"), FInsertUniqueI256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueI256(const FReducerEventContext& Context, const UInsertUniqueI256Reducer* Args)
{
    if (!OnInsertUniqueI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI256"));
        }
        return false;
    }

    OnInsertUniqueI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_i32"), FInsertUniqueI32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueI32(const FReducerEventContext& Context, const UInsertUniqueI32Reducer* Args)
{
    if (!OnInsertUniqueI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI32"));
        }
        return false;
    }

    OnInsertUniqueI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_i64"), FInsertUniqueI64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueI64(const FReducerEventContext& Context, const UInsertUniqueI64Reducer* Args)
{
    if (!OnInsertUniqueI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI64"));
        }
        return false;
    }

    OnInsertUniqueI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_i8"), FInsertUniqueI8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueI8(const FReducerEventContext& Context, const UInsertUniqueI8Reducer* Args)
{
    if (!OnInsertUniqueI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI8"));
        }
        return false;
    }

    OnInsertUniqueI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_identity"), FInsertUniqueIdentityArgs(I, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueIdentity(const FReducerEventContext& Context, const UInsertUniqueIdentityReducer* Args)
{
    if (!OnInsertUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueIdentity"));
        }
        return false;
    }

    OnInsertUniqueIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_string"), FInsertUniqueStringArgs(S, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueString(const FReducerEventContext& Context, const UInsertUniqueStringReducer* Args)
{
    if (!OnInsertUniqueString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueString"));
        }
        return false;
    }

    OnInsertUniqueString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u128"), FInsertUniqueU128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU128(const FReducerEventContext& Context, const UInsertUniqueU128Reducer* Args)
{
    if (!OnInsertUniqueU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU128"));
        }
        return false;
    }

    OnInsertUniqueU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u16"), FInsertUniqueU16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU16(const FReducerEventContext& Context, const UInsertUniqueU16Reducer* Args)
{
    if (!OnInsertUniqueU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU16"));
        }
        return false;
    }

    OnInsertUniqueU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u256"), FInsertUniqueU256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU256(const FReducerEventContext& Context, const UInsertUniqueU256Reducer* Args)
{
    if (!OnInsertUniqueU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU256"));
        }
        return false;
    }

    OnInsertUniqueU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u32"), FInsertUniqueU32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU32(const FReducerEventContext& Context, const UInsertUniqueU32Reducer* Args)
{
    if (!OnInsertUniqueU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU32"));
        }
        return false;
    }

    OnInsertUniqueU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueU32UpdatePkU32(const uint32 N, const int32 DUnique, const int32 DPk)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u32_update_pk_u32"), FInsertUniqueU32UpdatePkU32Args(N, DUnique, DPk), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU32UpdatePkU32(const FReducerEventContext& Context, const UInsertUniqueU32UpdatePkU32Reducer* Args)
{
    if (!OnInsertUniqueU32UpdatePkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU32UpdatePkU32"));
        }
        return false;
    }

    OnInsertUniqueU32UpdatePkU32.Broadcast(Context, Args->N, Args->DUnique, Args->DPk);
    return true;
}

void URemoteReducers::InsertUniqueU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u64"), FInsertUniqueU64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU64(const FReducerEventContext& Context, const UInsertUniqueU64Reducer* Args)
{
    if (!OnInsertUniqueU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU64"));
        }
        return false;
    }

    OnInsertUniqueU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUniqueU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_unique_u8"), FInsertUniqueU8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUniqueU8(const FReducerEventContext& Context, const UInsertUniqueU8Reducer* Args)
{
    if (!OnInsertUniqueU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU8"));
        }
        return false;
    }

    OnInsertUniqueU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::InsertUser(const FString& Name, const FSpacetimeDBIdentity& Identity)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_user"), FInsertUserArgs(Name, Identity), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertUser(const FReducerEventContext& Context, const UInsertUserReducer* Args)
{
    if (!OnInsertUser.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUser"));
        }
        return false;
    }

    OnInsertUser.Broadcast(Context, Args->Name, Args->Identity);
    return true;
}

void URemoteReducers::InsertVecBool(const TArray<bool>& B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_bool"), FInsertVecBoolArgs(B), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecBool(const FReducerEventContext& Context, const UInsertVecBoolReducer* Args)
{
    if (!OnInsertVecBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecBool"));
        }
        return false;
    }

    OnInsertVecBool.Broadcast(Context, Args->B);
    return true;
}

void URemoteReducers::InsertVecByteStruct(const TArray<FByteStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_byte_struct"), FInsertVecByteStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecByteStruct(const FReducerEventContext& Context, const UInsertVecByteStructReducer* Args)
{
    if (!OnInsertVecByteStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecByteStruct"));
        }
        return false;
    }

    OnInsertVecByteStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertVecConnectionId(const TArray<FSpacetimeDBConnectionId>& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_connection_id"), FInsertVecConnectionIdArgs(A), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecConnectionId(const FReducerEventContext& Context, const UInsertVecConnectionIdReducer* Args)
{
    if (!OnInsertVecConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecConnectionId"));
        }
        return false;
    }

    OnInsertVecConnectionId.Broadcast(Context, Args->A);
    return true;
}

void URemoteReducers::InsertVecEnumWithPayload(const TArray<FEnumWithPayloadType>& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_enum_with_payload"), FInsertVecEnumWithPayloadArgs(E), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecEnumWithPayload(const FReducerEventContext& Context, const UInsertVecEnumWithPayloadReducer* Args)
{
    if (!OnInsertVecEnumWithPayload.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEnumWithPayload"));
        }
        return false;
    }

    OnInsertVecEnumWithPayload.Broadcast(Context, Args->E);
    return true;
}

void URemoteReducers::InsertVecEveryPrimitiveStruct(const TArray<FEveryPrimitiveStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_every_primitive_struct"), FInsertVecEveryPrimitiveStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecEveryPrimitiveStruct(const FReducerEventContext& Context, const UInsertVecEveryPrimitiveStructReducer* Args)
{
    if (!OnInsertVecEveryPrimitiveStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertVecEveryPrimitiveStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertVecEveryVecStruct(const TArray<FEveryVecStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_every_vec_struct"), FInsertVecEveryVecStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecEveryVecStruct(const FReducerEventContext& Context, const UInsertVecEveryVecStructReducer* Args)
{
    if (!OnInsertVecEveryVecStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEveryVecStruct"));
        }
        return false;
    }

    OnInsertVecEveryVecStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertVecF32(const TArray<float>& F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_f32"), FInsertVecF32Args(F), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecF32(const FReducerEventContext& Context, const UInsertVecF32Reducer* Args)
{
    if (!OnInsertVecF32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecF32"));
        }
        return false;
    }

    OnInsertVecF32.Broadcast(Context, Args->F);
    return true;
}

void URemoteReducers::InsertVecF64(const TArray<double>& F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_f64"), FInsertVecF64Args(F), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecF64(const FReducerEventContext& Context, const UInsertVecF64Reducer* Args)
{
    if (!OnInsertVecF64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecF64"));
        }
        return false;
    }

    OnInsertVecF64.Broadcast(Context, Args->F);
    return true;
}

void URemoteReducers::InsertVecI128(const TArray<FSpacetimeDBInt128>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_i128"), FInsertVecI128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecI128(const FReducerEventContext& Context, const UInsertVecI128Reducer* Args)
{
    if (!OnInsertVecI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI128"));
        }
        return false;
    }

    OnInsertVecI128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecI16(const TArray<int16>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_i16"), FInsertVecI16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecI16(const FReducerEventContext& Context, const UInsertVecI16Reducer* Args)
{
    if (!OnInsertVecI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI16"));
        }
        return false;
    }

    OnInsertVecI16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecI256(const TArray<FSpacetimeDBInt256>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_i256"), FInsertVecI256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecI256(const FReducerEventContext& Context, const UInsertVecI256Reducer* Args)
{
    if (!OnInsertVecI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI256"));
        }
        return false;
    }

    OnInsertVecI256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecI32(const TArray<int32>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_i32"), FInsertVecI32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecI32(const FReducerEventContext& Context, const UInsertVecI32Reducer* Args)
{
    if (!OnInsertVecI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI32"));
        }
        return false;
    }

    OnInsertVecI32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecI64(const TArray<int64>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_i64"), FInsertVecI64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecI64(const FReducerEventContext& Context, const UInsertVecI64Reducer* Args)
{
    if (!OnInsertVecI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI64"));
        }
        return false;
    }

    OnInsertVecI64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecI8(const TArray<int8>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_i8"), FInsertVecI8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecI8(const FReducerEventContext& Context, const UInsertVecI8Reducer* Args)
{
    if (!OnInsertVecI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI8"));
        }
        return false;
    }

    OnInsertVecI8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecIdentity(const TArray<FSpacetimeDBIdentity>& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_identity"), FInsertVecIdentityArgs(I), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecIdentity(const FReducerEventContext& Context, const UInsertVecIdentityReducer* Args)
{
    if (!OnInsertVecIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecIdentity"));
        }
        return false;
    }

    OnInsertVecIdentity.Broadcast(Context, Args->I);
    return true;
}

void URemoteReducers::InsertVecSimpleEnum(const TArray<ESimpleEnumType>& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_simple_enum"), FInsertVecSimpleEnumArgs(E), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecSimpleEnum(const FReducerEventContext& Context, const UInsertVecSimpleEnumReducer* Args)
{
    if (!OnInsertVecSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecSimpleEnum"));
        }
        return false;
    }

    OnInsertVecSimpleEnum.Broadcast(Context, Args->E);
    return true;
}

void URemoteReducers::InsertVecString(const TArray<FString>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_string"), FInsertVecStringArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecString(const FReducerEventContext& Context, const UInsertVecStringReducer* Args)
{
    if (!OnInsertVecString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecString"));
        }
        return false;
    }

    OnInsertVecString.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::InsertVecTimestamp(const TArray<FSpacetimeDBTimestamp>& T)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_timestamp"), FInsertVecTimestampArgs(T), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecTimestamp(const FReducerEventContext& Context, const UInsertVecTimestampReducer* Args)
{
    if (!OnInsertVecTimestamp.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecTimestamp"));
        }
        return false;
    }

    OnInsertVecTimestamp.Broadcast(Context, Args->T);
    return true;
}

void URemoteReducers::InsertVecU128(const TArray<FSpacetimeDBUInt128>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_u128"), FInsertVecU128Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecU128(const FReducerEventContext& Context, const UInsertVecU128Reducer* Args)
{
    if (!OnInsertVecU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU128"));
        }
        return false;
    }

    OnInsertVecU128.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecU16(const TArray<uint16>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_u16"), FInsertVecU16Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecU16(const FReducerEventContext& Context, const UInsertVecU16Reducer* Args)
{
    if (!OnInsertVecU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU16"));
        }
        return false;
    }

    OnInsertVecU16.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecU256(const TArray<FSpacetimeDBUInt256>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_u256"), FInsertVecU256Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecU256(const FReducerEventContext& Context, const UInsertVecU256Reducer* Args)
{
    if (!OnInsertVecU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU256"));
        }
        return false;
    }

    OnInsertVecU256.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecU32(const TArray<uint32>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_u32"), FInsertVecU32Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecU32(const FReducerEventContext& Context, const UInsertVecU32Reducer* Args)
{
    if (!OnInsertVecU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU32"));
        }
        return false;
    }

    OnInsertVecU32.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecU64(const TArray<uint64>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_u64"), FInsertVecU64Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecU64(const FReducerEventContext& Context, const UInsertVecU64Reducer* Args)
{
    if (!OnInsertVecU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU64"));
        }
        return false;
    }

    OnInsertVecU64.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecU8(const TArray<uint8>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_u8"), FInsertVecU8Args(N), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecU8(const FReducerEventContext& Context, const UInsertVecU8Reducer* Args)
{
    if (!OnInsertVecU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU8"));
        }
        return false;
    }

    OnInsertVecU8.Broadcast(Context, Args->N);
    return true;
}

void URemoteReducers::InsertVecUnitStruct(const TArray<FUnitStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("insert_vec_unit_struct"), FInsertVecUnitStructArgs(S), SetCallReducerFlags);
}

bool URemoteReducers::InvokeInsertVecUnitStruct(const FReducerEventContext& Context, const UInsertVecUnitStructReducer* Args)
{
    if (!OnInsertVecUnitStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecUnitStruct"));
        }
        return false;
    }

    OnInsertVecUnitStruct.Broadcast(Context, Args->S);
    return true;
}

void URemoteReducers::NoOpSucceeds()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("no_op_succeeds"), FNoOpSucceedsArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeNoOpSucceeds(const FReducerEventContext& Context, const UNoOpSucceedsReducer* Args)
{
    if (!OnNoOpSucceeds.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for NoOpSucceeds"));
        }
        return false;
    }

    OnNoOpSucceeds.Broadcast(Context);
    return true;
}

void URemoteReducers::SendScheduledMessage(const FScheduledTableType& Arg)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("send_scheduled_message"), FSendScheduledMessageArgs(Arg), SetCallReducerFlags);
}

bool URemoteReducers::InvokeSendScheduledMessage(const FReducerEventContext& Context, const USendScheduledMessageReducer* Args)
{
    if (!OnSendScheduledMessage.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for SendScheduledMessage"));
        }
        return false;
    }

    OnSendScheduledMessage.Broadcast(Context, Args->Arg);
    return true;
}

void URemoteReducers::UpdateIndexedSimpleEnum(const ESimpleEnumType& A, const ESimpleEnumType& B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_indexed_simple_enum"), FUpdateIndexedSimpleEnumArgs(A, B), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateIndexedSimpleEnum(const FReducerEventContext& Context, const UUpdateIndexedSimpleEnumReducer* Args)
{
    if (!OnUpdateIndexedSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateIndexedSimpleEnum"));
        }
        return false;
    }

    OnUpdateIndexedSimpleEnum.Broadcast(Context, Args->A, Args->B);
    return true;
}

void URemoteReducers::UpdatePkBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_bool"), FUpdatePkBoolArgs(B, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkBool(const FReducerEventContext& Context, const UUpdatePkBoolReducer* Args)
{
    if (!OnUpdatePkBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkBool"));
        }
        return false;
    }

    OnUpdatePkBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_connection_id"), FUpdatePkConnectionIdArgs(A, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkConnectionId(const FReducerEventContext& Context, const UUpdatePkConnectionIdReducer* Args)
{
    if (!OnUpdatePkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkConnectionId"));
        }
        return false;
    }

    OnUpdatePkConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_i128"), FUpdatePkI128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkI128(const FReducerEventContext& Context, const UUpdatePkI128Reducer* Args)
{
    if (!OnUpdatePkI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI128"));
        }
        return false;
    }

    OnUpdatePkI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_i16"), FUpdatePkI16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkI16(const FReducerEventContext& Context, const UUpdatePkI16Reducer* Args)
{
    if (!OnUpdatePkI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI16"));
        }
        return false;
    }

    OnUpdatePkI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_i256"), FUpdatePkI256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkI256(const FReducerEventContext& Context, const UUpdatePkI256Reducer* Args)
{
    if (!OnUpdatePkI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI256"));
        }
        return false;
    }

    OnUpdatePkI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_i32"), FUpdatePkI32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkI32(const FReducerEventContext& Context, const UUpdatePkI32Reducer* Args)
{
    if (!OnUpdatePkI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI32"));
        }
        return false;
    }

    OnUpdatePkI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_i64"), FUpdatePkI64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkI64(const FReducerEventContext& Context, const UUpdatePkI64Reducer* Args)
{
    if (!OnUpdatePkI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI64"));
        }
        return false;
    }

    OnUpdatePkI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_i8"), FUpdatePkI8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkI8(const FReducerEventContext& Context, const UUpdatePkI8Reducer* Args)
{
    if (!OnUpdatePkI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI8"));
        }
        return false;
    }

    OnUpdatePkI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_identity"), FUpdatePkIdentityArgs(I, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkIdentity(const FReducerEventContext& Context, const UUpdatePkIdentityReducer* Args)
{
    if (!OnUpdatePkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkIdentity"));
        }
        return false;
    }

    OnUpdatePkIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkSimpleEnum(const ESimpleEnumType& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_simple_enum"), FUpdatePkSimpleEnumArgs(A, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkSimpleEnum(const FReducerEventContext& Context, const UUpdatePkSimpleEnumReducer* Args)
{
    if (!OnUpdatePkSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkSimpleEnum"));
        }
        return false;
    }

    OnUpdatePkSimpleEnum.Broadcast(Context, Args->A, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_string"), FUpdatePkStringArgs(S, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkString(const FReducerEventContext& Context, const UUpdatePkStringReducer* Args)
{
    if (!OnUpdatePkString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkString"));
        }
        return false;
    }

    OnUpdatePkString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u128"), FUpdatePkU128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU128(const FReducerEventContext& Context, const UUpdatePkU128Reducer* Args)
{
    if (!OnUpdatePkU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU128"));
        }
        return false;
    }

    OnUpdatePkU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u16"), FUpdatePkU16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU16(const FReducerEventContext& Context, const UUpdatePkU16Reducer* Args)
{
    if (!OnUpdatePkU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU16"));
        }
        return false;
    }

    OnUpdatePkU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u256"), FUpdatePkU256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU256(const FReducerEventContext& Context, const UUpdatePkU256Reducer* Args)
{
    if (!OnUpdatePkU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU256"));
        }
        return false;
    }

    OnUpdatePkU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u32"), FUpdatePkU32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU32(const FReducerEventContext& Context, const UUpdatePkU32Reducer* Args)
{
    if (!OnUpdatePkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU32"));
        }
        return false;
    }

    OnUpdatePkU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU32Two(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u32_two"), FUpdatePkU32TwoArgs(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU32Two(const FReducerEventContext& Context, const UUpdatePkU32TwoReducer* Args)
{
    if (!OnUpdatePkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU32Two"));
        }
        return false;
    }

    OnUpdatePkU32Two.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u64"), FUpdatePkU64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU64(const FReducerEventContext& Context, const UUpdatePkU64Reducer* Args)
{
    if (!OnUpdatePkU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU64"));
        }
        return false;
    }

    OnUpdatePkU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdatePkU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_pk_u8"), FUpdatePkU8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdatePkU8(const FReducerEventContext& Context, const UUpdatePkU8Reducer* Args)
{
    if (!OnUpdatePkU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU8"));
        }
        return false;
    }

    OnUpdatePkU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_bool"), FUpdateUniqueBoolArgs(B, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueBool(const FReducerEventContext& Context, const UUpdateUniqueBoolReducer* Args)
{
    if (!OnUpdateUniqueBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueBool"));
        }
        return false;
    }

    OnUpdateUniqueBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_connection_id"), FUpdateUniqueConnectionIdArgs(A, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueConnectionId(const FReducerEventContext& Context, const UUpdateUniqueConnectionIdReducer* Args)
{
    if (!OnUpdateUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueConnectionId"));
        }
        return false;
    }

    OnUpdateUniqueConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_i128"), FUpdateUniqueI128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueI128(const FReducerEventContext& Context, const UUpdateUniqueI128Reducer* Args)
{
    if (!OnUpdateUniqueI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI128"));
        }
        return false;
    }

    OnUpdateUniqueI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_i16"), FUpdateUniqueI16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueI16(const FReducerEventContext& Context, const UUpdateUniqueI16Reducer* Args)
{
    if (!OnUpdateUniqueI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI16"));
        }
        return false;
    }

    OnUpdateUniqueI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_i256"), FUpdateUniqueI256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueI256(const FReducerEventContext& Context, const UUpdateUniqueI256Reducer* Args)
{
    if (!OnUpdateUniqueI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI256"));
        }
        return false;
    }

    OnUpdateUniqueI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_i32"), FUpdateUniqueI32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueI32(const FReducerEventContext& Context, const UUpdateUniqueI32Reducer* Args)
{
    if (!OnUpdateUniqueI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI32"));
        }
        return false;
    }

    OnUpdateUniqueI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_i64"), FUpdateUniqueI64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueI64(const FReducerEventContext& Context, const UUpdateUniqueI64Reducer* Args)
{
    if (!OnUpdateUniqueI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI64"));
        }
        return false;
    }

    OnUpdateUniqueI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_i8"), FUpdateUniqueI8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueI8(const FReducerEventContext& Context, const UUpdateUniqueI8Reducer* Args)
{
    if (!OnUpdateUniqueI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI8"));
        }
        return false;
    }

    OnUpdateUniqueI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_identity"), FUpdateUniqueIdentityArgs(I, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueIdentity(const FReducerEventContext& Context, const UUpdateUniqueIdentityReducer* Args)
{
    if (!OnUpdateUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueIdentity"));
        }
        return false;
    }

    OnUpdateUniqueIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_string"), FUpdateUniqueStringArgs(S, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueString(const FReducerEventContext& Context, const UUpdateUniqueStringReducer* Args)
{
    if (!OnUpdateUniqueString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueString"));
        }
        return false;
    }

    OnUpdateUniqueString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_u128"), FUpdateUniqueU128Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueU128(const FReducerEventContext& Context, const UUpdateUniqueU128Reducer* Args)
{
    if (!OnUpdateUniqueU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU128"));
        }
        return false;
    }

    OnUpdateUniqueU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_u16"), FUpdateUniqueU16Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueU16(const FReducerEventContext& Context, const UUpdateUniqueU16Reducer* Args)
{
    if (!OnUpdateUniqueU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU16"));
        }
        return false;
    }

    OnUpdateUniqueU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_u256"), FUpdateUniqueU256Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueU256(const FReducerEventContext& Context, const UUpdateUniqueU256Reducer* Args)
{
    if (!OnUpdateUniqueU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU256"));
        }
        return false;
    }

    OnUpdateUniqueU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_u32"), FUpdateUniqueU32Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueU32(const FReducerEventContext& Context, const UUpdateUniqueU32Reducer* Args)
{
    if (!OnUpdateUniqueU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU32"));
        }
        return false;
    }

    OnUpdateUniqueU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_u64"), FUpdateUniqueU64Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueU64(const FReducerEventContext& Context, const UUpdateUniqueU64Reducer* Args)
{
    if (!OnUpdateUniqueU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU64"));
        }
        return false;
    }

    OnUpdateUniqueU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void URemoteReducers::UpdateUniqueU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("update_unique_u8"), FUpdateUniqueU8Args(N, Data), SetCallReducerFlags);
}

bool URemoteReducers::InvokeUpdateUniqueU8(const FReducerEventContext& Context, const UUpdateUniqueU8Reducer* Args)
{
    if (!OnUpdateUniqueU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU8"));
        }
        return false;
    }

    OnUpdateUniqueU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

void UDbConnection::PostInitProperties()
{
    Super::PostInitProperties();
    
    // Connect OnUnhandledReducerError to Reducers.InternalOnUnhandledReducerError
    if (Reducers)
    {
        Reducers->InternalOnUnhandledReducerError.AddDynamic(this, &UDbConnection::OnUnhandledReducerErrorHandler);
    }
}

UFUNCTION()
void UDbConnection::OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error)
{
    if (OnUnhandledReducerError.IsBound())
    {
        OnUnhandledReducerError.Broadcast(Context, Error);
    }
}

void UDbConnection::ReducerEvent(const FReducerEvent& Event)
{
    if (!Reducers) { return; }

    FReducer DecodedReducer = DecodeReducer(Event);

    FTestClientReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;
    ReducerEvent.Reducer            = DecodedReducer;

    FReducerEventContext Context(this, ReducerEvent);

    // Use hardcoded string matching for reducer dispatching
    const FString& ReducerName = Event.ReducerCall.ReducerName;

    if (ReducerName == TEXT("delete_from_btree_u32"))
    {
        FDeleteFromBtreeU32Args Args = ReducerEvent.Reducer.GetAsDeleteFromBtreeU32();
        UDeleteFromBtreeU32Reducer* Reducer = NewObject<UDeleteFromBtreeU32Reducer>();
        Reducer->Rows = Args.Rows;
        Reducers->InvokeDeleteFromBtreeU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_large_table"))
    {
        FDeleteLargeTableArgs Args = ReducerEvent.Reducer.GetAsDeleteLargeTable();
        UDeleteLargeTableReducer* Reducer = NewObject<UDeleteLargeTableReducer>();
        Reducer->A = Args.A;
        Reducer->B = Args.B;
        Reducer->C = Args.C;
        Reducer->D = Args.D;
        Reducer->E = Args.E;
        Reducer->F = Args.F;
        Reducer->G = Args.G;
        Reducer->H = Args.H;
        Reducer->I = Args.I;
        Reducer->J = Args.J;
        Reducer->K = Args.K;
        Reducer->L = Args.L;
        Reducer->M = Args.M;
        Reducer->N = Args.N;
        Reducer->O = Args.O;
        Reducer->P = Args.P;
        Reducer->Q = Args.Q;
        Reducer->R = Args.R;
        Reducer->S = Args.S;
        Reducer->T = Args.T;
        Reducer->U = Args.U;
        Reducer->V = Args.V;
        Reducers->InvokeDeleteLargeTable(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_bool"))
    {
        FDeletePkBoolArgs Args = ReducerEvent.Reducer.GetAsDeletePkBool();
        UDeletePkBoolReducer* Reducer = NewObject<UDeletePkBoolReducer>();
        Reducer->B = Args.B;
        Reducers->InvokeDeletePkBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_connection_id"))
    {
        FDeletePkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsDeletePkConnectionId();
        UDeletePkConnectionIdReducer* Reducer = NewObject<UDeletePkConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducers->InvokeDeletePkConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i128"))
    {
        FDeletePkI128Args Args = ReducerEvent.Reducer.GetAsDeletePkI128();
        UDeletePkI128Reducer* Reducer = NewObject<UDeletePkI128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i16"))
    {
        FDeletePkI16Args Args = ReducerEvent.Reducer.GetAsDeletePkI16();
        UDeletePkI16Reducer* Reducer = NewObject<UDeletePkI16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i256"))
    {
        FDeletePkI256Args Args = ReducerEvent.Reducer.GetAsDeletePkI256();
        UDeletePkI256Reducer* Reducer = NewObject<UDeletePkI256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i32"))
    {
        FDeletePkI32Args Args = ReducerEvent.Reducer.GetAsDeletePkI32();
        UDeletePkI32Reducer* Reducer = NewObject<UDeletePkI32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i64"))
    {
        FDeletePkI64Args Args = ReducerEvent.Reducer.GetAsDeletePkI64();
        UDeletePkI64Reducer* Reducer = NewObject<UDeletePkI64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i8"))
    {
        FDeletePkI8Args Args = ReducerEvent.Reducer.GetAsDeletePkI8();
        UDeletePkI8Reducer* Reducer = NewObject<UDeletePkI8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_identity"))
    {
        FDeletePkIdentityArgs Args = ReducerEvent.Reducer.GetAsDeletePkIdentity();
        UDeletePkIdentityReducer* Reducer = NewObject<UDeletePkIdentityReducer>();
        Reducer->I = Args.I;
        Reducers->InvokeDeletePkIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_string"))
    {
        FDeletePkStringArgs Args = ReducerEvent.Reducer.GetAsDeletePkString();
        UDeletePkStringReducer* Reducer = NewObject<UDeletePkStringReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeDeletePkString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u128"))
    {
        FDeletePkU128Args Args = ReducerEvent.Reducer.GetAsDeletePkU128();
        UDeletePkU128Reducer* Reducer = NewObject<UDeletePkU128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u16"))
    {
        FDeletePkU16Args Args = ReducerEvent.Reducer.GetAsDeletePkU16();
        UDeletePkU16Reducer* Reducer = NewObject<UDeletePkU16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u256"))
    {
        FDeletePkU256Args Args = ReducerEvent.Reducer.GetAsDeletePkU256();
        UDeletePkU256Reducer* Reducer = NewObject<UDeletePkU256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u32"))
    {
        FDeletePkU32Args Args = ReducerEvent.Reducer.GetAsDeletePkU32();
        UDeletePkU32Reducer* Reducer = NewObject<UDeletePkU32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u32_insert_pk_u32_two"))
    {
        FDeletePkU32InsertPkU32TwoArgs Args = ReducerEvent.Reducer.GetAsDeletePkU32InsertPkU32Two();
        UDeletePkU32InsertPkU32TwoReducer* Reducer = NewObject<UDeletePkU32InsertPkU32TwoReducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeDeletePkU32InsertPkU32Two(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u32_two"))
    {
        FDeletePkU32TwoArgs Args = ReducerEvent.Reducer.GetAsDeletePkU32Two();
        UDeletePkU32TwoReducer* Reducer = NewObject<UDeletePkU32TwoReducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU32Two(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u64"))
    {
        FDeletePkU64Args Args = ReducerEvent.Reducer.GetAsDeletePkU64();
        UDeletePkU64Reducer* Reducer = NewObject<UDeletePkU64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u8"))
    {
        FDeletePkU8Args Args = ReducerEvent.Reducer.GetAsDeletePkU8();
        UDeletePkU8Reducer* Reducer = NewObject<UDeletePkU8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeletePkU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_bool"))
    {
        FDeleteUniqueBoolArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueBool();
        UDeleteUniqueBoolReducer* Reducer = NewObject<UDeleteUniqueBoolReducer>();
        Reducer->B = Args.B;
        Reducers->InvokeDeleteUniqueBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_connection_id"))
    {
        FDeleteUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueConnectionId();
        UDeleteUniqueConnectionIdReducer* Reducer = NewObject<UDeleteUniqueConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducers->InvokeDeleteUniqueConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i128"))
    {
        FDeleteUniqueI128Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI128();
        UDeleteUniqueI128Reducer* Reducer = NewObject<UDeleteUniqueI128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i16"))
    {
        FDeleteUniqueI16Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI16();
        UDeleteUniqueI16Reducer* Reducer = NewObject<UDeleteUniqueI16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i256"))
    {
        FDeleteUniqueI256Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI256();
        UDeleteUniqueI256Reducer* Reducer = NewObject<UDeleteUniqueI256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i32"))
    {
        FDeleteUniqueI32Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI32();
        UDeleteUniqueI32Reducer* Reducer = NewObject<UDeleteUniqueI32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i64"))
    {
        FDeleteUniqueI64Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI64();
        UDeleteUniqueI64Reducer* Reducer = NewObject<UDeleteUniqueI64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i8"))
    {
        FDeleteUniqueI8Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI8();
        UDeleteUniqueI8Reducer* Reducer = NewObject<UDeleteUniqueI8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_identity"))
    {
        FDeleteUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueIdentity();
        UDeleteUniqueIdentityReducer* Reducer = NewObject<UDeleteUniqueIdentityReducer>();
        Reducer->I = Args.I;
        Reducers->InvokeDeleteUniqueIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_string"))
    {
        FDeleteUniqueStringArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueString();
        UDeleteUniqueStringReducer* Reducer = NewObject<UDeleteUniqueStringReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeDeleteUniqueString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u128"))
    {
        FDeleteUniqueU128Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU128();
        UDeleteUniqueU128Reducer* Reducer = NewObject<UDeleteUniqueU128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u16"))
    {
        FDeleteUniqueU16Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU16();
        UDeleteUniqueU16Reducer* Reducer = NewObject<UDeleteUniqueU16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u256"))
    {
        FDeleteUniqueU256Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU256();
        UDeleteUniqueU256Reducer* Reducer = NewObject<UDeleteUniqueU256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u32"))
    {
        FDeleteUniqueU32Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU32();
        UDeleteUniqueU32Reducer* Reducer = NewObject<UDeleteUniqueU32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u64"))
    {
        FDeleteUniqueU64Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU64();
        UDeleteUniqueU64Reducer* Reducer = NewObject<UDeleteUniqueU64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u8"))
    {
        FDeleteUniqueU8Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU8();
        UDeleteUniqueU8Reducer* Reducer = NewObject<UDeleteUniqueU8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeDeleteUniqueU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_call_timestamp"))
    {
        FInsertCallTimestampArgs Args = ReducerEvent.Reducer.GetAsInsertCallTimestamp();
        UInsertCallTimestampReducer* Reducer = NewObject<UInsertCallTimestampReducer>();
        Reducers->InvokeInsertCallTimestamp(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_one_connection_id"))
    {
        FInsertCallerOneConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerOneConnectionId();
        UInsertCallerOneConnectionIdReducer* Reducer = NewObject<UInsertCallerOneConnectionIdReducer>();
        Reducers->InvokeInsertCallerOneConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_one_identity"))
    {
        FInsertCallerOneIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerOneIdentity();
        UInsertCallerOneIdentityReducer* Reducer = NewObject<UInsertCallerOneIdentityReducer>();
        Reducers->InvokeInsertCallerOneIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_pk_connection_id"))
    {
        FInsertCallerPkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerPkConnectionId();
        UInsertCallerPkConnectionIdReducer* Reducer = NewObject<UInsertCallerPkConnectionIdReducer>();
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertCallerPkConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_pk_identity"))
    {
        FInsertCallerPkIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerPkIdentity();
        UInsertCallerPkIdentityReducer* Reducer = NewObject<UInsertCallerPkIdentityReducer>();
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertCallerPkIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_unique_connection_id"))
    {
        FInsertCallerUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerUniqueConnectionId();
        UInsertCallerUniqueConnectionIdReducer* Reducer = NewObject<UInsertCallerUniqueConnectionIdReducer>();
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertCallerUniqueConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_unique_identity"))
    {
        FInsertCallerUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerUniqueIdentity();
        UInsertCallerUniqueIdentityReducer* Reducer = NewObject<UInsertCallerUniqueIdentityReducer>();
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertCallerUniqueIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_vec_connection_id"))
    {
        FInsertCallerVecConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerVecConnectionId();
        UInsertCallerVecConnectionIdReducer* Reducer = NewObject<UInsertCallerVecConnectionIdReducer>();
        Reducers->InvokeInsertCallerVecConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_caller_vec_identity"))
    {
        FInsertCallerVecIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerVecIdentity();
        UInsertCallerVecIdentityReducer* Reducer = NewObject<UInsertCallerVecIdentityReducer>();
        Reducers->InvokeInsertCallerVecIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_into_btree_u32"))
    {
        FInsertIntoBtreeU32Args Args = ReducerEvent.Reducer.GetAsInsertIntoBtreeU32();
        UInsertIntoBtreeU32Reducer* Reducer = NewObject<UInsertIntoBtreeU32Reducer>();
        Reducer->Rows = Args.Rows;
        Reducers->InvokeInsertIntoBtreeU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_into_indexed_simple_enum"))
    {
        FInsertIntoIndexedSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertIntoIndexedSimpleEnum();
        UInsertIntoIndexedSimpleEnumReducer* Reducer = NewObject<UInsertIntoIndexedSimpleEnumReducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertIntoIndexedSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_into_pk_btree_u32"))
    {
        FInsertIntoPkBtreeU32Args Args = ReducerEvent.Reducer.GetAsInsertIntoPkBtreeU32();
        UInsertIntoPkBtreeU32Reducer* Reducer = NewObject<UInsertIntoPkBtreeU32Reducer>();
        Reducer->PkU32 = Args.PkU32;
        Reducer->BtU32 = Args.BtU32;
        Reducers->InvokeInsertIntoPkBtreeU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_large_table"))
    {
        FInsertLargeTableArgs Args = ReducerEvent.Reducer.GetAsInsertLargeTable();
        UInsertLargeTableReducer* Reducer = NewObject<UInsertLargeTableReducer>();
        Reducer->A = Args.A;
        Reducer->B = Args.B;
        Reducer->C = Args.C;
        Reducer->D = Args.D;
        Reducer->E = Args.E;
        Reducer->F = Args.F;
        Reducer->G = Args.G;
        Reducer->H = Args.H;
        Reducer->I = Args.I;
        Reducer->J = Args.J;
        Reducer->K = Args.K;
        Reducer->L = Args.L;
        Reducer->M = Args.M;
        Reducer->N = Args.N;
        Reducer->O = Args.O;
        Reducer->P = Args.P;
        Reducer->Q = Args.Q;
        Reducer->R = Args.R;
        Reducer->S = Args.S;
        Reducer->T = Args.T;
        Reducer->U = Args.U;
        Reducer->V = Args.V;
        Reducers->InvokeInsertLargeTable(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_bool"))
    {
        FInsertOneBoolArgs Args = ReducerEvent.Reducer.GetAsInsertOneBool();
        UInsertOneBoolReducer* Reducer = NewObject<UInsertOneBoolReducer>();
        Reducer->B = Args.B;
        Reducers->InvokeInsertOneBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_byte_struct"))
    {
        FInsertOneByteStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneByteStruct();
        UInsertOneByteStructReducer* Reducer = NewObject<UInsertOneByteStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOneByteStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_connection_id"))
    {
        FInsertOneConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertOneConnectionId();
        UInsertOneConnectionIdReducer* Reducer = NewObject<UInsertOneConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducers->InvokeInsertOneConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_enum_with_payload"))
    {
        FInsertOneEnumWithPayloadArgs Args = ReducerEvent.Reducer.GetAsInsertOneEnumWithPayload();
        UInsertOneEnumWithPayloadReducer* Reducer = NewObject<UInsertOneEnumWithPayloadReducer>();
        Reducer->E = Args.E;
        Reducers->InvokeInsertOneEnumWithPayload(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_every_primitive_struct"))
    {
        FInsertOneEveryPrimitiveStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneEveryPrimitiveStruct();
        UInsertOneEveryPrimitiveStructReducer* Reducer = NewObject<UInsertOneEveryPrimitiveStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOneEveryPrimitiveStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_every_vec_struct"))
    {
        FInsertOneEveryVecStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneEveryVecStruct();
        UInsertOneEveryVecStructReducer* Reducer = NewObject<UInsertOneEveryVecStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOneEveryVecStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_f32"))
    {
        FInsertOneF32Args Args = ReducerEvent.Reducer.GetAsInsertOneF32();
        UInsertOneF32Reducer* Reducer = NewObject<UInsertOneF32Reducer>();
        Reducer->F = Args.F;
        Reducers->InvokeInsertOneF32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_f64"))
    {
        FInsertOneF64Args Args = ReducerEvent.Reducer.GetAsInsertOneF64();
        UInsertOneF64Reducer* Reducer = NewObject<UInsertOneF64Reducer>();
        Reducer->F = Args.F;
        Reducers->InvokeInsertOneF64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_i128"))
    {
        FInsertOneI128Args Args = ReducerEvent.Reducer.GetAsInsertOneI128();
        UInsertOneI128Reducer* Reducer = NewObject<UInsertOneI128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_i16"))
    {
        FInsertOneI16Args Args = ReducerEvent.Reducer.GetAsInsertOneI16();
        UInsertOneI16Reducer* Reducer = NewObject<UInsertOneI16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_i256"))
    {
        FInsertOneI256Args Args = ReducerEvent.Reducer.GetAsInsertOneI256();
        UInsertOneI256Reducer* Reducer = NewObject<UInsertOneI256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_i32"))
    {
        FInsertOneI32Args Args = ReducerEvent.Reducer.GetAsInsertOneI32();
        UInsertOneI32Reducer* Reducer = NewObject<UInsertOneI32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_i64"))
    {
        FInsertOneI64Args Args = ReducerEvent.Reducer.GetAsInsertOneI64();
        UInsertOneI64Reducer* Reducer = NewObject<UInsertOneI64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_i8"))
    {
        FInsertOneI8Args Args = ReducerEvent.Reducer.GetAsInsertOneI8();
        UInsertOneI8Reducer* Reducer = NewObject<UInsertOneI8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_identity"))
    {
        FInsertOneIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertOneIdentity();
        UInsertOneIdentityReducer* Reducer = NewObject<UInsertOneIdentityReducer>();
        Reducer->I = Args.I;
        Reducers->InvokeInsertOneIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_simple_enum"))
    {
        FInsertOneSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertOneSimpleEnum();
        UInsertOneSimpleEnumReducer* Reducer = NewObject<UInsertOneSimpleEnumReducer>();
        Reducer->E = Args.E;
        Reducers->InvokeInsertOneSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_string"))
    {
        FInsertOneStringArgs Args = ReducerEvent.Reducer.GetAsInsertOneString();
        UInsertOneStringReducer* Reducer = NewObject<UInsertOneStringReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOneString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_timestamp"))
    {
        FInsertOneTimestampArgs Args = ReducerEvent.Reducer.GetAsInsertOneTimestamp();
        UInsertOneTimestampReducer* Reducer = NewObject<UInsertOneTimestampReducer>();
        Reducer->T = Args.T;
        Reducers->InvokeInsertOneTimestamp(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_u128"))
    {
        FInsertOneU128Args Args = ReducerEvent.Reducer.GetAsInsertOneU128();
        UInsertOneU128Reducer* Reducer = NewObject<UInsertOneU128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_u16"))
    {
        FInsertOneU16Args Args = ReducerEvent.Reducer.GetAsInsertOneU16();
        UInsertOneU16Reducer* Reducer = NewObject<UInsertOneU16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_u256"))
    {
        FInsertOneU256Args Args = ReducerEvent.Reducer.GetAsInsertOneU256();
        UInsertOneU256Reducer* Reducer = NewObject<UInsertOneU256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_u32"))
    {
        FInsertOneU32Args Args = ReducerEvent.Reducer.GetAsInsertOneU32();
        UInsertOneU32Reducer* Reducer = NewObject<UInsertOneU32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_u64"))
    {
        FInsertOneU64Args Args = ReducerEvent.Reducer.GetAsInsertOneU64();
        UInsertOneU64Reducer* Reducer = NewObject<UInsertOneU64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_u8"))
    {
        FInsertOneU8Args Args = ReducerEvent.Reducer.GetAsInsertOneU8();
        UInsertOneU8Reducer* Reducer = NewObject<UInsertOneU8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOneU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_one_unit_struct"))
    {
        FInsertOneUnitStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneUnitStruct();
        UInsertOneUnitStructReducer* Reducer = NewObject<UInsertOneUnitStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOneUnitStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_option_every_primitive_struct"))
    {
        FInsertOptionEveryPrimitiveStructArgs Args = ReducerEvent.Reducer.GetAsInsertOptionEveryPrimitiveStruct();
        UInsertOptionEveryPrimitiveStructReducer* Reducer = NewObject<UInsertOptionEveryPrimitiveStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOptionEveryPrimitiveStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_option_i32"))
    {
        FInsertOptionI32Args Args = ReducerEvent.Reducer.GetAsInsertOptionI32();
        UInsertOptionI32Reducer* Reducer = NewObject<UInsertOptionI32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertOptionI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_option_identity"))
    {
        FInsertOptionIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertOptionIdentity();
        UInsertOptionIdentityReducer* Reducer = NewObject<UInsertOptionIdentityReducer>();
        Reducer->I = Args.I;
        Reducers->InvokeInsertOptionIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_option_simple_enum"))
    {
        FInsertOptionSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertOptionSimpleEnum();
        UInsertOptionSimpleEnumReducer* Reducer = NewObject<UInsertOptionSimpleEnumReducer>();
        Reducer->E = Args.E;
        Reducers->InvokeInsertOptionSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_option_string"))
    {
        FInsertOptionStringArgs Args = ReducerEvent.Reducer.GetAsInsertOptionString();
        UInsertOptionStringReducer* Reducer = NewObject<UInsertOptionStringReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertOptionString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_option_vec_option_i32"))
    {
        FInsertOptionVecOptionI32Args Args = ReducerEvent.Reducer.GetAsInsertOptionVecOptionI32();
        UInsertOptionVecOptionI32Reducer* Reducer = NewObject<UInsertOptionVecOptionI32Reducer>();
        Reducer->V = Args.V;
        Reducers->InvokeInsertOptionVecOptionI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_bool"))
    {
        FInsertPkBoolArgs Args = ReducerEvent.Reducer.GetAsInsertPkBool();
        UInsertPkBoolReducer* Reducer = NewObject<UInsertPkBoolReducer>();
        Reducer->B = Args.B;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_connection_id"))
    {
        FInsertPkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertPkConnectionId();
        UInsertPkConnectionIdReducer* Reducer = NewObject<UInsertPkConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i128"))
    {
        FInsertPkI128Args Args = ReducerEvent.Reducer.GetAsInsertPkI128();
        UInsertPkI128Reducer* Reducer = NewObject<UInsertPkI128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i16"))
    {
        FInsertPkI16Args Args = ReducerEvent.Reducer.GetAsInsertPkI16();
        UInsertPkI16Reducer* Reducer = NewObject<UInsertPkI16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i256"))
    {
        FInsertPkI256Args Args = ReducerEvent.Reducer.GetAsInsertPkI256();
        UInsertPkI256Reducer* Reducer = NewObject<UInsertPkI256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i32"))
    {
        FInsertPkI32Args Args = ReducerEvent.Reducer.GetAsInsertPkI32();
        UInsertPkI32Reducer* Reducer = NewObject<UInsertPkI32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i64"))
    {
        FInsertPkI64Args Args = ReducerEvent.Reducer.GetAsInsertPkI64();
        UInsertPkI64Reducer* Reducer = NewObject<UInsertPkI64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i8"))
    {
        FInsertPkI8Args Args = ReducerEvent.Reducer.GetAsInsertPkI8();
        UInsertPkI8Reducer* Reducer = NewObject<UInsertPkI8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_identity"))
    {
        FInsertPkIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertPkIdentity();
        UInsertPkIdentityReducer* Reducer = NewObject<UInsertPkIdentityReducer>();
        Reducer->I = Args.I;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_simple_enum"))
    {
        FInsertPkSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertPkSimpleEnum();
        UInsertPkSimpleEnumReducer* Reducer = NewObject<UInsertPkSimpleEnumReducer>();
        Reducer->A = Args.A;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_string"))
    {
        FInsertPkStringArgs Args = ReducerEvent.Reducer.GetAsInsertPkString();
        UInsertPkStringReducer* Reducer = NewObject<UInsertPkStringReducer>();
        Reducer->S = Args.S;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u128"))
    {
        FInsertPkU128Args Args = ReducerEvent.Reducer.GetAsInsertPkU128();
        UInsertPkU128Reducer* Reducer = NewObject<UInsertPkU128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u16"))
    {
        FInsertPkU16Args Args = ReducerEvent.Reducer.GetAsInsertPkU16();
        UInsertPkU16Reducer* Reducer = NewObject<UInsertPkU16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u256"))
    {
        FInsertPkU256Args Args = ReducerEvent.Reducer.GetAsInsertPkU256();
        UInsertPkU256Reducer* Reducer = NewObject<UInsertPkU256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u32"))
    {
        FInsertPkU32Args Args = ReducerEvent.Reducer.GetAsInsertPkU32();
        UInsertPkU32Reducer* Reducer = NewObject<UInsertPkU32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u32_two"))
    {
        FInsertPkU32TwoArgs Args = ReducerEvent.Reducer.GetAsInsertPkU32Two();
        UInsertPkU32TwoReducer* Reducer = NewObject<UInsertPkU32TwoReducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU32Two(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u64"))
    {
        FInsertPkU64Args Args = ReducerEvent.Reducer.GetAsInsertPkU64();
        UInsertPkU64Reducer* Reducer = NewObject<UInsertPkU64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u8"))
    {
        FInsertPkU8Args Args = ReducerEvent.Reducer.GetAsInsertPkU8();
        UInsertPkU8Reducer* Reducer = NewObject<UInsertPkU8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertPkU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_primitives_as_strings"))
    {
        FInsertPrimitivesAsStringsArgs Args = ReducerEvent.Reducer.GetAsInsertPrimitivesAsStrings();
        UInsertPrimitivesAsStringsReducer* Reducer = NewObject<UInsertPrimitivesAsStringsReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertPrimitivesAsStrings(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_table_holds_table"))
    {
        FInsertTableHoldsTableArgs Args = ReducerEvent.Reducer.GetAsInsertTableHoldsTable();
        UInsertTableHoldsTableReducer* Reducer = NewObject<UInsertTableHoldsTableReducer>();
        Reducer->A = Args.A;
        Reducer->B = Args.B;
        Reducers->InvokeInsertTableHoldsTable(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_bool"))
    {
        FInsertUniqueBoolArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueBool();
        UInsertUniqueBoolReducer* Reducer = NewObject<UInsertUniqueBoolReducer>();
        Reducer->B = Args.B;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_connection_id"))
    {
        FInsertUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueConnectionId();
        UInsertUniqueConnectionIdReducer* Reducer = NewObject<UInsertUniqueConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i128"))
    {
        FInsertUniqueI128Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI128();
        UInsertUniqueI128Reducer* Reducer = NewObject<UInsertUniqueI128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i16"))
    {
        FInsertUniqueI16Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI16();
        UInsertUniqueI16Reducer* Reducer = NewObject<UInsertUniqueI16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i256"))
    {
        FInsertUniqueI256Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI256();
        UInsertUniqueI256Reducer* Reducer = NewObject<UInsertUniqueI256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i32"))
    {
        FInsertUniqueI32Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI32();
        UInsertUniqueI32Reducer* Reducer = NewObject<UInsertUniqueI32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i64"))
    {
        FInsertUniqueI64Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI64();
        UInsertUniqueI64Reducer* Reducer = NewObject<UInsertUniqueI64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i8"))
    {
        FInsertUniqueI8Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI8();
        UInsertUniqueI8Reducer* Reducer = NewObject<UInsertUniqueI8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_identity"))
    {
        FInsertUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueIdentity();
        UInsertUniqueIdentityReducer* Reducer = NewObject<UInsertUniqueIdentityReducer>();
        Reducer->I = Args.I;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_string"))
    {
        FInsertUniqueStringArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueString();
        UInsertUniqueStringReducer* Reducer = NewObject<UInsertUniqueStringReducer>();
        Reducer->S = Args.S;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u128"))
    {
        FInsertUniqueU128Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU128();
        UInsertUniqueU128Reducer* Reducer = NewObject<UInsertUniqueU128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u16"))
    {
        FInsertUniqueU16Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU16();
        UInsertUniqueU16Reducer* Reducer = NewObject<UInsertUniqueU16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u256"))
    {
        FInsertUniqueU256Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU256();
        UInsertUniqueU256Reducer* Reducer = NewObject<UInsertUniqueU256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u32"))
    {
        FInsertUniqueU32Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU32();
        UInsertUniqueU32Reducer* Reducer = NewObject<UInsertUniqueU32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u32_update_pk_u32"))
    {
        FInsertUniqueU32UpdatePkU32Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU32UpdatePkU32();
        UInsertUniqueU32UpdatePkU32Reducer* Reducer = NewObject<UInsertUniqueU32UpdatePkU32Reducer>();
        Reducer->N = Args.N;
        Reducer->DUnique = Args.DUnique;
        Reducer->DPk = Args.DPk;
        Reducers->InvokeInsertUniqueU32UpdatePkU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u64"))
    {
        FInsertUniqueU64Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU64();
        UInsertUniqueU64Reducer* Reducer = NewObject<UInsertUniqueU64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u8"))
    {
        FInsertUniqueU8Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU8();
        UInsertUniqueU8Reducer* Reducer = NewObject<UInsertUniqueU8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeInsertUniqueU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_user"))
    {
        FInsertUserArgs Args = ReducerEvent.Reducer.GetAsInsertUser();
        UInsertUserReducer* Reducer = NewObject<UInsertUserReducer>();
        Reducer->Name = Args.Name;
        Reducer->Identity = Args.Identity;
        Reducers->InvokeInsertUser(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_bool"))
    {
        FInsertVecBoolArgs Args = ReducerEvent.Reducer.GetAsInsertVecBool();
        UInsertVecBoolReducer* Reducer = NewObject<UInsertVecBoolReducer>();
        Reducer->B = Args.B;
        Reducers->InvokeInsertVecBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_byte_struct"))
    {
        FInsertVecByteStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecByteStruct();
        UInsertVecByteStructReducer* Reducer = NewObject<UInsertVecByteStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertVecByteStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_connection_id"))
    {
        FInsertVecConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertVecConnectionId();
        UInsertVecConnectionIdReducer* Reducer = NewObject<UInsertVecConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducers->InvokeInsertVecConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_enum_with_payload"))
    {
        FInsertVecEnumWithPayloadArgs Args = ReducerEvent.Reducer.GetAsInsertVecEnumWithPayload();
        UInsertVecEnumWithPayloadReducer* Reducer = NewObject<UInsertVecEnumWithPayloadReducer>();
        Reducer->E = Args.E;
        Reducers->InvokeInsertVecEnumWithPayload(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_every_primitive_struct"))
    {
        FInsertVecEveryPrimitiveStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecEveryPrimitiveStruct();
        UInsertVecEveryPrimitiveStructReducer* Reducer = NewObject<UInsertVecEveryPrimitiveStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertVecEveryPrimitiveStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_every_vec_struct"))
    {
        FInsertVecEveryVecStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecEveryVecStruct();
        UInsertVecEveryVecStructReducer* Reducer = NewObject<UInsertVecEveryVecStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertVecEveryVecStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_f32"))
    {
        FInsertVecF32Args Args = ReducerEvent.Reducer.GetAsInsertVecF32();
        UInsertVecF32Reducer* Reducer = NewObject<UInsertVecF32Reducer>();
        Reducer->F = Args.F;
        Reducers->InvokeInsertVecF32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_f64"))
    {
        FInsertVecF64Args Args = ReducerEvent.Reducer.GetAsInsertVecF64();
        UInsertVecF64Reducer* Reducer = NewObject<UInsertVecF64Reducer>();
        Reducer->F = Args.F;
        Reducers->InvokeInsertVecF64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i128"))
    {
        FInsertVecI128Args Args = ReducerEvent.Reducer.GetAsInsertVecI128();
        UInsertVecI128Reducer* Reducer = NewObject<UInsertVecI128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i16"))
    {
        FInsertVecI16Args Args = ReducerEvent.Reducer.GetAsInsertVecI16();
        UInsertVecI16Reducer* Reducer = NewObject<UInsertVecI16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i256"))
    {
        FInsertVecI256Args Args = ReducerEvent.Reducer.GetAsInsertVecI256();
        UInsertVecI256Reducer* Reducer = NewObject<UInsertVecI256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i32"))
    {
        FInsertVecI32Args Args = ReducerEvent.Reducer.GetAsInsertVecI32();
        UInsertVecI32Reducer* Reducer = NewObject<UInsertVecI32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i64"))
    {
        FInsertVecI64Args Args = ReducerEvent.Reducer.GetAsInsertVecI64();
        UInsertVecI64Reducer* Reducer = NewObject<UInsertVecI64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i8"))
    {
        FInsertVecI8Args Args = ReducerEvent.Reducer.GetAsInsertVecI8();
        UInsertVecI8Reducer* Reducer = NewObject<UInsertVecI8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_identity"))
    {
        FInsertVecIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertVecIdentity();
        UInsertVecIdentityReducer* Reducer = NewObject<UInsertVecIdentityReducer>();
        Reducer->I = Args.I;
        Reducers->InvokeInsertVecIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_simple_enum"))
    {
        FInsertVecSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertVecSimpleEnum();
        UInsertVecSimpleEnumReducer* Reducer = NewObject<UInsertVecSimpleEnumReducer>();
        Reducer->E = Args.E;
        Reducers->InvokeInsertVecSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_string"))
    {
        FInsertVecStringArgs Args = ReducerEvent.Reducer.GetAsInsertVecString();
        UInsertVecStringReducer* Reducer = NewObject<UInsertVecStringReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertVecString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_timestamp"))
    {
        FInsertVecTimestampArgs Args = ReducerEvent.Reducer.GetAsInsertVecTimestamp();
        UInsertVecTimestampReducer* Reducer = NewObject<UInsertVecTimestampReducer>();
        Reducer->T = Args.T;
        Reducers->InvokeInsertVecTimestamp(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u128"))
    {
        FInsertVecU128Args Args = ReducerEvent.Reducer.GetAsInsertVecU128();
        UInsertVecU128Reducer* Reducer = NewObject<UInsertVecU128Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u16"))
    {
        FInsertVecU16Args Args = ReducerEvent.Reducer.GetAsInsertVecU16();
        UInsertVecU16Reducer* Reducer = NewObject<UInsertVecU16Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u256"))
    {
        FInsertVecU256Args Args = ReducerEvent.Reducer.GetAsInsertVecU256();
        UInsertVecU256Reducer* Reducer = NewObject<UInsertVecU256Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u32"))
    {
        FInsertVecU32Args Args = ReducerEvent.Reducer.GetAsInsertVecU32();
        UInsertVecU32Reducer* Reducer = NewObject<UInsertVecU32Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u64"))
    {
        FInsertVecU64Args Args = ReducerEvent.Reducer.GetAsInsertVecU64();
        UInsertVecU64Reducer* Reducer = NewObject<UInsertVecU64Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u8"))
    {
        FInsertVecU8Args Args = ReducerEvent.Reducer.GetAsInsertVecU8();
        UInsertVecU8Reducer* Reducer = NewObject<UInsertVecU8Reducer>();
        Reducer->N = Args.N;
        Reducers->InvokeInsertVecU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("insert_vec_unit_struct"))
    {
        FInsertVecUnitStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecUnitStruct();
        UInsertVecUnitStructReducer* Reducer = NewObject<UInsertVecUnitStructReducer>();
        Reducer->S = Args.S;
        Reducers->InvokeInsertVecUnitStruct(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("no_op_succeeds"))
    {
        FNoOpSucceedsArgs Args = ReducerEvent.Reducer.GetAsNoOpSucceeds();
        UNoOpSucceedsReducer* Reducer = NewObject<UNoOpSucceedsReducer>();
        Reducers->InvokeNoOpSucceeds(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("send_scheduled_message"))
    {
        FSendScheduledMessageArgs Args = ReducerEvent.Reducer.GetAsSendScheduledMessage();
        USendScheduledMessageReducer* Reducer = NewObject<USendScheduledMessageReducer>();
        Reducer->Arg = Args.Arg;
        Reducers->InvokeSendScheduledMessage(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_indexed_simple_enum"))
    {
        FUpdateIndexedSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsUpdateIndexedSimpleEnum();
        UUpdateIndexedSimpleEnumReducer* Reducer = NewObject<UUpdateIndexedSimpleEnumReducer>();
        Reducer->A = Args.A;
        Reducer->B = Args.B;
        Reducers->InvokeUpdateIndexedSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_bool"))
    {
        FUpdatePkBoolArgs Args = ReducerEvent.Reducer.GetAsUpdatePkBool();
        UUpdatePkBoolReducer* Reducer = NewObject<UUpdatePkBoolReducer>();
        Reducer->B = Args.B;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_connection_id"))
    {
        FUpdatePkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsUpdatePkConnectionId();
        UUpdatePkConnectionIdReducer* Reducer = NewObject<UUpdatePkConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_i128"))
    {
        FUpdatePkI128Args Args = ReducerEvent.Reducer.GetAsUpdatePkI128();
        UUpdatePkI128Reducer* Reducer = NewObject<UUpdatePkI128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_i16"))
    {
        FUpdatePkI16Args Args = ReducerEvent.Reducer.GetAsUpdatePkI16();
        UUpdatePkI16Reducer* Reducer = NewObject<UUpdatePkI16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_i256"))
    {
        FUpdatePkI256Args Args = ReducerEvent.Reducer.GetAsUpdatePkI256();
        UUpdatePkI256Reducer* Reducer = NewObject<UUpdatePkI256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_i32"))
    {
        FUpdatePkI32Args Args = ReducerEvent.Reducer.GetAsUpdatePkI32();
        UUpdatePkI32Reducer* Reducer = NewObject<UUpdatePkI32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_i64"))
    {
        FUpdatePkI64Args Args = ReducerEvent.Reducer.GetAsUpdatePkI64();
        UUpdatePkI64Reducer* Reducer = NewObject<UUpdatePkI64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_i8"))
    {
        FUpdatePkI8Args Args = ReducerEvent.Reducer.GetAsUpdatePkI8();
        UUpdatePkI8Reducer* Reducer = NewObject<UUpdatePkI8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_identity"))
    {
        FUpdatePkIdentityArgs Args = ReducerEvent.Reducer.GetAsUpdatePkIdentity();
        UUpdatePkIdentityReducer* Reducer = NewObject<UUpdatePkIdentityReducer>();
        Reducer->I = Args.I;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_simple_enum"))
    {
        FUpdatePkSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsUpdatePkSimpleEnum();
        UUpdatePkSimpleEnumReducer* Reducer = NewObject<UUpdatePkSimpleEnumReducer>();
        Reducer->A = Args.A;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkSimpleEnum(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_string"))
    {
        FUpdatePkStringArgs Args = ReducerEvent.Reducer.GetAsUpdatePkString();
        UUpdatePkStringReducer* Reducer = NewObject<UUpdatePkStringReducer>();
        Reducer->S = Args.S;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u128"))
    {
        FUpdatePkU128Args Args = ReducerEvent.Reducer.GetAsUpdatePkU128();
        UUpdatePkU128Reducer* Reducer = NewObject<UUpdatePkU128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u16"))
    {
        FUpdatePkU16Args Args = ReducerEvent.Reducer.GetAsUpdatePkU16();
        UUpdatePkU16Reducer* Reducer = NewObject<UUpdatePkU16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u256"))
    {
        FUpdatePkU256Args Args = ReducerEvent.Reducer.GetAsUpdatePkU256();
        UUpdatePkU256Reducer* Reducer = NewObject<UUpdatePkU256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u32"))
    {
        FUpdatePkU32Args Args = ReducerEvent.Reducer.GetAsUpdatePkU32();
        UUpdatePkU32Reducer* Reducer = NewObject<UUpdatePkU32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u32_two"))
    {
        FUpdatePkU32TwoArgs Args = ReducerEvent.Reducer.GetAsUpdatePkU32Two();
        UUpdatePkU32TwoReducer* Reducer = NewObject<UUpdatePkU32TwoReducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU32Two(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u64"))
    {
        FUpdatePkU64Args Args = ReducerEvent.Reducer.GetAsUpdatePkU64();
        UUpdatePkU64Reducer* Reducer = NewObject<UUpdatePkU64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_pk_u8"))
    {
        FUpdatePkU8Args Args = ReducerEvent.Reducer.GetAsUpdatePkU8();
        UUpdatePkU8Reducer* Reducer = NewObject<UUpdatePkU8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdatePkU8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_bool"))
    {
        FUpdateUniqueBoolArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueBool();
        UUpdateUniqueBoolReducer* Reducer = NewObject<UUpdateUniqueBoolReducer>();
        Reducer->B = Args.B;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueBool(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_connection_id"))
    {
        FUpdateUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueConnectionId();
        UUpdateUniqueConnectionIdReducer* Reducer = NewObject<UUpdateUniqueConnectionIdReducer>();
        Reducer->A = Args.A;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueConnectionId(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_i128"))
    {
        FUpdateUniqueI128Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI128();
        UUpdateUniqueI128Reducer* Reducer = NewObject<UUpdateUniqueI128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueI128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_i16"))
    {
        FUpdateUniqueI16Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI16();
        UUpdateUniqueI16Reducer* Reducer = NewObject<UUpdateUniqueI16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueI16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_i256"))
    {
        FUpdateUniqueI256Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI256();
        UUpdateUniqueI256Reducer* Reducer = NewObject<UUpdateUniqueI256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueI256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_i32"))
    {
        FUpdateUniqueI32Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI32();
        UUpdateUniqueI32Reducer* Reducer = NewObject<UUpdateUniqueI32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueI32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_i64"))
    {
        FUpdateUniqueI64Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI64();
        UUpdateUniqueI64Reducer* Reducer = NewObject<UUpdateUniqueI64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueI64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_i8"))
    {
        FUpdateUniqueI8Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI8();
        UUpdateUniqueI8Reducer* Reducer = NewObject<UUpdateUniqueI8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueI8(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_identity"))
    {
        FUpdateUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueIdentity();
        UUpdateUniqueIdentityReducer* Reducer = NewObject<UUpdateUniqueIdentityReducer>();
        Reducer->I = Args.I;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueIdentity(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_string"))
    {
        FUpdateUniqueStringArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueString();
        UUpdateUniqueStringReducer* Reducer = NewObject<UUpdateUniqueStringReducer>();
        Reducer->S = Args.S;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueString(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_u128"))
    {
        FUpdateUniqueU128Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU128();
        UUpdateUniqueU128Reducer* Reducer = NewObject<UUpdateUniqueU128Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueU128(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_u16"))
    {
        FUpdateUniqueU16Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU16();
        UUpdateUniqueU16Reducer* Reducer = NewObject<UUpdateUniqueU16Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueU16(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_u256"))
    {
        FUpdateUniqueU256Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU256();
        UUpdateUniqueU256Reducer* Reducer = NewObject<UUpdateUniqueU256Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueU256(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_u32"))
    {
        FUpdateUniqueU32Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU32();
        UUpdateUniqueU32Reducer* Reducer = NewObject<UUpdateUniqueU32Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueU32(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_u64"))
    {
        FUpdateUniqueU64Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU64();
        UUpdateUniqueU64Reducer* Reducer = NewObject<UUpdateUniqueU64Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueU64(Context, Reducer);
        return;
    }
    if (ReducerName == TEXT("update_unique_u8"))
    {
        FUpdateUniqueU8Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU8();
        UUpdateUniqueU8Reducer* Reducer = NewObject<UUpdateUniqueU8Reducer>();
        Reducer->N = Args.N;
        Reducer->Data = Args.Data;
        Reducers->InvokeUpdateUniqueU8(Context, Reducer);
        return;
    }

    UE_LOG(LogTemp, Warning, TEXT("Unknown reducer: %s"), *ReducerName);
}

void UDbConnection::ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage)
{
    if (!Reducers) { return; }

    FTestClientReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;

    FReducerEventContext Context(this, ReducerEvent);

    if (Reducers->InternalOnUnhandledReducerError.IsBound())
    {
        Reducers->InternalOnUnhandledReducerError.Broadcast(Context, ErrorMessage);
    }
}

UDbConnectionBuilder* UDbConnection::Builder()
{
	return NewObject<UDbConnectionBuilder>();
}
// Added for creating subscriptions
USubscriptionBuilder* UDbConnection::SubscriptionBuilder()
{
	USubscriptionBuilder* Builder = NewObject<USubscriptionBuilder>(this);
	Builder->Conn = this;
	return Builder;
}
USubscriptionBuilder* USubscriptionBuilder::OnApplied(FOnSubscriptionApplied Callback)
{
	OnAppliedDelegateInternal = Callback;
	return this;
}
USubscriptionBuilder* USubscriptionBuilder::OnError(FOnSubscriptionError Callback)
{
	OnErrorDelegateInternal = Callback;
	return this;
}
USubscriptionHandle* USubscriptionBuilder::Subscribe(const TArray<FString>& SQL)
{
	USubscriptionHandle* Handle = NewObject<USubscriptionHandle>();

	// Store user callbacks on the handle
	Handle->Conn = Conn;
	Handle->OnAppliedDelegate = OnAppliedDelegateInternal;
	Handle->OnErrorDelegate = OnErrorDelegateInternal;

	// Bind forwarding functions that will convert base contexts
	FSubscriptionEventDelegate BaseApplied;
	BaseApplied.BindUFunction(Handle, TEXT("ForwardOnApplied"));
	OnAppliedBase(BaseApplied);

	FSubscriptionErrorDelegate BaseError;
	BaseError.BindUFunction(Handle, TEXT("ForwardOnError"));
	OnErrorBase(BaseError);

	SubscribeBase(SQL, Handle);
	if (Conn)
	{
		Conn->StartSubscription(Handle);
	}
	return Handle;
}
USubscriptionHandle* USubscriptionBuilder::SubscribeToAllTables()
{
	return Subscribe({ "SELECT * FROM * " });
}

USubscriptionHandle::USubscriptionHandle(UDbConnection* InConn)
{
	Conn = InConn;
}

void USubscriptionHandle::ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx)
{
	if (OnAppliedDelegate.IsBound())
	{
		FSubscriptionEventContext Ctx(Conn);
		OnAppliedDelegate.Execute(Ctx);
	}
}

void USubscriptionHandle::ForwardOnError(const FErrorContextBase& BaseCtx)
{
	if (OnErrorDelegate.IsBound())
	{
		FErrorContext Ctx(Conn, BaseCtx.Error);
		OnErrorDelegate.Execute(Ctx);
	}
}


// Cast from parent to child class
UDbConnectionBuilder* UDbConnectionBuilder::WithUri(const FString& InUri)
{
	return Cast<UDbConnectionBuilder>(WithUriBase(InUri));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithModuleName(const FString& InName)
{
	return Cast<UDbConnectionBuilder>(WithModuleNameBase(InName));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithToken(const FString& InToken)
{
	return Cast<UDbConnectionBuilder>(WithTokenBase(InToken));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithCompression(const ESpacetimeDBCompression& InCompression)
{
	return Cast<UDbConnectionBuilder>(WithCompressionBase(InCompression));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnect(FOnConnectDelegate Callback)
{
	OnConnectDelegateInternal = Callback;
	return this;
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnectError(FOnConnectErrorDelegate Callback)
{
	return Cast<UDbConnectionBuilder>(OnConnectErrorBase(Callback));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnDisconnect(FOnDisconnectDelegate Callback)
{
	OnDisconnectDelegateInternal = Callback;
	return this;
}
UDbConnection* UDbConnectionBuilder::Build()
{
	UDbConnection* Connection = NewObject<UDbConnection>();

	// Store delegates on the connection for later use
	Connection->OnConnectDelegate = OnConnectDelegateInternal;
	Connection->OnDisconnectDelegate = OnDisconnectDelegateInternal;

	// Wrap delegates so the base builder can bind them
	FOnConnectBaseDelegate BaseConnect;
	BaseConnect.BindUFunction(Connection, TEXT("ForwardOnConnect"));
	Connection->SetOnConnectDelegate(BaseConnect);
	OnConnectBase(BaseConnect);

	FOnDisconnectBaseDelegate BaseDisconnect;
	BaseDisconnect.BindUFunction(Connection, TEXT("ForwardOnDisconnect"));
	Connection->SetOnDisconnectDelegate(BaseDisconnect);
	OnDisconnectBase(BaseDisconnect);

	return Cast<UDbConnection>(BuildConnection(Connection));
}
void UDbConnection::ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken)
{
	if (OnConnectDelegate.IsBound())
	{
		OnConnectDelegate.Execute(this, Identity, Token);
	}
}
void UDbConnection::ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error)
{
	if (OnDisconnectDelegate.IsBound())
	{
		OnDisconnectDelegate.Execute(this, Error);
	}
}


void UDbConnection::DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event)
{
    FTestClientEvent BaseEvent;
    BaseEvent.Tag = Event.Tag;

    switch (Event.Tag)
    {
    case ESpacetimeDBEventTag::Reducer:
    {
        FReducerEvent ReducerEvent = Event.GetAsReducer();
        FReducer Reducer = DecodeReducer(ReducerEvent);
        BaseEvent = FTestClientEvent::Reducer(Reducer);
        break;
    }

    case ESpacetimeDBEventTag::SubscribeApplied:
        BaseEvent = FTestClientEvent::SubscribeApplied(Event.GetAsSubscribeApplied());
        break;

    case ESpacetimeDBEventTag::UnsubscribeApplied:
        BaseEvent = FTestClientEvent::UnsubscribeApplied(Event.GetAsUnsubscribeApplied());
        break;

    case ESpacetimeDBEventTag::Disconnected:
        BaseEvent = FTestClientEvent::Disconnected(Event.GetAsDisconnected());
        break;

    case ESpacetimeDBEventTag::SubscribeError:
        BaseEvent = FTestClientEvent::SubscribeError(Event.GetAsSubscribeError());
        break;

    case ESpacetimeDBEventTag::UnknownTransaction:
        BaseEvent = FTestClientEvent::UnknownTransaction(Event.GetAsUnknownTransaction());
        break;

    default:
        break;
    }

    FEventContext Context(this, BaseEvent);
    // Populate typed reducer args for convenience in table handlers

    ApplyRegisteredTableUpdates(Update, &Context);
}

