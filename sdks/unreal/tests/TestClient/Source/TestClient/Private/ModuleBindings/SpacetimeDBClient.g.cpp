// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#include "ModuleBindings/SpacetimeDBClient.g.h"
#include "DBCache/WithBsatn.h"
#include "BSATN/UEBSATNHelpers.h"
#include "ModuleBindings/Tables/BtreeU32Table.g.h"
#include "ModuleBindings/Tables/IndexedSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/LargeTableTable.g.h"
#include "ModuleBindings/Tables/OneBoolTable.g.h"
#include "ModuleBindings/Tables/OneByteStructTable.g.h"
#include "ModuleBindings/Tables/OneConnectionIdTable.g.h"
#include "ModuleBindings/Tables/OneEnumWithPayloadTable.g.h"
#include "ModuleBindings/Tables/OneEveryPrimitiveStructTable.g.h"
#include "ModuleBindings/Tables/OneEveryVecStructTable.g.h"
#include "ModuleBindings/Tables/OneF32Table.g.h"
#include "ModuleBindings/Tables/OneF64Table.g.h"
#include "ModuleBindings/Tables/OneI128Table.g.h"
#include "ModuleBindings/Tables/OneI16Table.g.h"
#include "ModuleBindings/Tables/OneI256Table.g.h"
#include "ModuleBindings/Tables/OneI32Table.g.h"
#include "ModuleBindings/Tables/OneI64Table.g.h"
#include "ModuleBindings/Tables/OneI8Table.g.h"
#include "ModuleBindings/Tables/OneIdentityTable.g.h"
#include "ModuleBindings/Tables/OneSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/OneStringTable.g.h"
#include "ModuleBindings/Tables/OneTimestampTable.g.h"
#include "ModuleBindings/Tables/OneU128Table.g.h"
#include "ModuleBindings/Tables/OneU16Table.g.h"
#include "ModuleBindings/Tables/OneU256Table.g.h"
#include "ModuleBindings/Tables/OneU32Table.g.h"
#include "ModuleBindings/Tables/OneU64Table.g.h"
#include "ModuleBindings/Tables/OneU8Table.g.h"
#include "ModuleBindings/Tables/OneUnitStructTable.g.h"
#include "ModuleBindings/Tables/OneUuidTable.g.h"
#include "ModuleBindings/Tables/OptionEveryPrimitiveStructTable.g.h"
#include "ModuleBindings/Tables/OptionI32Table.g.h"
#include "ModuleBindings/Tables/OptionIdentityTable.g.h"
#include "ModuleBindings/Tables/OptionSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/OptionStringTable.g.h"
#include "ModuleBindings/Tables/OptionUuidTable.g.h"
#include "ModuleBindings/Tables/OptionVecOptionI32Table.g.h"
#include "ModuleBindings/Tables/PkBoolTable.g.h"
#include "ModuleBindings/Tables/PkConnectionIdTable.g.h"
#include "ModuleBindings/Tables/PkI128Table.g.h"
#include "ModuleBindings/Tables/PkI16Table.g.h"
#include "ModuleBindings/Tables/PkI256Table.g.h"
#include "ModuleBindings/Tables/PkI32Table.g.h"
#include "ModuleBindings/Tables/PkI64Table.g.h"
#include "ModuleBindings/Tables/PkI8Table.g.h"
#include "ModuleBindings/Tables/PkIdentityTable.g.h"
#include "ModuleBindings/Tables/PkSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/PkStringTable.g.h"
#include "ModuleBindings/Tables/PkU128Table.g.h"
#include "ModuleBindings/Tables/PkU16Table.g.h"
#include "ModuleBindings/Tables/PkU256Table.g.h"
#include "ModuleBindings/Tables/PkU32Table.g.h"
#include "ModuleBindings/Tables/PkU32TwoTable.g.h"
#include "ModuleBindings/Tables/PkU64Table.g.h"
#include "ModuleBindings/Tables/PkU8Table.g.h"
#include "ModuleBindings/Tables/PkUuidTable.g.h"
#include "ModuleBindings/Tables/ResultEveryPrimitiveStructStringTable.g.h"
#include "ModuleBindings/Tables/ResultI32StringTable.g.h"
#include "ModuleBindings/Tables/ResultIdentityStringTable.g.h"
#include "ModuleBindings/Tables/ResultSimpleEnumI32Table.g.h"
#include "ModuleBindings/Tables/ResultStringI32Table.g.h"
#include "ModuleBindings/Tables/ResultVecI32StringTable.g.h"
#include "ModuleBindings/Tables/ScheduledTableTable.g.h"
#include "ModuleBindings/Tables/TableHoldsTableTable.g.h"
#include "ModuleBindings/Tables/UniqueBoolTable.g.h"
#include "ModuleBindings/Tables/UniqueConnectionIdTable.g.h"
#include "ModuleBindings/Tables/UniqueI128Table.g.h"
#include "ModuleBindings/Tables/UniqueI16Table.g.h"
#include "ModuleBindings/Tables/UniqueI256Table.g.h"
#include "ModuleBindings/Tables/UniqueI32Table.g.h"
#include "ModuleBindings/Tables/UniqueI64Table.g.h"
#include "ModuleBindings/Tables/UniqueI8Table.g.h"
#include "ModuleBindings/Tables/UniqueIdentityTable.g.h"
#include "ModuleBindings/Tables/UniqueStringTable.g.h"
#include "ModuleBindings/Tables/UniqueU128Table.g.h"
#include "ModuleBindings/Tables/UniqueU16Table.g.h"
#include "ModuleBindings/Tables/UniqueU256Table.g.h"
#include "ModuleBindings/Tables/UniqueU32Table.g.h"
#include "ModuleBindings/Tables/UniqueU64Table.g.h"
#include "ModuleBindings/Tables/UniqueU8Table.g.h"
#include "ModuleBindings/Tables/UniqueUuidTable.g.h"
#include "ModuleBindings/Tables/UsersTable.g.h"
#include "ModuleBindings/Tables/VecBoolTable.g.h"
#include "ModuleBindings/Tables/VecByteStructTable.g.h"
#include "ModuleBindings/Tables/VecConnectionIdTable.g.h"
#include "ModuleBindings/Tables/VecEnumWithPayloadTable.g.h"
#include "ModuleBindings/Tables/VecEveryPrimitiveStructTable.g.h"
#include "ModuleBindings/Tables/VecEveryVecStructTable.g.h"
#include "ModuleBindings/Tables/VecF32Table.g.h"
#include "ModuleBindings/Tables/VecF64Table.g.h"
#include "ModuleBindings/Tables/VecI128Table.g.h"
#include "ModuleBindings/Tables/VecI16Table.g.h"
#include "ModuleBindings/Tables/VecI256Table.g.h"
#include "ModuleBindings/Tables/VecI32Table.g.h"
#include "ModuleBindings/Tables/VecI64Table.g.h"
#include "ModuleBindings/Tables/VecI8Table.g.h"
#include "ModuleBindings/Tables/VecIdentityTable.g.h"
#include "ModuleBindings/Tables/VecSimpleEnumTable.g.h"
#include "ModuleBindings/Tables/VecStringTable.g.h"
#include "ModuleBindings/Tables/VecTimestampTable.g.h"
#include "ModuleBindings/Tables/VecU128Table.g.h"
#include "ModuleBindings/Tables/VecU16Table.g.h"
#include "ModuleBindings/Tables/VecU256Table.g.h"
#include "ModuleBindings/Tables/VecU32Table.g.h"
#include "ModuleBindings/Tables/VecU64Table.g.h"
#include "ModuleBindings/Tables/VecU8Table.g.h"
#include "ModuleBindings/Tables/VecUnitStructTable.g.h"
#include "ModuleBindings/Tables/VecUuidTable.g.h"

UDbConnection::UDbConnection(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	Db = ObjectInitializer.CreateDefaultSubobject<URemoteTables>(this, TEXT("RemoteTables"));
	Db->Initialize();
	
	Reducers = ObjectInitializer.CreateDefaultSubobject<URemoteReducers>(this, TEXT("RemoteReducers"));
	Reducers->Conn = this;

	Procedures = ObjectInitializer.CreateDefaultSubobject<URemoteProcedures>(this, TEXT("RemoteProcedures"));
	Procedures->Conn = this;

	RegisterTable<FBTreeU32Type, UBtreeU32Table, FEventContext>(TEXT("btree_u_32"), Db->BtreeU32);
	RegisterTable<FIndexedSimpleEnumType, UIndexedSimpleEnumTable, FEventContext>(TEXT("indexed_simple_enum"), Db->IndexedSimpleEnum);
	RegisterTable<FLargeTableType, ULargeTableTable, FEventContext>(TEXT("large_table"), Db->LargeTable);
	RegisterTable<FOneBoolType, UOneBoolTable, FEventContext>(TEXT("one_bool"), Db->OneBool);
	RegisterTable<FOneByteStructType, UOneByteStructTable, FEventContext>(TEXT("one_byte_struct"), Db->OneByteStruct);
	RegisterTable<FOneConnectionIdType, UOneConnectionIdTable, FEventContext>(TEXT("one_connection_id"), Db->OneConnectionId);
	RegisterTable<FOneEnumWithPayloadType, UOneEnumWithPayloadTable, FEventContext>(TEXT("one_enum_with_payload"), Db->OneEnumWithPayload);
	RegisterTable<FOneEveryPrimitiveStructType, UOneEveryPrimitiveStructTable, FEventContext>(TEXT("one_every_primitive_struct"), Db->OneEveryPrimitiveStruct);
	RegisterTable<FOneEveryVecStructType, UOneEveryVecStructTable, FEventContext>(TEXT("one_every_vec_struct"), Db->OneEveryVecStruct);
	RegisterTable<FOneF32Type, UOneF32Table, FEventContext>(TEXT("one_f_32"), Db->OneF32);
	RegisterTable<FOneF64Type, UOneF64Table, FEventContext>(TEXT("one_f_64"), Db->OneF64);
	RegisterTable<FOneI128Type, UOneI128Table, FEventContext>(TEXT("one_i_128"), Db->OneI128);
	RegisterTable<FOneI16Type, UOneI16Table, FEventContext>(TEXT("one_i_16"), Db->OneI16);
	RegisterTable<FOneI256Type, UOneI256Table, FEventContext>(TEXT("one_i_256"), Db->OneI256);
	RegisterTable<FOneI32Type, UOneI32Table, FEventContext>(TEXT("one_i_32"), Db->OneI32);
	RegisterTable<FOneI64Type, UOneI64Table, FEventContext>(TEXT("one_i_64"), Db->OneI64);
	RegisterTable<FOneI8Type, UOneI8Table, FEventContext>(TEXT("one_i_8"), Db->OneI8);
	RegisterTable<FOneIdentityType, UOneIdentityTable, FEventContext>(TEXT("one_identity"), Db->OneIdentity);
	RegisterTable<FOneSimpleEnumType, UOneSimpleEnumTable, FEventContext>(TEXT("one_simple_enum"), Db->OneSimpleEnum);
	RegisterTable<FOneStringType, UOneStringTable, FEventContext>(TEXT("one_string"), Db->OneString);
	RegisterTable<FOneTimestampType, UOneTimestampTable, FEventContext>(TEXT("one_timestamp"), Db->OneTimestamp);
	RegisterTable<FOneU128Type, UOneU128Table, FEventContext>(TEXT("one_u_128"), Db->OneU128);
	RegisterTable<FOneU16Type, UOneU16Table, FEventContext>(TEXT("one_u_16"), Db->OneU16);
	RegisterTable<FOneU256Type, UOneU256Table, FEventContext>(TEXT("one_u_256"), Db->OneU256);
	RegisterTable<FOneU32Type, UOneU32Table, FEventContext>(TEXT("one_u_32"), Db->OneU32);
	RegisterTable<FOneU64Type, UOneU64Table, FEventContext>(TEXT("one_u_64"), Db->OneU64);
	RegisterTable<FOneU8Type, UOneU8Table, FEventContext>(TEXT("one_u_8"), Db->OneU8);
	RegisterTable<FOneUnitStructType, UOneUnitStructTable, FEventContext>(TEXT("one_unit_struct"), Db->OneUnitStruct);
	RegisterTable<FOneUuidType, UOneUuidTable, FEventContext>(TEXT("one_uuid"), Db->OneUuid);
	RegisterTable<FOptionEveryPrimitiveStructType, UOptionEveryPrimitiveStructTable, FEventContext>(TEXT("option_every_primitive_struct"), Db->OptionEveryPrimitiveStruct);
	RegisterTable<FOptionI32Type, UOptionI32Table, FEventContext>(TEXT("option_i_32"), Db->OptionI32);
	RegisterTable<FOptionIdentityType, UOptionIdentityTable, FEventContext>(TEXT("option_identity"), Db->OptionIdentity);
	RegisterTable<FOptionSimpleEnumType, UOptionSimpleEnumTable, FEventContext>(TEXT("option_simple_enum"), Db->OptionSimpleEnum);
	RegisterTable<FOptionStringType, UOptionStringTable, FEventContext>(TEXT("option_string"), Db->OptionString);
	RegisterTable<FOptionUuidType, UOptionUuidTable, FEventContext>(TEXT("option_uuid"), Db->OptionUuid);
	RegisterTable<FOptionVecOptionI32Type, UOptionVecOptionI32Table, FEventContext>(TEXT("option_vec_option_i_32"), Db->OptionVecOptionI32);
	RegisterTable<FPkBoolType, UPkBoolTable, FEventContext>(TEXT("pk_bool"), Db->PkBool);
	RegisterTable<FPkConnectionIdType, UPkConnectionIdTable, FEventContext>(TEXT("pk_connection_id"), Db->PkConnectionId);
	RegisterTable<FPkI128Type, UPkI128Table, FEventContext>(TEXT("pk_i_128"), Db->PkI128);
	RegisterTable<FPkI16Type, UPkI16Table, FEventContext>(TEXT("pk_i_16"), Db->PkI16);
	RegisterTable<FPkI256Type, UPkI256Table, FEventContext>(TEXT("pk_i_256"), Db->PkI256);
	RegisterTable<FPkI32Type, UPkI32Table, FEventContext>(TEXT("pk_i_32"), Db->PkI32);
	RegisterTable<FPkI64Type, UPkI64Table, FEventContext>(TEXT("pk_i_64"), Db->PkI64);
	RegisterTable<FPkI8Type, UPkI8Table, FEventContext>(TEXT("pk_i_8"), Db->PkI8);
	RegisterTable<FPkIdentityType, UPkIdentityTable, FEventContext>(TEXT("pk_identity"), Db->PkIdentity);
	RegisterTable<FPkSimpleEnumType, UPkSimpleEnumTable, FEventContext>(TEXT("pk_simple_enum"), Db->PkSimpleEnum);
	RegisterTable<FPkStringType, UPkStringTable, FEventContext>(TEXT("pk_string"), Db->PkString);
	RegisterTable<FPkU128Type, UPkU128Table, FEventContext>(TEXT("pk_u_128"), Db->PkU128);
	RegisterTable<FPkU16Type, UPkU16Table, FEventContext>(TEXT("pk_u_16"), Db->PkU16);
	RegisterTable<FPkU256Type, UPkU256Table, FEventContext>(TEXT("pk_u_256"), Db->PkU256);
	RegisterTable<FPkU32Type, UPkU32Table, FEventContext>(TEXT("pk_u_32"), Db->PkU32);
	RegisterTable<FPkU32TwoType, UPkU32TwoTable, FEventContext>(TEXT("pk_u_32_two"), Db->PkU32Two);
	RegisterTable<FPkU64Type, UPkU64Table, FEventContext>(TEXT("pk_u_64"), Db->PkU64);
	RegisterTable<FPkU8Type, UPkU8Table, FEventContext>(TEXT("pk_u_8"), Db->PkU8);
	RegisterTable<FPkUuidType, UPkUuidTable, FEventContext>(TEXT("pk_uuid"), Db->PkUuid);
	RegisterTable<FResultEveryPrimitiveStructStringType, UResultEveryPrimitiveStructStringTable, FEventContext>(TEXT("result_every_primitive_struct_string"), Db->ResultEveryPrimitiveStructString);
	RegisterTable<FResultI32StringType, UResultI32StringTable, FEventContext>(TEXT("result_i_32_string"), Db->ResultI32String);
	RegisterTable<FResultIdentityStringType, UResultIdentityStringTable, FEventContext>(TEXT("result_identity_string"), Db->ResultIdentityString);
	RegisterTable<FResultSimpleEnumI32Type, UResultSimpleEnumI32Table, FEventContext>(TEXT("result_simple_enum_i_32"), Db->ResultSimpleEnumI32);
	RegisterTable<FResultStringI32Type, UResultStringI32Table, FEventContext>(TEXT("result_string_i_32"), Db->ResultStringI32);
	RegisterTable<FResultVecI32StringType, UResultVecI32StringTable, FEventContext>(TEXT("result_vec_i_32_string"), Db->ResultVecI32String);
	RegisterTable<FScheduledTableType, UScheduledTableTable, FEventContext>(TEXT("scheduled_table"), Db->ScheduledTable);
	RegisterTable<FTableHoldsTableType, UTableHoldsTableTable, FEventContext>(TEXT("table_holds_table"), Db->TableHoldsTable);
	RegisterTable<FUniqueBoolType, UUniqueBoolTable, FEventContext>(TEXT("unique_bool"), Db->UniqueBool);
	RegisterTable<FUniqueConnectionIdType, UUniqueConnectionIdTable, FEventContext>(TEXT("unique_connection_id"), Db->UniqueConnectionId);
	RegisterTable<FUniqueI128Type, UUniqueI128Table, FEventContext>(TEXT("unique_i_128"), Db->UniqueI128);
	RegisterTable<FUniqueI16Type, UUniqueI16Table, FEventContext>(TEXT("unique_i_16"), Db->UniqueI16);
	RegisterTable<FUniqueI256Type, UUniqueI256Table, FEventContext>(TEXT("unique_i_256"), Db->UniqueI256);
	RegisterTable<FUniqueI32Type, UUniqueI32Table, FEventContext>(TEXT("unique_i_32"), Db->UniqueI32);
	RegisterTable<FUniqueI64Type, UUniqueI64Table, FEventContext>(TEXT("unique_i_64"), Db->UniqueI64);
	RegisterTable<FUniqueI8Type, UUniqueI8Table, FEventContext>(TEXT("unique_i_8"), Db->UniqueI8);
	RegisterTable<FUniqueIdentityType, UUniqueIdentityTable, FEventContext>(TEXT("unique_identity"), Db->UniqueIdentity);
	RegisterTable<FUniqueStringType, UUniqueStringTable, FEventContext>(TEXT("unique_string"), Db->UniqueString);
	RegisterTable<FUniqueU128Type, UUniqueU128Table, FEventContext>(TEXT("unique_u_128"), Db->UniqueU128);
	RegisterTable<FUniqueU16Type, UUniqueU16Table, FEventContext>(TEXT("unique_u_16"), Db->UniqueU16);
	RegisterTable<FUniqueU256Type, UUniqueU256Table, FEventContext>(TEXT("unique_u_256"), Db->UniqueU256);
	RegisterTable<FUniqueU32Type, UUniqueU32Table, FEventContext>(TEXT("unique_u_32"), Db->UniqueU32);
	RegisterTable<FUniqueU64Type, UUniqueU64Table, FEventContext>(TEXT("unique_u_64"), Db->UniqueU64);
	RegisterTable<FUniqueU8Type, UUniqueU8Table, FEventContext>(TEXT("unique_u_8"), Db->UniqueU8);
	RegisterTable<FUniqueUuidType, UUniqueUuidTable, FEventContext>(TEXT("unique_uuid"), Db->UniqueUuid);
	RegisterTable<FUsersType, UUsersTable, FEventContext>(TEXT("users"), Db->Users);
	RegisterTable<FVecBoolType, UVecBoolTable, FEventContext>(TEXT("vec_bool"), Db->VecBool);
	RegisterTable<FVecByteStructType, UVecByteStructTable, FEventContext>(TEXT("vec_byte_struct"), Db->VecByteStruct);
	RegisterTable<FVecConnectionIdType, UVecConnectionIdTable, FEventContext>(TEXT("vec_connection_id"), Db->VecConnectionId);
	RegisterTable<FVecEnumWithPayloadType, UVecEnumWithPayloadTable, FEventContext>(TEXT("vec_enum_with_payload"), Db->VecEnumWithPayload);
	RegisterTable<FVecEveryPrimitiveStructType, UVecEveryPrimitiveStructTable, FEventContext>(TEXT("vec_every_primitive_struct"), Db->VecEveryPrimitiveStruct);
	RegisterTable<FVecEveryVecStructType, UVecEveryVecStructTable, FEventContext>(TEXT("vec_every_vec_struct"), Db->VecEveryVecStruct);
	RegisterTable<FVecF32Type, UVecF32Table, FEventContext>(TEXT("vec_f_32"), Db->VecF32);
	RegisterTable<FVecF64Type, UVecF64Table, FEventContext>(TEXT("vec_f_64"), Db->VecF64);
	RegisterTable<FVecI128Type, UVecI128Table, FEventContext>(TEXT("vec_i_128"), Db->VecI128);
	RegisterTable<FVecI16Type, UVecI16Table, FEventContext>(TEXT("vec_i_16"), Db->VecI16);
	RegisterTable<FVecI256Type, UVecI256Table, FEventContext>(TEXT("vec_i_256"), Db->VecI256);
	RegisterTable<FVecI32Type, UVecI32Table, FEventContext>(TEXT("vec_i_32"), Db->VecI32);
	RegisterTable<FVecI64Type, UVecI64Table, FEventContext>(TEXT("vec_i_64"), Db->VecI64);
	RegisterTable<FVecI8Type, UVecI8Table, FEventContext>(TEXT("vec_i_8"), Db->VecI8);
	RegisterTable<FVecIdentityType, UVecIdentityTable, FEventContext>(TEXT("vec_identity"), Db->VecIdentity);
	RegisterTable<FVecSimpleEnumType, UVecSimpleEnumTable, FEventContext>(TEXT("vec_simple_enum"), Db->VecSimpleEnum);
	RegisterTable<FVecStringType, UVecStringTable, FEventContext>(TEXT("vec_string"), Db->VecString);
	RegisterTable<FVecTimestampType, UVecTimestampTable, FEventContext>(TEXT("vec_timestamp"), Db->VecTimestamp);
	RegisterTable<FVecU128Type, UVecU128Table, FEventContext>(TEXT("vec_u_128"), Db->VecU128);
	RegisterTable<FVecU16Type, UVecU16Table, FEventContext>(TEXT("vec_u_16"), Db->VecU16);
	RegisterTable<FVecU256Type, UVecU256Table, FEventContext>(TEXT("vec_u_256"), Db->VecU256);
	RegisterTable<FVecU32Type, UVecU32Table, FEventContext>(TEXT("vec_u_32"), Db->VecU32);
	RegisterTable<FVecU64Type, UVecU64Table, FEventContext>(TEXT("vec_u_64"), Db->VecU64);
	RegisterTable<FVecU8Type, UVecU8Table, FEventContext>(TEXT("vec_u_8"), Db->VecU8);
	RegisterTable<FVecUnitStructType, UVecUnitStructTable, FEventContext>(TEXT("vec_unit_struct"), Db->VecUnitStruct);
	RegisterTable<FVecUuidType, UVecUuidTable, FEventContext>(TEXT("vec_uuid"), Db->VecUuid);
}

FContextBase::FContextBase(UDbConnection* InConn)
{
	Db = InConn->Db;
	Reducers = InConn->Reducers;
	Procedures = InConn->Procedures;
	Conn = InConn;
}
bool FContextBase::IsActive() const
{
	return Conn->IsActive();
}
void FContextBase::Disconnect()
{
	Conn->Disconnect();
}
USubscriptionBuilder* FContextBase::SubscriptionBuilder()
{
	return Conn->SubscriptionBuilder();
}
bool FContextBase::TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const
{
	return Conn->TryGetIdentity(OutIdentity);
}
FSpacetimeDBConnectionId FContextBase::GetConnectionId() const
{
	return Conn->GetConnectionId();
}

void URemoteTables::Initialize()
{

	/** Creating tables */
	BtreeU32 = NewObject<UBtreeU32Table>(this);
	IndexedSimpleEnum = NewObject<UIndexedSimpleEnumTable>(this);
	LargeTable = NewObject<ULargeTableTable>(this);
	OneBool = NewObject<UOneBoolTable>(this);
	OneByteStruct = NewObject<UOneByteStructTable>(this);
	OneConnectionId = NewObject<UOneConnectionIdTable>(this);
	OneEnumWithPayload = NewObject<UOneEnumWithPayloadTable>(this);
	OneEveryPrimitiveStruct = NewObject<UOneEveryPrimitiveStructTable>(this);
	OneEveryVecStruct = NewObject<UOneEveryVecStructTable>(this);
	OneF32 = NewObject<UOneF32Table>(this);
	OneF64 = NewObject<UOneF64Table>(this);
	OneI128 = NewObject<UOneI128Table>(this);
	OneI16 = NewObject<UOneI16Table>(this);
	OneI256 = NewObject<UOneI256Table>(this);
	OneI32 = NewObject<UOneI32Table>(this);
	OneI64 = NewObject<UOneI64Table>(this);
	OneI8 = NewObject<UOneI8Table>(this);
	OneIdentity = NewObject<UOneIdentityTable>(this);
	OneSimpleEnum = NewObject<UOneSimpleEnumTable>(this);
	OneString = NewObject<UOneStringTable>(this);
	OneTimestamp = NewObject<UOneTimestampTable>(this);
	OneU128 = NewObject<UOneU128Table>(this);
	OneU16 = NewObject<UOneU16Table>(this);
	OneU256 = NewObject<UOneU256Table>(this);
	OneU32 = NewObject<UOneU32Table>(this);
	OneU64 = NewObject<UOneU64Table>(this);
	OneU8 = NewObject<UOneU8Table>(this);
	OneUnitStruct = NewObject<UOneUnitStructTable>(this);
	OneUuid = NewObject<UOneUuidTable>(this);
	OptionEveryPrimitiveStruct = NewObject<UOptionEveryPrimitiveStructTable>(this);
	OptionI32 = NewObject<UOptionI32Table>(this);
	OptionIdentity = NewObject<UOptionIdentityTable>(this);
	OptionSimpleEnum = NewObject<UOptionSimpleEnumTable>(this);
	OptionString = NewObject<UOptionStringTable>(this);
	OptionUuid = NewObject<UOptionUuidTable>(this);
	OptionVecOptionI32 = NewObject<UOptionVecOptionI32Table>(this);
	PkBool = NewObject<UPkBoolTable>(this);
	PkConnectionId = NewObject<UPkConnectionIdTable>(this);
	PkI128 = NewObject<UPkI128Table>(this);
	PkI16 = NewObject<UPkI16Table>(this);
	PkI256 = NewObject<UPkI256Table>(this);
	PkI32 = NewObject<UPkI32Table>(this);
	PkI64 = NewObject<UPkI64Table>(this);
	PkI8 = NewObject<UPkI8Table>(this);
	PkIdentity = NewObject<UPkIdentityTable>(this);
	PkSimpleEnum = NewObject<UPkSimpleEnumTable>(this);
	PkString = NewObject<UPkStringTable>(this);
	PkU128 = NewObject<UPkU128Table>(this);
	PkU16 = NewObject<UPkU16Table>(this);
	PkU256 = NewObject<UPkU256Table>(this);
	PkU32 = NewObject<UPkU32Table>(this);
	PkU32Two = NewObject<UPkU32TwoTable>(this);
	PkU64 = NewObject<UPkU64Table>(this);
	PkU8 = NewObject<UPkU8Table>(this);
	PkUuid = NewObject<UPkUuidTable>(this);
	ResultEveryPrimitiveStructString = NewObject<UResultEveryPrimitiveStructStringTable>(this);
	ResultI32String = NewObject<UResultI32StringTable>(this);
	ResultIdentityString = NewObject<UResultIdentityStringTable>(this);
	ResultSimpleEnumI32 = NewObject<UResultSimpleEnumI32Table>(this);
	ResultStringI32 = NewObject<UResultStringI32Table>(this);
	ResultVecI32String = NewObject<UResultVecI32StringTable>(this);
	ScheduledTable = NewObject<UScheduledTableTable>(this);
	TableHoldsTable = NewObject<UTableHoldsTableTable>(this);
	UniqueBool = NewObject<UUniqueBoolTable>(this);
	UniqueConnectionId = NewObject<UUniqueConnectionIdTable>(this);
	UniqueI128 = NewObject<UUniqueI128Table>(this);
	UniqueI16 = NewObject<UUniqueI16Table>(this);
	UniqueI256 = NewObject<UUniqueI256Table>(this);
	UniqueI32 = NewObject<UUniqueI32Table>(this);
	UniqueI64 = NewObject<UUniqueI64Table>(this);
	UniqueI8 = NewObject<UUniqueI8Table>(this);
	UniqueIdentity = NewObject<UUniqueIdentityTable>(this);
	UniqueString = NewObject<UUniqueStringTable>(this);
	UniqueU128 = NewObject<UUniqueU128Table>(this);
	UniqueU16 = NewObject<UUniqueU16Table>(this);
	UniqueU256 = NewObject<UUniqueU256Table>(this);
	UniqueU32 = NewObject<UUniqueU32Table>(this);
	UniqueU64 = NewObject<UUniqueU64Table>(this);
	UniqueU8 = NewObject<UUniqueU8Table>(this);
	UniqueUuid = NewObject<UUniqueUuidTable>(this);
	Users = NewObject<UUsersTable>(this);
	VecBool = NewObject<UVecBoolTable>(this);
	VecByteStruct = NewObject<UVecByteStructTable>(this);
	VecConnectionId = NewObject<UVecConnectionIdTable>(this);
	VecEnumWithPayload = NewObject<UVecEnumWithPayloadTable>(this);
	VecEveryPrimitiveStruct = NewObject<UVecEveryPrimitiveStructTable>(this);
	VecEveryVecStruct = NewObject<UVecEveryVecStructTable>(this);
	VecF32 = NewObject<UVecF32Table>(this);
	VecF64 = NewObject<UVecF64Table>(this);
	VecI128 = NewObject<UVecI128Table>(this);
	VecI16 = NewObject<UVecI16Table>(this);
	VecI256 = NewObject<UVecI256Table>(this);
	VecI32 = NewObject<UVecI32Table>(this);
	VecI64 = NewObject<UVecI64Table>(this);
	VecI8 = NewObject<UVecI8Table>(this);
	VecIdentity = NewObject<UVecIdentityTable>(this);
	VecSimpleEnum = NewObject<UVecSimpleEnumTable>(this);
	VecString = NewObject<UVecStringTable>(this);
	VecTimestamp = NewObject<UVecTimestampTable>(this);
	VecU128 = NewObject<UVecU128Table>(this);
	VecU16 = NewObject<UVecU16Table>(this);
	VecU256 = NewObject<UVecU256Table>(this);
	VecU32 = NewObject<UVecU32Table>(this);
	VecU64 = NewObject<UVecU64Table>(this);
	VecU8 = NewObject<UVecU8Table>(this);
	VecUnitStruct = NewObject<UVecUnitStructTable>(this);
	VecUuid = NewObject<UVecUuidTable>(this);
	/**/

	/** Initialization */
	BtreeU32->PostInitialize();
	IndexedSimpleEnum->PostInitialize();
	LargeTable->PostInitialize();
	OneBool->PostInitialize();
	OneByteStruct->PostInitialize();
	OneConnectionId->PostInitialize();
	OneEnumWithPayload->PostInitialize();
	OneEveryPrimitiveStruct->PostInitialize();
	OneEveryVecStruct->PostInitialize();
	OneF32->PostInitialize();
	OneF64->PostInitialize();
	OneI128->PostInitialize();
	OneI16->PostInitialize();
	OneI256->PostInitialize();
	OneI32->PostInitialize();
	OneI64->PostInitialize();
	OneI8->PostInitialize();
	OneIdentity->PostInitialize();
	OneSimpleEnum->PostInitialize();
	OneString->PostInitialize();
	OneTimestamp->PostInitialize();
	OneU128->PostInitialize();
	OneU16->PostInitialize();
	OneU256->PostInitialize();
	OneU32->PostInitialize();
	OneU64->PostInitialize();
	OneU8->PostInitialize();
	OneUnitStruct->PostInitialize();
	OneUuid->PostInitialize();
	OptionEveryPrimitiveStruct->PostInitialize();
	OptionI32->PostInitialize();
	OptionIdentity->PostInitialize();
	OptionSimpleEnum->PostInitialize();
	OptionString->PostInitialize();
	OptionUuid->PostInitialize();
	OptionVecOptionI32->PostInitialize();
	PkBool->PostInitialize();
	PkConnectionId->PostInitialize();
	PkI128->PostInitialize();
	PkI16->PostInitialize();
	PkI256->PostInitialize();
	PkI32->PostInitialize();
	PkI64->PostInitialize();
	PkI8->PostInitialize();
	PkIdentity->PostInitialize();
	PkSimpleEnum->PostInitialize();
	PkString->PostInitialize();
	PkU128->PostInitialize();
	PkU16->PostInitialize();
	PkU256->PostInitialize();
	PkU32->PostInitialize();
	PkU32Two->PostInitialize();
	PkU64->PostInitialize();
	PkU8->PostInitialize();
	PkUuid->PostInitialize();
	ResultEveryPrimitiveStructString->PostInitialize();
	ResultI32String->PostInitialize();
	ResultIdentityString->PostInitialize();
	ResultSimpleEnumI32->PostInitialize();
	ResultStringI32->PostInitialize();
	ResultVecI32String->PostInitialize();
	ScheduledTable->PostInitialize();
	TableHoldsTable->PostInitialize();
	UniqueBool->PostInitialize();
	UniqueConnectionId->PostInitialize();
	UniqueI128->PostInitialize();
	UniqueI16->PostInitialize();
	UniqueI256->PostInitialize();
	UniqueI32->PostInitialize();
	UniqueI64->PostInitialize();
	UniqueI8->PostInitialize();
	UniqueIdentity->PostInitialize();
	UniqueString->PostInitialize();
	UniqueU128->PostInitialize();
	UniqueU16->PostInitialize();
	UniqueU256->PostInitialize();
	UniqueU32->PostInitialize();
	UniqueU64->PostInitialize();
	UniqueU8->PostInitialize();
	UniqueUuid->PostInitialize();
	Users->PostInitialize();
	VecBool->PostInitialize();
	VecByteStruct->PostInitialize();
	VecConnectionId->PostInitialize();
	VecEnumWithPayload->PostInitialize();
	VecEveryPrimitiveStruct->PostInitialize();
	VecEveryVecStruct->PostInitialize();
	VecF32->PostInitialize();
	VecF64->PostInitialize();
	VecI128->PostInitialize();
	VecI16->PostInitialize();
	VecI256->PostInitialize();
	VecI32->PostInitialize();
	VecI64->PostInitialize();
	VecI8->PostInitialize();
	VecIdentity->PostInitialize();
	VecSimpleEnum->PostInitialize();
	VecString->PostInitialize();
	VecTimestamp->PostInitialize();
	VecU128->PostInitialize();
	VecU16->PostInitialize();
	VecU256->PostInitialize();
	VecU32->PostInitialize();
	VecU64->PostInitialize();
	VecU8->PostInitialize();
	VecUnitStruct->PostInitialize();
	VecUuid->PostInitialize();
	/**/
}

void URemoteReducers::DeleteFromBtreeU32(const TArray<FBTreeU32Type>& Rows)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteFromBtreeU32Args ReducerArgs(Rows);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_from_btree_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteFromBtreeU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteFromBtreeU32(const FReducerEventContext& Context, const UDeleteFromBtreeU32Reducer* Args)
{
    if (!OnDeleteFromBtreeU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteFromBtreeU32"));
        }
        return false;
    }

    OnDeleteFromBtreeU32.Broadcast(Context, Args->Rows);
    return true;
}

bool URemoteReducers::InvokeDeleteFromBtreeU32WithArgs(const FReducerEventContext& Context, const FDeleteFromBtreeU32Args& Args)
{
    if (!OnDeleteFromBtreeU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteFromBtreeU32"));
        }
        return false;
    }

    OnDeleteFromBtreeU32.Broadcast(Context, Args.Rows);
    return true;
}

void URemoteReducers::DeleteLargeTable(const uint8 A, const uint16 B, const uint32 C, const uint64 D, const FSpacetimeDBUInt128& E, const FSpacetimeDBUInt256& F, const int8 G, const int16 H, const int32 I, const int64 J, const FSpacetimeDBInt128& K, const FSpacetimeDBInt256& L, const bool M, const float N, const double O, const FString& P, const ESimpleEnumType& Q, const FEnumWithPayloadType& R, const FUnitStructType& S, const FByteStructType& T, const FEveryPrimitiveStructType& U, const FEveryVecStructType& V)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteLargeTableArgs ReducerArgs(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_large_table"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteLargeTable(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteLargeTable(const FReducerEventContext& Context, const UDeleteLargeTableReducer* Args)
{
    if (!OnDeleteLargeTable.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteLargeTable"));
        }
        return false;
    }

    FDeleteLargeTableArgs ArgsStruct;
    ArgsStruct.A = Args->A;
    ArgsStruct.B = Args->B;
    ArgsStruct.C = Args->C;
    ArgsStruct.D = Args->D;
    ArgsStruct.E = Args->E;
    ArgsStruct.F = Args->F;
    ArgsStruct.G = Args->G;
    ArgsStruct.H = Args->H;
    ArgsStruct.I = Args->I;
    ArgsStruct.J = Args->J;
    ArgsStruct.K = Args->K;
    ArgsStruct.L = Args->L;
    ArgsStruct.M = Args->M;
    ArgsStruct.N = Args->N;
    ArgsStruct.O = Args->O;
    ArgsStruct.P = Args->P;
    ArgsStruct.Q = Args->Q;
    ArgsStruct.R = Args->R;
    ArgsStruct.S = Args->S;
    ArgsStruct.T = Args->T;
    ArgsStruct.U = Args->U;
    ArgsStruct.V = Args->V;
    OnDeleteLargeTable.Broadcast(Context, ArgsStruct);
    return true;
}

bool URemoteReducers::InvokeDeleteLargeTableWithArgs(const FReducerEventContext& Context, const FDeleteLargeTableArgs& Args)
{
    if (!OnDeleteLargeTable.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteLargeTable"));
        }
        return false;
    }

    OnDeleteLargeTable.Broadcast(Context, Args);
    return true;
}

void URemoteReducers::DeletePkBool(const bool B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkBoolArgs ReducerArgs(B);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkBool(const FReducerEventContext& Context, const UDeletePkBoolReducer* Args)
{
    if (!OnDeletePkBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkBool"));
        }
        return false;
    }

    OnDeletePkBool.Broadcast(Context, Args->B);
    return true;
}

bool URemoteReducers::InvokeDeletePkBoolWithArgs(const FReducerEventContext& Context, const FDeletePkBoolArgs& Args)
{
    if (!OnDeletePkBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkBool"));
        }
        return false;
    }

    OnDeletePkBool.Broadcast(Context, Args.B);
    return true;
}

void URemoteReducers::DeletePkConnectionId(const FSpacetimeDBConnectionId& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkConnectionIdArgs ReducerArgs(A);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkConnectionId(const FReducerEventContext& Context, const UDeletePkConnectionIdReducer* Args)
{
    if (!OnDeletePkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkConnectionId"));
        }
        return false;
    }

    OnDeletePkConnectionId.Broadcast(Context, Args->A);
    return true;
}

bool URemoteReducers::InvokeDeletePkConnectionIdWithArgs(const FReducerEventContext& Context, const FDeletePkConnectionIdArgs& Args)
{
    if (!OnDeletePkConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkConnectionId"));
        }
        return false;
    }

    OnDeletePkConnectionId.Broadcast(Context, Args.A);
    return true;
}

void URemoteReducers::DeletePkI128(const FSpacetimeDBInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkI128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkI128(const FReducerEventContext& Context, const UDeletePkI128Reducer* Args)
{
    if (!OnDeletePkI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI128"));
        }
        return false;
    }

    OnDeletePkI128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkI128WithArgs(const FReducerEventContext& Context, const FDeletePkI128Args& Args)
{
    if (!OnDeletePkI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI128"));
        }
        return false;
    }

    OnDeletePkI128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkI16(const int16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkI16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkI16(const FReducerEventContext& Context, const UDeletePkI16Reducer* Args)
{
    if (!OnDeletePkI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI16"));
        }
        return false;
    }

    OnDeletePkI16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkI16WithArgs(const FReducerEventContext& Context, const FDeletePkI16Args& Args)
{
    if (!OnDeletePkI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI16"));
        }
        return false;
    }

    OnDeletePkI16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkI256(const FSpacetimeDBInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkI256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkI256(const FReducerEventContext& Context, const UDeletePkI256Reducer* Args)
{
    if (!OnDeletePkI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI256"));
        }
        return false;
    }

    OnDeletePkI256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkI256WithArgs(const FReducerEventContext& Context, const FDeletePkI256Args& Args)
{
    if (!OnDeletePkI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI256"));
        }
        return false;
    }

    OnDeletePkI256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkI32(const int32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkI32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkI32(const FReducerEventContext& Context, const UDeletePkI32Reducer* Args)
{
    if (!OnDeletePkI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI32"));
        }
        return false;
    }

    OnDeletePkI32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkI32WithArgs(const FReducerEventContext& Context, const FDeletePkI32Args& Args)
{
    if (!OnDeletePkI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI32"));
        }
        return false;
    }

    OnDeletePkI32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkI64(const int64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkI64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkI64(const FReducerEventContext& Context, const UDeletePkI64Reducer* Args)
{
    if (!OnDeletePkI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI64"));
        }
        return false;
    }

    OnDeletePkI64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkI64WithArgs(const FReducerEventContext& Context, const FDeletePkI64Args& Args)
{
    if (!OnDeletePkI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI64"));
        }
        return false;
    }

    OnDeletePkI64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkI8(const int8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkI8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkI8(const FReducerEventContext& Context, const UDeletePkI8Reducer* Args)
{
    if (!OnDeletePkI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI8"));
        }
        return false;
    }

    OnDeletePkI8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkI8WithArgs(const FReducerEventContext& Context, const FDeletePkI8Args& Args)
{
    if (!OnDeletePkI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkI8"));
        }
        return false;
    }

    OnDeletePkI8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkIdentity(const FSpacetimeDBIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkIdentityArgs ReducerArgs(I);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkIdentity(const FReducerEventContext& Context, const UDeletePkIdentityReducer* Args)
{
    if (!OnDeletePkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkIdentity"));
        }
        return false;
    }

    OnDeletePkIdentity.Broadcast(Context, Args->I);
    return true;
}

bool URemoteReducers::InvokeDeletePkIdentityWithArgs(const FReducerEventContext& Context, const FDeletePkIdentityArgs& Args)
{
    if (!OnDeletePkIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkIdentity"));
        }
        return false;
    }

    OnDeletePkIdentity.Broadcast(Context, Args.I);
    return true;
}

void URemoteReducers::DeletePkString(const FString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkStringArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkString(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkString(const FReducerEventContext& Context, const UDeletePkStringReducer* Args)
{
    if (!OnDeletePkString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkString"));
        }
        return false;
    }

    OnDeletePkString.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeDeletePkStringWithArgs(const FReducerEventContext& Context, const FDeletePkStringArgs& Args)
{
    if (!OnDeletePkString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkString"));
        }
        return false;
    }

    OnDeletePkString.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::DeletePkU128(const FSpacetimeDBUInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU128(const FReducerEventContext& Context, const UDeletePkU128Reducer* Args)
{
    if (!OnDeletePkU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU128"));
        }
        return false;
    }

    OnDeletePkU128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU128WithArgs(const FReducerEventContext& Context, const FDeletePkU128Args& Args)
{
    if (!OnDeletePkU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU128"));
        }
        return false;
    }

    OnDeletePkU128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkU16(const uint16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU16(const FReducerEventContext& Context, const UDeletePkU16Reducer* Args)
{
    if (!OnDeletePkU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU16"));
        }
        return false;
    }

    OnDeletePkU16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU16WithArgs(const FReducerEventContext& Context, const FDeletePkU16Args& Args)
{
    if (!OnDeletePkU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU16"));
        }
        return false;
    }

    OnDeletePkU16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkU256(const FSpacetimeDBUInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU256(const FReducerEventContext& Context, const UDeletePkU256Reducer* Args)
{
    if (!OnDeletePkU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU256"));
        }
        return false;
    }

    OnDeletePkU256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU256WithArgs(const FReducerEventContext& Context, const FDeletePkU256Args& Args)
{
    if (!OnDeletePkU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU256"));
        }
        return false;
    }

    OnDeletePkU256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkU32(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU32(const FReducerEventContext& Context, const UDeletePkU32Reducer* Args)
{
    if (!OnDeletePkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32"));
        }
        return false;
    }

    OnDeletePkU32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU32WithArgs(const FReducerEventContext& Context, const FDeletePkU32Args& Args)
{
    if (!OnDeletePkU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32"));
        }
        return false;
    }

    OnDeletePkU32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkU32InsertPkU32Two(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU32InsertPkU32TwoArgs ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_32_insert_pk_u_32_two"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU32InsertPkU32Two(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU32InsertPkU32Two(const FReducerEventContext& Context, const UDeletePkU32InsertPkU32TwoReducer* Args)
{
    if (!OnDeletePkU32InsertPkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32InsertPkU32Two"));
        }
        return false;
    }

    OnDeletePkU32InsertPkU32Two.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeDeletePkU32InsertPkU32TwoWithArgs(const FReducerEventContext& Context, const FDeletePkU32InsertPkU32TwoArgs& Args)
{
    if (!OnDeletePkU32InsertPkU32Two.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32InsertPkU32Two"));
        }
        return false;
    }

    OnDeletePkU32InsertPkU32Two.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::DeletePkU32Two(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU32TwoArgs ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_32_two"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU32Two(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU32Two(const FReducerEventContext& Context, const UDeletePkU32TwoReducer* Args)
{
    if (!OnDeletePkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32Two"));
        }
        return false;
    }

    OnDeletePkU32Two.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU32TwoWithArgs(const FReducerEventContext& Context, const FDeletePkU32TwoArgs& Args)
{
    if (!OnDeletePkU32Two.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU32Two"));
        }
        return false;
    }

    OnDeletePkU32Two.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkU64(const uint64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU64(const FReducerEventContext& Context, const UDeletePkU64Reducer* Args)
{
    if (!OnDeletePkU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU64"));
        }
        return false;
    }

    OnDeletePkU64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU64WithArgs(const FReducerEventContext& Context, const FDeletePkU64Args& Args)
{
    if (!OnDeletePkU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU64"));
        }
        return false;
    }

    OnDeletePkU64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkU8(const uint8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkU8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkU8(const FReducerEventContext& Context, const UDeletePkU8Reducer* Args)
{
    if (!OnDeletePkU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU8"));
        }
        return false;
    }

    OnDeletePkU8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeletePkU8WithArgs(const FReducerEventContext& Context, const FDeletePkU8Args& Args)
{
    if (!OnDeletePkU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkU8"));
        }
        return false;
    }

    OnDeletePkU8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeletePkUuid(const FSpacetimeDBUuid& U)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeletePkUuidArgs ReducerArgs(U);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_pk_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeletePkUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeletePkUuid(const FReducerEventContext& Context, const UDeletePkUuidReducer* Args)
{
    if (!OnDeletePkUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkUuid"));
        }
        return false;
    }

    OnDeletePkUuid.Broadcast(Context, Args->U);
    return true;
}

bool URemoteReducers::InvokeDeletePkUuidWithArgs(const FReducerEventContext& Context, const FDeletePkUuidArgs& Args)
{
    if (!OnDeletePkUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeletePkUuid"));
        }
        return false;
    }

    OnDeletePkUuid.Broadcast(Context, Args.U);
    return true;
}

void URemoteReducers::DeleteUniqueBool(const bool B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueBoolArgs ReducerArgs(B);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueBool(const FReducerEventContext& Context, const UDeleteUniqueBoolReducer* Args)
{
    if (!OnDeleteUniqueBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueBool"));
        }
        return false;
    }

    OnDeleteUniqueBool.Broadcast(Context, Args->B);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueBoolWithArgs(const FReducerEventContext& Context, const FDeleteUniqueBoolArgs& Args)
{
    if (!OnDeleteUniqueBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueBool"));
        }
        return false;
    }

    OnDeleteUniqueBool.Broadcast(Context, Args.B);
    return true;
}

void URemoteReducers::DeleteUniqueConnectionId(const FSpacetimeDBConnectionId& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueConnectionIdArgs ReducerArgs(A);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueConnectionId(const FReducerEventContext& Context, const UDeleteUniqueConnectionIdReducer* Args)
{
    if (!OnDeleteUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueConnectionId"));
        }
        return false;
    }

    OnDeleteUniqueConnectionId.Broadcast(Context, Args->A);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueConnectionIdWithArgs(const FReducerEventContext& Context, const FDeleteUniqueConnectionIdArgs& Args)
{
    if (!OnDeleteUniqueConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueConnectionId"));
        }
        return false;
    }

    OnDeleteUniqueConnectionId.Broadcast(Context, Args.A);
    return true;
}

void URemoteReducers::DeleteUniqueI128(const FSpacetimeDBInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueI128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueI128(const FReducerEventContext& Context, const UDeleteUniqueI128Reducer* Args)
{
    if (!OnDeleteUniqueI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI128"));
        }
        return false;
    }

    OnDeleteUniqueI128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueI128WithArgs(const FReducerEventContext& Context, const FDeleteUniqueI128Args& Args)
{
    if (!OnDeleteUniqueI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI128"));
        }
        return false;
    }

    OnDeleteUniqueI128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueI16(const int16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueI16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueI16(const FReducerEventContext& Context, const UDeleteUniqueI16Reducer* Args)
{
    if (!OnDeleteUniqueI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI16"));
        }
        return false;
    }

    OnDeleteUniqueI16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueI16WithArgs(const FReducerEventContext& Context, const FDeleteUniqueI16Args& Args)
{
    if (!OnDeleteUniqueI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI16"));
        }
        return false;
    }

    OnDeleteUniqueI16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueI256(const FSpacetimeDBInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueI256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueI256(const FReducerEventContext& Context, const UDeleteUniqueI256Reducer* Args)
{
    if (!OnDeleteUniqueI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI256"));
        }
        return false;
    }

    OnDeleteUniqueI256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueI256WithArgs(const FReducerEventContext& Context, const FDeleteUniqueI256Args& Args)
{
    if (!OnDeleteUniqueI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI256"));
        }
        return false;
    }

    OnDeleteUniqueI256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueI32(const int32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueI32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueI32(const FReducerEventContext& Context, const UDeleteUniqueI32Reducer* Args)
{
    if (!OnDeleteUniqueI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI32"));
        }
        return false;
    }

    OnDeleteUniqueI32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueI32WithArgs(const FReducerEventContext& Context, const FDeleteUniqueI32Args& Args)
{
    if (!OnDeleteUniqueI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI32"));
        }
        return false;
    }

    OnDeleteUniqueI32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueI64(const int64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueI64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueI64(const FReducerEventContext& Context, const UDeleteUniqueI64Reducer* Args)
{
    if (!OnDeleteUniqueI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI64"));
        }
        return false;
    }

    OnDeleteUniqueI64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueI64WithArgs(const FReducerEventContext& Context, const FDeleteUniqueI64Args& Args)
{
    if (!OnDeleteUniqueI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI64"));
        }
        return false;
    }

    OnDeleteUniqueI64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueI8(const int8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueI8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueI8(const FReducerEventContext& Context, const UDeleteUniqueI8Reducer* Args)
{
    if (!OnDeleteUniqueI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI8"));
        }
        return false;
    }

    OnDeleteUniqueI8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueI8WithArgs(const FReducerEventContext& Context, const FDeleteUniqueI8Args& Args)
{
    if (!OnDeleteUniqueI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueI8"));
        }
        return false;
    }

    OnDeleteUniqueI8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueIdentity(const FSpacetimeDBIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueIdentityArgs ReducerArgs(I);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueIdentity(const FReducerEventContext& Context, const UDeleteUniqueIdentityReducer* Args)
{
    if (!OnDeleteUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueIdentity"));
        }
        return false;
    }

    OnDeleteUniqueIdentity.Broadcast(Context, Args->I);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueIdentityWithArgs(const FReducerEventContext& Context, const FDeleteUniqueIdentityArgs& Args)
{
    if (!OnDeleteUniqueIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueIdentity"));
        }
        return false;
    }

    OnDeleteUniqueIdentity.Broadcast(Context, Args.I);
    return true;
}

void URemoteReducers::DeleteUniqueString(const FString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueStringArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueString(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueString(const FReducerEventContext& Context, const UDeleteUniqueStringReducer* Args)
{
    if (!OnDeleteUniqueString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueString"));
        }
        return false;
    }

    OnDeleteUniqueString.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueStringWithArgs(const FReducerEventContext& Context, const FDeleteUniqueStringArgs& Args)
{
    if (!OnDeleteUniqueString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueString"));
        }
        return false;
    }

    OnDeleteUniqueString.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::DeleteUniqueU128(const FSpacetimeDBUInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueU128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueU128(const FReducerEventContext& Context, const UDeleteUniqueU128Reducer* Args)
{
    if (!OnDeleteUniqueU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU128"));
        }
        return false;
    }

    OnDeleteUniqueU128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueU128WithArgs(const FReducerEventContext& Context, const FDeleteUniqueU128Args& Args)
{
    if (!OnDeleteUniqueU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU128"));
        }
        return false;
    }

    OnDeleteUniqueU128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueU16(const uint16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueU16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueU16(const FReducerEventContext& Context, const UDeleteUniqueU16Reducer* Args)
{
    if (!OnDeleteUniqueU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU16"));
        }
        return false;
    }

    OnDeleteUniqueU16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueU16WithArgs(const FReducerEventContext& Context, const FDeleteUniqueU16Args& Args)
{
    if (!OnDeleteUniqueU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU16"));
        }
        return false;
    }

    OnDeleteUniqueU16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueU256(const FSpacetimeDBUInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueU256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueU256(const FReducerEventContext& Context, const UDeleteUniqueU256Reducer* Args)
{
    if (!OnDeleteUniqueU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU256"));
        }
        return false;
    }

    OnDeleteUniqueU256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueU256WithArgs(const FReducerEventContext& Context, const FDeleteUniqueU256Args& Args)
{
    if (!OnDeleteUniqueU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU256"));
        }
        return false;
    }

    OnDeleteUniqueU256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueU32(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueU32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueU32(const FReducerEventContext& Context, const UDeleteUniqueU32Reducer* Args)
{
    if (!OnDeleteUniqueU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU32"));
        }
        return false;
    }

    OnDeleteUniqueU32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueU32WithArgs(const FReducerEventContext& Context, const FDeleteUniqueU32Args& Args)
{
    if (!OnDeleteUniqueU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU32"));
        }
        return false;
    }

    OnDeleteUniqueU32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueU64(const uint64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueU64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueU64(const FReducerEventContext& Context, const UDeleteUniqueU64Reducer* Args)
{
    if (!OnDeleteUniqueU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU64"));
        }
        return false;
    }

    OnDeleteUniqueU64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueU64WithArgs(const FReducerEventContext& Context, const FDeleteUniqueU64Args& Args)
{
    if (!OnDeleteUniqueU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU64"));
        }
        return false;
    }

    OnDeleteUniqueU64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueU8(const uint8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueU8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueU8(const FReducerEventContext& Context, const UDeleteUniqueU8Reducer* Args)
{
    if (!OnDeleteUniqueU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU8"));
        }
        return false;
    }

    OnDeleteUniqueU8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueU8WithArgs(const FReducerEventContext& Context, const FDeleteUniqueU8Args& Args)
{
    if (!OnDeleteUniqueU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueU8"));
        }
        return false;
    }

    OnDeleteUniqueU8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::DeleteUniqueUuid(const FSpacetimeDBUuid& U)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FDeleteUniqueUuidArgs ReducerArgs(U);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("delete_unique_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::DeleteUniqueUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeDeleteUniqueUuid(const FReducerEventContext& Context, const UDeleteUniqueUuidReducer* Args)
{
    if (!OnDeleteUniqueUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueUuid"));
        }
        return false;
    }

    OnDeleteUniqueUuid.Broadcast(Context, Args->U);
    return true;
}

bool URemoteReducers::InvokeDeleteUniqueUuidWithArgs(const FReducerEventContext& Context, const FDeleteUniqueUuidArgs& Args)
{
    if (!OnDeleteUniqueUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for DeleteUniqueUuid"));
        }
        return false;
    }

    OnDeleteUniqueUuid.Broadcast(Context, Args.U);
    return true;
}

void URemoteReducers::InsertCallTimestamp()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallTimestampArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_call_timestamp"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallTimestamp(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallTimestamp(const FReducerEventContext& Context, const UInsertCallTimestampReducer* Args)
{
    if (!OnInsertCallTimestamp.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallTimestamp"));
        }
        return false;
    }

    OnInsertCallTimestamp.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallTimestampWithArgs(const FReducerEventContext& Context, const FInsertCallTimestampArgs& Args)
{
    if (!OnInsertCallTimestamp.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallTimestamp"));
        }
        return false;
    }

    OnInsertCallTimestamp.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallUuidV4()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallUuidV4Args ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_call_uuid_v_4"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallUuidV4(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallUuidV4(const FReducerEventContext& Context, const UInsertCallUuidV4Reducer* Args)
{
    if (!OnInsertCallUuidV4.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallUuidV4"));
        }
        return false;
    }

    OnInsertCallUuidV4.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallUuidV4WithArgs(const FReducerEventContext& Context, const FInsertCallUuidV4Args& Args)
{
    if (!OnInsertCallUuidV4.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallUuidV4"));
        }
        return false;
    }

    OnInsertCallUuidV4.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallUuidV7()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallUuidV7Args ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_call_uuid_v_7"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallUuidV7(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallUuidV7(const FReducerEventContext& Context, const UInsertCallUuidV7Reducer* Args)
{
    if (!OnInsertCallUuidV7.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallUuidV7"));
        }
        return false;
    }

    OnInsertCallUuidV7.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallUuidV7WithArgs(const FReducerEventContext& Context, const FInsertCallUuidV7Args& Args)
{
    if (!OnInsertCallUuidV7.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallUuidV7"));
        }
        return false;
    }

    OnInsertCallUuidV7.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerOneConnectionId()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerOneConnectionIdArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_one_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerOneConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerOneConnectionId(const FReducerEventContext& Context, const UInsertCallerOneConnectionIdReducer* Args)
{
    if (!OnInsertCallerOneConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerOneConnectionId"));
        }
        return false;
    }

    OnInsertCallerOneConnectionId.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallerOneConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertCallerOneConnectionIdArgs& Args)
{
    if (!OnInsertCallerOneConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerOneConnectionId"));
        }
        return false;
    }

    OnInsertCallerOneConnectionId.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerOneIdentity()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerOneIdentityArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_one_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerOneIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerOneIdentity(const FReducerEventContext& Context, const UInsertCallerOneIdentityReducer* Args)
{
    if (!OnInsertCallerOneIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerOneIdentity"));
        }
        return false;
    }

    OnInsertCallerOneIdentity.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallerOneIdentityWithArgs(const FReducerEventContext& Context, const FInsertCallerOneIdentityArgs& Args)
{
    if (!OnInsertCallerOneIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerOneIdentity"));
        }
        return false;
    }

    OnInsertCallerOneIdentity.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerPkConnectionId(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerPkConnectionIdArgs ReducerArgs(Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_pk_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerPkConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerPkConnectionId(const FReducerEventContext& Context, const UInsertCallerPkConnectionIdReducer* Args)
{
    if (!OnInsertCallerPkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerPkConnectionId"));
        }
        return false;
    }

    OnInsertCallerPkConnectionId.Broadcast(Context, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertCallerPkConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertCallerPkConnectionIdArgs& Args)
{
    if (!OnInsertCallerPkConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerPkConnectionId"));
        }
        return false;
    }

    OnInsertCallerPkConnectionId.Broadcast(Context, Args.Data);
    return true;
}

void URemoteReducers::InsertCallerPkIdentity(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerPkIdentityArgs ReducerArgs(Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_pk_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerPkIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerPkIdentity(const FReducerEventContext& Context, const UInsertCallerPkIdentityReducer* Args)
{
    if (!OnInsertCallerPkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerPkIdentity"));
        }
        return false;
    }

    OnInsertCallerPkIdentity.Broadcast(Context, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertCallerPkIdentityWithArgs(const FReducerEventContext& Context, const FInsertCallerPkIdentityArgs& Args)
{
    if (!OnInsertCallerPkIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerPkIdentity"));
        }
        return false;
    }

    OnInsertCallerPkIdentity.Broadcast(Context, Args.Data);
    return true;
}

void URemoteReducers::InsertCallerUniqueConnectionId(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerUniqueConnectionIdArgs ReducerArgs(Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_unique_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerUniqueConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerUniqueConnectionId(const FReducerEventContext& Context, const UInsertCallerUniqueConnectionIdReducer* Args)
{
    if (!OnInsertCallerUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerUniqueConnectionId"));
        }
        return false;
    }

    OnInsertCallerUniqueConnectionId.Broadcast(Context, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertCallerUniqueConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertCallerUniqueConnectionIdArgs& Args)
{
    if (!OnInsertCallerUniqueConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerUniqueConnectionId"));
        }
        return false;
    }

    OnInsertCallerUniqueConnectionId.Broadcast(Context, Args.Data);
    return true;
}

void URemoteReducers::InsertCallerUniqueIdentity(const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerUniqueIdentityArgs ReducerArgs(Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_unique_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerUniqueIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerUniqueIdentity(const FReducerEventContext& Context, const UInsertCallerUniqueIdentityReducer* Args)
{
    if (!OnInsertCallerUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerUniqueIdentity"));
        }
        return false;
    }

    OnInsertCallerUniqueIdentity.Broadcast(Context, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertCallerUniqueIdentityWithArgs(const FReducerEventContext& Context, const FInsertCallerUniqueIdentityArgs& Args)
{
    if (!OnInsertCallerUniqueIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerUniqueIdentity"));
        }
        return false;
    }

    OnInsertCallerUniqueIdentity.Broadcast(Context, Args.Data);
    return true;
}

void URemoteReducers::InsertCallerVecConnectionId()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerVecConnectionIdArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_vec_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerVecConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerVecConnectionId(const FReducerEventContext& Context, const UInsertCallerVecConnectionIdReducer* Args)
{
    if (!OnInsertCallerVecConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerVecConnectionId"));
        }
        return false;
    }

    OnInsertCallerVecConnectionId.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallerVecConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertCallerVecConnectionIdArgs& Args)
{
    if (!OnInsertCallerVecConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerVecConnectionId"));
        }
        return false;
    }

    OnInsertCallerVecConnectionId.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertCallerVecIdentity()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertCallerVecIdentityArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_caller_vec_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertCallerVecIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertCallerVecIdentity(const FReducerEventContext& Context, const UInsertCallerVecIdentityReducer* Args)
{
    if (!OnInsertCallerVecIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerVecIdentity"));
        }
        return false;
    }

    OnInsertCallerVecIdentity.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeInsertCallerVecIdentityWithArgs(const FReducerEventContext& Context, const FInsertCallerVecIdentityArgs& Args)
{
    if (!OnInsertCallerVecIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertCallerVecIdentity"));
        }
        return false;
    }

    OnInsertCallerVecIdentity.Broadcast(Context);
    return true;
}

void URemoteReducers::InsertIntoBtreeU32(const TArray<FBTreeU32Type>& Rows)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertIntoBtreeU32Args ReducerArgs(Rows);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_into_btree_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertIntoBtreeU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertIntoBtreeU32(const FReducerEventContext& Context, const UInsertIntoBtreeU32Reducer* Args)
{
    if (!OnInsertIntoBtreeU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoBtreeU32"));
        }
        return false;
    }

    OnInsertIntoBtreeU32.Broadcast(Context, Args->Rows);
    return true;
}

bool URemoteReducers::InvokeInsertIntoBtreeU32WithArgs(const FReducerEventContext& Context, const FInsertIntoBtreeU32Args& Args)
{
    if (!OnInsertIntoBtreeU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoBtreeU32"));
        }
        return false;
    }

    OnInsertIntoBtreeU32.Broadcast(Context, Args.Rows);
    return true;
}

void URemoteReducers::InsertIntoIndexedSimpleEnum(const ESimpleEnumType& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertIntoIndexedSimpleEnumArgs ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_into_indexed_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertIntoIndexedSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertIntoIndexedSimpleEnum(const FReducerEventContext& Context, const UInsertIntoIndexedSimpleEnumReducer* Args)
{
    if (!OnInsertIntoIndexedSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoIndexedSimpleEnum"));
        }
        return false;
    }

    OnInsertIntoIndexedSimpleEnum.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertIntoIndexedSimpleEnumWithArgs(const FReducerEventContext& Context, const FInsertIntoIndexedSimpleEnumArgs& Args)
{
    if (!OnInsertIntoIndexedSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoIndexedSimpleEnum"));
        }
        return false;
    }

    OnInsertIntoIndexedSimpleEnum.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertIntoPkBtreeU32(const TArray<FPkU32Type>& PkU32, const TArray<FBTreeU32Type>& BtU32)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertIntoPkBtreeU32Args ReducerArgs(PkU32, BtU32);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_into_pk_btree_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertIntoPkBtreeU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertIntoPkBtreeU32(const FReducerEventContext& Context, const UInsertIntoPkBtreeU32Reducer* Args)
{
    if (!OnInsertIntoPkBtreeU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoPkBtreeU32"));
        }
        return false;
    }

    OnInsertIntoPkBtreeU32.Broadcast(Context, Args->PkU32, Args->BtU32);
    return true;
}

bool URemoteReducers::InvokeInsertIntoPkBtreeU32WithArgs(const FReducerEventContext& Context, const FInsertIntoPkBtreeU32Args& Args)
{
    if (!OnInsertIntoPkBtreeU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertIntoPkBtreeU32"));
        }
        return false;
    }

    OnInsertIntoPkBtreeU32.Broadcast(Context, Args.PkU32, Args.BtU32);
    return true;
}

void URemoteReducers::InsertLargeTable(const uint8 A, const uint16 B, const uint32 C, const uint64 D, const FSpacetimeDBUInt128& E, const FSpacetimeDBUInt256& F, const int8 G, const int16 H, const int32 I, const int64 J, const FSpacetimeDBInt128& K, const FSpacetimeDBInt256& L, const bool M, const float N, const double O, const FString& P, const ESimpleEnumType& Q, const FEnumWithPayloadType& R, const FUnitStructType& S, const FByteStructType& T, const FEveryPrimitiveStructType& U, const FEveryVecStructType& V)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertLargeTableArgs ReducerArgs(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_large_table"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertLargeTable(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertLargeTable(const FReducerEventContext& Context, const UInsertLargeTableReducer* Args)
{
    if (!OnInsertLargeTable.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertLargeTable"));
        }
        return false;
    }

    FInsertLargeTableArgs ArgsStruct;
    ArgsStruct.A = Args->A;
    ArgsStruct.B = Args->B;
    ArgsStruct.C = Args->C;
    ArgsStruct.D = Args->D;
    ArgsStruct.E = Args->E;
    ArgsStruct.F = Args->F;
    ArgsStruct.G = Args->G;
    ArgsStruct.H = Args->H;
    ArgsStruct.I = Args->I;
    ArgsStruct.J = Args->J;
    ArgsStruct.K = Args->K;
    ArgsStruct.L = Args->L;
    ArgsStruct.M = Args->M;
    ArgsStruct.N = Args->N;
    ArgsStruct.O = Args->O;
    ArgsStruct.P = Args->P;
    ArgsStruct.Q = Args->Q;
    ArgsStruct.R = Args->R;
    ArgsStruct.S = Args->S;
    ArgsStruct.T = Args->T;
    ArgsStruct.U = Args->U;
    ArgsStruct.V = Args->V;
    OnInsertLargeTable.Broadcast(Context, ArgsStruct);
    return true;
}

bool URemoteReducers::InvokeInsertLargeTableWithArgs(const FReducerEventContext& Context, const FInsertLargeTableArgs& Args)
{
    if (!OnInsertLargeTable.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertLargeTable"));
        }
        return false;
    }

    OnInsertLargeTable.Broadcast(Context, Args);
    return true;
}

void URemoteReducers::InsertOneBool(const bool B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneBoolArgs ReducerArgs(B);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneBool(const FReducerEventContext& Context, const UInsertOneBoolReducer* Args)
{
    if (!OnInsertOneBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneBool"));
        }
        return false;
    }

    OnInsertOneBool.Broadcast(Context, Args->B);
    return true;
}

bool URemoteReducers::InvokeInsertOneBoolWithArgs(const FReducerEventContext& Context, const FInsertOneBoolArgs& Args)
{
    if (!OnInsertOneBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneBool"));
        }
        return false;
    }

    OnInsertOneBool.Broadcast(Context, Args.B);
    return true;
}

void URemoteReducers::InsertOneByteStruct(const FByteStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneByteStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_byte_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneByteStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneByteStruct(const FReducerEventContext& Context, const UInsertOneByteStructReducer* Args)
{
    if (!OnInsertOneByteStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneByteStruct"));
        }
        return false;
    }

    OnInsertOneByteStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOneByteStructWithArgs(const FReducerEventContext& Context, const FInsertOneByteStructArgs& Args)
{
    if (!OnInsertOneByteStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneByteStruct"));
        }
        return false;
    }

    OnInsertOneByteStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOneConnectionId(const FSpacetimeDBConnectionId& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneConnectionIdArgs ReducerArgs(A);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneConnectionId(const FReducerEventContext& Context, const UInsertOneConnectionIdReducer* Args)
{
    if (!OnInsertOneConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneConnectionId"));
        }
        return false;
    }

    OnInsertOneConnectionId.Broadcast(Context, Args->A);
    return true;
}

bool URemoteReducers::InvokeInsertOneConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertOneConnectionIdArgs& Args)
{
    if (!OnInsertOneConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneConnectionId"));
        }
        return false;
    }

    OnInsertOneConnectionId.Broadcast(Context, Args.A);
    return true;
}

void URemoteReducers::InsertOneEnumWithPayload(const FEnumWithPayloadType& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneEnumWithPayloadArgs ReducerArgs(E);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_enum_with_payload"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneEnumWithPayload(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneEnumWithPayload(const FReducerEventContext& Context, const UInsertOneEnumWithPayloadReducer* Args)
{
    if (!OnInsertOneEnumWithPayload.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEnumWithPayload"));
        }
        return false;
    }

    OnInsertOneEnumWithPayload.Broadcast(Context, Args->E);
    return true;
}

bool URemoteReducers::InvokeInsertOneEnumWithPayloadWithArgs(const FReducerEventContext& Context, const FInsertOneEnumWithPayloadArgs& Args)
{
    if (!OnInsertOneEnumWithPayload.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEnumWithPayload"));
        }
        return false;
    }

    OnInsertOneEnumWithPayload.Broadcast(Context, Args.E);
    return true;
}

void URemoteReducers::InsertOneEveryPrimitiveStruct(const FEveryPrimitiveStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneEveryPrimitiveStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_every_primitive_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneEveryPrimitiveStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneEveryPrimitiveStruct(const FReducerEventContext& Context, const UInsertOneEveryPrimitiveStructReducer* Args)
{
    if (!OnInsertOneEveryPrimitiveStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertOneEveryPrimitiveStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOneEveryPrimitiveStructWithArgs(const FReducerEventContext& Context, const FInsertOneEveryPrimitiveStructArgs& Args)
{
    if (!OnInsertOneEveryPrimitiveStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertOneEveryPrimitiveStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOneEveryVecStruct(const FEveryVecStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneEveryVecStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_every_vec_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneEveryVecStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneEveryVecStruct(const FReducerEventContext& Context, const UInsertOneEveryVecStructReducer* Args)
{
    if (!OnInsertOneEveryVecStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEveryVecStruct"));
        }
        return false;
    }

    OnInsertOneEveryVecStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOneEveryVecStructWithArgs(const FReducerEventContext& Context, const FInsertOneEveryVecStructArgs& Args)
{
    if (!OnInsertOneEveryVecStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneEveryVecStruct"));
        }
        return false;
    }

    OnInsertOneEveryVecStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOneF32(const float F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneF32Args ReducerArgs(F);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_f_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneF32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneF32(const FReducerEventContext& Context, const UInsertOneF32Reducer* Args)
{
    if (!OnInsertOneF32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneF32"));
        }
        return false;
    }

    OnInsertOneF32.Broadcast(Context, Args->F);
    return true;
}

bool URemoteReducers::InvokeInsertOneF32WithArgs(const FReducerEventContext& Context, const FInsertOneF32Args& Args)
{
    if (!OnInsertOneF32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneF32"));
        }
        return false;
    }

    OnInsertOneF32.Broadcast(Context, Args.F);
    return true;
}

void URemoteReducers::InsertOneF64(const double F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneF64Args ReducerArgs(F);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_f_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneF64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneF64(const FReducerEventContext& Context, const UInsertOneF64Reducer* Args)
{
    if (!OnInsertOneF64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneF64"));
        }
        return false;
    }

    OnInsertOneF64.Broadcast(Context, Args->F);
    return true;
}

bool URemoteReducers::InvokeInsertOneF64WithArgs(const FReducerEventContext& Context, const FInsertOneF64Args& Args)
{
    if (!OnInsertOneF64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneF64"));
        }
        return false;
    }

    OnInsertOneF64.Broadcast(Context, Args.F);
    return true;
}

void URemoteReducers::InsertOneI128(const FSpacetimeDBInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneI128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneI128(const FReducerEventContext& Context, const UInsertOneI128Reducer* Args)
{
    if (!OnInsertOneI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI128"));
        }
        return false;
    }

    OnInsertOneI128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneI128WithArgs(const FReducerEventContext& Context, const FInsertOneI128Args& Args)
{
    if (!OnInsertOneI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI128"));
        }
        return false;
    }

    OnInsertOneI128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneI16(const int16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneI16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneI16(const FReducerEventContext& Context, const UInsertOneI16Reducer* Args)
{
    if (!OnInsertOneI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI16"));
        }
        return false;
    }

    OnInsertOneI16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneI16WithArgs(const FReducerEventContext& Context, const FInsertOneI16Args& Args)
{
    if (!OnInsertOneI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI16"));
        }
        return false;
    }

    OnInsertOneI16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneI256(const FSpacetimeDBInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneI256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneI256(const FReducerEventContext& Context, const UInsertOneI256Reducer* Args)
{
    if (!OnInsertOneI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI256"));
        }
        return false;
    }

    OnInsertOneI256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneI256WithArgs(const FReducerEventContext& Context, const FInsertOneI256Args& Args)
{
    if (!OnInsertOneI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI256"));
        }
        return false;
    }

    OnInsertOneI256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneI32(const int32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneI32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneI32(const FReducerEventContext& Context, const UInsertOneI32Reducer* Args)
{
    if (!OnInsertOneI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI32"));
        }
        return false;
    }

    OnInsertOneI32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneI32WithArgs(const FReducerEventContext& Context, const FInsertOneI32Args& Args)
{
    if (!OnInsertOneI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI32"));
        }
        return false;
    }

    OnInsertOneI32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneI64(const int64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneI64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneI64(const FReducerEventContext& Context, const UInsertOneI64Reducer* Args)
{
    if (!OnInsertOneI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI64"));
        }
        return false;
    }

    OnInsertOneI64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneI64WithArgs(const FReducerEventContext& Context, const FInsertOneI64Args& Args)
{
    if (!OnInsertOneI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI64"));
        }
        return false;
    }

    OnInsertOneI64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneI8(const int8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneI8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneI8(const FReducerEventContext& Context, const UInsertOneI8Reducer* Args)
{
    if (!OnInsertOneI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI8"));
        }
        return false;
    }

    OnInsertOneI8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneI8WithArgs(const FReducerEventContext& Context, const FInsertOneI8Args& Args)
{
    if (!OnInsertOneI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneI8"));
        }
        return false;
    }

    OnInsertOneI8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneIdentity(const FSpacetimeDBIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneIdentityArgs ReducerArgs(I);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneIdentity(const FReducerEventContext& Context, const UInsertOneIdentityReducer* Args)
{
    if (!OnInsertOneIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneIdentity"));
        }
        return false;
    }

    OnInsertOneIdentity.Broadcast(Context, Args->I);
    return true;
}

bool URemoteReducers::InvokeInsertOneIdentityWithArgs(const FReducerEventContext& Context, const FInsertOneIdentityArgs& Args)
{
    if (!OnInsertOneIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneIdentity"));
        }
        return false;
    }

    OnInsertOneIdentity.Broadcast(Context, Args.I);
    return true;
}

void URemoteReducers::InsertOneSimpleEnum(const ESimpleEnumType& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneSimpleEnumArgs ReducerArgs(E);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneSimpleEnum(const FReducerEventContext& Context, const UInsertOneSimpleEnumReducer* Args)
{
    if (!OnInsertOneSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneSimpleEnum"));
        }
        return false;
    }

    OnInsertOneSimpleEnum.Broadcast(Context, Args->E);
    return true;
}

bool URemoteReducers::InvokeInsertOneSimpleEnumWithArgs(const FReducerEventContext& Context, const FInsertOneSimpleEnumArgs& Args)
{
    if (!OnInsertOneSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneSimpleEnum"));
        }
        return false;
    }

    OnInsertOneSimpleEnum.Broadcast(Context, Args.E);
    return true;
}

void URemoteReducers::InsertOneString(const FString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneStringArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneString(const FReducerEventContext& Context, const UInsertOneStringReducer* Args)
{
    if (!OnInsertOneString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneString"));
        }
        return false;
    }

    OnInsertOneString.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOneStringWithArgs(const FReducerEventContext& Context, const FInsertOneStringArgs& Args)
{
    if (!OnInsertOneString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneString"));
        }
        return false;
    }

    OnInsertOneString.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOneTimestamp(const FSpacetimeDBTimestamp& T)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneTimestampArgs ReducerArgs(T);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_timestamp"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneTimestamp(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneTimestamp(const FReducerEventContext& Context, const UInsertOneTimestampReducer* Args)
{
    if (!OnInsertOneTimestamp.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneTimestamp"));
        }
        return false;
    }

    OnInsertOneTimestamp.Broadcast(Context, Args->T);
    return true;
}

bool URemoteReducers::InvokeInsertOneTimestampWithArgs(const FReducerEventContext& Context, const FInsertOneTimestampArgs& Args)
{
    if (!OnInsertOneTimestamp.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneTimestamp"));
        }
        return false;
    }

    OnInsertOneTimestamp.Broadcast(Context, Args.T);
    return true;
}

void URemoteReducers::InsertOneU128(const FSpacetimeDBUInt128& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneU128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneU128(const FReducerEventContext& Context, const UInsertOneU128Reducer* Args)
{
    if (!OnInsertOneU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU128"));
        }
        return false;
    }

    OnInsertOneU128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneU128WithArgs(const FReducerEventContext& Context, const FInsertOneU128Args& Args)
{
    if (!OnInsertOneU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU128"));
        }
        return false;
    }

    OnInsertOneU128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneU16(const uint16 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneU16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneU16(const FReducerEventContext& Context, const UInsertOneU16Reducer* Args)
{
    if (!OnInsertOneU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU16"));
        }
        return false;
    }

    OnInsertOneU16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneU16WithArgs(const FReducerEventContext& Context, const FInsertOneU16Args& Args)
{
    if (!OnInsertOneU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU16"));
        }
        return false;
    }

    OnInsertOneU16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneU256(const FSpacetimeDBUInt256& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneU256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneU256(const FReducerEventContext& Context, const UInsertOneU256Reducer* Args)
{
    if (!OnInsertOneU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU256"));
        }
        return false;
    }

    OnInsertOneU256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneU256WithArgs(const FReducerEventContext& Context, const FInsertOneU256Args& Args)
{
    if (!OnInsertOneU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU256"));
        }
        return false;
    }

    OnInsertOneU256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneU32(const uint32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneU32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneU32(const FReducerEventContext& Context, const UInsertOneU32Reducer* Args)
{
    if (!OnInsertOneU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU32"));
        }
        return false;
    }

    OnInsertOneU32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneU32WithArgs(const FReducerEventContext& Context, const FInsertOneU32Args& Args)
{
    if (!OnInsertOneU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU32"));
        }
        return false;
    }

    OnInsertOneU32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneU64(const uint64 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneU64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneU64(const FReducerEventContext& Context, const UInsertOneU64Reducer* Args)
{
    if (!OnInsertOneU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU64"));
        }
        return false;
    }

    OnInsertOneU64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneU64WithArgs(const FReducerEventContext& Context, const FInsertOneU64Args& Args)
{
    if (!OnInsertOneU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU64"));
        }
        return false;
    }

    OnInsertOneU64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneU8(const uint8 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneU8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneU8(const FReducerEventContext& Context, const UInsertOneU8Reducer* Args)
{
    if (!OnInsertOneU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU8"));
        }
        return false;
    }

    OnInsertOneU8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOneU8WithArgs(const FReducerEventContext& Context, const FInsertOneU8Args& Args)
{
    if (!OnInsertOneU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneU8"));
        }
        return false;
    }

    OnInsertOneU8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOneUnitStruct(const FUnitStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneUnitStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_unit_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneUnitStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneUnitStruct(const FReducerEventContext& Context, const UInsertOneUnitStructReducer* Args)
{
    if (!OnInsertOneUnitStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneUnitStruct"));
        }
        return false;
    }

    OnInsertOneUnitStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOneUnitStructWithArgs(const FReducerEventContext& Context, const FInsertOneUnitStructArgs& Args)
{
    if (!OnInsertOneUnitStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneUnitStruct"));
        }
        return false;
    }

    OnInsertOneUnitStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOneUuid(const FSpacetimeDBUuid& U)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOneUuidArgs ReducerArgs(U);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_one_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOneUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOneUuid(const FReducerEventContext& Context, const UInsertOneUuidReducer* Args)
{
    if (!OnInsertOneUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneUuid"));
        }
        return false;
    }

    OnInsertOneUuid.Broadcast(Context, Args->U);
    return true;
}

bool URemoteReducers::InvokeInsertOneUuidWithArgs(const FReducerEventContext& Context, const FInsertOneUuidArgs& Args)
{
    if (!OnInsertOneUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOneUuid"));
        }
        return false;
    }

    OnInsertOneUuid.Broadcast(Context, Args.U);
    return true;
}

void URemoteReducers::InsertOptionEveryPrimitiveStruct(const FTestClientOptionalEveryPrimitiveStruct& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionEveryPrimitiveStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_every_primitive_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionEveryPrimitiveStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionEveryPrimitiveStruct(const FReducerEventContext& Context, const UInsertOptionEveryPrimitiveStructReducer* Args)
{
    if (!OnInsertOptionEveryPrimitiveStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertOptionEveryPrimitiveStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOptionEveryPrimitiveStructWithArgs(const FReducerEventContext& Context, const FInsertOptionEveryPrimitiveStructArgs& Args)
{
    if (!OnInsertOptionEveryPrimitiveStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertOptionEveryPrimitiveStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOptionI32(const FTestClientOptionalInt32 N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionI32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionI32(const FReducerEventContext& Context, const UInsertOptionI32Reducer* Args)
{
    if (!OnInsertOptionI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionI32"));
        }
        return false;
    }

    OnInsertOptionI32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertOptionI32WithArgs(const FReducerEventContext& Context, const FInsertOptionI32Args& Args)
{
    if (!OnInsertOptionI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionI32"));
        }
        return false;
    }

    OnInsertOptionI32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertOptionIdentity(const FTestClientOptionalIdentity& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionIdentityArgs ReducerArgs(I);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionIdentity(const FReducerEventContext& Context, const UInsertOptionIdentityReducer* Args)
{
    if (!OnInsertOptionIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionIdentity"));
        }
        return false;
    }

    OnInsertOptionIdentity.Broadcast(Context, Args->I);
    return true;
}

bool URemoteReducers::InvokeInsertOptionIdentityWithArgs(const FReducerEventContext& Context, const FInsertOptionIdentityArgs& Args)
{
    if (!OnInsertOptionIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionIdentity"));
        }
        return false;
    }

    OnInsertOptionIdentity.Broadcast(Context, Args.I);
    return true;
}

void URemoteReducers::InsertOptionSimpleEnum(const FTestClientOptionalSimpleEnum& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionSimpleEnumArgs ReducerArgs(E);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionSimpleEnum(const FReducerEventContext& Context, const UInsertOptionSimpleEnumReducer* Args)
{
    if (!OnInsertOptionSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionSimpleEnum"));
        }
        return false;
    }

    OnInsertOptionSimpleEnum.Broadcast(Context, Args->E);
    return true;
}

bool URemoteReducers::InvokeInsertOptionSimpleEnumWithArgs(const FReducerEventContext& Context, const FInsertOptionSimpleEnumArgs& Args)
{
    if (!OnInsertOptionSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionSimpleEnum"));
        }
        return false;
    }

    OnInsertOptionSimpleEnum.Broadcast(Context, Args.E);
    return true;
}

void URemoteReducers::InsertOptionString(const FTestClientOptionalString& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionStringArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionString(const FReducerEventContext& Context, const UInsertOptionStringReducer* Args)
{
    if (!OnInsertOptionString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionString"));
        }
        return false;
    }

    OnInsertOptionString.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertOptionStringWithArgs(const FReducerEventContext& Context, const FInsertOptionStringArgs& Args)
{
    if (!OnInsertOptionString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionString"));
        }
        return false;
    }

    OnInsertOptionString.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertOptionUuid(const FTestClientOptionalUuid& U)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionUuidArgs ReducerArgs(U);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionUuid(const FReducerEventContext& Context, const UInsertOptionUuidReducer* Args)
{
    if (!OnInsertOptionUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionUuid"));
        }
        return false;
    }

    OnInsertOptionUuid.Broadcast(Context, Args->U);
    return true;
}

bool URemoteReducers::InvokeInsertOptionUuidWithArgs(const FReducerEventContext& Context, const FInsertOptionUuidArgs& Args)
{
    if (!OnInsertOptionUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionUuid"));
        }
        return false;
    }

    OnInsertOptionUuid.Broadcast(Context, Args.U);
    return true;
}

void URemoteReducers::InsertOptionVecOptionI32(const FTestClientOptionalVecOptionalInt32& V)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertOptionVecOptionI32Args ReducerArgs(V);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_option_vec_option_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertOptionVecOptionI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertOptionVecOptionI32(const FReducerEventContext& Context, const UInsertOptionVecOptionI32Reducer* Args)
{
    if (!OnInsertOptionVecOptionI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionVecOptionI32"));
        }
        return false;
    }

    OnInsertOptionVecOptionI32.Broadcast(Context, Args->V);
    return true;
}

bool URemoteReducers::InvokeInsertOptionVecOptionI32WithArgs(const FReducerEventContext& Context, const FInsertOptionVecOptionI32Args& Args)
{
    if (!OnInsertOptionVecOptionI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertOptionVecOptionI32"));
        }
        return false;
    }

    OnInsertOptionVecOptionI32.Broadcast(Context, Args.V);
    return true;
}

void URemoteReducers::InsertPkBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkBoolArgs ReducerArgs(B, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkBool(const FReducerEventContext& Context, const UInsertPkBoolReducer* Args)
{
    if (!OnInsertPkBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkBool"));
        }
        return false;
    }

    OnInsertPkBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkBoolWithArgs(const FReducerEventContext& Context, const FInsertPkBoolArgs& Args)
{
    if (!OnInsertPkBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkBool"));
        }
        return false;
    }

    OnInsertPkBool.Broadcast(Context, Args.B, Args.Data);
    return true;
}

void URemoteReducers::InsertPkConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkConnectionIdArgs ReducerArgs(A, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkConnectionId(const FReducerEventContext& Context, const UInsertPkConnectionIdReducer* Args)
{
    if (!OnInsertPkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkConnectionId"));
        }
        return false;
    }

    OnInsertPkConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertPkConnectionIdArgs& Args)
{
    if (!OnInsertPkConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkConnectionId"));
        }
        return false;
    }

    OnInsertPkConnectionId.Broadcast(Context, Args.A, Args.Data);
    return true;
}

void URemoteReducers::InsertPkI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkI128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkI128(const FReducerEventContext& Context, const UInsertPkI128Reducer* Args)
{
    if (!OnInsertPkI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI128"));
        }
        return false;
    }

    OnInsertPkI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkI128WithArgs(const FReducerEventContext& Context, const FInsertPkI128Args& Args)
{
    if (!OnInsertPkI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI128"));
        }
        return false;
    }

    OnInsertPkI128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkI16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkI16(const FReducerEventContext& Context, const UInsertPkI16Reducer* Args)
{
    if (!OnInsertPkI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI16"));
        }
        return false;
    }

    OnInsertPkI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkI16WithArgs(const FReducerEventContext& Context, const FInsertPkI16Args& Args)
{
    if (!OnInsertPkI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI16"));
        }
        return false;
    }

    OnInsertPkI16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkI256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkI256(const FReducerEventContext& Context, const UInsertPkI256Reducer* Args)
{
    if (!OnInsertPkI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI256"));
        }
        return false;
    }

    OnInsertPkI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkI256WithArgs(const FReducerEventContext& Context, const FInsertPkI256Args& Args)
{
    if (!OnInsertPkI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI256"));
        }
        return false;
    }

    OnInsertPkI256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkI32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkI32(const FReducerEventContext& Context, const UInsertPkI32Reducer* Args)
{
    if (!OnInsertPkI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI32"));
        }
        return false;
    }

    OnInsertPkI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkI32WithArgs(const FReducerEventContext& Context, const FInsertPkI32Args& Args)
{
    if (!OnInsertPkI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI32"));
        }
        return false;
    }

    OnInsertPkI32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkI64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkI64(const FReducerEventContext& Context, const UInsertPkI64Reducer* Args)
{
    if (!OnInsertPkI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI64"));
        }
        return false;
    }

    OnInsertPkI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkI64WithArgs(const FReducerEventContext& Context, const FInsertPkI64Args& Args)
{
    if (!OnInsertPkI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI64"));
        }
        return false;
    }

    OnInsertPkI64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkI8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkI8(const FReducerEventContext& Context, const UInsertPkI8Reducer* Args)
{
    if (!OnInsertPkI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI8"));
        }
        return false;
    }

    OnInsertPkI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkI8WithArgs(const FReducerEventContext& Context, const FInsertPkI8Args& Args)
{
    if (!OnInsertPkI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkI8"));
        }
        return false;
    }

    OnInsertPkI8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkIdentityArgs ReducerArgs(I, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkIdentity(const FReducerEventContext& Context, const UInsertPkIdentityReducer* Args)
{
    if (!OnInsertPkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkIdentity"));
        }
        return false;
    }

    OnInsertPkIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkIdentityWithArgs(const FReducerEventContext& Context, const FInsertPkIdentityArgs& Args)
{
    if (!OnInsertPkIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkIdentity"));
        }
        return false;
    }

    OnInsertPkIdentity.Broadcast(Context, Args.I, Args.Data);
    return true;
}

void URemoteReducers::InsertPkSimpleEnum(const ESimpleEnumType& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkSimpleEnumArgs ReducerArgs(A, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkSimpleEnum(const FReducerEventContext& Context, const UInsertPkSimpleEnumReducer* Args)
{
    if (!OnInsertPkSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkSimpleEnum"));
        }
        return false;
    }

    OnInsertPkSimpleEnum.Broadcast(Context, Args->A, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkSimpleEnumWithArgs(const FReducerEventContext& Context, const FInsertPkSimpleEnumArgs& Args)
{
    if (!OnInsertPkSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkSimpleEnum"));
        }
        return false;
    }

    OnInsertPkSimpleEnum.Broadcast(Context, Args.A, Args.Data);
    return true;
}

void URemoteReducers::InsertPkString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkStringArgs ReducerArgs(S, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkString(const FReducerEventContext& Context, const UInsertPkStringReducer* Args)
{
    if (!OnInsertPkString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkString"));
        }
        return false;
    }

    OnInsertPkString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkStringWithArgs(const FReducerEventContext& Context, const FInsertPkStringArgs& Args)
{
    if (!OnInsertPkString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkString"));
        }
        return false;
    }

    OnInsertPkString.Broadcast(Context, Args.S, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU128(const FReducerEventContext& Context, const UInsertPkU128Reducer* Args)
{
    if (!OnInsertPkU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU128"));
        }
        return false;
    }

    OnInsertPkU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU128WithArgs(const FReducerEventContext& Context, const FInsertPkU128Args& Args)
{
    if (!OnInsertPkU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU128"));
        }
        return false;
    }

    OnInsertPkU128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU16(const FReducerEventContext& Context, const UInsertPkU16Reducer* Args)
{
    if (!OnInsertPkU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU16"));
        }
        return false;
    }

    OnInsertPkU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU16WithArgs(const FReducerEventContext& Context, const FInsertPkU16Args& Args)
{
    if (!OnInsertPkU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU16"));
        }
        return false;
    }

    OnInsertPkU16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU256(const FReducerEventContext& Context, const UInsertPkU256Reducer* Args)
{
    if (!OnInsertPkU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU256"));
        }
        return false;
    }

    OnInsertPkU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU256WithArgs(const FReducerEventContext& Context, const FInsertPkU256Args& Args)
{
    if (!OnInsertPkU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU256"));
        }
        return false;
    }

    OnInsertPkU256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU32(const FReducerEventContext& Context, const UInsertPkU32Reducer* Args)
{
    if (!OnInsertPkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU32"));
        }
        return false;
    }

    OnInsertPkU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU32WithArgs(const FReducerEventContext& Context, const FInsertPkU32Args& Args)
{
    if (!OnInsertPkU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU32"));
        }
        return false;
    }

    OnInsertPkU32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU32Two(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU32TwoArgs ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_32_two"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU32Two(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU32Two(const FReducerEventContext& Context, const UInsertPkU32TwoReducer* Args)
{
    if (!OnInsertPkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU32Two"));
        }
        return false;
    }

    OnInsertPkU32Two.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU32TwoWithArgs(const FReducerEventContext& Context, const FInsertPkU32TwoArgs& Args)
{
    if (!OnInsertPkU32Two.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU32Two"));
        }
        return false;
    }

    OnInsertPkU32Two.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU64(const FReducerEventContext& Context, const UInsertPkU64Reducer* Args)
{
    if (!OnInsertPkU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU64"));
        }
        return false;
    }

    OnInsertPkU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU64WithArgs(const FReducerEventContext& Context, const FInsertPkU64Args& Args)
{
    if (!OnInsertPkU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU64"));
        }
        return false;
    }

    OnInsertPkU64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkU8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkU8(const FReducerEventContext& Context, const UInsertPkU8Reducer* Args)
{
    if (!OnInsertPkU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU8"));
        }
        return false;
    }

    OnInsertPkU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkU8WithArgs(const FReducerEventContext& Context, const FInsertPkU8Args& Args)
{
    if (!OnInsertPkU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkU8"));
        }
        return false;
    }

    OnInsertPkU8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertPkUuid(const FSpacetimeDBUuid& U, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPkUuidArgs ReducerArgs(U, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_pk_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPkUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPkUuid(const FReducerEventContext& Context, const UInsertPkUuidReducer* Args)
{
    if (!OnInsertPkUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkUuid"));
        }
        return false;
    }

    OnInsertPkUuid.Broadcast(Context, Args->U, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertPkUuidWithArgs(const FReducerEventContext& Context, const FInsertPkUuidArgs& Args)
{
    if (!OnInsertPkUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPkUuid"));
        }
        return false;
    }

    OnInsertPkUuid.Broadcast(Context, Args.U, Args.Data);
    return true;
}

void URemoteReducers::InsertPrimitivesAsStrings(const FEveryPrimitiveStructType& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertPrimitivesAsStringsArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_primitives_as_strings"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertPrimitivesAsStrings(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertPrimitivesAsStrings(const FReducerEventContext& Context, const UInsertPrimitivesAsStringsReducer* Args)
{
    if (!OnInsertPrimitivesAsStrings.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPrimitivesAsStrings"));
        }
        return false;
    }

    OnInsertPrimitivesAsStrings.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertPrimitivesAsStringsWithArgs(const FReducerEventContext& Context, const FInsertPrimitivesAsStringsArgs& Args)
{
    if (!OnInsertPrimitivesAsStrings.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertPrimitivesAsStrings"));
        }
        return false;
    }

    OnInsertPrimitivesAsStrings.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertResultEveryPrimitiveStructString(const FTestClientResultEveryPrimitiveStructString& R)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertResultEveryPrimitiveStructStringArgs ReducerArgs(R);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_result_every_primitive_struct_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertResultEveryPrimitiveStructString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertResultEveryPrimitiveStructString(const FReducerEventContext& Context, const UInsertResultEveryPrimitiveStructStringReducer* Args)
{
    if (!OnInsertResultEveryPrimitiveStructString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultEveryPrimitiveStructString"));
        }
        return false;
    }

    OnInsertResultEveryPrimitiveStructString.Broadcast(Context, Args->R);
    return true;
}

bool URemoteReducers::InvokeInsertResultEveryPrimitiveStructStringWithArgs(const FReducerEventContext& Context, const FInsertResultEveryPrimitiveStructStringArgs& Args)
{
    if (!OnInsertResultEveryPrimitiveStructString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultEveryPrimitiveStructString"));
        }
        return false;
    }

    OnInsertResultEveryPrimitiveStructString.Broadcast(Context, Args.R);
    return true;
}

void URemoteReducers::InsertResultI32String(const FTestClientResultInt32String& R)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertResultI32StringArgs ReducerArgs(R);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_result_i_32_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertResultI32String(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertResultI32String(const FReducerEventContext& Context, const UInsertResultI32StringReducer* Args)
{
    if (!OnInsertResultI32String.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultI32String"));
        }
        return false;
    }

    OnInsertResultI32String.Broadcast(Context, Args->R);
    return true;
}

bool URemoteReducers::InvokeInsertResultI32StringWithArgs(const FReducerEventContext& Context, const FInsertResultI32StringArgs& Args)
{
    if (!OnInsertResultI32String.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultI32String"));
        }
        return false;
    }

    OnInsertResultI32String.Broadcast(Context, Args.R);
    return true;
}

void URemoteReducers::InsertResultIdentityString(const FTestClientResultIdentityString& R)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertResultIdentityStringArgs ReducerArgs(R);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_result_identity_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertResultIdentityString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertResultIdentityString(const FReducerEventContext& Context, const UInsertResultIdentityStringReducer* Args)
{
    if (!OnInsertResultIdentityString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultIdentityString"));
        }
        return false;
    }

    OnInsertResultIdentityString.Broadcast(Context, Args->R);
    return true;
}

bool URemoteReducers::InvokeInsertResultIdentityStringWithArgs(const FReducerEventContext& Context, const FInsertResultIdentityStringArgs& Args)
{
    if (!OnInsertResultIdentityString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultIdentityString"));
        }
        return false;
    }

    OnInsertResultIdentityString.Broadcast(Context, Args.R);
    return true;
}

void URemoteReducers::InsertResultSimpleEnumI32(const FTestClientResultSimpleEnumInt32& R)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertResultSimpleEnumI32Args ReducerArgs(R);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_result_simple_enum_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertResultSimpleEnumI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertResultSimpleEnumI32(const FReducerEventContext& Context, const UInsertResultSimpleEnumI32Reducer* Args)
{
    if (!OnInsertResultSimpleEnumI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultSimpleEnumI32"));
        }
        return false;
    }

    OnInsertResultSimpleEnumI32.Broadcast(Context, Args->R);
    return true;
}

bool URemoteReducers::InvokeInsertResultSimpleEnumI32WithArgs(const FReducerEventContext& Context, const FInsertResultSimpleEnumI32Args& Args)
{
    if (!OnInsertResultSimpleEnumI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultSimpleEnumI32"));
        }
        return false;
    }

    OnInsertResultSimpleEnumI32.Broadcast(Context, Args.R);
    return true;
}

void URemoteReducers::InsertResultStringI32(const FTestClientResultStringInt32& R)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertResultStringI32Args ReducerArgs(R);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_result_string_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertResultStringI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertResultStringI32(const FReducerEventContext& Context, const UInsertResultStringI32Reducer* Args)
{
    if (!OnInsertResultStringI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultStringI32"));
        }
        return false;
    }

    OnInsertResultStringI32.Broadcast(Context, Args->R);
    return true;
}

bool URemoteReducers::InvokeInsertResultStringI32WithArgs(const FReducerEventContext& Context, const FInsertResultStringI32Args& Args)
{
    if (!OnInsertResultStringI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultStringI32"));
        }
        return false;
    }

    OnInsertResultStringI32.Broadcast(Context, Args.R);
    return true;
}

void URemoteReducers::InsertResultVecI32String(const FTestClientResultVecInt32String& R)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertResultVecI32StringArgs ReducerArgs(R);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_result_vec_i_32_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertResultVecI32String(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertResultVecI32String(const FReducerEventContext& Context, const UInsertResultVecI32StringReducer* Args)
{
    if (!OnInsertResultVecI32String.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultVecI32String"));
        }
        return false;
    }

    OnInsertResultVecI32String.Broadcast(Context, Args->R);
    return true;
}

bool URemoteReducers::InvokeInsertResultVecI32StringWithArgs(const FReducerEventContext& Context, const FInsertResultVecI32StringArgs& Args)
{
    if (!OnInsertResultVecI32String.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertResultVecI32String"));
        }
        return false;
    }

    OnInsertResultVecI32String.Broadcast(Context, Args.R);
    return true;
}

void URemoteReducers::InsertTableHoldsTable(const FOneU8Type& A, const FVecU8Type& B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertTableHoldsTableArgs ReducerArgs(A, B);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_table_holds_table"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertTableHoldsTable(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertTableHoldsTable(const FReducerEventContext& Context, const UInsertTableHoldsTableReducer* Args)
{
    if (!OnInsertTableHoldsTable.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertTableHoldsTable"));
        }
        return false;
    }

    OnInsertTableHoldsTable.Broadcast(Context, Args->A, Args->B);
    return true;
}

bool URemoteReducers::InvokeInsertTableHoldsTableWithArgs(const FReducerEventContext& Context, const FInsertTableHoldsTableArgs& Args)
{
    if (!OnInsertTableHoldsTable.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertTableHoldsTable"));
        }
        return false;
    }

    OnInsertTableHoldsTable.Broadcast(Context, Args.A, Args.B);
    return true;
}

void URemoteReducers::InsertUniqueBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueBoolArgs ReducerArgs(B, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueBool(const FReducerEventContext& Context, const UInsertUniqueBoolReducer* Args)
{
    if (!OnInsertUniqueBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueBool"));
        }
        return false;
    }

    OnInsertUniqueBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueBoolWithArgs(const FReducerEventContext& Context, const FInsertUniqueBoolArgs& Args)
{
    if (!OnInsertUniqueBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueBool"));
        }
        return false;
    }

    OnInsertUniqueBool.Broadcast(Context, Args.B, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueConnectionIdArgs ReducerArgs(A, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueConnectionId(const FReducerEventContext& Context, const UInsertUniqueConnectionIdReducer* Args)
{
    if (!OnInsertUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueConnectionId"));
        }
        return false;
    }

    OnInsertUniqueConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertUniqueConnectionIdArgs& Args)
{
    if (!OnInsertUniqueConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueConnectionId"));
        }
        return false;
    }

    OnInsertUniqueConnectionId.Broadcast(Context, Args.A, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueI128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueI128(const FReducerEventContext& Context, const UInsertUniqueI128Reducer* Args)
{
    if (!OnInsertUniqueI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI128"));
        }
        return false;
    }

    OnInsertUniqueI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueI128WithArgs(const FReducerEventContext& Context, const FInsertUniqueI128Args& Args)
{
    if (!OnInsertUniqueI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI128"));
        }
        return false;
    }

    OnInsertUniqueI128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueI16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueI16(const FReducerEventContext& Context, const UInsertUniqueI16Reducer* Args)
{
    if (!OnInsertUniqueI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI16"));
        }
        return false;
    }

    OnInsertUniqueI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueI16WithArgs(const FReducerEventContext& Context, const FInsertUniqueI16Args& Args)
{
    if (!OnInsertUniqueI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI16"));
        }
        return false;
    }

    OnInsertUniqueI16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueI256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueI256(const FReducerEventContext& Context, const UInsertUniqueI256Reducer* Args)
{
    if (!OnInsertUniqueI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI256"));
        }
        return false;
    }

    OnInsertUniqueI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueI256WithArgs(const FReducerEventContext& Context, const FInsertUniqueI256Args& Args)
{
    if (!OnInsertUniqueI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI256"));
        }
        return false;
    }

    OnInsertUniqueI256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueI32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueI32(const FReducerEventContext& Context, const UInsertUniqueI32Reducer* Args)
{
    if (!OnInsertUniqueI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI32"));
        }
        return false;
    }

    OnInsertUniqueI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueI32WithArgs(const FReducerEventContext& Context, const FInsertUniqueI32Args& Args)
{
    if (!OnInsertUniqueI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI32"));
        }
        return false;
    }

    OnInsertUniqueI32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueI64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueI64(const FReducerEventContext& Context, const UInsertUniqueI64Reducer* Args)
{
    if (!OnInsertUniqueI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI64"));
        }
        return false;
    }

    OnInsertUniqueI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueI64WithArgs(const FReducerEventContext& Context, const FInsertUniqueI64Args& Args)
{
    if (!OnInsertUniqueI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI64"));
        }
        return false;
    }

    OnInsertUniqueI64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueI8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueI8(const FReducerEventContext& Context, const UInsertUniqueI8Reducer* Args)
{
    if (!OnInsertUniqueI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI8"));
        }
        return false;
    }

    OnInsertUniqueI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueI8WithArgs(const FReducerEventContext& Context, const FInsertUniqueI8Args& Args)
{
    if (!OnInsertUniqueI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueI8"));
        }
        return false;
    }

    OnInsertUniqueI8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueIdentityArgs ReducerArgs(I, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueIdentity(const FReducerEventContext& Context, const UInsertUniqueIdentityReducer* Args)
{
    if (!OnInsertUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueIdentity"));
        }
        return false;
    }

    OnInsertUniqueIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueIdentityWithArgs(const FReducerEventContext& Context, const FInsertUniqueIdentityArgs& Args)
{
    if (!OnInsertUniqueIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueIdentity"));
        }
        return false;
    }

    OnInsertUniqueIdentity.Broadcast(Context, Args.I, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueStringArgs ReducerArgs(S, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueString(const FReducerEventContext& Context, const UInsertUniqueStringReducer* Args)
{
    if (!OnInsertUniqueString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueString"));
        }
        return false;
    }

    OnInsertUniqueString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueStringWithArgs(const FReducerEventContext& Context, const FInsertUniqueStringArgs& Args)
{
    if (!OnInsertUniqueString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueString"));
        }
        return false;
    }

    OnInsertUniqueString.Broadcast(Context, Args.S, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU128(const FReducerEventContext& Context, const UInsertUniqueU128Reducer* Args)
{
    if (!OnInsertUniqueU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU128"));
        }
        return false;
    }

    OnInsertUniqueU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU128WithArgs(const FReducerEventContext& Context, const FInsertUniqueU128Args& Args)
{
    if (!OnInsertUniqueU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU128"));
        }
        return false;
    }

    OnInsertUniqueU128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU16(const FReducerEventContext& Context, const UInsertUniqueU16Reducer* Args)
{
    if (!OnInsertUniqueU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU16"));
        }
        return false;
    }

    OnInsertUniqueU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU16WithArgs(const FReducerEventContext& Context, const FInsertUniqueU16Args& Args)
{
    if (!OnInsertUniqueU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU16"));
        }
        return false;
    }

    OnInsertUniqueU16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU256(const FReducerEventContext& Context, const UInsertUniqueU256Reducer* Args)
{
    if (!OnInsertUniqueU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU256"));
        }
        return false;
    }

    OnInsertUniqueU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU256WithArgs(const FReducerEventContext& Context, const FInsertUniqueU256Args& Args)
{
    if (!OnInsertUniqueU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU256"));
        }
        return false;
    }

    OnInsertUniqueU256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU32(const FReducerEventContext& Context, const UInsertUniqueU32Reducer* Args)
{
    if (!OnInsertUniqueU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU32"));
        }
        return false;
    }

    OnInsertUniqueU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU32WithArgs(const FReducerEventContext& Context, const FInsertUniqueU32Args& Args)
{
    if (!OnInsertUniqueU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU32"));
        }
        return false;
    }

    OnInsertUniqueU32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueU32UpdatePkU32(const uint32 N, const int32 DUnique, const int32 DPk)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU32UpdatePkU32Args ReducerArgs(N, DUnique, DPk);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_32_update_pk_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU32UpdatePkU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU32UpdatePkU32(const FReducerEventContext& Context, const UInsertUniqueU32UpdatePkU32Reducer* Args)
{
    if (!OnInsertUniqueU32UpdatePkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU32UpdatePkU32"));
        }
        return false;
    }

    OnInsertUniqueU32UpdatePkU32.Broadcast(Context, Args->N, Args->DUnique, Args->DPk);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU32UpdatePkU32WithArgs(const FReducerEventContext& Context, const FInsertUniqueU32UpdatePkU32Args& Args)
{
    if (!OnInsertUniqueU32UpdatePkU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU32UpdatePkU32"));
        }
        return false;
    }

    OnInsertUniqueU32UpdatePkU32.Broadcast(Context, Args.N, Args.DUnique, Args.DPk);
    return true;
}

void URemoteReducers::InsertUniqueU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU64(const FReducerEventContext& Context, const UInsertUniqueU64Reducer* Args)
{
    if (!OnInsertUniqueU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU64"));
        }
        return false;
    }

    OnInsertUniqueU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU64WithArgs(const FReducerEventContext& Context, const FInsertUniqueU64Args& Args)
{
    if (!OnInsertUniqueU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU64"));
        }
        return false;
    }

    OnInsertUniqueU64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueU8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueU8(const FReducerEventContext& Context, const UInsertUniqueU8Reducer* Args)
{
    if (!OnInsertUniqueU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU8"));
        }
        return false;
    }

    OnInsertUniqueU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueU8WithArgs(const FReducerEventContext& Context, const FInsertUniqueU8Args& Args)
{
    if (!OnInsertUniqueU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueU8"));
        }
        return false;
    }

    OnInsertUniqueU8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::InsertUniqueUuid(const FSpacetimeDBUuid& U, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUniqueUuidArgs ReducerArgs(U, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_unique_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUniqueUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUniqueUuid(const FReducerEventContext& Context, const UInsertUniqueUuidReducer* Args)
{
    if (!OnInsertUniqueUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueUuid"));
        }
        return false;
    }

    OnInsertUniqueUuid.Broadcast(Context, Args->U, Args->Data);
    return true;
}

bool URemoteReducers::InvokeInsertUniqueUuidWithArgs(const FReducerEventContext& Context, const FInsertUniqueUuidArgs& Args)
{
    if (!OnInsertUniqueUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUniqueUuid"));
        }
        return false;
    }

    OnInsertUniqueUuid.Broadcast(Context, Args.U, Args.Data);
    return true;
}

void URemoteReducers::InsertUser(const FString& Name, const FSpacetimeDBIdentity& Identity)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertUserArgs ReducerArgs(Name, Identity);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_user"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertUser(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertUser(const FReducerEventContext& Context, const UInsertUserReducer* Args)
{
    if (!OnInsertUser.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUser"));
        }
        return false;
    }

    OnInsertUser.Broadcast(Context, Args->Name, Args->Identity);
    return true;
}

bool URemoteReducers::InvokeInsertUserWithArgs(const FReducerEventContext& Context, const FInsertUserArgs& Args)
{
    if (!OnInsertUser.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertUser"));
        }
        return false;
    }

    OnInsertUser.Broadcast(Context, Args.Name, Args.Identity);
    return true;
}

void URemoteReducers::InsertVecBool(const TArray<bool>& B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecBoolArgs ReducerArgs(B);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecBool(const FReducerEventContext& Context, const UInsertVecBoolReducer* Args)
{
    if (!OnInsertVecBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecBool"));
        }
        return false;
    }

    OnInsertVecBool.Broadcast(Context, Args->B);
    return true;
}

bool URemoteReducers::InvokeInsertVecBoolWithArgs(const FReducerEventContext& Context, const FInsertVecBoolArgs& Args)
{
    if (!OnInsertVecBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecBool"));
        }
        return false;
    }

    OnInsertVecBool.Broadcast(Context, Args.B);
    return true;
}

void URemoteReducers::InsertVecByteStruct(const TArray<FByteStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecByteStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_byte_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecByteStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecByteStruct(const FReducerEventContext& Context, const UInsertVecByteStructReducer* Args)
{
    if (!OnInsertVecByteStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecByteStruct"));
        }
        return false;
    }

    OnInsertVecByteStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertVecByteStructWithArgs(const FReducerEventContext& Context, const FInsertVecByteStructArgs& Args)
{
    if (!OnInsertVecByteStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecByteStruct"));
        }
        return false;
    }

    OnInsertVecByteStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertVecConnectionId(const TArray<FSpacetimeDBConnectionId>& A)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecConnectionIdArgs ReducerArgs(A);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecConnectionId(const FReducerEventContext& Context, const UInsertVecConnectionIdReducer* Args)
{
    if (!OnInsertVecConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecConnectionId"));
        }
        return false;
    }

    OnInsertVecConnectionId.Broadcast(Context, Args->A);
    return true;
}

bool URemoteReducers::InvokeInsertVecConnectionIdWithArgs(const FReducerEventContext& Context, const FInsertVecConnectionIdArgs& Args)
{
    if (!OnInsertVecConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecConnectionId"));
        }
        return false;
    }

    OnInsertVecConnectionId.Broadcast(Context, Args.A);
    return true;
}

void URemoteReducers::InsertVecEnumWithPayload(const TArray<FEnumWithPayloadType>& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecEnumWithPayloadArgs ReducerArgs(E);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_enum_with_payload"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecEnumWithPayload(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecEnumWithPayload(const FReducerEventContext& Context, const UInsertVecEnumWithPayloadReducer* Args)
{
    if (!OnInsertVecEnumWithPayload.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEnumWithPayload"));
        }
        return false;
    }

    OnInsertVecEnumWithPayload.Broadcast(Context, Args->E);
    return true;
}

bool URemoteReducers::InvokeInsertVecEnumWithPayloadWithArgs(const FReducerEventContext& Context, const FInsertVecEnumWithPayloadArgs& Args)
{
    if (!OnInsertVecEnumWithPayload.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEnumWithPayload"));
        }
        return false;
    }

    OnInsertVecEnumWithPayload.Broadcast(Context, Args.E);
    return true;
}

void URemoteReducers::InsertVecEveryPrimitiveStruct(const TArray<FEveryPrimitiveStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecEveryPrimitiveStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_every_primitive_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecEveryPrimitiveStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecEveryPrimitiveStruct(const FReducerEventContext& Context, const UInsertVecEveryPrimitiveStructReducer* Args)
{
    if (!OnInsertVecEveryPrimitiveStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertVecEveryPrimitiveStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertVecEveryPrimitiveStructWithArgs(const FReducerEventContext& Context, const FInsertVecEveryPrimitiveStructArgs& Args)
{
    if (!OnInsertVecEveryPrimitiveStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEveryPrimitiveStruct"));
        }
        return false;
    }

    OnInsertVecEveryPrimitiveStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertVecEveryVecStruct(const TArray<FEveryVecStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecEveryVecStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_every_vec_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecEveryVecStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecEveryVecStruct(const FReducerEventContext& Context, const UInsertVecEveryVecStructReducer* Args)
{
    if (!OnInsertVecEveryVecStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEveryVecStruct"));
        }
        return false;
    }

    OnInsertVecEveryVecStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertVecEveryVecStructWithArgs(const FReducerEventContext& Context, const FInsertVecEveryVecStructArgs& Args)
{
    if (!OnInsertVecEveryVecStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecEveryVecStruct"));
        }
        return false;
    }

    OnInsertVecEveryVecStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertVecF32(const TArray<float>& F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecF32Args ReducerArgs(F);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_f_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecF32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecF32(const FReducerEventContext& Context, const UInsertVecF32Reducer* Args)
{
    if (!OnInsertVecF32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecF32"));
        }
        return false;
    }

    OnInsertVecF32.Broadcast(Context, Args->F);
    return true;
}

bool URemoteReducers::InvokeInsertVecF32WithArgs(const FReducerEventContext& Context, const FInsertVecF32Args& Args)
{
    if (!OnInsertVecF32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecF32"));
        }
        return false;
    }

    OnInsertVecF32.Broadcast(Context, Args.F);
    return true;
}

void URemoteReducers::InsertVecF64(const TArray<double>& F)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecF64Args ReducerArgs(F);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_f_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecF64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecF64(const FReducerEventContext& Context, const UInsertVecF64Reducer* Args)
{
    if (!OnInsertVecF64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecF64"));
        }
        return false;
    }

    OnInsertVecF64.Broadcast(Context, Args->F);
    return true;
}

bool URemoteReducers::InvokeInsertVecF64WithArgs(const FReducerEventContext& Context, const FInsertVecF64Args& Args)
{
    if (!OnInsertVecF64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecF64"));
        }
        return false;
    }

    OnInsertVecF64.Broadcast(Context, Args.F);
    return true;
}

void URemoteReducers::InsertVecI128(const TArray<FSpacetimeDBInt128>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecI128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecI128(const FReducerEventContext& Context, const UInsertVecI128Reducer* Args)
{
    if (!OnInsertVecI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI128"));
        }
        return false;
    }

    OnInsertVecI128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecI128WithArgs(const FReducerEventContext& Context, const FInsertVecI128Args& Args)
{
    if (!OnInsertVecI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI128"));
        }
        return false;
    }

    OnInsertVecI128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecI16(const TArray<int16>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecI16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecI16(const FReducerEventContext& Context, const UInsertVecI16Reducer* Args)
{
    if (!OnInsertVecI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI16"));
        }
        return false;
    }

    OnInsertVecI16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecI16WithArgs(const FReducerEventContext& Context, const FInsertVecI16Args& Args)
{
    if (!OnInsertVecI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI16"));
        }
        return false;
    }

    OnInsertVecI16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecI256(const TArray<FSpacetimeDBInt256>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecI256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecI256(const FReducerEventContext& Context, const UInsertVecI256Reducer* Args)
{
    if (!OnInsertVecI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI256"));
        }
        return false;
    }

    OnInsertVecI256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecI256WithArgs(const FReducerEventContext& Context, const FInsertVecI256Args& Args)
{
    if (!OnInsertVecI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI256"));
        }
        return false;
    }

    OnInsertVecI256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecI32(const TArray<int32>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecI32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecI32(const FReducerEventContext& Context, const UInsertVecI32Reducer* Args)
{
    if (!OnInsertVecI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI32"));
        }
        return false;
    }

    OnInsertVecI32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecI32WithArgs(const FReducerEventContext& Context, const FInsertVecI32Args& Args)
{
    if (!OnInsertVecI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI32"));
        }
        return false;
    }

    OnInsertVecI32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecI64(const TArray<int64>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecI64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecI64(const FReducerEventContext& Context, const UInsertVecI64Reducer* Args)
{
    if (!OnInsertVecI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI64"));
        }
        return false;
    }

    OnInsertVecI64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecI64WithArgs(const FReducerEventContext& Context, const FInsertVecI64Args& Args)
{
    if (!OnInsertVecI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI64"));
        }
        return false;
    }

    OnInsertVecI64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecI8(const TArray<int8>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecI8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecI8(const FReducerEventContext& Context, const UInsertVecI8Reducer* Args)
{
    if (!OnInsertVecI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI8"));
        }
        return false;
    }

    OnInsertVecI8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecI8WithArgs(const FReducerEventContext& Context, const FInsertVecI8Args& Args)
{
    if (!OnInsertVecI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecI8"));
        }
        return false;
    }

    OnInsertVecI8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecIdentity(const TArray<FSpacetimeDBIdentity>& I)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecIdentityArgs ReducerArgs(I);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecIdentity(const FReducerEventContext& Context, const UInsertVecIdentityReducer* Args)
{
    if (!OnInsertVecIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecIdentity"));
        }
        return false;
    }

    OnInsertVecIdentity.Broadcast(Context, Args->I);
    return true;
}

bool URemoteReducers::InvokeInsertVecIdentityWithArgs(const FReducerEventContext& Context, const FInsertVecIdentityArgs& Args)
{
    if (!OnInsertVecIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecIdentity"));
        }
        return false;
    }

    OnInsertVecIdentity.Broadcast(Context, Args.I);
    return true;
}

void URemoteReducers::InsertVecSimpleEnum(const TArray<ESimpleEnumType>& E)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecSimpleEnumArgs ReducerArgs(E);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecSimpleEnum(const FReducerEventContext& Context, const UInsertVecSimpleEnumReducer* Args)
{
    if (!OnInsertVecSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecSimpleEnum"));
        }
        return false;
    }

    OnInsertVecSimpleEnum.Broadcast(Context, Args->E);
    return true;
}

bool URemoteReducers::InvokeInsertVecSimpleEnumWithArgs(const FReducerEventContext& Context, const FInsertVecSimpleEnumArgs& Args)
{
    if (!OnInsertVecSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecSimpleEnum"));
        }
        return false;
    }

    OnInsertVecSimpleEnum.Broadcast(Context, Args.E);
    return true;
}

void URemoteReducers::InsertVecString(const TArray<FString>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecStringArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecString(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecString(const FReducerEventContext& Context, const UInsertVecStringReducer* Args)
{
    if (!OnInsertVecString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecString"));
        }
        return false;
    }

    OnInsertVecString.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertVecStringWithArgs(const FReducerEventContext& Context, const FInsertVecStringArgs& Args)
{
    if (!OnInsertVecString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecString"));
        }
        return false;
    }

    OnInsertVecString.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertVecTimestamp(const TArray<FSpacetimeDBTimestamp>& T)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecTimestampArgs ReducerArgs(T);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_timestamp"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecTimestamp(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecTimestamp(const FReducerEventContext& Context, const UInsertVecTimestampReducer* Args)
{
    if (!OnInsertVecTimestamp.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecTimestamp"));
        }
        return false;
    }

    OnInsertVecTimestamp.Broadcast(Context, Args->T);
    return true;
}

bool URemoteReducers::InvokeInsertVecTimestampWithArgs(const FReducerEventContext& Context, const FInsertVecTimestampArgs& Args)
{
    if (!OnInsertVecTimestamp.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecTimestamp"));
        }
        return false;
    }

    OnInsertVecTimestamp.Broadcast(Context, Args.T);
    return true;
}

void URemoteReducers::InsertVecU128(const TArray<FSpacetimeDBUInt128>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecU128Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecU128(const FReducerEventContext& Context, const UInsertVecU128Reducer* Args)
{
    if (!OnInsertVecU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU128"));
        }
        return false;
    }

    OnInsertVecU128.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecU128WithArgs(const FReducerEventContext& Context, const FInsertVecU128Args& Args)
{
    if (!OnInsertVecU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU128"));
        }
        return false;
    }

    OnInsertVecU128.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecU16(const TArray<uint16>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecU16Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecU16(const FReducerEventContext& Context, const UInsertVecU16Reducer* Args)
{
    if (!OnInsertVecU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU16"));
        }
        return false;
    }

    OnInsertVecU16.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecU16WithArgs(const FReducerEventContext& Context, const FInsertVecU16Args& Args)
{
    if (!OnInsertVecU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU16"));
        }
        return false;
    }

    OnInsertVecU16.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecU256(const TArray<FSpacetimeDBUInt256>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecU256Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecU256(const FReducerEventContext& Context, const UInsertVecU256Reducer* Args)
{
    if (!OnInsertVecU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU256"));
        }
        return false;
    }

    OnInsertVecU256.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecU256WithArgs(const FReducerEventContext& Context, const FInsertVecU256Args& Args)
{
    if (!OnInsertVecU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU256"));
        }
        return false;
    }

    OnInsertVecU256.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecU32(const TArray<uint32>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecU32Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecU32(const FReducerEventContext& Context, const UInsertVecU32Reducer* Args)
{
    if (!OnInsertVecU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU32"));
        }
        return false;
    }

    OnInsertVecU32.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecU32WithArgs(const FReducerEventContext& Context, const FInsertVecU32Args& Args)
{
    if (!OnInsertVecU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU32"));
        }
        return false;
    }

    OnInsertVecU32.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecU64(const TArray<uint64>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecU64Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecU64(const FReducerEventContext& Context, const UInsertVecU64Reducer* Args)
{
    if (!OnInsertVecU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU64"));
        }
        return false;
    }

    OnInsertVecU64.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecU64WithArgs(const FReducerEventContext& Context, const FInsertVecU64Args& Args)
{
    if (!OnInsertVecU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU64"));
        }
        return false;
    }

    OnInsertVecU64.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecU8(const TArray<uint8>& N)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecU8Args ReducerArgs(N);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecU8(const FReducerEventContext& Context, const UInsertVecU8Reducer* Args)
{
    if (!OnInsertVecU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU8"));
        }
        return false;
    }

    OnInsertVecU8.Broadcast(Context, Args->N);
    return true;
}

bool URemoteReducers::InvokeInsertVecU8WithArgs(const FReducerEventContext& Context, const FInsertVecU8Args& Args)
{
    if (!OnInsertVecU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecU8"));
        }
        return false;
    }

    OnInsertVecU8.Broadcast(Context, Args.N);
    return true;
}

void URemoteReducers::InsertVecUnitStruct(const TArray<FUnitStructType>& S)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecUnitStructArgs ReducerArgs(S);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_unit_struct"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecUnitStruct(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecUnitStruct(const FReducerEventContext& Context, const UInsertVecUnitStructReducer* Args)
{
    if (!OnInsertVecUnitStruct.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecUnitStruct"));
        }
        return false;
    }

    OnInsertVecUnitStruct.Broadcast(Context, Args->S);
    return true;
}

bool URemoteReducers::InvokeInsertVecUnitStructWithArgs(const FReducerEventContext& Context, const FInsertVecUnitStructArgs& Args)
{
    if (!OnInsertVecUnitStruct.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecUnitStruct"));
        }
        return false;
    }

    OnInsertVecUnitStruct.Broadcast(Context, Args.S);
    return true;
}

void URemoteReducers::InsertVecUuid(const TArray<FSpacetimeDBUuid>& U)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FInsertVecUuidArgs ReducerArgs(U);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("insert_vec_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::InsertVecUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeInsertVecUuid(const FReducerEventContext& Context, const UInsertVecUuidReducer* Args)
{
    if (!OnInsertVecUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecUuid"));
        }
        return false;
    }

    OnInsertVecUuid.Broadcast(Context, Args->U);
    return true;
}

bool URemoteReducers::InvokeInsertVecUuidWithArgs(const FReducerEventContext& Context, const FInsertVecUuidArgs& Args)
{
    if (!OnInsertVecUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for InsertVecUuid"));
        }
        return false;
    }

    OnInsertVecUuid.Broadcast(Context, Args.U);
    return true;
}

void URemoteReducers::NoOpSucceeds()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FNoOpSucceedsArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("no_op_succeeds"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::NoOpSucceeds(ReducerArgs)); }
}

bool URemoteReducers::InvokeNoOpSucceeds(const FReducerEventContext& Context, const UNoOpSucceedsReducer* Args)
{
    if (!OnNoOpSucceeds.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for NoOpSucceeds"));
        }
        return false;
    }

    OnNoOpSucceeds.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeNoOpSucceedsWithArgs(const FReducerEventContext& Context, const FNoOpSucceedsArgs& Args)
{
    if (!OnNoOpSucceeds.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for NoOpSucceeds"));
        }
        return false;
    }

    OnNoOpSucceeds.Broadcast(Context);
    return true;
}

void URemoteReducers::SortedUuidsInsert()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FSortedUuidsInsertArgs ReducerArgs;
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("sorted_uuids_insert"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::SortedUuidsInsert(ReducerArgs)); }
}

bool URemoteReducers::InvokeSortedUuidsInsert(const FReducerEventContext& Context, const USortedUuidsInsertReducer* Args)
{
    if (!OnSortedUuidsInsert.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for SortedUuidsInsert"));
        }
        return false;
    }

    OnSortedUuidsInsert.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeSortedUuidsInsertWithArgs(const FReducerEventContext& Context, const FSortedUuidsInsertArgs& Args)
{
    if (!OnSortedUuidsInsert.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for SortedUuidsInsert"));
        }
        return false;
    }

    OnSortedUuidsInsert.Broadcast(Context);
    return true;
}

void URemoteReducers::UpdateIndexedSimpleEnum(const ESimpleEnumType& A, const ESimpleEnumType& B)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateIndexedSimpleEnumArgs ReducerArgs(A, B);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_indexed_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateIndexedSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateIndexedSimpleEnum(const FReducerEventContext& Context, const UUpdateIndexedSimpleEnumReducer* Args)
{
    if (!OnUpdateIndexedSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateIndexedSimpleEnum"));
        }
        return false;
    }

    OnUpdateIndexedSimpleEnum.Broadcast(Context, Args->A, Args->B);
    return true;
}

bool URemoteReducers::InvokeUpdateIndexedSimpleEnumWithArgs(const FReducerEventContext& Context, const FUpdateIndexedSimpleEnumArgs& Args)
{
    if (!OnUpdateIndexedSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateIndexedSimpleEnum"));
        }
        return false;
    }

    OnUpdateIndexedSimpleEnum.Broadcast(Context, Args.A, Args.B);
    return true;
}

void URemoteReducers::UpdatePkBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkBoolArgs ReducerArgs(B, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkBool(const FReducerEventContext& Context, const UUpdatePkBoolReducer* Args)
{
    if (!OnUpdatePkBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkBool"));
        }
        return false;
    }

    OnUpdatePkBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkBoolWithArgs(const FReducerEventContext& Context, const FUpdatePkBoolArgs& Args)
{
    if (!OnUpdatePkBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkBool"));
        }
        return false;
    }

    OnUpdatePkBool.Broadcast(Context, Args.B, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkConnectionIdArgs ReducerArgs(A, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkConnectionId(const FReducerEventContext& Context, const UUpdatePkConnectionIdReducer* Args)
{
    if (!OnUpdatePkConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkConnectionId"));
        }
        return false;
    }

    OnUpdatePkConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkConnectionIdWithArgs(const FReducerEventContext& Context, const FUpdatePkConnectionIdArgs& Args)
{
    if (!OnUpdatePkConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkConnectionId"));
        }
        return false;
    }

    OnUpdatePkConnectionId.Broadcast(Context, Args.A, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkI128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkI128(const FReducerEventContext& Context, const UUpdatePkI128Reducer* Args)
{
    if (!OnUpdatePkI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI128"));
        }
        return false;
    }

    OnUpdatePkI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkI128WithArgs(const FReducerEventContext& Context, const FUpdatePkI128Args& Args)
{
    if (!OnUpdatePkI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI128"));
        }
        return false;
    }

    OnUpdatePkI128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkI16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkI16(const FReducerEventContext& Context, const UUpdatePkI16Reducer* Args)
{
    if (!OnUpdatePkI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI16"));
        }
        return false;
    }

    OnUpdatePkI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkI16WithArgs(const FReducerEventContext& Context, const FUpdatePkI16Args& Args)
{
    if (!OnUpdatePkI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI16"));
        }
        return false;
    }

    OnUpdatePkI16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkI256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkI256(const FReducerEventContext& Context, const UUpdatePkI256Reducer* Args)
{
    if (!OnUpdatePkI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI256"));
        }
        return false;
    }

    OnUpdatePkI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkI256WithArgs(const FReducerEventContext& Context, const FUpdatePkI256Args& Args)
{
    if (!OnUpdatePkI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI256"));
        }
        return false;
    }

    OnUpdatePkI256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkI32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkI32(const FReducerEventContext& Context, const UUpdatePkI32Reducer* Args)
{
    if (!OnUpdatePkI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI32"));
        }
        return false;
    }

    OnUpdatePkI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkI32WithArgs(const FReducerEventContext& Context, const FUpdatePkI32Args& Args)
{
    if (!OnUpdatePkI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI32"));
        }
        return false;
    }

    OnUpdatePkI32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkI64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkI64(const FReducerEventContext& Context, const UUpdatePkI64Reducer* Args)
{
    if (!OnUpdatePkI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI64"));
        }
        return false;
    }

    OnUpdatePkI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkI64WithArgs(const FReducerEventContext& Context, const FUpdatePkI64Args& Args)
{
    if (!OnUpdatePkI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI64"));
        }
        return false;
    }

    OnUpdatePkI64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkI8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkI8(const FReducerEventContext& Context, const UUpdatePkI8Reducer* Args)
{
    if (!OnUpdatePkI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI8"));
        }
        return false;
    }

    OnUpdatePkI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkI8WithArgs(const FReducerEventContext& Context, const FUpdatePkI8Args& Args)
{
    if (!OnUpdatePkI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkI8"));
        }
        return false;
    }

    OnUpdatePkI8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkIdentityArgs ReducerArgs(I, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkIdentity(const FReducerEventContext& Context, const UUpdatePkIdentityReducer* Args)
{
    if (!OnUpdatePkIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkIdentity"));
        }
        return false;
    }

    OnUpdatePkIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkIdentityWithArgs(const FReducerEventContext& Context, const FUpdatePkIdentityArgs& Args)
{
    if (!OnUpdatePkIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkIdentity"));
        }
        return false;
    }

    OnUpdatePkIdentity.Broadcast(Context, Args.I, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkSimpleEnum(const ESimpleEnumType& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkSimpleEnumArgs ReducerArgs(A, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_simple_enum"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkSimpleEnum(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkSimpleEnum(const FReducerEventContext& Context, const UUpdatePkSimpleEnumReducer* Args)
{
    if (!OnUpdatePkSimpleEnum.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkSimpleEnum"));
        }
        return false;
    }

    OnUpdatePkSimpleEnum.Broadcast(Context, Args->A, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkSimpleEnumWithArgs(const FReducerEventContext& Context, const FUpdatePkSimpleEnumArgs& Args)
{
    if (!OnUpdatePkSimpleEnum.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkSimpleEnum"));
        }
        return false;
    }

    OnUpdatePkSimpleEnum.Broadcast(Context, Args.A, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkStringArgs ReducerArgs(S, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkString(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkString(const FReducerEventContext& Context, const UUpdatePkStringReducer* Args)
{
    if (!OnUpdatePkString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkString"));
        }
        return false;
    }

    OnUpdatePkString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkStringWithArgs(const FReducerEventContext& Context, const FUpdatePkStringArgs& Args)
{
    if (!OnUpdatePkString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkString"));
        }
        return false;
    }

    OnUpdatePkString.Broadcast(Context, Args.S, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU128(const FReducerEventContext& Context, const UUpdatePkU128Reducer* Args)
{
    if (!OnUpdatePkU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU128"));
        }
        return false;
    }

    OnUpdatePkU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU128WithArgs(const FReducerEventContext& Context, const FUpdatePkU128Args& Args)
{
    if (!OnUpdatePkU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU128"));
        }
        return false;
    }

    OnUpdatePkU128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU16(const FReducerEventContext& Context, const UUpdatePkU16Reducer* Args)
{
    if (!OnUpdatePkU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU16"));
        }
        return false;
    }

    OnUpdatePkU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU16WithArgs(const FReducerEventContext& Context, const FUpdatePkU16Args& Args)
{
    if (!OnUpdatePkU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU16"));
        }
        return false;
    }

    OnUpdatePkU16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU256(const FReducerEventContext& Context, const UUpdatePkU256Reducer* Args)
{
    if (!OnUpdatePkU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU256"));
        }
        return false;
    }

    OnUpdatePkU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU256WithArgs(const FReducerEventContext& Context, const FUpdatePkU256Args& Args)
{
    if (!OnUpdatePkU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU256"));
        }
        return false;
    }

    OnUpdatePkU256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU32(const FReducerEventContext& Context, const UUpdatePkU32Reducer* Args)
{
    if (!OnUpdatePkU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU32"));
        }
        return false;
    }

    OnUpdatePkU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU32WithArgs(const FReducerEventContext& Context, const FUpdatePkU32Args& Args)
{
    if (!OnUpdatePkU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU32"));
        }
        return false;
    }

    OnUpdatePkU32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU32Two(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU32TwoArgs ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_32_two"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU32Two(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU32Two(const FReducerEventContext& Context, const UUpdatePkU32TwoReducer* Args)
{
    if (!OnUpdatePkU32Two.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU32Two"));
        }
        return false;
    }

    OnUpdatePkU32Two.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU32TwoWithArgs(const FReducerEventContext& Context, const FUpdatePkU32TwoArgs& Args)
{
    if (!OnUpdatePkU32Two.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU32Two"));
        }
        return false;
    }

    OnUpdatePkU32Two.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU64(const FReducerEventContext& Context, const UUpdatePkU64Reducer* Args)
{
    if (!OnUpdatePkU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU64"));
        }
        return false;
    }

    OnUpdatePkU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU64WithArgs(const FReducerEventContext& Context, const FUpdatePkU64Args& Args)
{
    if (!OnUpdatePkU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU64"));
        }
        return false;
    }

    OnUpdatePkU64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkU8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkU8(const FReducerEventContext& Context, const UUpdatePkU8Reducer* Args)
{
    if (!OnUpdatePkU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU8"));
        }
        return false;
    }

    OnUpdatePkU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkU8WithArgs(const FReducerEventContext& Context, const FUpdatePkU8Args& Args)
{
    if (!OnUpdatePkU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkU8"));
        }
        return false;
    }

    OnUpdatePkU8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdatePkUuid(const FSpacetimeDBUuid& U, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdatePkUuidArgs ReducerArgs(U, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_pk_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdatePkUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdatePkUuid(const FReducerEventContext& Context, const UUpdatePkUuidReducer* Args)
{
    if (!OnUpdatePkUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkUuid"));
        }
        return false;
    }

    OnUpdatePkUuid.Broadcast(Context, Args->U, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdatePkUuidWithArgs(const FReducerEventContext& Context, const FUpdatePkUuidArgs& Args)
{
    if (!OnUpdatePkUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdatePkUuid"));
        }
        return false;
    }

    OnUpdatePkUuid.Broadcast(Context, Args.U, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueBool(const bool B, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueBoolArgs ReducerArgs(B, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_bool"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueBool(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueBool(const FReducerEventContext& Context, const UUpdateUniqueBoolReducer* Args)
{
    if (!OnUpdateUniqueBool.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueBool"));
        }
        return false;
    }

    OnUpdateUniqueBool.Broadcast(Context, Args->B, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueBoolWithArgs(const FReducerEventContext& Context, const FUpdateUniqueBoolArgs& Args)
{
    if (!OnUpdateUniqueBool.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueBool"));
        }
        return false;
    }

    OnUpdateUniqueBool.Broadcast(Context, Args.B, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueConnectionId(const FSpacetimeDBConnectionId& A, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueConnectionIdArgs ReducerArgs(A, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_connection_id"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueConnectionId(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueConnectionId(const FReducerEventContext& Context, const UUpdateUniqueConnectionIdReducer* Args)
{
    if (!OnUpdateUniqueConnectionId.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueConnectionId"));
        }
        return false;
    }

    OnUpdateUniqueConnectionId.Broadcast(Context, Args->A, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueConnectionIdWithArgs(const FReducerEventContext& Context, const FUpdateUniqueConnectionIdArgs& Args)
{
    if (!OnUpdateUniqueConnectionId.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueConnectionId"));
        }
        return false;
    }

    OnUpdateUniqueConnectionId.Broadcast(Context, Args.A, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueI128(const FSpacetimeDBInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueI128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_i_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueI128(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueI128(const FReducerEventContext& Context, const UUpdateUniqueI128Reducer* Args)
{
    if (!OnUpdateUniqueI128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI128"));
        }
        return false;
    }

    OnUpdateUniqueI128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueI128WithArgs(const FReducerEventContext& Context, const FUpdateUniqueI128Args& Args)
{
    if (!OnUpdateUniqueI128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI128"));
        }
        return false;
    }

    OnUpdateUniqueI128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueI16(const int16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueI16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_i_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueI16(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueI16(const FReducerEventContext& Context, const UUpdateUniqueI16Reducer* Args)
{
    if (!OnUpdateUniqueI16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI16"));
        }
        return false;
    }

    OnUpdateUniqueI16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueI16WithArgs(const FReducerEventContext& Context, const FUpdateUniqueI16Args& Args)
{
    if (!OnUpdateUniqueI16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI16"));
        }
        return false;
    }

    OnUpdateUniqueI16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueI256(const FSpacetimeDBInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueI256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_i_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueI256(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueI256(const FReducerEventContext& Context, const UUpdateUniqueI256Reducer* Args)
{
    if (!OnUpdateUniqueI256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI256"));
        }
        return false;
    }

    OnUpdateUniqueI256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueI256WithArgs(const FReducerEventContext& Context, const FUpdateUniqueI256Args& Args)
{
    if (!OnUpdateUniqueI256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI256"));
        }
        return false;
    }

    OnUpdateUniqueI256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueI32(const int32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueI32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_i_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueI32(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueI32(const FReducerEventContext& Context, const UUpdateUniqueI32Reducer* Args)
{
    if (!OnUpdateUniqueI32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI32"));
        }
        return false;
    }

    OnUpdateUniqueI32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueI32WithArgs(const FReducerEventContext& Context, const FUpdateUniqueI32Args& Args)
{
    if (!OnUpdateUniqueI32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI32"));
        }
        return false;
    }

    OnUpdateUniqueI32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueI64(const int64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueI64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_i_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueI64(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueI64(const FReducerEventContext& Context, const UUpdateUniqueI64Reducer* Args)
{
    if (!OnUpdateUniqueI64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI64"));
        }
        return false;
    }

    OnUpdateUniqueI64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueI64WithArgs(const FReducerEventContext& Context, const FUpdateUniqueI64Args& Args)
{
    if (!OnUpdateUniqueI64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI64"));
        }
        return false;
    }

    OnUpdateUniqueI64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueI8(const int8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueI8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_i_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueI8(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueI8(const FReducerEventContext& Context, const UUpdateUniqueI8Reducer* Args)
{
    if (!OnUpdateUniqueI8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI8"));
        }
        return false;
    }

    OnUpdateUniqueI8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueI8WithArgs(const FReducerEventContext& Context, const FUpdateUniqueI8Args& Args)
{
    if (!OnUpdateUniqueI8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueI8"));
        }
        return false;
    }

    OnUpdateUniqueI8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueIdentity(const FSpacetimeDBIdentity& I, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueIdentityArgs ReducerArgs(I, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_identity"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueIdentity(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueIdentity(const FReducerEventContext& Context, const UUpdateUniqueIdentityReducer* Args)
{
    if (!OnUpdateUniqueIdentity.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueIdentity"));
        }
        return false;
    }

    OnUpdateUniqueIdentity.Broadcast(Context, Args->I, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueIdentityWithArgs(const FReducerEventContext& Context, const FUpdateUniqueIdentityArgs& Args)
{
    if (!OnUpdateUniqueIdentity.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueIdentity"));
        }
        return false;
    }

    OnUpdateUniqueIdentity.Broadcast(Context, Args.I, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueString(const FString& S, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueStringArgs ReducerArgs(S, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_string"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueString(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueString(const FReducerEventContext& Context, const UUpdateUniqueStringReducer* Args)
{
    if (!OnUpdateUniqueString.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueString"));
        }
        return false;
    }

    OnUpdateUniqueString.Broadcast(Context, Args->S, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueStringWithArgs(const FReducerEventContext& Context, const FUpdateUniqueStringArgs& Args)
{
    if (!OnUpdateUniqueString.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueString"));
        }
        return false;
    }

    OnUpdateUniqueString.Broadcast(Context, Args.S, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueU128(const FSpacetimeDBUInt128& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueU128Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_u_128"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueU128(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueU128(const FReducerEventContext& Context, const UUpdateUniqueU128Reducer* Args)
{
    if (!OnUpdateUniqueU128.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU128"));
        }
        return false;
    }

    OnUpdateUniqueU128.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueU128WithArgs(const FReducerEventContext& Context, const FUpdateUniqueU128Args& Args)
{
    if (!OnUpdateUniqueU128.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU128"));
        }
        return false;
    }

    OnUpdateUniqueU128.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueU16(const uint16 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueU16Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_u_16"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueU16(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueU16(const FReducerEventContext& Context, const UUpdateUniqueU16Reducer* Args)
{
    if (!OnUpdateUniqueU16.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU16"));
        }
        return false;
    }

    OnUpdateUniqueU16.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueU16WithArgs(const FReducerEventContext& Context, const FUpdateUniqueU16Args& Args)
{
    if (!OnUpdateUniqueU16.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU16"));
        }
        return false;
    }

    OnUpdateUniqueU16.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueU256(const FSpacetimeDBUInt256& N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueU256Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_u_256"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueU256(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueU256(const FReducerEventContext& Context, const UUpdateUniqueU256Reducer* Args)
{
    if (!OnUpdateUniqueU256.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU256"));
        }
        return false;
    }

    OnUpdateUniqueU256.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueU256WithArgs(const FReducerEventContext& Context, const FUpdateUniqueU256Args& Args)
{
    if (!OnUpdateUniqueU256.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU256"));
        }
        return false;
    }

    OnUpdateUniqueU256.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueU32(const uint32 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueU32Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_u_32"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueU32(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueU32(const FReducerEventContext& Context, const UUpdateUniqueU32Reducer* Args)
{
    if (!OnUpdateUniqueU32.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU32"));
        }
        return false;
    }

    OnUpdateUniqueU32.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueU32WithArgs(const FReducerEventContext& Context, const FUpdateUniqueU32Args& Args)
{
    if (!OnUpdateUniqueU32.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU32"));
        }
        return false;
    }

    OnUpdateUniqueU32.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueU64(const uint64 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueU64Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_u_64"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueU64(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueU64(const FReducerEventContext& Context, const UUpdateUniqueU64Reducer* Args)
{
    if (!OnUpdateUniqueU64.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU64"));
        }
        return false;
    }

    OnUpdateUniqueU64.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueU64WithArgs(const FReducerEventContext& Context, const FUpdateUniqueU64Args& Args)
{
    if (!OnUpdateUniqueU64.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU64"));
        }
        return false;
    }

    OnUpdateUniqueU64.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueU8(const uint8 N, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueU8Args ReducerArgs(N, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_u_8"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueU8(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueU8(const FReducerEventContext& Context, const UUpdateUniqueU8Reducer* Args)
{
    if (!OnUpdateUniqueU8.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU8"));
        }
        return false;
    }

    OnUpdateUniqueU8.Broadcast(Context, Args->N, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueU8WithArgs(const FReducerEventContext& Context, const FUpdateUniqueU8Args& Args)
{
    if (!OnUpdateUniqueU8.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueU8"));
        }
        return false;
    }

    OnUpdateUniqueU8.Broadcast(Context, Args.N, Args.Data);
    return true;
}

void URemoteReducers::UpdateUniqueUuid(const FSpacetimeDBUuid& U, const int32 Data)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	FUpdateUniqueUuidArgs ReducerArgs(U, Data);
	const uint32 RequestId = Conn->CallReducerTyped(TEXT("update_unique_uuid"), ReducerArgs);
	if (RequestId != 0) { Conn->RegisterPendingTypedReducer(RequestId, FReducer::UpdateUniqueUuid(ReducerArgs)); }
}

bool URemoteReducers::InvokeUpdateUniqueUuid(const FReducerEventContext& Context, const UUpdateUniqueUuidReducer* Args)
{
    if (!OnUpdateUniqueUuid.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueUuid"));
        }
        return false;
    }

    OnUpdateUniqueUuid.Broadcast(Context, Args->U, Args->Data);
    return true;
}

bool URemoteReducers::InvokeUpdateUniqueUuidWithArgs(const FReducerEventContext& Context, const FUpdateUniqueUuidArgs& Args)
{
    if (!OnUpdateUniqueUuid.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for UpdateUniqueUuid"));
        }
        return false;
    }

    OnUpdateUniqueUuid.Broadcast(Context, Args.U, Args.Data);
    return true;
}

void UDbConnection::PostInitProperties()
{
    Super::PostInitProperties();
    
    // Connect OnUnhandledReducerError to Reducers.InternalOnUnhandledReducerError
    if (Reducers)
    {
        Reducers->InternalOnUnhandledReducerError.AddDynamic(this, &UDbConnection::OnUnhandledReducerErrorHandler);
    }

    // Connect OnUnhandledProcedureError to Procedures.InternalOnUnhandledProcedureError
    if (Procedures)
    {
        Procedures->InternalOnUnhandledProcedureError.AddDynamic(this, &UDbConnection::OnUnhandledProcedureErrorHandler);
    }
}

UFUNCTION()
void UDbConnection::OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error)
{
    if (OnUnhandledReducerError.IsBound())
    {
        OnUnhandledReducerError.Broadcast(Context, Error);
    }
}

UFUNCTION()
void UDbConnection::OnUnhandledProcedureErrorHandler(const FProcedureEventContext& Context, const FString& Error)
{
    if (OnUnhandledProcedureError.IsBound())
    {
        OnUnhandledProcedureError.Broadcast(Context, Error);
    }
}

void UDbConnection::RegisterPendingTypedReducer(uint32 RequestId, FReducer Reducer)
{
    Reducer.RequestId = RequestId;
    PendingTypedReducers.Add(RequestId, MoveTemp(Reducer));
}

bool UDbConnection::TryGetPendingTypedReducer(uint32 RequestId, FReducer& OutReducer) const
{
    if (const FReducer* Found = PendingTypedReducers.Find(RequestId))
    {
        OutReducer = *Found;
        return true;
    }
    return false;
}

bool UDbConnection::TryTakePendingTypedReducer(uint32 RequestId, FReducer& OutReducer)
{
    if (FReducer* Found = PendingTypedReducers.Find(RequestId))
    {
        OutReducer = *Found;
        PendingTypedReducers.Remove(RequestId);
        return true;
    }
    return false;
}

void UDbConnection::ReducerEvent(const FReducerEvent& Event)
{
    if (!Reducers) { return; }

    FReducer DecodedReducer;
    if (!TryTakePendingTypedReducer(Event.RequestId, DecodedReducer))
    {
        const FString ErrorMessage = FString::Printf(TEXT("Reducer result for unknown request_id %u"), Event.RequestId);
        UE_LOG(LogTemp, Error, TEXT("%s"), *ErrorMessage);
        ReducerEventFailed(Event, ErrorMessage);
        return;
    }

    FTestClientReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;
    ReducerEvent.Reducer            = DecodedReducer;

    FReducerEventContext Context(this, ReducerEvent);

    // Dispatch by typed reducer metadata
    const FString& ReducerName = ReducerEvent.Reducer.ReducerName;

    if (ReducerName == TEXT("delete_from_btree_u_32"))
    {
        FDeleteFromBtreeU32Args Args = ReducerEvent.Reducer.GetAsDeleteFromBtreeU32();
        Reducers->InvokeDeleteFromBtreeU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_large_table"))
    {
        FDeleteLargeTableArgs Args = ReducerEvent.Reducer.GetAsDeleteLargeTable();
        Reducers->InvokeDeleteLargeTableWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_bool"))
    {
        FDeletePkBoolArgs Args = ReducerEvent.Reducer.GetAsDeletePkBool();
        Reducers->InvokeDeletePkBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_connection_id"))
    {
        FDeletePkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsDeletePkConnectionId();
        Reducers->InvokeDeletePkConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i_128"))
    {
        FDeletePkI128Args Args = ReducerEvent.Reducer.GetAsDeletePkI128();
        Reducers->InvokeDeletePkI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i_16"))
    {
        FDeletePkI16Args Args = ReducerEvent.Reducer.GetAsDeletePkI16();
        Reducers->InvokeDeletePkI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i_256"))
    {
        FDeletePkI256Args Args = ReducerEvent.Reducer.GetAsDeletePkI256();
        Reducers->InvokeDeletePkI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i_32"))
    {
        FDeletePkI32Args Args = ReducerEvent.Reducer.GetAsDeletePkI32();
        Reducers->InvokeDeletePkI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i_64"))
    {
        FDeletePkI64Args Args = ReducerEvent.Reducer.GetAsDeletePkI64();
        Reducers->InvokeDeletePkI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_i_8"))
    {
        FDeletePkI8Args Args = ReducerEvent.Reducer.GetAsDeletePkI8();
        Reducers->InvokeDeletePkI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_identity"))
    {
        FDeletePkIdentityArgs Args = ReducerEvent.Reducer.GetAsDeletePkIdentity();
        Reducers->InvokeDeletePkIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_string"))
    {
        FDeletePkStringArgs Args = ReducerEvent.Reducer.GetAsDeletePkString();
        Reducers->InvokeDeletePkStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_128"))
    {
        FDeletePkU128Args Args = ReducerEvent.Reducer.GetAsDeletePkU128();
        Reducers->InvokeDeletePkU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_16"))
    {
        FDeletePkU16Args Args = ReducerEvent.Reducer.GetAsDeletePkU16();
        Reducers->InvokeDeletePkU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_256"))
    {
        FDeletePkU256Args Args = ReducerEvent.Reducer.GetAsDeletePkU256();
        Reducers->InvokeDeletePkU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_32"))
    {
        FDeletePkU32Args Args = ReducerEvent.Reducer.GetAsDeletePkU32();
        Reducers->InvokeDeletePkU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_32_insert_pk_u_32_two"))
    {
        FDeletePkU32InsertPkU32TwoArgs Args = ReducerEvent.Reducer.GetAsDeletePkU32InsertPkU32Two();
        Reducers->InvokeDeletePkU32InsertPkU32TwoWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_32_two"))
    {
        FDeletePkU32TwoArgs Args = ReducerEvent.Reducer.GetAsDeletePkU32Two();
        Reducers->InvokeDeletePkU32TwoWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_64"))
    {
        FDeletePkU64Args Args = ReducerEvent.Reducer.GetAsDeletePkU64();
        Reducers->InvokeDeletePkU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_u_8"))
    {
        FDeletePkU8Args Args = ReducerEvent.Reducer.GetAsDeletePkU8();
        Reducers->InvokeDeletePkU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_pk_uuid"))
    {
        FDeletePkUuidArgs Args = ReducerEvent.Reducer.GetAsDeletePkUuid();
        Reducers->InvokeDeletePkUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_bool"))
    {
        FDeleteUniqueBoolArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueBool();
        Reducers->InvokeDeleteUniqueBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_connection_id"))
    {
        FDeleteUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueConnectionId();
        Reducers->InvokeDeleteUniqueConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i_128"))
    {
        FDeleteUniqueI128Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI128();
        Reducers->InvokeDeleteUniqueI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i_16"))
    {
        FDeleteUniqueI16Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI16();
        Reducers->InvokeDeleteUniqueI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i_256"))
    {
        FDeleteUniqueI256Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI256();
        Reducers->InvokeDeleteUniqueI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i_32"))
    {
        FDeleteUniqueI32Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI32();
        Reducers->InvokeDeleteUniqueI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i_64"))
    {
        FDeleteUniqueI64Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI64();
        Reducers->InvokeDeleteUniqueI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_i_8"))
    {
        FDeleteUniqueI8Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueI8();
        Reducers->InvokeDeleteUniqueI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_identity"))
    {
        FDeleteUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueIdentity();
        Reducers->InvokeDeleteUniqueIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_string"))
    {
        FDeleteUniqueStringArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueString();
        Reducers->InvokeDeleteUniqueStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u_128"))
    {
        FDeleteUniqueU128Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU128();
        Reducers->InvokeDeleteUniqueU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u_16"))
    {
        FDeleteUniqueU16Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU16();
        Reducers->InvokeDeleteUniqueU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u_256"))
    {
        FDeleteUniqueU256Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU256();
        Reducers->InvokeDeleteUniqueU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u_32"))
    {
        FDeleteUniqueU32Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU32();
        Reducers->InvokeDeleteUniqueU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u_64"))
    {
        FDeleteUniqueU64Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU64();
        Reducers->InvokeDeleteUniqueU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_u_8"))
    {
        FDeleteUniqueU8Args Args = ReducerEvent.Reducer.GetAsDeleteUniqueU8();
        Reducers->InvokeDeleteUniqueU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("delete_unique_uuid"))
    {
        FDeleteUniqueUuidArgs Args = ReducerEvent.Reducer.GetAsDeleteUniqueUuid();
        Reducers->InvokeDeleteUniqueUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_call_timestamp"))
    {
        FInsertCallTimestampArgs Args = ReducerEvent.Reducer.GetAsInsertCallTimestamp();
        Reducers->InvokeInsertCallTimestampWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_call_uuid_v_4"))
    {
        FInsertCallUuidV4Args Args = ReducerEvent.Reducer.GetAsInsertCallUuidV4();
        Reducers->InvokeInsertCallUuidV4WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_call_uuid_v_7"))
    {
        FInsertCallUuidV7Args Args = ReducerEvent.Reducer.GetAsInsertCallUuidV7();
        Reducers->InvokeInsertCallUuidV7WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_one_connection_id"))
    {
        FInsertCallerOneConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerOneConnectionId();
        Reducers->InvokeInsertCallerOneConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_one_identity"))
    {
        FInsertCallerOneIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerOneIdentity();
        Reducers->InvokeInsertCallerOneIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_pk_connection_id"))
    {
        FInsertCallerPkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerPkConnectionId();
        Reducers->InvokeInsertCallerPkConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_pk_identity"))
    {
        FInsertCallerPkIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerPkIdentity();
        Reducers->InvokeInsertCallerPkIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_unique_connection_id"))
    {
        FInsertCallerUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerUniqueConnectionId();
        Reducers->InvokeInsertCallerUniqueConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_unique_identity"))
    {
        FInsertCallerUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerUniqueIdentity();
        Reducers->InvokeInsertCallerUniqueIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_vec_connection_id"))
    {
        FInsertCallerVecConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertCallerVecConnectionId();
        Reducers->InvokeInsertCallerVecConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_caller_vec_identity"))
    {
        FInsertCallerVecIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertCallerVecIdentity();
        Reducers->InvokeInsertCallerVecIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_into_btree_u_32"))
    {
        FInsertIntoBtreeU32Args Args = ReducerEvent.Reducer.GetAsInsertIntoBtreeU32();
        Reducers->InvokeInsertIntoBtreeU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_into_indexed_simple_enum"))
    {
        FInsertIntoIndexedSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertIntoIndexedSimpleEnum();
        Reducers->InvokeInsertIntoIndexedSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_into_pk_btree_u_32"))
    {
        FInsertIntoPkBtreeU32Args Args = ReducerEvent.Reducer.GetAsInsertIntoPkBtreeU32();
        Reducers->InvokeInsertIntoPkBtreeU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_large_table"))
    {
        FInsertLargeTableArgs Args = ReducerEvent.Reducer.GetAsInsertLargeTable();
        Reducers->InvokeInsertLargeTableWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_bool"))
    {
        FInsertOneBoolArgs Args = ReducerEvent.Reducer.GetAsInsertOneBool();
        Reducers->InvokeInsertOneBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_byte_struct"))
    {
        FInsertOneByteStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneByteStruct();
        Reducers->InvokeInsertOneByteStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_connection_id"))
    {
        FInsertOneConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertOneConnectionId();
        Reducers->InvokeInsertOneConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_enum_with_payload"))
    {
        FInsertOneEnumWithPayloadArgs Args = ReducerEvent.Reducer.GetAsInsertOneEnumWithPayload();
        Reducers->InvokeInsertOneEnumWithPayloadWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_every_primitive_struct"))
    {
        FInsertOneEveryPrimitiveStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneEveryPrimitiveStruct();
        Reducers->InvokeInsertOneEveryPrimitiveStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_every_vec_struct"))
    {
        FInsertOneEveryVecStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneEveryVecStruct();
        Reducers->InvokeInsertOneEveryVecStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_f_32"))
    {
        FInsertOneF32Args Args = ReducerEvent.Reducer.GetAsInsertOneF32();
        Reducers->InvokeInsertOneF32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_f_64"))
    {
        FInsertOneF64Args Args = ReducerEvent.Reducer.GetAsInsertOneF64();
        Reducers->InvokeInsertOneF64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_i_128"))
    {
        FInsertOneI128Args Args = ReducerEvent.Reducer.GetAsInsertOneI128();
        Reducers->InvokeInsertOneI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_i_16"))
    {
        FInsertOneI16Args Args = ReducerEvent.Reducer.GetAsInsertOneI16();
        Reducers->InvokeInsertOneI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_i_256"))
    {
        FInsertOneI256Args Args = ReducerEvent.Reducer.GetAsInsertOneI256();
        Reducers->InvokeInsertOneI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_i_32"))
    {
        FInsertOneI32Args Args = ReducerEvent.Reducer.GetAsInsertOneI32();
        Reducers->InvokeInsertOneI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_i_64"))
    {
        FInsertOneI64Args Args = ReducerEvent.Reducer.GetAsInsertOneI64();
        Reducers->InvokeInsertOneI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_i_8"))
    {
        FInsertOneI8Args Args = ReducerEvent.Reducer.GetAsInsertOneI8();
        Reducers->InvokeInsertOneI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_identity"))
    {
        FInsertOneIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertOneIdentity();
        Reducers->InvokeInsertOneIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_simple_enum"))
    {
        FInsertOneSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertOneSimpleEnum();
        Reducers->InvokeInsertOneSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_string"))
    {
        FInsertOneStringArgs Args = ReducerEvent.Reducer.GetAsInsertOneString();
        Reducers->InvokeInsertOneStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_timestamp"))
    {
        FInsertOneTimestampArgs Args = ReducerEvent.Reducer.GetAsInsertOneTimestamp();
        Reducers->InvokeInsertOneTimestampWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_u_128"))
    {
        FInsertOneU128Args Args = ReducerEvent.Reducer.GetAsInsertOneU128();
        Reducers->InvokeInsertOneU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_u_16"))
    {
        FInsertOneU16Args Args = ReducerEvent.Reducer.GetAsInsertOneU16();
        Reducers->InvokeInsertOneU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_u_256"))
    {
        FInsertOneU256Args Args = ReducerEvent.Reducer.GetAsInsertOneU256();
        Reducers->InvokeInsertOneU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_u_32"))
    {
        FInsertOneU32Args Args = ReducerEvent.Reducer.GetAsInsertOneU32();
        Reducers->InvokeInsertOneU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_u_64"))
    {
        FInsertOneU64Args Args = ReducerEvent.Reducer.GetAsInsertOneU64();
        Reducers->InvokeInsertOneU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_u_8"))
    {
        FInsertOneU8Args Args = ReducerEvent.Reducer.GetAsInsertOneU8();
        Reducers->InvokeInsertOneU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_unit_struct"))
    {
        FInsertOneUnitStructArgs Args = ReducerEvent.Reducer.GetAsInsertOneUnitStruct();
        Reducers->InvokeInsertOneUnitStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_one_uuid"))
    {
        FInsertOneUuidArgs Args = ReducerEvent.Reducer.GetAsInsertOneUuid();
        Reducers->InvokeInsertOneUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_every_primitive_struct"))
    {
        FInsertOptionEveryPrimitiveStructArgs Args = ReducerEvent.Reducer.GetAsInsertOptionEveryPrimitiveStruct();
        Reducers->InvokeInsertOptionEveryPrimitiveStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_i_32"))
    {
        FInsertOptionI32Args Args = ReducerEvent.Reducer.GetAsInsertOptionI32();
        Reducers->InvokeInsertOptionI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_identity"))
    {
        FInsertOptionIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertOptionIdentity();
        Reducers->InvokeInsertOptionIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_simple_enum"))
    {
        FInsertOptionSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertOptionSimpleEnum();
        Reducers->InvokeInsertOptionSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_string"))
    {
        FInsertOptionStringArgs Args = ReducerEvent.Reducer.GetAsInsertOptionString();
        Reducers->InvokeInsertOptionStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_uuid"))
    {
        FInsertOptionUuidArgs Args = ReducerEvent.Reducer.GetAsInsertOptionUuid();
        Reducers->InvokeInsertOptionUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_option_vec_option_i_32"))
    {
        FInsertOptionVecOptionI32Args Args = ReducerEvent.Reducer.GetAsInsertOptionVecOptionI32();
        Reducers->InvokeInsertOptionVecOptionI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_bool"))
    {
        FInsertPkBoolArgs Args = ReducerEvent.Reducer.GetAsInsertPkBool();
        Reducers->InvokeInsertPkBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_connection_id"))
    {
        FInsertPkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertPkConnectionId();
        Reducers->InvokeInsertPkConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i_128"))
    {
        FInsertPkI128Args Args = ReducerEvent.Reducer.GetAsInsertPkI128();
        Reducers->InvokeInsertPkI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i_16"))
    {
        FInsertPkI16Args Args = ReducerEvent.Reducer.GetAsInsertPkI16();
        Reducers->InvokeInsertPkI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i_256"))
    {
        FInsertPkI256Args Args = ReducerEvent.Reducer.GetAsInsertPkI256();
        Reducers->InvokeInsertPkI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i_32"))
    {
        FInsertPkI32Args Args = ReducerEvent.Reducer.GetAsInsertPkI32();
        Reducers->InvokeInsertPkI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i_64"))
    {
        FInsertPkI64Args Args = ReducerEvent.Reducer.GetAsInsertPkI64();
        Reducers->InvokeInsertPkI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_i_8"))
    {
        FInsertPkI8Args Args = ReducerEvent.Reducer.GetAsInsertPkI8();
        Reducers->InvokeInsertPkI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_identity"))
    {
        FInsertPkIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertPkIdentity();
        Reducers->InvokeInsertPkIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_simple_enum"))
    {
        FInsertPkSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertPkSimpleEnum();
        Reducers->InvokeInsertPkSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_string"))
    {
        FInsertPkStringArgs Args = ReducerEvent.Reducer.GetAsInsertPkString();
        Reducers->InvokeInsertPkStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_128"))
    {
        FInsertPkU128Args Args = ReducerEvent.Reducer.GetAsInsertPkU128();
        Reducers->InvokeInsertPkU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_16"))
    {
        FInsertPkU16Args Args = ReducerEvent.Reducer.GetAsInsertPkU16();
        Reducers->InvokeInsertPkU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_256"))
    {
        FInsertPkU256Args Args = ReducerEvent.Reducer.GetAsInsertPkU256();
        Reducers->InvokeInsertPkU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_32"))
    {
        FInsertPkU32Args Args = ReducerEvent.Reducer.GetAsInsertPkU32();
        Reducers->InvokeInsertPkU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_32_two"))
    {
        FInsertPkU32TwoArgs Args = ReducerEvent.Reducer.GetAsInsertPkU32Two();
        Reducers->InvokeInsertPkU32TwoWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_64"))
    {
        FInsertPkU64Args Args = ReducerEvent.Reducer.GetAsInsertPkU64();
        Reducers->InvokeInsertPkU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_u_8"))
    {
        FInsertPkU8Args Args = ReducerEvent.Reducer.GetAsInsertPkU8();
        Reducers->InvokeInsertPkU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_pk_uuid"))
    {
        FInsertPkUuidArgs Args = ReducerEvent.Reducer.GetAsInsertPkUuid();
        Reducers->InvokeInsertPkUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_primitives_as_strings"))
    {
        FInsertPrimitivesAsStringsArgs Args = ReducerEvent.Reducer.GetAsInsertPrimitivesAsStrings();
        Reducers->InvokeInsertPrimitivesAsStringsWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_result_every_primitive_struct_string"))
    {
        FInsertResultEveryPrimitiveStructStringArgs Args = ReducerEvent.Reducer.GetAsInsertResultEveryPrimitiveStructString();
        Reducers->InvokeInsertResultEveryPrimitiveStructStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_result_i_32_string"))
    {
        FInsertResultI32StringArgs Args = ReducerEvent.Reducer.GetAsInsertResultI32String();
        Reducers->InvokeInsertResultI32StringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_result_identity_string"))
    {
        FInsertResultIdentityStringArgs Args = ReducerEvent.Reducer.GetAsInsertResultIdentityString();
        Reducers->InvokeInsertResultIdentityStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_result_simple_enum_i_32"))
    {
        FInsertResultSimpleEnumI32Args Args = ReducerEvent.Reducer.GetAsInsertResultSimpleEnumI32();
        Reducers->InvokeInsertResultSimpleEnumI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_result_string_i_32"))
    {
        FInsertResultStringI32Args Args = ReducerEvent.Reducer.GetAsInsertResultStringI32();
        Reducers->InvokeInsertResultStringI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_result_vec_i_32_string"))
    {
        FInsertResultVecI32StringArgs Args = ReducerEvent.Reducer.GetAsInsertResultVecI32String();
        Reducers->InvokeInsertResultVecI32StringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_table_holds_table"))
    {
        FInsertTableHoldsTableArgs Args = ReducerEvent.Reducer.GetAsInsertTableHoldsTable();
        Reducers->InvokeInsertTableHoldsTableWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_bool"))
    {
        FInsertUniqueBoolArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueBool();
        Reducers->InvokeInsertUniqueBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_connection_id"))
    {
        FInsertUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueConnectionId();
        Reducers->InvokeInsertUniqueConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i_128"))
    {
        FInsertUniqueI128Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI128();
        Reducers->InvokeInsertUniqueI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i_16"))
    {
        FInsertUniqueI16Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI16();
        Reducers->InvokeInsertUniqueI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i_256"))
    {
        FInsertUniqueI256Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI256();
        Reducers->InvokeInsertUniqueI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i_32"))
    {
        FInsertUniqueI32Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI32();
        Reducers->InvokeInsertUniqueI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i_64"))
    {
        FInsertUniqueI64Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI64();
        Reducers->InvokeInsertUniqueI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_i_8"))
    {
        FInsertUniqueI8Args Args = ReducerEvent.Reducer.GetAsInsertUniqueI8();
        Reducers->InvokeInsertUniqueI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_identity"))
    {
        FInsertUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueIdentity();
        Reducers->InvokeInsertUniqueIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_string"))
    {
        FInsertUniqueStringArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueString();
        Reducers->InvokeInsertUniqueStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_128"))
    {
        FInsertUniqueU128Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU128();
        Reducers->InvokeInsertUniqueU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_16"))
    {
        FInsertUniqueU16Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU16();
        Reducers->InvokeInsertUniqueU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_256"))
    {
        FInsertUniqueU256Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU256();
        Reducers->InvokeInsertUniqueU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_32"))
    {
        FInsertUniqueU32Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU32();
        Reducers->InvokeInsertUniqueU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_32_update_pk_u_32"))
    {
        FInsertUniqueU32UpdatePkU32Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU32UpdatePkU32();
        Reducers->InvokeInsertUniqueU32UpdatePkU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_64"))
    {
        FInsertUniqueU64Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU64();
        Reducers->InvokeInsertUniqueU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_u_8"))
    {
        FInsertUniqueU8Args Args = ReducerEvent.Reducer.GetAsInsertUniqueU8();
        Reducers->InvokeInsertUniqueU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_unique_uuid"))
    {
        FInsertUniqueUuidArgs Args = ReducerEvent.Reducer.GetAsInsertUniqueUuid();
        Reducers->InvokeInsertUniqueUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_user"))
    {
        FInsertUserArgs Args = ReducerEvent.Reducer.GetAsInsertUser();
        Reducers->InvokeInsertUserWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_bool"))
    {
        FInsertVecBoolArgs Args = ReducerEvent.Reducer.GetAsInsertVecBool();
        Reducers->InvokeInsertVecBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_byte_struct"))
    {
        FInsertVecByteStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecByteStruct();
        Reducers->InvokeInsertVecByteStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_connection_id"))
    {
        FInsertVecConnectionIdArgs Args = ReducerEvent.Reducer.GetAsInsertVecConnectionId();
        Reducers->InvokeInsertVecConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_enum_with_payload"))
    {
        FInsertVecEnumWithPayloadArgs Args = ReducerEvent.Reducer.GetAsInsertVecEnumWithPayload();
        Reducers->InvokeInsertVecEnumWithPayloadWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_every_primitive_struct"))
    {
        FInsertVecEveryPrimitiveStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecEveryPrimitiveStruct();
        Reducers->InvokeInsertVecEveryPrimitiveStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_every_vec_struct"))
    {
        FInsertVecEveryVecStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecEveryVecStruct();
        Reducers->InvokeInsertVecEveryVecStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_f_32"))
    {
        FInsertVecF32Args Args = ReducerEvent.Reducer.GetAsInsertVecF32();
        Reducers->InvokeInsertVecF32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_f_64"))
    {
        FInsertVecF64Args Args = ReducerEvent.Reducer.GetAsInsertVecF64();
        Reducers->InvokeInsertVecF64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i_128"))
    {
        FInsertVecI128Args Args = ReducerEvent.Reducer.GetAsInsertVecI128();
        Reducers->InvokeInsertVecI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i_16"))
    {
        FInsertVecI16Args Args = ReducerEvent.Reducer.GetAsInsertVecI16();
        Reducers->InvokeInsertVecI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i_256"))
    {
        FInsertVecI256Args Args = ReducerEvent.Reducer.GetAsInsertVecI256();
        Reducers->InvokeInsertVecI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i_32"))
    {
        FInsertVecI32Args Args = ReducerEvent.Reducer.GetAsInsertVecI32();
        Reducers->InvokeInsertVecI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i_64"))
    {
        FInsertVecI64Args Args = ReducerEvent.Reducer.GetAsInsertVecI64();
        Reducers->InvokeInsertVecI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_i_8"))
    {
        FInsertVecI8Args Args = ReducerEvent.Reducer.GetAsInsertVecI8();
        Reducers->InvokeInsertVecI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_identity"))
    {
        FInsertVecIdentityArgs Args = ReducerEvent.Reducer.GetAsInsertVecIdentity();
        Reducers->InvokeInsertVecIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_simple_enum"))
    {
        FInsertVecSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsInsertVecSimpleEnum();
        Reducers->InvokeInsertVecSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_string"))
    {
        FInsertVecStringArgs Args = ReducerEvent.Reducer.GetAsInsertVecString();
        Reducers->InvokeInsertVecStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_timestamp"))
    {
        FInsertVecTimestampArgs Args = ReducerEvent.Reducer.GetAsInsertVecTimestamp();
        Reducers->InvokeInsertVecTimestampWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u_128"))
    {
        FInsertVecU128Args Args = ReducerEvent.Reducer.GetAsInsertVecU128();
        Reducers->InvokeInsertVecU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u_16"))
    {
        FInsertVecU16Args Args = ReducerEvent.Reducer.GetAsInsertVecU16();
        Reducers->InvokeInsertVecU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u_256"))
    {
        FInsertVecU256Args Args = ReducerEvent.Reducer.GetAsInsertVecU256();
        Reducers->InvokeInsertVecU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u_32"))
    {
        FInsertVecU32Args Args = ReducerEvent.Reducer.GetAsInsertVecU32();
        Reducers->InvokeInsertVecU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u_64"))
    {
        FInsertVecU64Args Args = ReducerEvent.Reducer.GetAsInsertVecU64();
        Reducers->InvokeInsertVecU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_u_8"))
    {
        FInsertVecU8Args Args = ReducerEvent.Reducer.GetAsInsertVecU8();
        Reducers->InvokeInsertVecU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_unit_struct"))
    {
        FInsertVecUnitStructArgs Args = ReducerEvent.Reducer.GetAsInsertVecUnitStruct();
        Reducers->InvokeInsertVecUnitStructWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("insert_vec_uuid"))
    {
        FInsertVecUuidArgs Args = ReducerEvent.Reducer.GetAsInsertVecUuid();
        Reducers->InvokeInsertVecUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("no_op_succeeds"))
    {
        FNoOpSucceedsArgs Args = ReducerEvent.Reducer.GetAsNoOpSucceeds();
        Reducers->InvokeNoOpSucceedsWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("sorted_uuids_insert"))
    {
        FSortedUuidsInsertArgs Args = ReducerEvent.Reducer.GetAsSortedUuidsInsert();
        Reducers->InvokeSortedUuidsInsertWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_indexed_simple_enum"))
    {
        FUpdateIndexedSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsUpdateIndexedSimpleEnum();
        Reducers->InvokeUpdateIndexedSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_bool"))
    {
        FUpdatePkBoolArgs Args = ReducerEvent.Reducer.GetAsUpdatePkBool();
        Reducers->InvokeUpdatePkBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_connection_id"))
    {
        FUpdatePkConnectionIdArgs Args = ReducerEvent.Reducer.GetAsUpdatePkConnectionId();
        Reducers->InvokeUpdatePkConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_i_128"))
    {
        FUpdatePkI128Args Args = ReducerEvent.Reducer.GetAsUpdatePkI128();
        Reducers->InvokeUpdatePkI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_i_16"))
    {
        FUpdatePkI16Args Args = ReducerEvent.Reducer.GetAsUpdatePkI16();
        Reducers->InvokeUpdatePkI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_i_256"))
    {
        FUpdatePkI256Args Args = ReducerEvent.Reducer.GetAsUpdatePkI256();
        Reducers->InvokeUpdatePkI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_i_32"))
    {
        FUpdatePkI32Args Args = ReducerEvent.Reducer.GetAsUpdatePkI32();
        Reducers->InvokeUpdatePkI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_i_64"))
    {
        FUpdatePkI64Args Args = ReducerEvent.Reducer.GetAsUpdatePkI64();
        Reducers->InvokeUpdatePkI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_i_8"))
    {
        FUpdatePkI8Args Args = ReducerEvent.Reducer.GetAsUpdatePkI8();
        Reducers->InvokeUpdatePkI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_identity"))
    {
        FUpdatePkIdentityArgs Args = ReducerEvent.Reducer.GetAsUpdatePkIdentity();
        Reducers->InvokeUpdatePkIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_simple_enum"))
    {
        FUpdatePkSimpleEnumArgs Args = ReducerEvent.Reducer.GetAsUpdatePkSimpleEnum();
        Reducers->InvokeUpdatePkSimpleEnumWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_string"))
    {
        FUpdatePkStringArgs Args = ReducerEvent.Reducer.GetAsUpdatePkString();
        Reducers->InvokeUpdatePkStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_128"))
    {
        FUpdatePkU128Args Args = ReducerEvent.Reducer.GetAsUpdatePkU128();
        Reducers->InvokeUpdatePkU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_16"))
    {
        FUpdatePkU16Args Args = ReducerEvent.Reducer.GetAsUpdatePkU16();
        Reducers->InvokeUpdatePkU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_256"))
    {
        FUpdatePkU256Args Args = ReducerEvent.Reducer.GetAsUpdatePkU256();
        Reducers->InvokeUpdatePkU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_32"))
    {
        FUpdatePkU32Args Args = ReducerEvent.Reducer.GetAsUpdatePkU32();
        Reducers->InvokeUpdatePkU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_32_two"))
    {
        FUpdatePkU32TwoArgs Args = ReducerEvent.Reducer.GetAsUpdatePkU32Two();
        Reducers->InvokeUpdatePkU32TwoWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_64"))
    {
        FUpdatePkU64Args Args = ReducerEvent.Reducer.GetAsUpdatePkU64();
        Reducers->InvokeUpdatePkU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_u_8"))
    {
        FUpdatePkU8Args Args = ReducerEvent.Reducer.GetAsUpdatePkU8();
        Reducers->InvokeUpdatePkU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_pk_uuid"))
    {
        FUpdatePkUuidArgs Args = ReducerEvent.Reducer.GetAsUpdatePkUuid();
        Reducers->InvokeUpdatePkUuidWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_bool"))
    {
        FUpdateUniqueBoolArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueBool();
        Reducers->InvokeUpdateUniqueBoolWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_connection_id"))
    {
        FUpdateUniqueConnectionIdArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueConnectionId();
        Reducers->InvokeUpdateUniqueConnectionIdWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_i_128"))
    {
        FUpdateUniqueI128Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI128();
        Reducers->InvokeUpdateUniqueI128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_i_16"))
    {
        FUpdateUniqueI16Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI16();
        Reducers->InvokeUpdateUniqueI16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_i_256"))
    {
        FUpdateUniqueI256Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI256();
        Reducers->InvokeUpdateUniqueI256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_i_32"))
    {
        FUpdateUniqueI32Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI32();
        Reducers->InvokeUpdateUniqueI32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_i_64"))
    {
        FUpdateUniqueI64Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI64();
        Reducers->InvokeUpdateUniqueI64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_i_8"))
    {
        FUpdateUniqueI8Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueI8();
        Reducers->InvokeUpdateUniqueI8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_identity"))
    {
        FUpdateUniqueIdentityArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueIdentity();
        Reducers->InvokeUpdateUniqueIdentityWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_string"))
    {
        FUpdateUniqueStringArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueString();
        Reducers->InvokeUpdateUniqueStringWithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_u_128"))
    {
        FUpdateUniqueU128Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU128();
        Reducers->InvokeUpdateUniqueU128WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_u_16"))
    {
        FUpdateUniqueU16Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU16();
        Reducers->InvokeUpdateUniqueU16WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_u_256"))
    {
        FUpdateUniqueU256Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU256();
        Reducers->InvokeUpdateUniqueU256WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_u_32"))
    {
        FUpdateUniqueU32Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU32();
        Reducers->InvokeUpdateUniqueU32WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_u_64"))
    {
        FUpdateUniqueU64Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU64();
        Reducers->InvokeUpdateUniqueU64WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_u_8"))
    {
        FUpdateUniqueU8Args Args = ReducerEvent.Reducer.GetAsUpdateUniqueU8();
        Reducers->InvokeUpdateUniqueU8WithArgs(Context, Args);
        return;
    }
    if (ReducerName == TEXT("update_unique_uuid"))
    {
        FUpdateUniqueUuidArgs Args = ReducerEvent.Reducer.GetAsUpdateUniqueUuid();
        Reducers->InvokeUpdateUniqueUuidWithArgs(Context, Args);
        return;
    }

    UE_LOG(LogTemp, Warning, TEXT("Unknown reducer: %s"), *ReducerName);
}

void UDbConnection::ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage)
{
    if (!Reducers) { return; }

    FTestClientReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;

    FReducerEventContext Context(this, ReducerEvent);

    if (Reducers->InternalOnUnhandledReducerError.IsBound())
    {
        Reducers->InternalOnUnhandledReducerError.Broadcast(Context, ErrorMessage);
    }
}

void UDbConnection::ProcedureEventFailed(const FProcedureEvent& Event, const FString ErrorMessage)
{
    if (!Procedures) { return; }

    FTestClientProcedureEvent ProcedureEvent;
    ProcedureEvent.Status             = FSpacetimeDBProcedureStatus::FromStatus(Event.Status);
    ProcedureEvent.Timestamp          = Event.Timestamp;

    FProcedureEventContext Context(this, ProcedureEvent);

    if (Procedures->InternalOnUnhandledProcedureError.IsBound())
    {
        Procedures->InternalOnUnhandledProcedureError.Broadcast(Context, ErrorMessage);
    }
}

UDbConnectionBuilder* UDbConnection::Builder()
{
	return NewObject<UDbConnectionBuilder>();
}
// Added for creating subscriptions
USubscriptionBuilder* UDbConnection::SubscriptionBuilder()
{
	USubscriptionBuilder* Builder = NewObject<USubscriptionBuilder>(this);
	Builder->Conn = this;
	return Builder;
}
USubscriptionBuilder* USubscriptionBuilder::OnApplied(FOnSubscriptionApplied Callback)
{
	OnAppliedDelegateInternal = Callback;
	return this;
}
USubscriptionBuilder* USubscriptionBuilder::OnError(FOnSubscriptionError Callback)
{
	OnErrorDelegateInternal = Callback;
	return this;
}
USubscriptionHandle* USubscriptionBuilder::Subscribe(const TArray<FString>& SQL)
{
	USubscriptionHandle* Handle = NewObject<USubscriptionHandle>();

	// Store user callbacks on the handle
	Handle->Conn = Conn;
	Handle->OnAppliedDelegate = OnAppliedDelegateInternal;
	Handle->OnErrorDelegate = OnErrorDelegateInternal;

	// Bind forwarding functions that will convert base contexts
	FSubscriptionEventDelegate BaseApplied;
	BaseApplied.BindUFunction(Handle, TEXT("ForwardOnApplied"));
	OnAppliedBase(BaseApplied);

	FSubscriptionErrorDelegate BaseError;
	BaseError.BindUFunction(Handle, TEXT("ForwardOnError"));
	OnErrorBase(BaseError);

	SubscribeBase(SQL, Handle);
	if (Conn)
	{
		Conn->StartSubscription(Handle);
	}
	return Handle;
}
USubscriptionHandle* USubscriptionBuilder::SubscribeToAllTables()
{
	return Subscribe({ "SELECT * FROM * " });
}

USubscriptionHandle::USubscriptionHandle(UDbConnection* InConn)
{
	Conn = InConn;
}

void USubscriptionHandle::ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx)
{
	if (OnAppliedDelegate.IsBound())
	{
		FSubscriptionEventContext Ctx(Conn);
		OnAppliedDelegate.Execute(Ctx);
	}
}

void USubscriptionHandle::ForwardOnError(const FErrorContextBase& BaseCtx)
{
	if (OnErrorDelegate.IsBound())
	{
		FErrorContext Ctx(Conn, BaseCtx.Error);
		OnErrorDelegate.Execute(Ctx);
	}
}


// Cast from parent to child class
UDbConnectionBuilder* UDbConnectionBuilder::WithUri(const FString& InUri)
{
	return Cast<UDbConnectionBuilder>(WithUriBase(InUri));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithDatabaseName(const FString& InName)
{
	return Cast<UDbConnectionBuilder>(WithDatabaseNameBase(InName));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithToken(const FString& InToken)
{
	return Cast<UDbConnectionBuilder>(WithTokenBase(InToken));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithCompression(const ESpacetimeDBCompression& InCompression)
{
	return Cast<UDbConnectionBuilder>(WithCompressionBase(InCompression));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnect(FOnConnectDelegate Callback)
{
	OnConnectDelegateInternal = Callback;
	return this;
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnectError(FOnConnectErrorDelegate Callback)
{
	return Cast<UDbConnectionBuilder>(OnConnectErrorBase(Callback));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnDisconnect(FOnDisconnectDelegate Callback)
{
	OnDisconnectDelegateInternal = Callback;
	return this;
}
UDbConnection* UDbConnectionBuilder::Build()
{
	UDbConnection* Connection = NewObject<UDbConnection>();

	// Store delegates on the connection for later use
	Connection->OnConnectDelegate = OnConnectDelegateInternal;
	Connection->OnDisconnectDelegate = OnDisconnectDelegateInternal;

	// Wrap delegates so the base builder can bind them
	FOnConnectBaseDelegate BaseConnect;
	BaseConnect.BindUFunction(Connection, TEXT("ForwardOnConnect"));
	Connection->SetOnConnectDelegate(BaseConnect);
	OnConnectBase(BaseConnect);

	FOnDisconnectBaseDelegate BaseDisconnect;
	BaseDisconnect.BindUFunction(Connection, TEXT("ForwardOnDisconnect"));
	Connection->SetOnDisconnectDelegate(BaseDisconnect);
	OnDisconnectBase(BaseDisconnect);

	return Cast<UDbConnection>(BuildConnection(Connection));
}
void UDbConnection::ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken)
{
	if (OnConnectDelegate.IsBound())
	{
		OnConnectDelegate.Execute(this, Identity, Token);
	}
}
void UDbConnection::ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error)
{
	if (OnDisconnectDelegate.IsBound())
	{
		OnDisconnectDelegate.Execute(this, Error);
	}
}


void UDbConnection::DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event)
{
    FTestClientEvent BaseEvent;
    BaseEvent.Tag = Event.Tag;

    switch (Event.Tag)
    {
    case ESpacetimeDBEventTag::Reducer:
    {
        FReducerEvent ReducerEvent = Event.GetAsReducer();
        FReducer Reducer;
        if (!TryGetPendingTypedReducer(ReducerEvent.RequestId, Reducer))
        {
            UE_LOG(LogTemp, Warning, TEXT("Missing typed reducer for request_id %u while building table-update event context; using UnknownTransaction event"), ReducerEvent.RequestId);
            BaseEvent = FTestClientEvent::UnknownTransaction(FSpacetimeDBUnit());
            break;
        }
        BaseEvent = FTestClientEvent::Reducer(Reducer);
        break;
    }

    case ESpacetimeDBEventTag::SubscribeApplied:
        BaseEvent = FTestClientEvent::SubscribeApplied(Event.GetAsSubscribeApplied());
        break;

    case ESpacetimeDBEventTag::UnsubscribeApplied:
        BaseEvent = FTestClientEvent::UnsubscribeApplied(Event.GetAsUnsubscribeApplied());
        break;

    case ESpacetimeDBEventTag::Disconnected:
        BaseEvent = FTestClientEvent::Disconnected(Event.GetAsDisconnected());
        break;

    case ESpacetimeDBEventTag::Transaction:
        BaseEvent = FTestClientEvent::Transaction(Event.GetAsTransaction());
        break;

    case ESpacetimeDBEventTag::SubscribeError:
        BaseEvent = FTestClientEvent::SubscribeError(Event.GetAsSubscribeError());
        break;

    case ESpacetimeDBEventTag::UnknownTransaction:
        BaseEvent = FTestClientEvent::UnknownTransaction(Event.GetAsUnknownTransaction());
        break;

    default:
        break;
    }

    FEventContext Context(this, BaseEvent);
    // Populate typed reducer args for convenience in table handlers

    ApplyRegisteredTableUpdates(Update, &Context);
}

