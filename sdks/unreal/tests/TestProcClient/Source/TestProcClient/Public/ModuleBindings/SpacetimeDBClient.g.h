// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

// This was generated using spacetimedb cli version 1.11.2 (commit e090367c50e718fe19fbf827206a7516502288a9).

#pragma once
#include "CoreMinimal.h"
#include "BSATN/UESpacetimeDB.h"
#include "Connection/Callback.h"
#include "Connection/DbConnectionBase.h"
#include "Connection/DbConnectionBuilder.h"
#include "Connection/SetReducerFlags.h"
#include "Connection/Subscription.h"
#include "Kismet/BlueprintFunctionLibrary.h"
#include "ModuleBindings/Procedures/InsertWithTxCommit.g.h"
#include "ModuleBindings/Procedures/InsertWithTxRollback.g.h"
#include "ModuleBindings/Procedures/InvalidRequest.g.h"
#include "ModuleBindings/Procedures/ReadMySchema.g.h"
#include "ModuleBindings/Procedures/ReturnEnumA.g.h"
#include "ModuleBindings/Procedures/ReturnEnumB.g.h"
#include "ModuleBindings/Procedures/ReturnPrimitive.g.h"
#include "ModuleBindings/Procedures/ReturnStruct.g.h"
#include "ModuleBindings/Procedures/ScheduledProc.g.h"
#include "ModuleBindings/Procedures/SortedUuidsInsert.g.h"
#include "ModuleBindings/Procedures/WillPanic.g.h"
#include "ModuleBindings/ReducerBase.g.h"
#include "ModuleBindings/Reducers/ScheduleProc.g.h"
#include "ModuleBindings/Types/ReturnEnumType.g.h"
#include "ModuleBindings/Types/ReturnStructType.g.h"
#include "ModuleBindings/Types/ScheduledProcTableType.g.h"
#include "Types/Builtins.h"
#include "Types/UnitType.h"
#include "SpacetimeDBClient.g.generated.h"

// Forward declarations
class UDbConnection;
class URemoteTables;
class URemoteReducers;
class URemoteProcedures;
class USubscriptionBuilder;
class USubscriptionHandle;

/** Forward declaration for tables */
class UMyTableTable;
class UPkUuidTable;
class UProcInsertsIntoTable;
class UScheduledProcTableTable;
/***/

// Delegates using the generated connection type. These wrap the base
// delegates defined in the SDK so that projects can work directly with
// UDbConnection without manual casting in user code.
DECLARE_DYNAMIC_DELEGATE_ThreeParams(
	FOnConnectDelegate,
	UDbConnection*, Connection,
	FSpacetimeDBIdentity, Identity,
	const FString&, Token);

DECLARE_DYNAMIC_DELEGATE_TwoParams(
	FOnDisconnectDelegate,
	UDbConnection*, Connection,
	const FString&, Error);


// Context classes for event handling

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FContextBase
{
	GENERATED_BODY()

	FContextBase() : Db(nullptr), Reducers(nullptr), SetReducerFlags(nullptr), Procedures(nullptr), Conn(nullptr) {};
	FContextBase(UDbConnection* InConn);

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteTables* Db;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteReducers* Reducers;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	USetReducerFlags* SetReducerFlags;

	UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
	URemoteProcedures* Procedures;

	bool IsActive() const;
	void Disconnect();
	bool TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const;
	FSpacetimeDBConnectionId GetConnectionId() const;
	USubscriptionBuilder* SubscriptionBuilder();

protected:
	UPROPERTY()
	UDbConnection* Conn;

};

UCLASS()
class TESTPROCCLIENT_API UContextBaseBpLib : public UBlueprintFunctionLibrary
{
	GENERATED_BODY()

private:
	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static URemoteTables* GetDb(const FContextBase& Ctx) { return Ctx.Db; }

	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static URemoteReducers* GetReducers(const FContextBase& Ctx) { return Ctx.Reducers; }

	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static USetReducerFlags* GetSetReducerFlags(const FContextBase& Ctx) { return Ctx.SetReducerFlags; }

	static URemoteProcedures* GetProcedures(const FContextBase& Ctx) { return Ctx.Procedures; }

	UFUNCTION(BlueprintPure, Category="SpacetimeDB")
	static bool IsActive(const FContextBase& Ctx) { return Ctx.IsActive(); }
};

UENUM(BlueprintType, Category = "SpacetimeDB")
enum class EReducerTag : uint8
{
    ScheduleProc
};

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FReducer
{
    GENERATED_BODY()

public:
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    EReducerTag Tag = static_cast<EReducerTag>(0);

    TVariant<FScheduleProcArgs> Data;

    // Optional metadata
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    FString ReducerName;
    uint32 ReducerId = 0;
    uint32 RequestId = 0;

    static FReducer ScheduleProc(const FScheduleProcArgs& Value)
    {
        FReducer Out;
        Out.Tag = EReducerTag::ScheduleProc;
        Out.Data.Set<FScheduleProcArgs>(Value);
        Out.ReducerName = TEXT("schedule_proc");
        return Out;
    }

    FORCEINLINE bool IsScheduleProc() const { return Tag == EReducerTag::ScheduleProc; }
    FORCEINLINE FScheduleProcArgs GetAsScheduleProc() const
    {
        ensureMsgf(IsScheduleProc(), TEXT("Reducer does not hold ScheduleProc!"));
        return Data.Get<FScheduleProcArgs>();
    }

    FORCEINLINE bool operator==(const FReducer& Other) const
    {
        if (Tag != Other.Tag || ReducerId != Other.ReducerId || RequestId != Other.RequestId || ReducerName != Other.ReducerName) return false;
        switch (Tag)
        {
        case EReducerTag::ScheduleProc:
            return GetAsScheduleProc() == Other.GetAsScheduleProc();
        default: return false;
        }
    }
    FORCEINLINE bool operator!=(const FReducer& Other) const { return !(*this == Other); }
};

UCLASS()
class TESTPROCCLIENT_API UReducerBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Reducer")
    static FReducer ScheduleProc(const FScheduleProcArgs& Value) {
        return FReducer::ScheduleProc(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static bool IsScheduleProc(const FReducer& Reducer) { return Reducer.IsScheduleProc(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Reducer")
    static FScheduleProcArgs GetAsScheduleProc(const FReducer& Reducer) {
        return Reducer.GetAsScheduleProc();
    }
};

/** Metadata describing a reducer run. */
USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FTestProcClientReducerEvent
{
	GENERATED_BODY()

	/** Timestamp for when the reducer executed */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimestamp Timestamp;

	/** Result status of the reducer */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBStatus Status;

	/** Identity that initiated the call */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBIdentity CallerIdentity;

	/** Connection ID for the caller */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBConnectionId CallerConnectionId;

	/** Energy consumed while executing */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FEnergyQuantaType EnergyConsumed;

	/** Detailed call information */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FReducer Reducer;

	FORCEINLINE bool operator==(const FTestProcClientReducerEvent& Other) const
	{
		return Status == Other.Status && Timestamp == Other.Timestamp && CallerIdentity == Other.CallerIdentity &&
			CallerConnectionId == Other.CallerConnectionId && EnergyConsumed == Other.EnergyConsumed &&
			Reducer == Other.Reducer;
	}

	FORCEINLINE bool operator!=(const FTestProcClientReducerEvent& Other) const
	{
		return !(*this == Other);
	}
};

UENUM(BlueprintType, Category = "SpacetimeDB")
enum class EProcedureTag : uint8
{
    InsertWithTxCommit,
    InsertWithTxRollback,
    InvalidRequest,
    ReadMySchema,
    ReturnEnumA,
    ReturnEnumB,
    ReturnPrimitive,
    ReturnStruct,
    ScheduledProc,
    SortedUuidsInsert,
    WillPanic
};

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FProcedure
{
    GENERATED_BODY()

public:
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    EProcedureTag Tag = static_cast<EProcedureTag>(0);

    TVariant<FInsertWithTxCommitArgs, FInsertWithTxRollbackArgs, FInvalidRequestArgs, FReadMySchemaArgs, FReturnEnumAArgs, FReturnEnumBArgs, FReturnPrimitiveArgs, FReturnStructArgs, FScheduledProcArgs, FSortedUuidsInsertArgs, FWillPanicArgs> Data;

    // Optional metadata
    UPROPERTY(BlueprintReadOnly, Category = "SpacetimeDB")
    FString ProcedureName;
    uint32 ProcedureId = 0;
    uint32 RequestId = 0;

    static FProcedure InsertWithTxCommit(const FInsertWithTxCommitArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::InsertWithTxCommit;
        Out.Data.Set<FInsertWithTxCommitArgs>(Value);
        Out.ProcedureName = TEXT("insert_with_tx_commit");
        return Out;
    }

    FORCEINLINE bool IsInsertWithTxCommit() const { return Tag == EProcedureTag::InsertWithTxCommit; }
    FORCEINLINE FInsertWithTxCommitArgs GetAsInsertWithTxCommit() const
    {
        ensureMsgf(IsInsertWithTxCommit(), TEXT("Procedure does not hold InsertWithTxCommit!"));
        return Data.Get<FInsertWithTxCommitArgs>();
    }

    static FProcedure InsertWithTxRollback(const FInsertWithTxRollbackArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::InsertWithTxRollback;
        Out.Data.Set<FInsertWithTxRollbackArgs>(Value);
        Out.ProcedureName = TEXT("insert_with_tx_rollback");
        return Out;
    }

    FORCEINLINE bool IsInsertWithTxRollback() const { return Tag == EProcedureTag::InsertWithTxRollback; }
    FORCEINLINE FInsertWithTxRollbackArgs GetAsInsertWithTxRollback() const
    {
        ensureMsgf(IsInsertWithTxRollback(), TEXT("Procedure does not hold InsertWithTxRollback!"));
        return Data.Get<FInsertWithTxRollbackArgs>();
    }

    static FProcedure InvalidRequest(const FInvalidRequestArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::InvalidRequest;
        Out.Data.Set<FInvalidRequestArgs>(Value);
        Out.ProcedureName = TEXT("invalid_request");
        return Out;
    }

    FORCEINLINE bool IsInvalidRequest() const { return Tag == EProcedureTag::InvalidRequest; }
    FORCEINLINE FInvalidRequestArgs GetAsInvalidRequest() const
    {
        ensureMsgf(IsInvalidRequest(), TEXT("Procedure does not hold InvalidRequest!"));
        return Data.Get<FInvalidRequestArgs>();
    }

    static FProcedure ReadMySchema(const FReadMySchemaArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::ReadMySchema;
        Out.Data.Set<FReadMySchemaArgs>(Value);
        Out.ProcedureName = TEXT("read_my_schema");
        return Out;
    }

    FORCEINLINE bool IsReadMySchema() const { return Tag == EProcedureTag::ReadMySchema; }
    FORCEINLINE FReadMySchemaArgs GetAsReadMySchema() const
    {
        ensureMsgf(IsReadMySchema(), TEXT("Procedure does not hold ReadMySchema!"));
        return Data.Get<FReadMySchemaArgs>();
    }

    static FProcedure ReturnEnumA(const FReturnEnumAArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::ReturnEnumA;
        Out.Data.Set<FReturnEnumAArgs>(Value);
        Out.ProcedureName = TEXT("return_enum_a");
        return Out;
    }

    FORCEINLINE bool IsReturnEnumA() const { return Tag == EProcedureTag::ReturnEnumA; }
    FORCEINLINE FReturnEnumAArgs GetAsReturnEnumA() const
    {
        ensureMsgf(IsReturnEnumA(), TEXT("Procedure does not hold ReturnEnumA!"));
        return Data.Get<FReturnEnumAArgs>();
    }

    static FProcedure ReturnEnumB(const FReturnEnumBArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::ReturnEnumB;
        Out.Data.Set<FReturnEnumBArgs>(Value);
        Out.ProcedureName = TEXT("return_enum_b");
        return Out;
    }

    FORCEINLINE bool IsReturnEnumB() const { return Tag == EProcedureTag::ReturnEnumB; }
    FORCEINLINE FReturnEnumBArgs GetAsReturnEnumB() const
    {
        ensureMsgf(IsReturnEnumB(), TEXT("Procedure does not hold ReturnEnumB!"));
        return Data.Get<FReturnEnumBArgs>();
    }

    static FProcedure ReturnPrimitive(const FReturnPrimitiveArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::ReturnPrimitive;
        Out.Data.Set<FReturnPrimitiveArgs>(Value);
        Out.ProcedureName = TEXT("return_primitive");
        return Out;
    }

    FORCEINLINE bool IsReturnPrimitive() const { return Tag == EProcedureTag::ReturnPrimitive; }
    FORCEINLINE FReturnPrimitiveArgs GetAsReturnPrimitive() const
    {
        ensureMsgf(IsReturnPrimitive(), TEXT("Procedure does not hold ReturnPrimitive!"));
        return Data.Get<FReturnPrimitiveArgs>();
    }

    static FProcedure ReturnStruct(const FReturnStructArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::ReturnStruct;
        Out.Data.Set<FReturnStructArgs>(Value);
        Out.ProcedureName = TEXT("return_struct");
        return Out;
    }

    FORCEINLINE bool IsReturnStruct() const { return Tag == EProcedureTag::ReturnStruct; }
    FORCEINLINE FReturnStructArgs GetAsReturnStruct() const
    {
        ensureMsgf(IsReturnStruct(), TEXT("Procedure does not hold ReturnStruct!"));
        return Data.Get<FReturnStructArgs>();
    }

    static FProcedure ScheduledProc(const FScheduledProcArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::ScheduledProc;
        Out.Data.Set<FScheduledProcArgs>(Value);
        Out.ProcedureName = TEXT("scheduled_proc");
        return Out;
    }

    FORCEINLINE bool IsScheduledProc() const { return Tag == EProcedureTag::ScheduledProc; }
    FORCEINLINE FScheduledProcArgs GetAsScheduledProc() const
    {
        ensureMsgf(IsScheduledProc(), TEXT("Procedure does not hold ScheduledProc!"));
        return Data.Get<FScheduledProcArgs>();
    }

    static FProcedure SortedUuidsInsert(const FSortedUuidsInsertArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::SortedUuidsInsert;
        Out.Data.Set<FSortedUuidsInsertArgs>(Value);
        Out.ProcedureName = TEXT("sorted_uuids_insert");
        return Out;
    }

    FORCEINLINE bool IsSortedUuidsInsert() const { return Tag == EProcedureTag::SortedUuidsInsert; }
    FORCEINLINE FSortedUuidsInsertArgs GetAsSortedUuidsInsert() const
    {
        ensureMsgf(IsSortedUuidsInsert(), TEXT("Procedure does not hold SortedUuidsInsert!"));
        return Data.Get<FSortedUuidsInsertArgs>();
    }

    static FProcedure WillPanic(const FWillPanicArgs& Value)
    {
        FProcedure Out;
        Out.Tag = EProcedureTag::WillPanic;
        Out.Data.Set<FWillPanicArgs>(Value);
        Out.ProcedureName = TEXT("will_panic");
        return Out;
    }

    FORCEINLINE bool IsWillPanic() const { return Tag == EProcedureTag::WillPanic; }
    FORCEINLINE FWillPanicArgs GetAsWillPanic() const
    {
        ensureMsgf(IsWillPanic(), TEXT("Procedure does not hold WillPanic!"));
        return Data.Get<FWillPanicArgs>();
    }

    FORCEINLINE bool operator==(const FProcedure& Other) const
    {
        if (Tag != Other.Tag || ProcedureId != Other.ProcedureId || RequestId != Other.RequestId || ProcedureName != Other.ProcedureName) return false;
        switch (Tag)
        {
        case EProcedureTag::InsertWithTxCommit:
            return GetAsInsertWithTxCommit() == Other.GetAsInsertWithTxCommit();
        case EProcedureTag::InsertWithTxRollback:
            return GetAsInsertWithTxRollback() == Other.GetAsInsertWithTxRollback();
        case EProcedureTag::InvalidRequest:
            return GetAsInvalidRequest() == Other.GetAsInvalidRequest();
        case EProcedureTag::ReadMySchema:
            return GetAsReadMySchema() == Other.GetAsReadMySchema();
        case EProcedureTag::ReturnEnumA:
            return GetAsReturnEnumA() == Other.GetAsReturnEnumA();
        case EProcedureTag::ReturnEnumB:
            return GetAsReturnEnumB() == Other.GetAsReturnEnumB();
        case EProcedureTag::ReturnPrimitive:
            return GetAsReturnPrimitive() == Other.GetAsReturnPrimitive();
        case EProcedureTag::ReturnStruct:
            return GetAsReturnStruct() == Other.GetAsReturnStruct();
        case EProcedureTag::ScheduledProc:
            return GetAsScheduledProc() == Other.GetAsScheduledProc();
        case EProcedureTag::SortedUuidsInsert:
            return GetAsSortedUuidsInsert() == Other.GetAsSortedUuidsInsert();
        case EProcedureTag::WillPanic:
            return GetAsWillPanic() == Other.GetAsWillPanic();
        default: return false;
        }
    }
    FORCEINLINE bool operator!=(const FProcedure& Other) const { return !(*this == Other); }
};

UCLASS()
class TESTPROCCLIENT_API UProcedureBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure InsertWithTxCommit(const FInsertWithTxCommitArgs& Value) {
        return FProcedure::InsertWithTxCommit(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsInsertWithTxCommit(const FProcedure& Procedure) { return Procedure.IsInsertWithTxCommit(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FInsertWithTxCommitArgs GetAsInsertWithTxCommit(const FProcedure& Procedure) {
        return Procedure.GetAsInsertWithTxCommit();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure InsertWithTxRollback(const FInsertWithTxRollbackArgs& Value) {
        return FProcedure::InsertWithTxRollback(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsInsertWithTxRollback(const FProcedure& Procedure) { return Procedure.IsInsertWithTxRollback(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FInsertWithTxRollbackArgs GetAsInsertWithTxRollback(const FProcedure& Procedure) {
        return Procedure.GetAsInsertWithTxRollback();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure InvalidRequest(const FInvalidRequestArgs& Value) {
        return FProcedure::InvalidRequest(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsInvalidRequest(const FProcedure& Procedure) { return Procedure.IsInvalidRequest(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FInvalidRequestArgs GetAsInvalidRequest(const FProcedure& Procedure) {
        return Procedure.GetAsInvalidRequest();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure ReadMySchema(const FReadMySchemaArgs& Value) {
        return FProcedure::ReadMySchema(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsReadMySchema(const FProcedure& Procedure) { return Procedure.IsReadMySchema(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FReadMySchemaArgs GetAsReadMySchema(const FProcedure& Procedure) {
        return Procedure.GetAsReadMySchema();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure ReturnEnumA(const FReturnEnumAArgs& Value) {
        return FProcedure::ReturnEnumA(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsReturnEnumA(const FProcedure& Procedure) { return Procedure.IsReturnEnumA(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FReturnEnumAArgs GetAsReturnEnumA(const FProcedure& Procedure) {
        return Procedure.GetAsReturnEnumA();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure ReturnEnumB(const FReturnEnumBArgs& Value) {
        return FProcedure::ReturnEnumB(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsReturnEnumB(const FProcedure& Procedure) { return Procedure.IsReturnEnumB(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FReturnEnumBArgs GetAsReturnEnumB(const FProcedure& Procedure) {
        return Procedure.GetAsReturnEnumB();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure ReturnPrimitive(const FReturnPrimitiveArgs& Value) {
        return FProcedure::ReturnPrimitive(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsReturnPrimitive(const FProcedure& Procedure) { return Procedure.IsReturnPrimitive(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FReturnPrimitiveArgs GetAsReturnPrimitive(const FProcedure& Procedure) {
        return Procedure.GetAsReturnPrimitive();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure ReturnStruct(const FReturnStructArgs& Value) {
        return FProcedure::ReturnStruct(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsReturnStruct(const FProcedure& Procedure) { return Procedure.IsReturnStruct(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FReturnStructArgs GetAsReturnStruct(const FProcedure& Procedure) {
        return Procedure.GetAsReturnStruct();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure ScheduledProc(const FScheduledProcArgs& Value) {
        return FProcedure::ScheduledProc(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsScheduledProc(const FProcedure& Procedure) { return Procedure.IsScheduledProc(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FScheduledProcArgs GetAsScheduledProc(const FProcedure& Procedure) {
        return Procedure.GetAsScheduledProc();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure SortedUuidsInsert(const FSortedUuidsInsertArgs& Value) {
        return FProcedure::SortedUuidsInsert(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsSortedUuidsInsert(const FProcedure& Procedure) { return Procedure.IsSortedUuidsInsert(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FSortedUuidsInsertArgs GetAsSortedUuidsInsert(const FProcedure& Procedure) {
        return Procedure.GetAsSortedUuidsInsert();
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|Procedure")
    static FProcedure WillPanic(const FWillPanicArgs& Value) {
        return FProcedure::WillPanic(Value);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static bool IsWillPanic(const FProcedure& Procedure) { return Procedure.IsWillPanic(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|Procedure")
    static FWillPanicArgs GetAsWillPanic(const FProcedure& Procedure) {
        return Procedure.GetAsWillPanic();
    }
};

/** Metadata describing a procedure run. */
USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FTestProcClientProcedureEvent
{
	GENERATED_BODY()

	/** Timestamp for when the procedure executed */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimestamp Timestamp;

	/** Result status of the procedure */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBProcedureStatus Status;

	/** Identity that initiated the call */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="SpacetimeDB")
	FSpacetimeDBTimeDuration TotalHostExecutionDuration;

	FTestProcClientProcedureEvent() {
	}
	FTestProcClientProcedureEvent(FProcedureEvent Event) {
		Timestamp = Event.Timestamp;
		Status = FSpacetimeDBProcedureStatus::FromStatus(Event.Status);
		TotalHostExecutionDuration = Event.TotalHostExecutionDuration;
	}
	FORCEINLINE bool operator==(const FTestProcClientProcedureEvent& Other) const
	{
		return Status == Other.Status && Timestamp == Other.Timestamp &&
			TotalHostExecutionDuration == Other.TotalHostExecutionDuration;
	}

	FORCEINLINE bool operator!=(const FTestProcClientProcedureEvent& Other) const
	{
		return !(*this == Other);
	}
};

/** Represents event with variant message data. */
USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FTestProcClientEvent
{
	GENERATED_BODY()

	/** Tagged union holding reducer call, unit events, or error string */
	TVariant<FReducer, FSpacetimeDBUnit, FString> MessageData;

	/** Type tag indicating what this event represents */
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	ESpacetimeDBEventTag Tag = ESpacetimeDBEventTag::UnknownTransaction;

	/** === Static factory methods ===*/
	static FTestProcClientEvent Reducer(const FReducer& Value)
	{
		FTestProcClientEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Reducer;
		Obj.MessageData.Set<FReducer>(Value);
		return Obj;
	}

	static FTestProcClientEvent SubscribeApplied(const FSpacetimeDBUnit& Value)
	{
		FTestProcClientEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::SubscribeApplied;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FTestProcClientEvent UnsubscribeApplied(const FSpacetimeDBUnit& Value)
	{
		FTestProcClientEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::UnsubscribeApplied;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FTestProcClientEvent Disconnected(const FSpacetimeDBUnit& Value)
	{
		FTestProcClientEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::Disconnected;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	static FTestProcClientEvent SubscribeError(const FString& Value)
	{
		FTestProcClientEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::SubscribeError;
		Obj.MessageData.Set<FString>(Value);
		return Obj;
	}

	static FTestProcClientEvent UnknownTransaction(const FSpacetimeDBUnit& Value)
	{
		FTestProcClientEvent Obj;
		Obj.Tag = ESpacetimeDBEventTag::UnknownTransaction;
		Obj.MessageData.Set<FSpacetimeDBUnit>(Value);
		return Obj;
	}

	FORCEINLINE bool IsReducer() const { return Tag == ESpacetimeDBEventTag::Reducer; }
	FORCEINLINE FReducer GetAsReducer() const
	{
		ensureMsgf(IsReducer(), TEXT("MessageData does not hold Reducer!"));
		return MessageData.Get<FReducer>();
	}

	FORCEINLINE bool IsSubscribeApplied() const { return Tag == ESpacetimeDBEventTag::SubscribeApplied; }
	FORCEINLINE FSpacetimeDBUnit GetAsSubscribeApplied() const
	{
		ensureMsgf(IsSubscribeApplied(), TEXT("MessageData does not hold SubscribeApplied!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsUnsubscribeApplied() const { return Tag == ESpacetimeDBEventTag::UnsubscribeApplied; }
	FORCEINLINE FSpacetimeDBUnit GetAsUnsubscribeApplied() const
	{
		ensureMsgf(IsUnsubscribeApplied(), TEXT("MessageData does not hold UnsubscribeApplied!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsDisconnected() const { return Tag == ESpacetimeDBEventTag::Disconnected; }
	FORCEINLINE FSpacetimeDBUnit GetAsDisconnected() const
	{
		ensureMsgf(IsDisconnected(), TEXT("MessageData does not hold Disconnected!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool IsSubscribeError() const { return Tag == ESpacetimeDBEventTag::SubscribeError; }
	FORCEINLINE FString GetAsSubscribeError() const
	{
		ensureMsgf(IsSubscribeError(), TEXT("MessageData does not hold SubscribeError!"));
		return MessageData.Get<FString>();
	}

	FORCEINLINE bool IsUnknownTransaction() const { return Tag == ESpacetimeDBEventTag::UnknownTransaction; }
	FORCEINLINE FSpacetimeDBUnit GetAsUnknownTransaction() const
	{
		ensureMsgf(IsUnknownTransaction(), TEXT("MessageData does not hold UnknownTransaction!"));
		return MessageData.Get<FSpacetimeDBUnit>();
	}

	FORCEINLINE bool operator==(const FTestProcClientEvent& Other) const
	{
		if (Tag != Other.Tag) return false;
		switch (Tag)
		{
		case ESpacetimeDBEventTag::Reducer: return GetAsReducer() == Other.GetAsReducer();
		case ESpacetimeDBEventTag::SubscribeApplied: return GetAsSubscribeApplied() == Other.GetAsSubscribeApplied();
		case ESpacetimeDBEventTag::UnsubscribeApplied: return GetAsUnsubscribeApplied() == Other.GetAsUnsubscribeApplied();
		case ESpacetimeDBEventTag::Disconnected: return GetAsDisconnected() == Other.GetAsDisconnected();
		case ESpacetimeDBEventTag::SubscribeError: return GetAsSubscribeError() == Other.GetAsSubscribeError();
		case ESpacetimeDBEventTag::UnknownTransaction: return GetAsUnknownTransaction() == Other.GetAsUnknownTransaction();
		default: return false;
		}
	}

	FORCEINLINE bool operator!=(const FTestProcClientEvent& Other) const
	{
		return !(*this == Other);
	}
};

UCLASS()
class TESTPROCCLIENT_API UTestProcClientEventBpLib : public UBlueprintFunctionLibrary
{
    GENERATED_BODY()

private:
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|TestProcClientEvent")
    static FTestProcClientEvent Reducer(const FReducer& InValue)
    {
        return FTestProcClientEvent::Reducer(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|TestProcClientEvent")
    static FTestProcClientEvent SubscribeApplied(const FSpacetimeDBUnit& InValue)
    {
        return FTestProcClientEvent::SubscribeApplied(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|TestProcClientEvent")
    static FTestProcClientEvent UnsubscribeApplied(const FSpacetimeDBUnit& InValue)
    {
        return FTestProcClientEvent::UnsubscribeApplied(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|TestProcClientEvent")
    static FTestProcClientEvent Disconnected(const FSpacetimeDBUnit& InValue)
    {
        return FTestProcClientEvent::Disconnected(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|TestProcClientEvent")
    static FTestProcClientEvent SubscribeError(const FString& InValue)
    {
        return FTestProcClientEvent::SubscribeError(InValue);
    }

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB|TestProcClientEvent")
    static FTestProcClientEvent UnknownTransaction(const FSpacetimeDBUnit& InValue)
    {
        return FTestProcClientEvent::UnknownTransaction(InValue);
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static bool IsReducer(const FTestProcClientEvent& Event) { return Event.IsReducer(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static bool IsSubscribeApplied(const FTestProcClientEvent& Event) { return Event.IsSubscribeApplied(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static bool IsUnsubscribeApplied(const FTestProcClientEvent& Event) { return Event.IsUnsubscribeApplied(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static bool IsDisconnected(const FTestProcClientEvent& Event) { return Event.IsDisconnected(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static bool IsSubscribeError(const FTestProcClientEvent& Event) { return Event.IsSubscribeError(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static bool IsUnknownTransaction(const FTestProcClientEvent& Event) { return Event.IsUnknownTransaction(); }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static FReducer GetAsReducer(const FTestProcClientEvent& Event)
    {
        return Event.GetAsReducer();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static FSpacetimeDBUnit GetAsSubscribeApplied(const FTestProcClientEvent& Event)
    {
        return Event.GetAsSubscribeApplied();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static FSpacetimeDBUnit GetAsUnsubscribeApplied(const FTestProcClientEvent& Event)
    {
        return Event.GetAsUnsubscribeApplied();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static FSpacetimeDBUnit GetAsDisconnected(const FTestProcClientEvent& Event)
    {
        return Event.GetAsDisconnected();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static FString GetAsSubscribeError(const FTestProcClientEvent& Event)
    {
        return Event.GetAsSubscribeError();
    }

    UFUNCTION(BlueprintPure, Category = "SpacetimeDB|TestProcClientEvent")
    static FSpacetimeDBUnit GetAsUnknownTransaction(const FTestProcClientEvent& Event)
    {
        return Event.GetAsUnknownTransaction();
    }

};


USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FEventContext : public FContextBase
{
	GENERATED_BODY()

	FEventContext() = default;
	FEventContext(UDbConnection* InConn, const FTestProcClientEvent& InEvent) : FContextBase(InConn), Event(InEvent) {}

	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	FTestProcClientEvent Event;
};

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FReducerEventContext : public FContextBase
{
	GENERATED_BODY()

	FReducerEventContext() = default;
	FReducerEventContext(UDbConnection* InConn, FTestProcClientReducerEvent InEvent) : FContextBase(InConn), Event(InEvent) {}
	
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB") 
	FTestProcClientReducerEvent Event;
};

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FProcedureEventContext : public FContextBase
{
	GENERATED_BODY()

	FProcedureEventContext() = default;
	FProcedureEventContext(UDbConnection* InConn, FTestProcClientProcedureEvent InEvent) : FContextBase(InConn), Event(InEvent) {}
	
	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB") 
	FTestProcClientProcedureEvent Event;
};

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FErrorContext : public FContextBase
{
	GENERATED_BODY()

	FErrorContext() = default;
	FErrorContext(UDbConnection* InConn, const FString& InError) : FContextBase(InConn), Error(InError) {}

	UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
	FString Error;

};

USTRUCT(BlueprintType)
struct TESTPROCCLIENT_API FSubscriptionEventContext : public FContextBase
{
	GENERATED_BODY()

	FSubscriptionEventContext() = default;
	FSubscriptionEventContext(UDbConnection* InConn) : FContextBase(InConn) {}

};

DECLARE_DYNAMIC_DELEGATE_OneParam(
	FOnSubscriptionApplied,
	FSubscriptionEventContext, Context);

DECLARE_DYNAMIC_DELEGATE_OneParam(
	FOnSubscriptionError,
	FErrorContext, Context);

UCLASS(BlueprintType)
class TESTPROCCLIENT_API USetReducerFlags : public USetReducerFlagsBase
{
	GENERATED_BODY()

public:
	UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
	void ScheduleProc(ECallReducerFlags Flag);

};

// RemoteTables class
UCLASS(BlueprintType)
class TESTPROCCLIENT_API URemoteTables : public UObject
{
    GENERATED_BODY()

public:
    void Initialize();

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UMyTableTable* MyTable;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UPkUuidTable* PkUuid;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UProcInsertsIntoTable* ProcInsertsInto;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    UScheduledProcTableTable* ScheduledProcTable;

};

// RemoteReducers class
UCLASS(BlueprintType)
class TESTPROCCLIENT_API URemoteReducers : public UObject
{
    GENERATED_BODY()

public:

    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(
        FScheduleProcHandler,
        const FReducerEventContext&, Context
    );
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FScheduleProcHandler OnScheduleProc;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void ScheduleProc();

    bool InvokeScheduleProc(const FReducerEventContext& Context, const UScheduleProcReducer* Args);
    bool InvokeScheduleProcWithArgs(const FReducerEventContext& Context, const FScheduleProcArgs& Args);

    // Internal error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FInternalOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);
    FInternalOnUnhandledReducerError InternalOnUnhandledReducerError;

private:

    friend UDbConnection;

    UPROPERTY()
    class UDbConnection* Conn;

    UPROPERTY()
    USetReducerFlags* SetCallReducerFlags;
};

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnInsertWithTxCommitComplete,
    const FProcedureEventContext&, Context,
    FSpacetimeDBUnit, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnInsertWithTxRollbackComplete,
    const FProcedureEventContext&, Context,
    FSpacetimeDBUnit, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnInvalidRequestComplete,
    const FProcedureEventContext&, Context,
    const FString&, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnReadMySchemaComplete,
    const FProcedureEventContext&, Context,
    const FString&, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnReturnEnumAComplete,
    const FProcedureEventContext&, Context,
    const FReturnEnumType&, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnReturnEnumBComplete,
    const FProcedureEventContext&, Context,
    const FReturnEnumType&, Result,
    bool, bSuccess);

// NOTE: Procedure ReturnPrimitive has non-Blueprint-compatible return type: uint32
DECLARE_DELEGATE_ThreeParams(FOnReturnPrimitiveComplete,
    const FProcedureEventContext&, /*Context*/
    uint32, /*Result,*/
    bool /*bSuccess*/);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnReturnStructComplete,
    const FProcedureEventContext&, Context,
    const FReturnStructType&, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnScheduledProcComplete,
    const FProcedureEventContext&, Context,
    FSpacetimeDBUnit, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnSortedUuidsInsertComplete,
    const FProcedureEventContext&, Context,
    FSpacetimeDBUnit, Result,
    bool, bSuccess);

DECLARE_DYNAMIC_DELEGATE_ThreeParams(FOnWillPanicComplete,
    const FProcedureEventContext&, Context,
    FSpacetimeDBUnit, Result,
    bool, bSuccess);

// RemoteProcedures class
UCLASS(BlueprintType)
class TESTPROCCLIENT_API URemoteProcedures : public UObject
{
    GENERATED_BODY()

public:

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void InsertWithTxCommit(FOnInsertWithTxCommitComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void InsertWithTxRollback(FOnInsertWithTxRollbackComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void InvalidRequest(FOnInvalidRequestComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void ReadMySchema(FOnReadMySchemaComplete Callback);


    // NOTE: Not exposed to Blueprint because return type or uint32 types are not Blueprint-compatible
    void ReturnEnumA(const uint32 A, FOnReturnEnumAComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void ReturnEnumB(const FString& B, FOnReturnEnumBComplete Callback);


    // NOTE: Not exposed to Blueprint because return type or uint32, uint32 types are not Blueprint-compatible
    void ReturnPrimitive(const uint32 Lhs, const uint32 Rhs, FOnReturnPrimitiveComplete Callback);


    // NOTE: Not exposed to Blueprint because return type or uint32 types are not Blueprint-compatible
    void ReturnStruct(const uint32 A, const FString& B, FOnReturnStructComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void ScheduledProc(const FScheduledProcTableType& Data, FOnScheduledProcComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void SortedUuidsInsert(FOnSortedUuidsInsertComplete Callback);


    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    void WillPanic(FOnWillPanicComplete Callback);


    // Internal error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FInternalOnUnhandledProcedureError, const FProcedureEventContext&, Context, const FString&, Error);
    FInternalOnUnhandledProcedureError InternalOnUnhandledProcedureError;

private:

    friend UDbConnection;

    UPROPERTY()
    class UDbConnection* Conn;
};

// SubscriptionBuilder class
UCLASS(BlueprintType)
class TESTPROCCLIENT_API USubscriptionBuilder : public USubscriptionBuilderBase
{
    GENERATED_BODY()

public:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionBuilder* OnApplied(FOnSubscriptionApplied Callback);

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionBuilder* OnError(FOnSubscriptionError Callback);

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    USubscriptionHandle* Subscribe(const TArray<FString>& SQL);

    /** Convenience for subscribing to all rows from all tables */
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    USubscriptionHandle* SubscribeToAllTables();


    friend class UDbConnection;
    friend class UDbConnectionBase;

protected:
    UPROPERTY()
    class UDbConnection* Conn;

    // Delegates stored so Subscribe() can bind forwarding callbacks
    FOnSubscriptionApplied OnAppliedDelegateInternal;
    FOnSubscriptionError OnErrorDelegateInternal;
};

// SubscriptionHandle class
UCLASS(BlueprintType)
class TESTPROCCLIENT_API USubscriptionHandle : public USubscriptionHandleBase
{
    GENERATED_BODY()

public:

    USubscriptionHandle() {};

    explicit USubscriptionHandle(UDbConnection* InConn);

    friend class USubscriptionBuilder;

private:
    UPROPERTY()
    class UDbConnection* Conn;

    // Delegates that expose subscription events with connection aware contexts
    FOnSubscriptionApplied OnAppliedDelegate;
    FOnSubscriptionError OnErrorDelegate;

    UFUNCTION()
    void ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx);

    UFUNCTION()
    void ForwardOnError(const FErrorContextBase& BaseCtx);
};

/*
    @Note: Child class of UDbConnectionBuilderBase.
*/
UCLASS(BlueprintType)
class TESTPROCCLIENT_API UDbConnectionBuilder : public UDbConnectionBuilderBase
{
    GENERATED_BODY()
public:

    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithUri(const FString& InUri);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithModuleName(const FString& InName);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithToken(const FString& InToken);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* WithCompression(const ESpacetimeDBCompression& InCompression);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnConnect(FOnConnectDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnConnectError(FOnConnectErrorDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnectionBuilder* OnDisconnect(FOnDisconnectDelegate Callback);
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB")
    UDbConnection* Build();

private:

    // Stored delegates which will be forwarded when the connection events occur.
    FOnConnectDelegate OnConnectDelegateInternal;
    FOnDisconnectDelegate OnDisconnectDelegateInternal;
};

// Main DbConnection class
UCLASS(BlueprintType)
class TESTPROCCLIENT_API UDbConnection : public UDbConnectionBase
{
    GENERATED_BODY()

public:
    explicit UDbConnection(const FObjectInitializer& ObjectInitializer = FObjectInitializer::Get());


    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteTables* Db;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteReducers* Reducers;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    USetReducerFlags* SetReducerFlags;

    UPROPERTY(BlueprintReadOnly, Category="SpacetimeDB")
    URemoteProcedures* Procedures;

    // Delegates that allow users to bind with the concrete connection type.
    FOnConnectDelegate OnConnectDelegate;
    FOnDisconnectDelegate OnDisconnectDelegate;

    UFUNCTION(BlueprintCallable, Category="SpacetimeDB")
    USubscriptionBuilder* SubscriptionBuilder();

    /** Static entry point for constructing a connection. */
    UFUNCTION(BlueprintCallable, Category = "SpacetimeDB", DisplayName = "SpacetimeDB Builder")
    static UDbConnectionBuilder* Builder();

    // Error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnUnhandledReducerError, const FReducerEventContext&, Context, const FString&, Error);
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FOnUnhandledReducerError OnUnhandledReducerError;

    // Error handling
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnUnhandledProcedureError, const FProcedureEventContext&, Context, const FString&, Error);
    UPROPERTY(BlueprintAssignable, Category="SpacetimeDB")
    FOnUnhandledProcedureError OnUnhandledProcedureError;


protected:

    // Hook up error handling to reducers and procedures
    virtual void PostInitProperties() override;

    UFUNCTION()
    void ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken);
    UFUNCTION()
    void ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error);

    UFUNCTION()
    void OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error);

    UFUNCTION()
    void OnUnhandledProcedureErrorHandler(const FProcedureEventContext& Context, const FString& Error);

    // Override the DbConnectionBase methods to handle updates and events
    virtual void DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event) override;
    
    // Override the reducer event handler to dispatch events to the appropriate reducers
    virtual void ReducerEvent(const FReducerEvent& Event) override;
    
    // Override the reducer event failed handler
    virtual void ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage) override;
    // Override the procedure event failed handler
    virtual void ProcedureEventFailed(const FProcedureEvent& Event, const FString ErrorMessage) override;
};

