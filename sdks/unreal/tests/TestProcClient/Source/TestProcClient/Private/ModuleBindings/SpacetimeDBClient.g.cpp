// THIS FILE IS AUTOMATICALLY GENERATED BY SPACETIMEDB. EDITS TO THIS FILE
// WILL NOT BE SAVED. MODIFY TABLES IN YOUR MODULE SOURCE CODE INSTEAD.

#include "ModuleBindings/SpacetimeDBClient.g.h"
#include "DBCache/WithBsatn.h"
#include "BSATN/UEBSATNHelpers.h"
#include "ModuleBindings/Tables/MyTableTable.g.h"
#include "ModuleBindings/Tables/PkUuidTable.g.h"
#include "ModuleBindings/Tables/ProcInsertsIntoTable.g.h"
#include "ModuleBindings/Tables/ScheduledProcTableTable.g.h"

static FReducer DecodeReducer(const FReducerEvent& Event)
{
    const FString& ReducerName = Event.ReducerCall.ReducerName;

    if (ReducerName == TEXT("schedule_proc"))
    {
        FScheduleProcArgs Args = UE::SpacetimeDB::Deserialize<FScheduleProcArgs>(Event.ReducerCall.Args);
        return FReducer::ScheduleProc(Args);
    }

    return FReducer();
}

UDbConnection::UDbConnection(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
{
	SetReducerFlags = ObjectInitializer.CreateDefaultSubobject<USetReducerFlags>(this, TEXT("SetReducerFlags"));

	Db = ObjectInitializer.CreateDefaultSubobject<URemoteTables>(this, TEXT("RemoteTables"));
	Db->Initialize();
	
	Reducers = ObjectInitializer.CreateDefaultSubobject<URemoteReducers>(this, TEXT("RemoteReducers"));
	Reducers->SetCallReducerFlags = SetReducerFlags;
	Reducers->Conn = this;

	Procedures = ObjectInitializer.CreateDefaultSubobject<URemoteProcedures>(this, TEXT("RemoteProcedures"));
	Procedures->Conn = this;

	RegisterTable<FMyTableType, UMyTableTable, FEventContext>(TEXT("my_table"), Db->MyTable);
	RegisterTable<FPkUuidType, UPkUuidTable, FEventContext>(TEXT("pk_uuid"), Db->PkUuid);
	RegisterTable<FProcInsertsIntoType, UProcInsertsIntoTable, FEventContext>(TEXT("proc_inserts_into"), Db->ProcInsertsInto);
	RegisterTable<FScheduledProcTableType, UScheduledProcTableTable, FEventContext>(TEXT("scheduled_proc_table"), Db->ScheduledProcTable);
}

FContextBase::FContextBase(UDbConnection* InConn)
{
	Db = InConn->Db;
	Reducers = InConn->Reducers;
	SetReducerFlags = InConn->SetReducerFlags;
	Procedures = InConn->Procedures;
	Conn = InConn;
}
bool FContextBase::IsActive() const
{
	return Conn->IsActive();
}
void FContextBase::Disconnect()
{
	Conn->Disconnect();
}
USubscriptionBuilder* FContextBase::SubscriptionBuilder()
{
	return Conn->SubscriptionBuilder();
}
bool FContextBase::TryGetIdentity(FSpacetimeDBIdentity& OutIdentity) const
{
	return Conn->TryGetIdentity(OutIdentity);
}
FSpacetimeDBConnectionId FContextBase::GetConnectionId() const
{
	return Conn->GetConnectionId();
}

void URemoteTables::Initialize()
{

	/** Creating tables */
	MyTable = NewObject<UMyTableTable>(this);
	PkUuid = NewObject<UPkUuidTable>(this);
	ProcInsertsInto = NewObject<UProcInsertsIntoTable>(this);
	ScheduledProcTable = NewObject<UScheduledProcTableTable>(this);
	/**/

	/** Initialization */
	MyTable->PostInitialize();
	PkUuid->PostInitialize();
	ProcInsertsInto->PostInitialize();
	ScheduledProcTable->PostInitialize();
	/**/
}

void USetReducerFlags::ScheduleProc(ECallReducerFlags Flag)
{
	FlagMap.Add("ScheduleProc", Flag);
}

void URemoteReducers::ScheduleProc()
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

	Conn->CallReducerTyped(TEXT("schedule_proc"), FScheduleProcArgs(), SetCallReducerFlags);
}

bool URemoteReducers::InvokeScheduleProc(const FReducerEventContext& Context, const UScheduleProcReducer* Args)
{
    if (!OnScheduleProc.IsBound())
    {
        // Handle unhandled reducer error
        if (InternalOnUnhandledReducerError.IsBound())
        {
            // TODO: Check Context.Event.Status for Failed/OutOfEnergy cases
            // For now, just broadcast any error
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for ScheduleProc"));
        }
        return false;
    }

    OnScheduleProc.Broadcast(Context);
    return true;
}

bool URemoteReducers::InvokeScheduleProcWithArgs(const FReducerEventContext& Context, const FScheduleProcArgs& Args)
{
    if (!OnScheduleProc.IsBound())
    {
        if (InternalOnUnhandledReducerError.IsBound())
        {
            InternalOnUnhandledReducerError.Broadcast(Context, TEXT("No handler registered for ScheduleProc"));
        }
        return false;
    }

    OnScheduleProc.Broadcast(Context);
    return true;
}

void URemoteProcedures::InsertWithTxCommit(FOnInsertWithTxCommitComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FSpacetimeDBUnit ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FSpacetimeDBUnit>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("insert_with_tx_commit"), FInsertWithTxCommitArgs(), Wrapper);
}

void URemoteProcedures::InsertWithTxRollback(FOnInsertWithTxRollbackComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FSpacetimeDBUnit ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FSpacetimeDBUnit>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("insert_with_tx_rollback"), FInsertWithTxRollbackArgs(), Wrapper);
}

void URemoteProcedures::InvalidRequest(FOnInvalidRequestComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FString ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FString>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("invalid_request"), FInvalidRequestArgs(), Wrapper);
}

void URemoteProcedures::ReadMySchema(FOnReadMySchemaComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FString ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FString>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("read_my_schema"), FReadMySchemaArgs(), Wrapper);
}

void URemoteProcedures::ReturnEnumA(const uint32 A, FOnReturnEnumAComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FReturnEnumType ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FReturnEnumType>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("return_enum_a"), FReturnEnumAArgs(A), Wrapper);
}

void URemoteProcedures::ReturnEnumB(const FString& B, FOnReturnEnumBComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FReturnEnumType ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FReturnEnumType>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("return_enum_b"), FReturnEnumBArgs(B), Wrapper);
}

void URemoteProcedures::ReturnPrimitive(const uint32 Lhs, const uint32 Rhs, FOnReturnPrimitiveComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            uint32 ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<uint32>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("return_primitive"), FReturnPrimitiveArgs(Lhs, Rhs), Wrapper);
}

void URemoteProcedures::ReturnStruct(const uint32 A, const FString& B, FOnReturnStructComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FReturnStructType ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FReturnStructType>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("return_struct"), FReturnStructArgs(A, B), Wrapper);
}

void URemoteProcedures::ScheduledProc(const FScheduledProcTableType& Data, FOnScheduledProcComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FSpacetimeDBUnit ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FSpacetimeDBUnit>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("scheduled_proc"), FScheduledProcArgs(Data), Wrapper);
}

void URemoteProcedures::SortedUuidsInsert(FOnSortedUuidsInsertComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FSpacetimeDBUnit ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FSpacetimeDBUnit>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("sorted_uuids_insert"), FSortedUuidsInsertArgs(), Wrapper);
}

void URemoteProcedures::WillPanic(FOnWillPanicComplete Callback)
{
    if (!Conn)
    {
        UE_LOG(LogTemp, Error, TEXT("SpacetimeDB connection is null"));
        return;
    }

    FOnProcedureCompleteDelegate Wrapper;
    Wrapper.BindLambda(
        [Callback = MoveTemp(Callback), Conn = this->Conn]
        (const FSpacetimeDBEvent& Event,
            const TArray<uint8>& ResultData,
            bool bSuccess) mutable
        {
            FSpacetimeDBUnit ResultValue{};

            if (bSuccess) {
                ResultValue = UE::SpacetimeDB::Deserialize<FSpacetimeDBUnit>(ResultData);
            }

            FTestProcClientProcedureEvent ProcedureEvent = FTestProcClientProcedureEvent(Event.GetAsProcedure());
            FProcedureEventContext Context = FProcedureEventContext(Conn, ProcedureEvent);
            // Fire the user's typed delegate
            Callback.ExecuteIfBound(Context, ResultValue, bSuccess);
        });
	Conn->CallProcedureTyped(TEXT("will_panic"), FWillPanicArgs(), Wrapper);
}

void UDbConnection::PostInitProperties()
{
    Super::PostInitProperties();
    
    // Connect OnUnhandledReducerError to Reducers.InternalOnUnhandledReducerError
    if (Reducers)
    {
        Reducers->InternalOnUnhandledReducerError.AddDynamic(this, &UDbConnection::OnUnhandledReducerErrorHandler);
    }

    // Connect OnUnhandledProcedureError to Procedures.InternalOnUnhandledProcedureError
    if (Procedures)
    {
        Procedures->InternalOnUnhandledProcedureError.AddDynamic(this, &UDbConnection::OnUnhandledProcedureErrorHandler);
    }
}

UFUNCTION()
void UDbConnection::OnUnhandledReducerErrorHandler(const FReducerEventContext& Context, const FString& Error)
{
    if (OnUnhandledReducerError.IsBound())
    {
        OnUnhandledReducerError.Broadcast(Context, Error);
    }
}

UFUNCTION()
void UDbConnection::OnUnhandledProcedureErrorHandler(const FProcedureEventContext& Context, const FString& Error)
{
    if (OnUnhandledProcedureError.IsBound())
    {
        OnUnhandledProcedureError.Broadcast(Context, Error);
    }
}

void UDbConnection::ReducerEvent(const FReducerEvent& Event)
{
    if (!Reducers) { return; }

    FReducer DecodedReducer = DecodeReducer(Event);

    FTestProcClientReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;
    ReducerEvent.Reducer            = DecodedReducer;

    FReducerEventContext Context(this, ReducerEvent);

    // Use hardcoded string matching for reducer dispatching
    const FString& ReducerName = Event.ReducerCall.ReducerName;

    if (ReducerName == TEXT("schedule_proc"))
    {
        FScheduleProcArgs Args = ReducerEvent.Reducer.GetAsScheduleProc();
        Reducers->InvokeScheduleProcWithArgs(Context, Args);
        return;
    }

    UE_LOG(LogTemp, Warning, TEXT("Unknown reducer: %s"), *ReducerName);
}

void UDbConnection::ReducerEventFailed(const FReducerEvent& Event, const FString ErrorMessage)
{
    if (!Reducers) { return; }

    FTestProcClientReducerEvent ReducerEvent;
    ReducerEvent.CallerConnectionId = Event.CallerConnectionId;
    ReducerEvent.CallerIdentity     = Event.CallerIdentity;
    ReducerEvent.EnergyConsumed     = Event.EnergyConsumed;
    ReducerEvent.Status             = Event.Status;
    ReducerEvent.Timestamp          = Event.Timestamp;

    FReducerEventContext Context(this, ReducerEvent);

    if (Reducers->InternalOnUnhandledReducerError.IsBound())
    {
        Reducers->InternalOnUnhandledReducerError.Broadcast(Context, ErrorMessage);
    }
}

void UDbConnection::ProcedureEventFailed(const FProcedureEvent& Event, const FString ErrorMessage)
{
    if (!Procedures) { return; }

    FTestProcClientProcedureEvent ProcedureEvent;
    ProcedureEvent.Status             = FSpacetimeDBProcedureStatus::FromStatus(Event.Status);
    ProcedureEvent.Timestamp          = Event.Timestamp;

    FProcedureEventContext Context(this, ProcedureEvent);

    if (Procedures->InternalOnUnhandledProcedureError.IsBound())
    {
        Procedures->InternalOnUnhandledProcedureError.Broadcast(Context, ErrorMessage);
    }
}

UDbConnectionBuilder* UDbConnection::Builder()
{
	return NewObject<UDbConnectionBuilder>();
}
// Added for creating subscriptions
USubscriptionBuilder* UDbConnection::SubscriptionBuilder()
{
	USubscriptionBuilder* Builder = NewObject<USubscriptionBuilder>(this);
	Builder->Conn = this;
	return Builder;
}
USubscriptionBuilder* USubscriptionBuilder::OnApplied(FOnSubscriptionApplied Callback)
{
	OnAppliedDelegateInternal = Callback;
	return this;
}
USubscriptionBuilder* USubscriptionBuilder::OnError(FOnSubscriptionError Callback)
{
	OnErrorDelegateInternal = Callback;
	return this;
}
USubscriptionHandle* USubscriptionBuilder::Subscribe(const TArray<FString>& SQL)
{
	USubscriptionHandle* Handle = NewObject<USubscriptionHandle>();

	// Store user callbacks on the handle
	Handle->Conn = Conn;
	Handle->OnAppliedDelegate = OnAppliedDelegateInternal;
	Handle->OnErrorDelegate = OnErrorDelegateInternal;

	// Bind forwarding functions that will convert base contexts
	FSubscriptionEventDelegate BaseApplied;
	BaseApplied.BindUFunction(Handle, TEXT("ForwardOnApplied"));
	OnAppliedBase(BaseApplied);

	FSubscriptionErrorDelegate BaseError;
	BaseError.BindUFunction(Handle, TEXT("ForwardOnError"));
	OnErrorBase(BaseError);

	SubscribeBase(SQL, Handle);
	if (Conn)
	{
		Conn->StartSubscription(Handle);
	}
	return Handle;
}
USubscriptionHandle* USubscriptionBuilder::SubscribeToAllTables()
{
	return Subscribe({ "SELECT * FROM * " });
}

USubscriptionHandle::USubscriptionHandle(UDbConnection* InConn)
{
	Conn = InConn;
}

void USubscriptionHandle::ForwardOnApplied(const FSubscriptionEventContextBase& BaseCtx)
{
	if (OnAppliedDelegate.IsBound())
	{
		FSubscriptionEventContext Ctx(Conn);
		OnAppliedDelegate.Execute(Ctx);
	}
}

void USubscriptionHandle::ForwardOnError(const FErrorContextBase& BaseCtx)
{
	if (OnErrorDelegate.IsBound())
	{
		FErrorContext Ctx(Conn, BaseCtx.Error);
		OnErrorDelegate.Execute(Ctx);
	}
}


// Cast from parent to child class
UDbConnectionBuilder* UDbConnectionBuilder::WithUri(const FString& InUri)
{
	return Cast<UDbConnectionBuilder>(WithUriBase(InUri));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithModuleName(const FString& InName)
{
	return Cast<UDbConnectionBuilder>(WithModuleNameBase(InName));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithToken(const FString& InToken)
{
	return Cast<UDbConnectionBuilder>(WithTokenBase(InToken));
}
UDbConnectionBuilder* UDbConnectionBuilder::WithCompression(const ESpacetimeDBCompression& InCompression)
{
	return Cast<UDbConnectionBuilder>(WithCompressionBase(InCompression));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnect(FOnConnectDelegate Callback)
{
	OnConnectDelegateInternal = Callback;
	return this;
}
UDbConnectionBuilder* UDbConnectionBuilder::OnConnectError(FOnConnectErrorDelegate Callback)
{
	return Cast<UDbConnectionBuilder>(OnConnectErrorBase(Callback));
}
UDbConnectionBuilder* UDbConnectionBuilder::OnDisconnect(FOnDisconnectDelegate Callback)
{
	OnDisconnectDelegateInternal = Callback;
	return this;
}
UDbConnection* UDbConnectionBuilder::Build()
{
	UDbConnection* Connection = NewObject<UDbConnection>();

	// Store delegates on the connection for later use
	Connection->OnConnectDelegate = OnConnectDelegateInternal;
	Connection->OnDisconnectDelegate = OnDisconnectDelegateInternal;

	// Wrap delegates so the base builder can bind them
	FOnConnectBaseDelegate BaseConnect;
	BaseConnect.BindUFunction(Connection, TEXT("ForwardOnConnect"));
	Connection->SetOnConnectDelegate(BaseConnect);
	OnConnectBase(BaseConnect);

	FOnDisconnectBaseDelegate BaseDisconnect;
	BaseDisconnect.BindUFunction(Connection, TEXT("ForwardOnDisconnect"));
	Connection->SetOnDisconnectDelegate(BaseDisconnect);
	OnDisconnectBase(BaseDisconnect);

	return Cast<UDbConnection>(BuildConnection(Connection));
}
void UDbConnection::ForwardOnConnect(UDbConnectionBase* BaseConnection, FSpacetimeDBIdentity InIdentity, const FString& InToken)
{
	if (OnConnectDelegate.IsBound())
	{
		OnConnectDelegate.Execute(this, Identity, Token);
	}
}
void UDbConnection::ForwardOnDisconnect(UDbConnectionBase* BaseConnection, const FString& Error)
{
	if (OnDisconnectDelegate.IsBound())
	{
		OnDisconnectDelegate.Execute(this, Error);
	}
}


void UDbConnection::DbUpdate(const FDatabaseUpdateType& Update, const FSpacetimeDBEvent& Event)
{
    FTestProcClientEvent BaseEvent;
    BaseEvent.Tag = Event.Tag;

    switch (Event.Tag)
    {
    case ESpacetimeDBEventTag::Reducer:
    {
        FReducerEvent ReducerEvent = Event.GetAsReducer();
        FReducer Reducer = DecodeReducer(ReducerEvent);
        BaseEvent = FTestProcClientEvent::Reducer(Reducer);
        break;
    }

    case ESpacetimeDBEventTag::SubscribeApplied:
        BaseEvent = FTestProcClientEvent::SubscribeApplied(Event.GetAsSubscribeApplied());
        break;

    case ESpacetimeDBEventTag::UnsubscribeApplied:
        BaseEvent = FTestProcClientEvent::UnsubscribeApplied(Event.GetAsUnsubscribeApplied());
        break;

    case ESpacetimeDBEventTag::Disconnected:
        BaseEvent = FTestProcClientEvent::Disconnected(Event.GetAsDisconnected());
        break;

    case ESpacetimeDBEventTag::SubscribeError:
        BaseEvent = FTestProcClientEvent::SubscribeError(Event.GetAsSubscribeError());
        break;

    case ESpacetimeDBEventTag::UnknownTransaction:
        BaseEvent = FTestProcClientEvent::UnknownTransaction(Event.GetAsUnknownTransaction());
        break;

    default:
        break;
    }

    FEventContext Context(this, BaseEvent);
    // Populate typed reducer args for convenience in table handlers

    ApplyRegisteredTableUpdates(Update, &Context);
}

