"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8893],{6119:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>r});var i=s(3303);const t={},c=i.createContext(t);function a(e){const n=i.useContext(c);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(c.Provider,{value:n},e.children)}},9968:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"Subscriptions/Subscription-Semantics","title":"Subscription Semantics","description":"This document describes the subscription semantics maintained by the SpacetimeDB host over WebSocket connections. These semantics outline message ordering guarantees, subscription handling, transaction updates, and client cache consistency.","source":"@site/docs/09-Subscriptions/02-Subscription-Semantics.md","sourceDirName":"09-Subscriptions","slug":"/subscriptions/semantics","permalink":"/subscriptions/semantics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Subscription Semantics","slug":"/subscriptions/semantics"},"sidebar":"sidebar","previous":{"title":"Subscription Reference","permalink":"/subscriptions"},"next":{"title":"Row Level Security","permalink":"/rls"}}');var t=s(7711),c=s(6119);const a={title:"Subscription Semantics",slug:"/subscriptions/semantics"},r="SpacetimeDB Subscription Semantics",l={},o=[{value:"WebSocket Communication Channels",id:"websocket-communication-channels",level:2},{value:"Ordering Guarantees",id:"ordering-guarantees",level:3},{value:"Subscription Workflow",id:"subscription-workflow",level:2},{value:"Transaction Update Workflow",id:"transaction-update-workflow",level:2},{value:"Multiple Subscription Sets",id:"multiple-subscription-sets",level:2},{value:"Client Cache Guarantees",id:"client-cache-guarantees",level:2},{value:"Pending Callbacks and Cache Consistency",id:"pending-callbacks-and-cache-consistency",level:3}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"spacetimedb-subscription-semantics",children:"SpacetimeDB Subscription Semantics"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the subscription semantics maintained by the SpacetimeDB host over WebSocket connections. These semantics outline message ordering guarantees, subscription handling, transaction updates, and client cache consistency."}),"\n",(0,t.jsx)(n.h2,{id:"websocket-communication-channels",children:"WebSocket Communication Channels"}),"\n",(0,t.jsx)(n.p,{children:"A single WebSocket connection between a client and the SpacetimeDB host consists of two distinct message channels:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Client \u2192 Server:"})," Sends requests such as reducer invocations and subscription queries."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Server \u2192 Client:"})," Sends responses to client requests and database transaction updates."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"ordering-guarantees",children:"Ordering Guarantees"}),"\n",(0,t.jsx)(n.p,{children:"The server maintains the following guarantees:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Sequential Response Ordering:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Responses to client requests are always sent back in the same order the requests were received. If request A precedes request B, the response to A will always precede the response to B, even if A takes longer to process."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Atomic Transaction Updates:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Each database transaction (e.g., reducer invocation, INSERT, UPDATE, DELETE queries) generates exactly zero or one update message sent to clients. These updates are atomic and reflect the exact order of committed transactions."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Atomic Subscription Initialization:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When subscriptions are established, clients receive exactly one response containing all initially matching rows from a consistent database state snapshot taken between two transactions."}),"\n",(0,t.jsx)(n.li,{children:"The state snapshot reflects a committed database state that includes all previous transaction updates received and excludes all future transaction updates."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"subscription-workflow",children:"Subscription Workflow"}),"\n",(0,t.jsxs)(n.p,{children:["When invoking ",(0,t.jsx)(n.code,{children:"SubscriptionBuilder::subscribe(QUERIES)"})," from the client SDK:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Client SDK \u2192 Host:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Sends a ",(0,t.jsx)(n.code,{children:"Subscribe"})," message containing the specified QUERIES."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Host Processing:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Captures a snapshot of the committed database state."}),"\n",(0,t.jsx)(n.li,{children:"Evaluates the QUERIES against this snapshot to determine matching rows."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Host \u2192 Client SDK:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Sends a ",(0,t.jsx)(n.code,{children:"SubscribeApplied"})," message containing the matching rows."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Client SDK Processing:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Receives and processes the message."}),"\n",(0,t.jsx)(n.li,{children:"Locks the client cache and inserts all rows atomically."}),"\n",(0,t.jsxs)(n.li,{children:["Invokes relevant callbacks:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"on_insert"})," callback for each row."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"on_applied"})," callback for the subscription.","\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"No relative ordering guarantees are made regarding the invocation order of these callbacks."})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"transaction-update-workflow",children:"Transaction Update Workflow"}),"\n",(0,t.jsx)(n.p,{children:"Upon committing a database transaction:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Transaction Results in a State Delta:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The result of a transaction is a state delta, i.e. an unordered set of inserted and deleted rows."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Host Evaluates Queries:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Evaluates the QUERIES against the state delta to determine matching altered rows."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Host \u2192 Client SDK:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Sends a ",(0,t.jsx)(n.code,{children:"TransactionUpdate"})," message if relevant updates exist, containing affected rows and transaction metadata."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Client SDK Processing:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Receives and processes the message."}),"\n",(0,t.jsx)(n.li,{children:"Locks the client cache, applying deletions and insertions atomically."}),"\n",(0,t.jsxs)(n.li,{children:["Invokes relevant callbacks:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"on_insert"}),", ",(0,t.jsx)(n.code,{children:"on_delete"}),", ",(0,t.jsx)(n.code,{children:"on_update"})," callbacks for modified rows."]}),"\n",(0,t.jsxs)(n.li,{children:["Reducer callbacks, if the transaction was the result of a reducer.","\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"No relative ordering guarantees are made regarding the invocation order of these callbacks."})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"multiple-subscription-sets",children:"Multiple Subscription Sets"}),"\n",(0,t.jsxs)(n.p,{children:["If multiple subscription sets are active, updates across these sets are bundled together into a single ",(0,t.jsx)(n.code,{children:"TransactionUpdate"})," message."]}),"\n",(0,t.jsx)(n.h2,{id:"client-cache-guarantees",children:"Client Cache Guarantees"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The client cache always maintains a consistent and correct subset of the committed database state."}),"\n",(0,t.jsx)(n.li,{children:"Callback functions invoked due to events have guaranteed visibility into a fully updated cache state."}),"\n",(0,t.jsx)(n.li,{children:"Reads from the client cache are effectively free as they access locally cached data."}),"\n",(0,t.jsx)(n.li,{children:"During callback execution, the client cache accurately reflects the database state immediately following the event-triggering transaction."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pending-callbacks-and-cache-consistency",children:"Pending Callbacks and Cache Consistency"}),"\n",(0,t.jsxs)(n.p,{children:["While processing a ",(0,t.jsx)(n.code,{children:"TransactionUpdate"})," message, callbacks are queued within the SDK and deferred until the cache updates (inserts/deletes) from a transaction are fully applied. This ensures all callbacks see the fully consistent state of the cache, preventing callbacks from observing an inconsistent intermediate state."]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);