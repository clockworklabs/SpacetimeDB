---
title: FAQ
slug: /intro/faq
---

## General

### What is SpacetimeDB?

SpacetimeDB is a database that is also a server. You upload your application logic (called a "module") directly into the database, and clients connect to it without any server in between. It's a relational database with tables, queries, and transactions — but your business logic runs inside it as stored procedures on steroids.

### How is SpacetimeDB different from a traditional backend?

In a traditional stack, you deploy a web server (Node, Django, Rails, etc.) that sits between your clients and your database. You write API endpoints, manage connection pooling, handle caching, and deploy infrastructure.

With SpacetimeDB, you skip all of that. Your module *is* the backend. Clients connect directly to the database, call reducers (like RPC endpoints), and subscribe to real-time data updates. No separate server, no REST API, no GraphQL layer.

```
Traditional:                    SpacetimeDB:
Client → Server → Database      Client → SpacetimeDB (database + logic)
```

### Is SpacetimeDB only for games?

No. SpacetimeDB is designed for any real-time application: games, chat apps, collaboration tools, dashboards, IoT, or anything that benefits from low-latency state synchronization. Games are a demanding use case that proves SpacetimeDB's performance — our own MMORPG [BitCraft Online](https://bitcraftonline.com) runs entirely on SpacetimeDB — but the same architecture works for any application.

### Is SpacetimeDB a blockchain / smart contract platform?

No. SpacetimeDB has nothing to do with blockchain. The concept is similar to smart contracts in that your logic runs inside the database, but SpacetimeDB is a centralized relational database optimized for speed. It's orders of magnitude faster than any smart contract system.

### Is SpacetimeDB open source?

SpacetimeDB is source-available under the [Business Source License 1.1 (BSL)](https://github.com/clockworklabs/SpacetimeDB/blob/master/LICENSE.txt). It converts to the AGPL v3.0 (with a linking exception) after a few years. The linking exception means you are **not** required to open-source your own code if you use SpacetimeDB — you only need to contribute back changes to SpacetimeDB itself.

### Can I self-host SpacetimeDB?

Yes. You can run SpacetimeDB on your own infrastructure using `spacetime start`, or with Docker:

```bash
docker run --rm --pull always -p 3000:3000 clockworklabs/spacetime start
```

You can also use the hosted SpacetimeDB cloud (maincloud) at no cost during the current beta period.

---

## How does SpacetimeDB compare to...

### How is SpacetimeDB different from Mirror / Netcode / Photon / other networking libraries?

Networking libraries like Mirror, Netcode for GameObjects, and Photon handle the transport layer — sending messages between clients and a server you build and deploy yourself. You're still responsible for writing server logic, managing state, handling persistence, and deploying infrastructure.

SpacetimeDB replaces the entire server. Your game state lives in tables, your game logic lives in reducers, and SpacetimeDB automatically synchronizes state to clients in real-time. You don't write networking code, serialization code, or deploy servers.

| | Networking Libraries | SpacetimeDB |
|---|---|---|
| **Server logic** | You write and deploy it | Runs inside the database |
| **State management** | You manage it | Tables with auto-sync |
| **Persistence** | You add a database | Built in |
| **Real-time sync** | You implement it | Automatic via subscriptions |
| **Infrastructure** | You deploy and scale it | Managed or self-hosted |

### How is SpacetimeDB different from Firebase / Supabase?

Firebase and Supabase are Backend-as-a-Service platforms. They give you a database with an API layer on top, but your application logic still runs elsewhere (cloud functions, edge functions, or your own server). Complex business logic is awkward to express as database triggers or serverless functions.

SpacetimeDB lets you write your entire application as a module in a real programming language (Rust, C#, TypeScript) that runs inside the database. You get full transactional guarantees, direct table access, and real-time subscriptions — without the cold starts, execution limits, or awkward abstractions of serverless functions.

### How is SpacetimeDB different from a regular database (PostgreSQL, MySQL)?

A traditional database stores data and lets you query it. Your application logic runs in a separate server that connects to the database over the network.

SpacetimeDB holds all data in memory for sub-millisecond access, runs your application logic inside the database as WebAssembly modules, and pushes real-time updates to connected clients automatically. It's purpose-built for real-time applications, not batch processing or analytics.

---

## Architecture

### How does data persistence work?

SpacetimeDB holds all data in memory for fast access, but persists everything to a commit log (similar to a write-ahead log). On restart, the database replays the commit log to recover its exact state. You get the speed of in-memory computing with the durability of a traditional database.

### How does real-time sync work?

Clients subscribe to SQL queries that specify what data they care about. SpacetimeDB evaluates these subscriptions and pushes incremental updates whenever the underlying data changes. On the client side, the SDK maintains a local cache that mirrors the server state — you query this cache directly with no round trips.

```typescript
// Client subscribes to nearby players
ctx.subscribe("SELECT * FROM players WHERE distance(x, y, ?, ?) < 100", myX, myY);

// The local cache updates automatically
const nearbyPlayers = ctx.db.players;
```

### Are reducers like REST endpoints?

Reducers are more like transactional RPC calls. A client calls a reducer by name with arguments, the reducer runs inside a database transaction, and either all changes commit or none do. Unlike REST, there's no HTTP overhead, no JSON serialization, and no need to design URL routes. Clients call reducers through auto-generated, type-safe bindings.

### What happens if a reducer fails?

The entire transaction rolls back. No partial updates, no corrupted state. The database remains exactly as it was before the reducer was called. You can throw errors or return `Err` freely — SpacetimeDB handles the cleanup.

### What languages can I write modules in?

Server-side modules can be written in:
- **Rust**
- **C#**
- **TypeScript** (new in 2.0)
- **C++** (new in 2.0)

Client SDKs are available for:
- **Rust**
- **C#** (including Unity)
- **TypeScript** (including React, Vue, Svelte, Angular, and more)
- **C++** (Unreal Engine)

### What is a "module"?

A module is your application's server-side code compiled to WebAssembly (or bundled as JavaScript for TypeScript modules). It defines your tables, reducers, views, and procedures. You upload it to SpacetimeDB with `spacetime publish`, and it runs inside the database. Think of it as your entire backend in a single deployable unit.

---

## Development

### How do I get started?

1. Install the CLI: `curl -sSf https://install.spacetimedb.com | sh`
2. Start a local instance: `spacetime start`
3. Create a project: `spacetime init --lang rust` (or `csharp`, `typescript`)
4. Write your module, publish it: `spacetime publish my-app`
5. Generate client bindings: `spacetime generate --lang typescript --out-dir src/module_bindings`
6. Connect from your client using the generated code

See the [quickstart guides](/quickstart) for step-by-step tutorials.

### What is `spacetime dev`?

`spacetime dev` is the development workflow command. It watches your module for changes, automatically rebuilds and republishes it, generates client bindings, and optionally starts your client dev server. It's like `npm run dev` but for your entire full-stack application.

### Do I need to write SQL?

Only for client-side subscriptions (telling the client what data to sync). Your server-side module code uses native language APIs to query and modify tables — no SQL needed on the server side.

### Can I use SpacetimeDB with Unity?

Yes. SpacetimeDB has a C# client SDK that works with Unity. The SDK maintains a local cache of your subscribed data and provides callbacks for changes. See the [Unity tutorial](/tutorials/unity) for a complete walkthrough.

### Can I use SpacetimeDB with Unreal Engine?

Yes. SpacetimeDB has a C++ client SDK for Unreal Engine with Blueprint support. See the [Unreal quickstart](/quickstart/unreal) for details.

### Can I use SpacetimeDB with React / Vue / Angular / Svelte?

Yes. The TypeScript SDK includes framework-specific integrations for React, Vue, Angular, Svelte, and more. These provide reactive hooks/composables that automatically update your UI when database state changes.

### How do I handle authentication?

SpacetimeDB uses the [OpenID Connect](https://openid.net/developers/how-connect-works/) standard. You can use SpacetimeDB's built-in auth provider (SpacetimeAuth), or integrate with any OpenID Connect provider (Google, Auth0, etc.). Every reducer call includes the caller's `Identity`, which you can use for authorization logic.

### What are Views?

Views are read-only functions that compute derived data from your tables. They're like SQL views but written in your module's language. Clients can subscribe to views just like tables, and they update automatically when the underlying data changes.

### What are Procedures?

Procedures are like reducers but with additional capabilities — they can make HTTP requests to external services and manually manage transactions. They're currently in beta. Use reducers for most use cases; use procedures when you need to interact with the outside world.

---

## Deployment & Operations

### How do I deploy to production?

You can deploy to the SpacetimeDB cloud (maincloud) with:

```bash
spacetime publish my-app --server maincloud
```

Or self-host SpacetimeDB and publish to your own server.

### Can I update my module without downtime?

Yes. When you `spacetime publish` an update, SpacetimeDB hot-swaps the module code. Connected clients are **not** disconnected — they seamlessly continue with the new logic. This is possible because all state lives in tables, not in the server process.

### How do I handle schema migrations?

When you publish an updated module, SpacetimeDB compares the new schema with the existing one and performs automatic migrations for compatible changes (adding tables, adding columns with defaults, etc.). For breaking changes, you may need to publish with `--delete-data` during development or implement manual migration logic in your `init` reducer.

### Is there a size limit for databases?

SpacetimeDB holds all data in memory, so the practical limit is the available RAM on the host. On the hosted cloud, resource limits depend on your plan. For self-hosted deployments, you control the hardware.

### How much does SpacetimeDB cost?

SpacetimeDB is free to use during the current beta period, including the hosted cloud. Pricing for production workloads will be announced separately.

---

## Troubleshooting

### I'm getting a 401/403 when publishing — what's wrong?

Database names are **global** on maincloud. If someone else already published a database with that name, you'll get an authorization error. Try a more unique name.

### My `spacetime generate` command gives a confusing error

If your module's `init` reducer panics (e.g., due to a unique constraint violation), `spacetime generate` may show an unhelpful error like `EOF while parsing a value`. Fix the runtime error in your module first, then generate again.

### How do I reset my database during development?

Use `spacetime publish my-app --delete-data` to clear all data and republish. Or use `spacetime dev` which handles this automatically with the `--delete-data=on-conflict` flag.
